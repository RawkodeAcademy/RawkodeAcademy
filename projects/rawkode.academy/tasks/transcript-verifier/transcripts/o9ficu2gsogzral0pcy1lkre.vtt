WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 74b43a22-4afd-4037-83c7-3a4a9ebb9660
Created: 2025-04-29T20:25:23.636Z
Duration: 1748.6084
Channels: 1

00:00:02.480 --> 00:00:04.800
<v Speaker 0>Hi there. Welcome to my session today.

00:00:05.200 --> 00:00:08.400
<v Speaker 0>This session is titled Cluster API as Code.

00:00:08.400 --> 00:00:10.320
<v Speaker 0>And I want to use the time that

00:00:10.320 --> 00:00:11.840
<v Speaker 0>I have today to introduce you to the

00:00:11.840 --> 00:00:14.945
<v Speaker 0>Kubernetes cluster API, as well as some higher

00:00:14.945 --> 00:00:16.785
<v Speaker 0>level user friendly obstructions

00:00:17.185 --> 00:00:19.185
<v Speaker 0>and libraries that I've been working on in

00:00:19.185 --> 00:00:20.305
<v Speaker 0>my spare time.

00:00:21.105 --> 00:00:22.865
<v Speaker 0>Now a little bit about me. My name

00:00:22.865 --> 00:00:25.665
<v Speaker 0>is David McKay. I am from Glasgow in

00:00:25.665 --> 00:00:26.305
<v Speaker 0>Scotland

00:00:26.760 --> 00:00:29.160
<v Speaker 0>and I am a developer advocate. I work

00:00:29.160 --> 00:00:31.000
<v Speaker 0>for a company called Equinix Metal. You may

00:00:31.000 --> 00:00:32.920
<v Speaker 0>be familiar with them. They were formerly called

00:00:32.920 --> 00:00:34.680
<v Speaker 0>Packet and they had a bare metal cloud

00:00:34.680 --> 00:00:35.320
<v Speaker 0>provider.

00:00:36.680 --> 00:00:38.840
<v Speaker 0>I'm very fortunate that they sponsor most of

00:00:38.840 --> 00:00:42.200
<v Speaker 0>my time to produce educational materials to help

00:00:42.515 --> 00:00:45.475
<v Speaker 0>people learn how to consume the vast cloud

00:00:45.475 --> 00:00:47.475
<v Speaker 0>native landscape. So please check out my channel.

00:00:47.475 --> 00:00:49.235
<v Speaker 0>The link is in the bottom right corner.

00:00:49.715 --> 00:00:52.355
<v Speaker 0>I'm also an active Kubernetes contributor and I,

00:00:52.355 --> 00:00:54.515
<v Speaker 0>you know, take full responsibility for Dan pop

00:00:54.515 --> 00:00:56.515
<v Speaker 0>eating a pineapple pizza on my stream a

00:00:56.515 --> 00:00:57.075
<v Speaker 0>few weeks ago.

00:00:59.199 --> 00:01:01.840
<v Speaker 0>Now, what is the cluster API? It is

00:01:01.840 --> 00:01:03.120
<v Speaker 0>a Kubernetes

00:01:03.120 --> 00:01:04.799
<v Speaker 0>SIG sub project

00:01:05.360 --> 00:01:07.840
<v Speaker 0>that aims to commoditize

00:01:08.400 --> 00:01:11.280
<v Speaker 0>the way that we provision our Kubernetes cluster.

00:01:13.215 --> 00:01:15.295
<v Speaker 0>It has a declarative API,

00:01:15.375 --> 00:01:17.454
<v Speaker 0>much like everything else in Kubernetes

00:01:17.854 --> 00:01:20.095
<v Speaker 0>and in which we write YAML to apply

00:01:20.095 --> 00:01:21.215
<v Speaker 0>to our cluster.

00:01:21.854 --> 00:01:24.735
<v Speaker 0>And then the controllers within the cluster do

00:01:24.735 --> 00:01:25.935
<v Speaker 0>the thing that we want them to do.

00:01:26.840 --> 00:01:29.560
<v Speaker 0>And this case, cluster API is providing this

00:01:29.560 --> 00:01:31.399
<v Speaker 0>declarative API and that we can define a

00:01:31.399 --> 00:01:33.560
<v Speaker 0>Kubernetes cluster and the YAML,

00:01:33.880 --> 00:01:36.280
<v Speaker 0>apply that to a Kubernetes cluster

00:01:36.360 --> 00:01:38.439
<v Speaker 0>and it creates a Kubernetes cluster.

00:01:39.655 --> 00:01:42.215
<v Speaker 0>The responsibilities of the cluster API are to

00:01:42.215 --> 00:01:44.055
<v Speaker 0>create and provision these clusters,

00:01:44.455 --> 00:01:46.375
<v Speaker 0>but then a little bit more. The cluster

00:01:46.375 --> 00:01:47.255
<v Speaker 0>API

00:01:47.255 --> 00:01:48.615
<v Speaker 0>can upgrade

00:01:48.615 --> 00:01:49.575
<v Speaker 0>your cluster.

00:01:50.455 --> 00:01:52.775
<v Speaker 0>It also has some special provisions and it

00:01:52.775 --> 00:01:55.450
<v Speaker 0>tries to handle any operations if things go

00:01:55.450 --> 00:01:58.329
<v Speaker 0>wrong or we lose machines within our cluster

00:01:58.329 --> 00:01:59.850
<v Speaker 0>nodes within our clusters.

00:02:00.490 --> 00:02:02.570
<v Speaker 0>And it also has some limited support

00:02:02.890 --> 00:02:06.810
<v Speaker 0>for a get ops style deployment of applications

00:02:06.810 --> 00:02:07.929
<v Speaker 0>to the clusters.

00:02:09.345 --> 00:02:11.584
<v Speaker 0>It is currently in B1 alpha three, so

00:02:11.584 --> 00:02:13.345
<v Speaker 0>it's still early days in the Cluster API

00:02:13.345 --> 00:02:14.944
<v Speaker 0>project, but it has a lot of support

00:02:14.944 --> 00:02:16.785
<v Speaker 0>from all the major cloud providers

00:02:17.105 --> 00:02:18.705
<v Speaker 0>and a very active community.

00:02:19.665 --> 00:02:21.505
<v Speaker 0>And it's a very collaborative project.

00:02:21.745 --> 00:02:24.065
<v Speaker 0>It has support from my company Equinix Metal,

00:02:24.065 --> 00:02:26.090
<v Speaker 0>but also from AWS, from Google, from digital

00:02:26.090 --> 00:02:28.090
<v Speaker 0>ocean and all these other major players.

00:02:28.410 --> 00:02:30.890
<v Speaker 0>So the cluster API is becoming a very,

00:02:30.970 --> 00:02:32.330
<v Speaker 0>very great option

00:02:32.970 --> 00:02:35.290
<v Speaker 0>as being the primary tooling for one to

00:02:35.290 --> 00:02:38.695
<v Speaker 0>use to create new Kubernetes clusters. This

00:02:40.775 --> 00:02:42.534
<v Speaker 0>is the logo. And if you're not familiar,

00:02:42.534 --> 00:02:43.734
<v Speaker 0>I love the logo. I just thought I'd

00:02:43.734 --> 00:02:44.935
<v Speaker 0>bring it in on the slides, but it's

00:02:44.935 --> 00:02:47.174
<v Speaker 0>turtle stacking, right? Kubernetes all the way down.

00:02:47.174 --> 00:02:49.255
<v Speaker 0>You need Kubernetes to get Kubernetes.

00:02:49.334 --> 00:02:50.135
<v Speaker 0>And

00:02:50.135 --> 00:02:50.935
<v Speaker 0>I love the logo.

00:02:52.350 --> 00:02:54.350
<v Speaker 0>Now there's a little, a little bit of

00:02:54.350 --> 00:02:56.910
<v Speaker 0>a caputary, but one has to become accustomed

00:02:56.910 --> 00:02:58.910
<v Speaker 0>to to work with a cluster API.

00:02:58.990 --> 00:03:01.070
<v Speaker 0>Now the first one is we talk about

00:03:01.070 --> 00:03:03.390
<v Speaker 0>management clusters and workload clusters.

00:03:03.870 --> 00:03:06.505
<v Speaker 0>The management cluster tends to be or is

00:03:06.505 --> 00:03:08.345
<v Speaker 0>going to be the cluster that is running

00:03:08.345 --> 00:03:10.265
<v Speaker 0>the cluster API controllers.

00:03:10.825 --> 00:03:13.385
<v Speaker 0>This is the first cluster, the origin cluster.

00:03:13.385 --> 00:03:14.985
<v Speaker 0>This is the one that controls and creates

00:03:14.985 --> 00:03:16.345
<v Speaker 0>all other clusters.

00:03:16.985 --> 00:03:17.465
<v Speaker 0>And

00:03:18.510 --> 00:03:20.510
<v Speaker 0>then we have the workload clusters, which are

00:03:20.510 --> 00:03:21.950
<v Speaker 0>the clusters that we applied to the management

00:03:21.950 --> 00:03:23.550
<v Speaker 0>cluster that we want to be created.

00:03:24.430 --> 00:03:26.990
<v Speaker 0>Now it's very common at least and getting

00:03:26.990 --> 00:03:29.710
<v Speaker 0>started guides and other tutorials that are available

00:03:29.710 --> 00:03:30.350
<v Speaker 0>online

00:03:30.515 --> 00:03:32.595
<v Speaker 0>to use Docker for Mac or Kind or

00:03:32.595 --> 00:03:34.755
<v Speaker 0>MiniKube Azure management cluster.

00:03:35.235 --> 00:03:37.635
<v Speaker 0>And that is perfectly okay in some situations.

00:03:37.635 --> 00:03:39.474
<v Speaker 0>Of course, if you want the longer term

00:03:39.474 --> 00:03:42.114
<v Speaker 0>reconciliation options that Cluster API provides, you're gonna

00:03:42.114 --> 00:03:44.355
<v Speaker 0>wanna use a slightly longer term cluster.

00:03:44.755 --> 00:03:47.040
<v Speaker 0>And cluster API has a mechanism for that

00:03:47.040 --> 00:03:49.600
<v Speaker 0>too. You can use cluster API, you can

00:03:49.600 --> 00:03:52.400
<v Speaker 0>choose these ephemeral clusters like Kine Mini Kube

00:03:52.400 --> 00:03:54.160
<v Speaker 0>and Docker for Mac to create a Kubernetes

00:03:54.160 --> 00:03:56.160
<v Speaker 0>cluster and then move

00:03:56.240 --> 00:03:59.040
<v Speaker 0>that controller loop to your first production cluster,

00:03:59.525 --> 00:04:01.045
<v Speaker 0>Very viable option.

00:04:01.925 --> 00:04:04.885
<v Speaker 0>We also have infrastructure providers. Now Cluster API

00:04:04.885 --> 00:04:07.045
<v Speaker 0>can't do much on its own. You have

00:04:07.045 --> 00:04:10.805
<v Speaker 0>to install a provider. The providers being AWS,

00:04:10.885 --> 00:04:13.045
<v Speaker 0>Digital Ocean, GCP or Equinix metal.

00:04:13.570 --> 00:04:15.890
<v Speaker 0>Once you have one of those providers enabled

00:04:15.890 --> 00:04:18.050
<v Speaker 0>one or more of those providers enabled on

00:04:18.050 --> 00:04:20.370
<v Speaker 0>your management cluster, you can then create new

00:04:20.370 --> 00:04:23.010
<v Speaker 0>clusters on all of those infrastructures.

00:04:23.570 --> 00:04:26.210
<v Speaker 0>So that's the primary vocabulary and most of

00:04:26.210 --> 00:04:27.250
<v Speaker 0>what you need to get started.

00:04:29.665 --> 00:04:32.225
<v Speaker 0>Then when we beyond and we're talking about

00:04:32.225 --> 00:04:33.425
<v Speaker 0>creating clusters,

00:04:33.905 --> 00:04:35.824
<v Speaker 0>we need to talk about the primitives involves

00:04:35.824 --> 00:04:37.985
<v Speaker 0>for that too. Now this

00:04:38.705 --> 00:04:40.945
<v Speaker 0>requires you to write YAML that first defines

00:04:40.945 --> 00:04:41.905
<v Speaker 0>a machine deployment.

00:04:42.690 --> 00:04:45.410
<v Speaker 0>The machine deployment is like a node group

00:04:45.410 --> 00:04:47.330
<v Speaker 0>or a node pool if you're familiar with

00:04:47.330 --> 00:04:49.490
<v Speaker 0>other methods of spinning up clusters

00:04:49.650 --> 00:04:52.050
<v Speaker 0>that is responsible for managing a machine set

00:04:52.050 --> 00:04:53.490
<v Speaker 0>and then we have a machine set which

00:04:53.490 --> 00:04:55.490
<v Speaker 0>is responsible for managing the individual machines.

00:04:56.115 --> 00:04:58.035
<v Speaker 0>We also have the ability to apply machine

00:04:58.035 --> 00:05:00.035
<v Speaker 0>health checks to this that tells when the

00:05:00.035 --> 00:05:01.715
<v Speaker 0>machine is healthy or not healthy to allow

00:05:01.715 --> 00:05:04.514
<v Speaker 0>the controllers to then take away those broken

00:05:04.514 --> 00:05:06.194
<v Speaker 0>machines and bring in and replace them with

00:05:06.194 --> 00:05:07.155
<v Speaker 0>new machines.

00:05:07.875 --> 00:05:10.514
<v Speaker 0>Of course this should feel really really familiar.

00:05:10.849 --> 00:05:13.090
<v Speaker 0>If you have been working with Kubernetes for

00:05:13.090 --> 00:05:14.770
<v Speaker 0>any length of time, you're gonna be familiar

00:05:14.770 --> 00:05:15.970
<v Speaker 0>with the hierarchy

00:05:15.970 --> 00:05:17.650
<v Speaker 0>of I have a deployment

00:05:17.650 --> 00:05:21.009
<v Speaker 0>which manages replica sets, which manages pods and

00:05:21.009 --> 00:05:22.130
<v Speaker 0>we have probes.

00:05:22.530 --> 00:05:24.449
<v Speaker 0>Very similar when you group this together, it's

00:05:24.449 --> 00:05:26.210
<v Speaker 0>just that we're no longer talking about applications

00:05:26.355 --> 00:05:29.315
<v Speaker 0>or services or pods, we're talking about Kubernetes

00:05:29.875 --> 00:05:30.755
<v Speaker 0>clusters.

00:05:31.155 --> 00:05:31.795
<v Speaker 0>So

00:05:31.955 --> 00:05:33.715
<v Speaker 0>it should feel familiar

00:05:34.195 --> 00:05:36.435
<v Speaker 0>and hopefully that's all you need to understand

00:05:36.435 --> 00:05:38.515
<v Speaker 0>to really start kicking the tires with the

00:05:38.515 --> 00:05:39.315
<v Speaker 0>cluster API.

00:05:41.539 --> 00:05:43.460
<v Speaker 0>Now the best way to kind of show

00:05:43.460 --> 00:05:46.100
<v Speaker 0>you the Cluster API would just be to

00:05:46.100 --> 00:05:47.460
<v Speaker 0>give you a demo

00:05:48.100 --> 00:05:50.340
<v Speaker 0>and instead of actually doing these commands locally

00:05:50.340 --> 00:05:51.940
<v Speaker 0>and waiting for a cluster to spin up,

00:05:51.940 --> 00:05:53.300
<v Speaker 0>I'm just gonna run through the quick start

00:05:53.300 --> 00:05:55.699
<v Speaker 0>guide to highlight some of the more important

00:05:55.699 --> 00:05:57.604
<v Speaker 0>components and process steps that you need to

00:05:57.604 --> 00:05:58.325
<v Speaker 0>go through.

00:05:58.565 --> 00:06:00.324
<v Speaker 0>And then there'll be a slight little more

00:06:00.324 --> 00:06:02.324
<v Speaker 0>elaborate demo at the end with the abstraction

00:06:02.324 --> 00:06:03.685
<v Speaker 0>that I wanna provide on top.

00:06:09.540 --> 00:06:10.660
<v Speaker 0>So here we are.

00:06:10.980 --> 00:06:12.900
<v Speaker 0>This is the cluster API

00:06:13.220 --> 00:06:15.540
<v Speaker 0>quick start on the cluster API book. The

00:06:15.540 --> 00:06:17.460
<v Speaker 0>URL is in the corner. You can search

00:06:17.460 --> 00:06:19.300
<v Speaker 0>Google for cluster API quick start. It'll take

00:06:19.300 --> 00:06:21.060
<v Speaker 0>you right to it. Now of course cluster

00:06:21.060 --> 00:06:24.534
<v Speaker 0>API does require a Kubernetes cluster upfront. Today

00:06:24.534 --> 00:06:26.534
<v Speaker 0>I will be using Docker for Mac but

00:06:26.534 --> 00:06:27.974
<v Speaker 0>you can use many cube, you can use

00:06:27.974 --> 00:06:30.134
<v Speaker 0>kind, you can use any managed cluster from

00:06:30.134 --> 00:06:31.735
<v Speaker 0>any cloud provider that you want.

00:06:32.215 --> 00:06:33.974
<v Speaker 0>Once we have that cluster in place, we

00:06:33.974 --> 00:06:35.495
<v Speaker 0>just need to make sure our cube config

00:06:35.495 --> 00:06:37.414
<v Speaker 0>is working and that just means I can

00:06:37.414 --> 00:06:39.130
<v Speaker 0>run cube control,

00:06:39.130 --> 00:06:40.970
<v Speaker 0>get nodes, get pods, etcetera and it's gonna

00:06:40.970 --> 00:06:41.610
<v Speaker 0>work.

00:06:43.370 --> 00:06:47.370
<v Speaker 0>Now because there is a significant amount of

00:06:47.370 --> 00:06:50.250
<v Speaker 0>Yamo required to create a Kubernetes cluster,

00:06:50.330 --> 00:06:52.755
<v Speaker 0>you will need the cluster CTL command to

00:06:52.755 --> 00:06:55.395
<v Speaker 0>first install the provider and then generate the

00:06:55.395 --> 00:06:56.835
<v Speaker 0>manifest that we wanna apply to create the

00:06:56.835 --> 00:06:57.875
<v Speaker 0>workload cluster.

00:06:58.195 --> 00:06:59.875
<v Speaker 0>You can just download this with the curl

00:06:59.875 --> 00:07:01.875
<v Speaker 0>command from the documentation, stick it down to

00:07:01.875 --> 00:07:03.235
<v Speaker 0>your path and run it

00:07:03.555 --> 00:07:05.555
<v Speaker 0>much like any other binary on your machine.

00:07:06.979 --> 00:07:09.220
<v Speaker 0>Now to initialize the management cluster, there are

00:07:09.220 --> 00:07:11.220
<v Speaker 0>instructions for all of the providers that are

00:07:11.220 --> 00:07:14.180
<v Speaker 0>already supported. You can use AWS, Azure, Docker,

00:07:14.180 --> 00:07:16.900
<v Speaker 0>etcetera, etcetera, etcetera, etcetera, right? And they all

00:07:16.900 --> 00:07:18.979
<v Speaker 0>follow very similar steps. First, you just need

00:07:18.979 --> 00:07:21.539
<v Speaker 0>to tell it any sort of region information,

00:07:21.539 --> 00:07:23.225
<v Speaker 0>access keys are needed,

00:07:23.225 --> 00:07:24.185
<v Speaker 0>any credentials,

00:07:24.264 --> 00:07:26.825
<v Speaker 0>whatever. Right? AWS is there.

00:07:27.225 --> 00:07:29.145
<v Speaker 0>We can see GCP is similar. We just

00:07:29.145 --> 00:07:31.145
<v Speaker 0>need to access can tokens.

00:07:31.305 --> 00:07:33.065
<v Speaker 0>If you wanna run OpenStack,

00:07:33.065 --> 00:07:34.900
<v Speaker 0>know, by all means go for it. There

00:07:34.900 --> 00:07:37.220
<v Speaker 0>is metal cubed, there's packet which is now

00:07:37.220 --> 00:07:39.700
<v Speaker 0>Equinix metal, the provider hasn't been renamed yet

00:07:39.700 --> 00:07:42.180
<v Speaker 0>which just requires API key. So whatever provider

00:07:42.180 --> 00:07:42.980
<v Speaker 0>you're using,

00:07:43.380 --> 00:07:45.780
<v Speaker 0>expose the information through environment variables that you

00:07:45.780 --> 00:07:48.895
<v Speaker 0>need, run Cluster control and tell it which

00:07:48.895 --> 00:07:50.975
<v Speaker 0>infrastructure provider you require.

00:07:51.134 --> 00:07:52.335
<v Speaker 0>Here's packet,

00:07:52.574 --> 00:07:53.695
<v Speaker 0>there's GCP

00:07:54.574 --> 00:07:56.495
<v Speaker 0>and of course we have AWS.

00:07:58.175 --> 00:08:00.574
<v Speaker 0>Now that's just gonna do a few things

00:08:00.574 --> 00:08:02.240
<v Speaker 0>to our management cluster. First of all, we

00:08:02.240 --> 00:08:03.840
<v Speaker 0>need cert manager installed.

00:08:04.000 --> 00:08:05.520
<v Speaker 0>Cert manager is going to provision all of

00:08:05.520 --> 00:08:07.680
<v Speaker 0>the tokens that need for the webhook components

00:08:07.680 --> 00:08:09.680
<v Speaker 0>to work within the controllers

00:08:10.400 --> 00:08:11.280
<v Speaker 0>and then

00:08:11.760 --> 00:08:13.440
<v Speaker 0>it's going to install all of the controller

00:08:13.440 --> 00:08:14.880
<v Speaker 0>loops that we need

00:08:15.040 --> 00:08:16.535
<v Speaker 0>to the management cluster.

00:08:16.935 --> 00:08:19.335
<v Speaker 0>It also registers the CRDs are required so

00:08:19.335 --> 00:08:21.895
<v Speaker 0>that we can apply our own cluster definitions

00:08:21.895 --> 00:08:24.455
<v Speaker 0>to it. Right? Again, if you're working with

00:08:24.455 --> 00:08:26.695
<v Speaker 0>Kubernetes for any length of time, this should

00:08:26.695 --> 00:08:28.375
<v Speaker 0>feel mostly familiar.

00:08:30.240 --> 00:08:32.960
<v Speaker 0>Okay. Now that takes a few moments.

00:08:33.279 --> 00:08:36.080
<v Speaker 0>Once that becomes healthy, we then can start

00:08:36.080 --> 00:08:37.919
<v Speaker 0>to say, right, how do I create my

00:08:37.919 --> 00:08:39.520
<v Speaker 0>first workload cluster?

00:08:40.080 --> 00:08:42.320
<v Speaker 0>Well, there is a command that allows us

00:08:42.320 --> 00:08:43.200
<v Speaker 0>to generate

00:08:43.365 --> 00:08:45.445
<v Speaker 0>some of the YAML required or all of

00:08:45.445 --> 00:08:47.045
<v Speaker 0>the YAML that is required

00:08:47.205 --> 00:08:50.084
<v Speaker 0>and again cluster control is just wanting us

00:08:50.084 --> 00:08:52.325
<v Speaker 0>to expose any environment information that we need

00:08:52.325 --> 00:08:54.805
<v Speaker 0>to define how that cluster should look and

00:08:54.805 --> 00:08:56.805
<v Speaker 0>then it will generate the YAML for us.

00:08:56.805 --> 00:08:58.680
<v Speaker 0>So for AWS, we just need to tell

00:08:58.680 --> 00:09:00.600
<v Speaker 0>the region we want to create the cluster,

00:09:00.680 --> 00:09:03.000
<v Speaker 0>SSH key to make available on the nodes,

00:09:03.160 --> 00:09:05.720
<v Speaker 0>the control plane machine type and the workload

00:09:05.720 --> 00:09:07.240
<v Speaker 0>cluster machine type.

00:09:09.400 --> 00:09:12.040
<v Speaker 0>Azure is the same, GCP is the same,

00:09:12.785 --> 00:09:15.505
<v Speaker 0>Equinix metal and packet is the same. Right?

00:09:15.745 --> 00:09:17.105
<v Speaker 0>All we need to know is where to

00:09:17.105 --> 00:09:19.345
<v Speaker 0>create the cluster and the types of machines

00:09:19.345 --> 00:09:20.065
<v Speaker 0>to use.

00:09:20.465 --> 00:09:23.745
<v Speaker 0>We can also provide how many worker nodes,

00:09:23.745 --> 00:09:26.050
<v Speaker 0>how many control plane nodes we want how

00:09:26.050 --> 00:09:28.130
<v Speaker 0>many worker nodes we want. So once we've

00:09:28.130 --> 00:09:29.970
<v Speaker 0>exposed those environment variables, we can come back

00:09:29.970 --> 00:09:31.890
<v Speaker 0>to our cluster control command where we say

00:09:31.890 --> 00:09:33.330
<v Speaker 0>configure me a cluster.

00:09:33.970 --> 00:09:35.490
<v Speaker 0>We provide the name of the cluster that

00:09:35.490 --> 00:09:37.410
<v Speaker 0>we wish to create, the Kubernetes version that

00:09:37.410 --> 00:09:39.810
<v Speaker 0>we wish to deploy and then the counts

00:09:39.810 --> 00:09:41.970
<v Speaker 0>of how many machines we want on our

00:09:41.475 --> 00:09:43.235
<v Speaker 0>control plane and on

00:09:43.634 --> 00:09:44.675
<v Speaker 0>worker plane.

00:09:45.235 --> 00:09:47.394
<v Speaker 0>Now of course for the control plane, you're

00:09:47.394 --> 00:09:48.995
<v Speaker 0>gonna want to pick either one or three

00:09:48.995 --> 00:09:51.555
<v Speaker 0>depending on your use case. One being we

00:09:51.555 --> 00:09:53.235
<v Speaker 0>don't want a highly available control plane and

00:09:53.235 --> 00:09:54.595
<v Speaker 0>three being we do want a highly available

00:09:54.595 --> 00:09:56.610
<v Speaker 0>control plane. That is up to you, your

00:09:56.610 --> 00:09:58.370
<v Speaker 0>use case and what you're trying to do.

00:09:58.930 --> 00:10:00.769
<v Speaker 0>We then scale up how many worker machines

00:10:00.769 --> 00:10:02.370
<v Speaker 0>we want. It's important to note that you're

00:10:02.370 --> 00:10:03.970
<v Speaker 0>only ever gonna really get one node pool

00:10:03.970 --> 00:10:06.769
<v Speaker 0>in this configuration. However, you can modify the

00:10:06.769 --> 00:10:07.810
<v Speaker 0>YAML yourself

00:10:08.315 --> 00:10:10.795
<v Speaker 0>be able to change those machine types. Maybe

00:10:10.795 --> 00:10:11.675
<v Speaker 0>you want a,

00:10:12.154 --> 00:10:13.755
<v Speaker 0>maybe you want a node pool that has

00:10:13.755 --> 00:10:16.235
<v Speaker 0>a really high end infrastructure plus you want

00:10:16.235 --> 00:10:17.755
<v Speaker 0>a larger one that is maybe smaller or

00:10:17.755 --> 00:10:19.915
<v Speaker 0>small spot instances or something like that, right?

00:10:19.915 --> 00:10:21.675
<v Speaker 0>You know, you know what you're looking for.

00:10:21.915 --> 00:10:24.154
<v Speaker 0>However, the cluster control command line is really

00:10:24.450 --> 00:10:25.250
<v Speaker 0>basic.

00:10:25.570 --> 00:10:27.490
<v Speaker 0>So use that to get enough YAML that

00:10:27.490 --> 00:10:29.730
<v Speaker 0>you can understand how it's composed together to

00:10:29.730 --> 00:10:31.330
<v Speaker 0>be able to modify that yourself.

00:10:32.530 --> 00:10:34.930
<v Speaker 0>And then all we need to do is

00:10:34.930 --> 00:10:37.570
<v Speaker 0>kubectl apply the YAML that it spits out,

00:10:38.175 --> 00:10:39.935
<v Speaker 0>send it to our management cluster and the

00:10:39.935 --> 00:10:42.095
<v Speaker 0>controller loops will then begin to do everything

00:10:42.095 --> 00:10:44.255
<v Speaker 0>it needs to do to create

00:10:44.415 --> 00:10:46.654
<v Speaker 0>and provision our new cluster.

00:10:47.214 --> 00:10:49.135
<v Speaker 0>Now that can take anywhere from ten or

00:10:49.135 --> 00:10:50.815
<v Speaker 0>fifteen minutes to thirty minutes. It depends on

00:10:50.815 --> 00:10:53.529
<v Speaker 0>provider, depends how big the machines are, it

00:10:53.529 --> 00:10:55.129
<v Speaker 0>depends on whether you went for a single

00:10:55.129 --> 00:10:58.009
<v Speaker 0>control plane node or a highly available control

00:10:58.009 --> 00:11:00.250
<v Speaker 0>plane node. Obviously this is all gonna take

00:11:00.250 --> 00:11:02.170
<v Speaker 0>a slightly different amount of time.

00:11:02.490 --> 00:11:05.529
<v Speaker 0>Provisioning and creating Kubernetes clusters is not instantaneous.

00:11:06.825 --> 00:11:08.425
<v Speaker 0>Now there's one more thing that is really

00:11:08.425 --> 00:11:10.425
<v Speaker 0>important to note that when we do this

00:11:10.425 --> 00:11:12.745
<v Speaker 0>step is that we will not have a

00:11:12.745 --> 00:11:14.185
<v Speaker 0>working Kubernetes

00:11:14.185 --> 00:11:15.705
<v Speaker 0>cluster yet

00:11:16.105 --> 00:11:18.345
<v Speaker 0>and the reason for that is, is that

00:11:18.345 --> 00:11:21.785
<v Speaker 0>we don't have any networking within

00:11:21.480 --> 00:11:24.040
<v Speaker 0>cluster. We need to deploy our own CNI

00:11:24.040 --> 00:11:26.519
<v Speaker 0>provider that tells that how the nodes can

00:11:26.519 --> 00:11:28.279
<v Speaker 0>communicate with each other. In fact, the nodes

00:11:28.279 --> 00:11:30.519
<v Speaker 0>won't come under, their nodes won't be labeled

00:11:30.519 --> 00:11:33.079
<v Speaker 0>as ready until we have performed that step.

00:11:34.695 --> 00:11:35.655
<v Speaker 0>Now the

00:11:35.895 --> 00:11:36.855
<v Speaker 0>book here

00:11:37.415 --> 00:11:39.654
<v Speaker 0>will suggest that you install Calico and the

00:11:39.654 --> 00:11:41.335
<v Speaker 0>instructions for that are just here. You can

00:11:41.335 --> 00:11:43.335
<v Speaker 0>use whatever CNI you want, you just have

00:11:43.335 --> 00:11:45.415
<v Speaker 0>to make sure that the subnet configuration you

00:11:45.415 --> 00:11:47.930
<v Speaker 0>provide for your cluster will match. That will

00:11:47.930 --> 00:11:49.610
<v Speaker 0>be exposed to the YAML file that is

00:11:49.610 --> 00:11:52.250
<v Speaker 0>generated for you through KubeControl

00:11:52.410 --> 00:11:53.690
<v Speaker 0>config cluster.

00:11:54.410 --> 00:11:55.610
<v Speaker 0>In order to be able to do that

00:11:55.610 --> 00:11:57.690
<v Speaker 0>applying, you do need to get a KubeConfig

00:11:57.690 --> 00:12:00.125
<v Speaker 0>from the management cluster to your local machine

00:12:00.285 --> 00:12:02.204
<v Speaker 0>and there is a command for doing that

00:12:02.204 --> 00:12:02.925
<v Speaker 0>as well.

00:12:03.324 --> 00:12:05.165
<v Speaker 0>This is the very manual one that actually

00:12:05.165 --> 00:12:07.084
<v Speaker 0>pulls out the value from the secret. If

00:12:07.084 --> 00:12:08.764
<v Speaker 0>you're running a recent

00:12:08.764 --> 00:12:11.725
<v Speaker 0>version of cluster CTL, you can just run

00:12:11.725 --> 00:12:13.725
<v Speaker 0>cluster CTL get KubeConfig.

00:12:14.940 --> 00:12:17.900
<v Speaker 0>Once you've done that and deployed the CNI,

00:12:17.980 --> 00:12:22.300
<v Speaker 0>you have a production ready Kubernetes cluster ready

00:12:22.300 --> 00:12:23.660
<v Speaker 0>to do whatever you wish.

00:12:28.855 --> 00:12:29.495
<v Speaker 0>Okay.

00:12:30.375 --> 00:12:32.695
<v Speaker 0>Let's go back to the slides. So that

00:12:32.695 --> 00:12:34.855
<v Speaker 0>is how we get started with the Cluster

00:12:34.855 --> 00:12:37.095
<v Speaker 0>API using cluster control,

00:12:37.255 --> 00:12:39.740
<v Speaker 0>using all the defaults and the provider just

00:12:39.740 --> 00:12:40.860
<v Speaker 0>from the quick start.

00:12:42.060 --> 00:12:43.260
<v Speaker 0>Now what's the problem?

00:12:43.660 --> 00:12:44.300
<v Speaker 0>Well,

00:12:44.860 --> 00:12:48.220
<v Speaker 0>unfortunately there's a lot of Yamal involved, right?

00:12:48.620 --> 00:12:50.540
<v Speaker 0>And that may be no surprise to you

00:12:50.540 --> 00:12:52.940
<v Speaker 0>if you're already, you know, working with Kubernetes

00:12:52.940 --> 00:12:56.175
<v Speaker 0>but Yamal is what is what everything expects

00:12:56.175 --> 00:12:58.175
<v Speaker 0>us to write, configure,

00:12:58.335 --> 00:12:59.215
<v Speaker 0>manage,

00:12:59.775 --> 00:13:02.654
<v Speaker 0>to interact with our Kubernetes control plane and

00:13:02.654 --> 00:13:04.735
<v Speaker 0>of course there are many many memes online

00:13:04.735 --> 00:13:07.055
<v Speaker 0>about how much we are YAML engineers now

00:13:07.055 --> 00:13:08.895
<v Speaker 0>or how the only thing that the only

00:13:08.895 --> 00:13:10.730
<v Speaker 0>programming language you use to know is and

00:13:10.730 --> 00:13:11.850
<v Speaker 0>so forth and that

00:13:12.649 --> 00:13:14.329
<v Speaker 0>may get you so far but there are

00:13:14.329 --> 00:13:16.009
<v Speaker 0>limitations to how far we can go with

00:13:16.009 --> 00:13:17.529
<v Speaker 0>that YAML. So much so that we have

00:13:17.529 --> 00:13:19.449
<v Speaker 0>all of this other tooling coming out that

00:13:19.449 --> 00:13:22.329
<v Speaker 0>tries to abstract and simplify the process of

00:13:22.329 --> 00:13:23.690
<v Speaker 0>wrangling this YAML together.

00:13:24.475 --> 00:13:26.395
<v Speaker 0>One you're probably more familiar with will be

00:13:26.395 --> 00:13:29.195
<v Speaker 0>Helm, right? We use Helm to provide prepackaged

00:13:29.195 --> 00:13:31.835
<v Speaker 0>or template to build YAML configurations for applications

00:13:31.835 --> 00:13:33.435
<v Speaker 0>that we don't necessarily

00:13:33.515 --> 00:13:36.475
<v Speaker 0>understand or got completely ourselves that allow other

00:13:36.475 --> 00:13:37.995
<v Speaker 0>people who have that knowledge to produce it.

00:13:38.740 --> 00:13:40.740
<v Speaker 0>There's also tools like Capitan

00:13:40.740 --> 00:13:42.100
<v Speaker 0>or Customize

00:13:42.100 --> 00:13:44.340
<v Speaker 0>or all of those other tools, the Carvel

00:13:44.340 --> 00:13:47.460
<v Speaker 0>tools, etcetera that also provide their own abstractions

00:13:47.460 --> 00:13:49.540
<v Speaker 0>in order to handle this YAML mess that

00:13:49.540 --> 00:13:50.500
<v Speaker 0>we've gotten ourselves into.

00:13:53.955 --> 00:13:54.595
<v Speaker 0>So

00:13:55.315 --> 00:13:57.635
<v Speaker 0>I took a little bit of time and

00:13:57.635 --> 00:14:00.115
<v Speaker 0>reached out to Jason to to is one

00:14:00.115 --> 00:14:02.995
<v Speaker 0>of the, you know, maintainers and contributors to

00:14:02.995 --> 00:14:04.435
<v Speaker 0>the Cluster API project.

00:14:04.915 --> 00:14:06.595
<v Speaker 0>And I asked him what his thoughts were

00:14:06.595 --> 00:14:09.610
<v Speaker 0>on the responsibilities of the Cluster API in

00:14:09.610 --> 00:14:11.690
<v Speaker 0>regard to how the end users should consume

00:14:11.690 --> 00:14:12.250
<v Speaker 0>it.

00:14:13.130 --> 00:14:14.810
<v Speaker 0>I would read this out, you know, take

00:14:14.810 --> 00:14:16.650
<v Speaker 0>a moment to pause it if you want

00:14:16.650 --> 00:14:18.970
<v Speaker 0>to read it verbatim, but I think the

00:14:18.970 --> 00:14:19.770
<v Speaker 0>message is clear.

00:14:20.775 --> 00:14:23.735
<v Speaker 0>And Jason's opinion is that the cluster API's

00:14:23.735 --> 00:14:25.175
<v Speaker 0>primary responsibility

00:14:25.655 --> 00:14:29.015
<v Speaker 0>is the reconciliation creation and provisioning and management

00:14:29.015 --> 00:14:31.175
<v Speaker 0>of the Kubernetes clusters itself.

00:14:31.975 --> 00:14:35.190
<v Speaker 0>The responsibility is not to generate or provide

00:14:35.190 --> 00:14:38.470
<v Speaker 0>the tooling to describe those clusters, right? The

00:14:38.470 --> 00:14:41.350
<v Speaker 0>cluster API provides the CRDs, provides the spec

00:14:41.350 --> 00:14:42.790
<v Speaker 0>for how we describe

00:14:43.030 --> 00:14:44.150
<v Speaker 0>those clusters.

00:14:44.550 --> 00:14:47.350
<v Speaker 0>But really it's our responsibility to provide the

00:14:47.350 --> 00:14:48.070
<v Speaker 0>YAML.

00:14:48.870 --> 00:14:50.885
<v Speaker 0>Now, of course we already seen through the

00:14:50.885 --> 00:14:53.685
<v Speaker 0>quick start that Cluster CTL provides a really

00:14:53.685 --> 00:14:56.725
<v Speaker 0>simple method of generating some YAML from environment

00:14:56.725 --> 00:14:57.445
<v Speaker 0>variables.

00:14:57.685 --> 00:14:59.365
<v Speaker 0>And that's great for getting started, but we

00:14:59.365 --> 00:15:01.925
<v Speaker 0>need more tooling and we need other tools

00:15:01.925 --> 00:15:03.925
<v Speaker 0>to come along and help with the creation

00:15:03.925 --> 00:15:04.990
<v Speaker 0>of that YAML.

00:15:06.510 --> 00:15:07.070
<v Speaker 0>So

00:15:07.630 --> 00:15:09.390
<v Speaker 0>what would be a potential solution?

00:15:10.190 --> 00:15:12.350
<v Speaker 0>I'm a big fan of infrastructure as code

00:15:12.350 --> 00:15:15.070
<v Speaker 0>and I do not mean infrastructure as YAML.

00:15:15.070 --> 00:15:16.029
<v Speaker 0>I mean, code.

00:15:17.375 --> 00:15:20.095
<v Speaker 0>So what I want from a solution in

00:15:20.095 --> 00:15:22.975
<v Speaker 0>this space is something that is first and

00:15:22.975 --> 00:15:24.015
<v Speaker 0>foremost flexible.

00:15:24.575 --> 00:15:27.535
<v Speaker 0>Something that allows me to describe a cluster

00:15:27.695 --> 00:15:29.214
<v Speaker 0>and my configuration

00:15:29.295 --> 00:15:32.190
<v Speaker 0>with however many node pools I want with

00:15:32.190 --> 00:15:35.310
<v Speaker 0>whichever operating system or images I want, the

00:15:35.310 --> 00:15:36.910
<v Speaker 0>size and infrastructure,

00:15:36.990 --> 00:15:38.590
<v Speaker 0>you know the size of the clusters and

00:15:38.590 --> 00:15:40.190
<v Speaker 0>the node pools and the size of the

00:15:40.190 --> 00:15:42.510
<v Speaker 0>machines that I wanna use that I want.

00:15:43.470 --> 00:15:45.310
<v Speaker 0>I also wanted to be composable.

00:15:46.035 --> 00:15:48.274
<v Speaker 0>I'm probably going to be creating many many

00:15:48.274 --> 00:15:50.274
<v Speaker 0>clusters and the reason I want it to

00:15:50.274 --> 00:15:52.595
<v Speaker 0>be composable is I maybe want to have

00:15:52.995 --> 00:15:53.875
<v Speaker 0>definitions

00:15:53.875 --> 00:15:56.514
<v Speaker 0>that I can reuse across those clusters. Like

00:15:56.514 --> 00:15:58.595
<v Speaker 0>if I'm deploying some of the node groups

00:15:58.595 --> 00:16:01.680
<v Speaker 0>for stateful workloads, for storage, for memory consumption,

00:16:01.680 --> 00:16:02.480
<v Speaker 0>for databases,

00:16:02.640 --> 00:16:05.120
<v Speaker 0>for a compute machine learning with GPU's.

00:16:05.360 --> 00:16:09.120
<v Speaker 0>I wanna be able to generalize

00:16:09.360 --> 00:16:12.240
<v Speaker 0>those configurations and reuse them across my multiple

00:16:12.240 --> 00:16:13.200
<v Speaker 0>clusters

00:16:13.185 --> 00:16:15.745
<v Speaker 0>And it has to be ergonomic, has to

00:16:16.065 --> 00:16:18.625
<v Speaker 0>feel and be fun to work with to

00:16:18.625 --> 00:16:20.625
<v Speaker 0>a certain degree, right? We don't need to

00:16:20.625 --> 00:16:22.305
<v Speaker 0>take all the fun out of this stuff.

00:16:22.785 --> 00:16:24.385
<v Speaker 0>So can I have a solution that is

00:16:24.385 --> 00:16:26.785
<v Speaker 0>flexible, composable and ergonomic?

00:16:27.425 --> 00:16:29.720
<v Speaker 0>And I hope so. And I think that

00:16:29.720 --> 00:16:30.920
<v Speaker 0>the foundation

00:16:30.920 --> 00:16:32.360
<v Speaker 0>for the tooling that I'm going to show

00:16:32.360 --> 00:16:34.840
<v Speaker 0>you all comes from a project called Pulumi.

00:16:35.240 --> 00:16:38.040
<v Speaker 0>Pulumi is an infrastructure as code tool that

00:16:38.040 --> 00:16:39.640
<v Speaker 0>doesn't use DSL.

00:16:39.880 --> 00:16:41.905
<v Speaker 0>It allows you the user to use whatever

00:16:41.905 --> 00:16:44.945
<v Speaker 0>language you're comfortable with provided as supported,

00:16:45.425 --> 00:16:47.105
<v Speaker 0>but they have really good support.

00:16:47.825 --> 00:16:49.505
<v Speaker 0>And here's an example I grabbed from one

00:16:49.505 --> 00:16:52.225
<v Speaker 0>of their example repositories where they're using the

00:16:52.225 --> 00:16:53.905
<v Speaker 0>Azure provider in Pulumi

00:16:54.180 --> 00:16:56.260
<v Speaker 0>to deploy a new

00:16:56.420 --> 00:16:58.900
<v Speaker 0>function, HTTP function that it was I guess

00:16:58.900 --> 00:17:00.500
<v Speaker 0>like Lambda with an endpoint.

00:17:01.220 --> 00:17:02.740
<v Speaker 0>And you can see how simple this is

00:17:02.740 --> 00:17:04.020
<v Speaker 0>using TypeScript.

00:17:04.099 --> 00:17:05.780
<v Speaker 0>First I just create a new resource group

00:17:05.780 --> 00:17:07.815
<v Speaker 0>and give it a name. I can define

00:17:07.815 --> 00:17:09.895
<v Speaker 0>a handler which is just an anonymous function

00:17:09.895 --> 00:17:11.655
<v Speaker 0>with whatever code that I want in there

00:17:11.655 --> 00:17:13.254
<v Speaker 0>to do whatever I want it to do

00:17:13.655 --> 00:17:15.415
<v Speaker 0>and then I just say I want a

00:17:15.415 --> 00:17:17.095
<v Speaker 0>new HTTP event subscription

00:17:17.175 --> 00:17:19.494
<v Speaker 0>pointed to the resource group, pointed to the

00:17:19.494 --> 00:17:20.214
<v Speaker 0>handler

00:17:20.295 --> 00:17:22.680
<v Speaker 0>and that's it. Doing this is cool as

00:17:22.680 --> 00:17:24.359
<v Speaker 0>allows us to leverage all of the

00:17:24.680 --> 00:17:27.640
<v Speaker 0>functional or object oriented practices that we've developed

00:17:27.640 --> 00:17:29.240
<v Speaker 0>over the years for making our code reusable

00:17:29.240 --> 00:17:31.639
<v Speaker 0>and composable and of course flexible.

00:17:33.160 --> 00:17:35.400
<v Speaker 0>Now another project that is

00:17:36.184 --> 00:17:39.625
<v Speaker 0>really, really important and the libraries that I'm

00:17:39.625 --> 00:17:42.025
<v Speaker 0>going to share is something called CRD to

00:17:42.025 --> 00:17:42.904
<v Speaker 0>Pulumi.

00:17:43.385 --> 00:17:45.465
<v Speaker 0>This is a go application

00:17:45.465 --> 00:17:47.225
<v Speaker 0>by the Pulumi team. I believe it was

00:17:47.225 --> 00:17:48.665
<v Speaker 0>written by one of the interns

00:17:49.100 --> 00:17:52.140
<v Speaker 0>that allows me to pass in a Kubernetes

00:17:52.140 --> 00:17:54.620
<v Speaker 0>custom resource definition YAML file,

00:17:55.500 --> 00:17:56.300
<v Speaker 0>generate

00:17:56.300 --> 00:17:57.179
<v Speaker 0>types

00:17:57.180 --> 00:17:59.500
<v Speaker 0>for that that can be consumed

00:17:59.660 --> 00:18:01.340
<v Speaker 0>by Pulumi

00:18:01.005 --> 00:18:03.485
<v Speaker 0>projects or Pulumi end projects.

00:18:04.285 --> 00:18:06.445
<v Speaker 0>It supports all of the supported languages

00:18:06.685 --> 00:18:08.284
<v Speaker 0>that Pulumi supports.

00:18:08.605 --> 00:18:11.325
<v Speaker 0>Here I've got an example that generates

00:18:11.325 --> 00:18:13.405
<v Speaker 0>node JS which is TypeScript types

00:18:13.910 --> 00:18:15.830
<v Speaker 0>that can be reused on my project

00:18:16.150 --> 00:18:17.590
<v Speaker 0>and we'll come back to that in a

00:18:17.590 --> 00:18:18.389
<v Speaker 0>little bit too.

00:18:20.150 --> 00:18:22.950
<v Speaker 0>Now I said that the libraries, the language

00:18:22.950 --> 00:18:25.110
<v Speaker 0>support is very good for Pulumi. These are

00:18:25.110 --> 00:18:27.909
<v Speaker 0>the primary languages. I believe adding new languages

00:18:28.150 --> 00:18:31.345
<v Speaker 0>is not trivial but also not an enormous

00:18:31.345 --> 00:18:31.904
<v Speaker 0>task.

00:18:32.625 --> 00:18:34.225
<v Speaker 0>Maybe I could hack us on project one

00:18:34.225 --> 00:18:35.825
<v Speaker 0>day to try and address but

00:18:36.305 --> 00:18:39.025
<v Speaker 0>TypeScript is my preferred approach here and because

00:18:39.025 --> 00:18:40.865
<v Speaker 0>of the type system and the ergonomics of

00:18:40.865 --> 00:18:42.225
<v Speaker 0>working with the language are really good. The

00:18:42.225 --> 00:18:44.570
<v Speaker 0>tooling is good across IDEs. TypeScript

00:18:44.570 --> 00:18:46.330
<v Speaker 0>is the one that I'll be using today.

00:18:46.730 --> 00:18:49.690
<v Speaker 0>You can use go as well. You can

00:18:49.690 --> 00:18:51.450
<v Speaker 0>use Python and you can use any of

00:18:51.450 --> 00:18:53.130
<v Speaker 0>the dot net languages. I think C sharp

00:18:53.130 --> 00:18:55.050
<v Speaker 0>and F sharp seem to be quite widely

00:18:55.050 --> 00:18:55.530
<v Speaker 0>supported.

00:18:58.845 --> 00:18:59.485
<v Speaker 0>And

00:18:59.725 --> 00:19:01.405
<v Speaker 0>this is one of these things that I'm

00:19:01.405 --> 00:19:02.685
<v Speaker 0>just gonna have to spend a little bit

00:19:02.685 --> 00:19:03.805
<v Speaker 0>of hyperbole

00:19:03.805 --> 00:19:05.405
<v Speaker 0>and be like, it doesn't exist yet, but

00:19:05.405 --> 00:19:07.565
<v Speaker 0>it's coming, but I do, you know, speak

00:19:07.565 --> 00:19:09.885
<v Speaker 0>with the Pulumi team regularly and one of

00:19:09.885 --> 00:19:12.045
<v Speaker 0>the things that

00:19:11.030 --> 00:19:12.710
<v Speaker 0>I've been trying to talk to them about

00:19:12.710 --> 00:19:13.909
<v Speaker 0>and understand is

00:19:14.230 --> 00:19:17.750
<v Speaker 0>if I write composable units of Pulumi codes

00:19:17.750 --> 00:19:19.750
<v Speaker 0>that can be consumed by others is like

00:19:19.750 --> 00:19:21.510
<v Speaker 0>is there some sort of AST that I

00:19:21.510 --> 00:19:23.110
<v Speaker 0>can consume this and other

00:19:23.110 --> 00:19:24.710
<v Speaker 0>teams can consume this

00:19:24.870 --> 00:19:26.710
<v Speaker 0>even if they're not using the same language

00:19:26.445 --> 00:19:27.164
<v Speaker 0>as me.

00:19:27.725 --> 00:19:29.884
<v Speaker 0>And the answer is it's coming soon. So

00:19:29.884 --> 00:19:32.205
<v Speaker 0>while the types that I'm generating for this

00:19:32.205 --> 00:19:34.764
<v Speaker 0>Cluster API project are all in TypeScript

00:19:35.404 --> 00:19:37.804
<v Speaker 0>and the coming future short temperature I believe

00:19:37.804 --> 00:19:40.524
<v Speaker 0>is that you as a team using Pulumi

00:19:40.524 --> 00:19:41.565
<v Speaker 0>and goor.net

00:19:41.565 --> 00:19:44.200
<v Speaker 0>or Python will still be able to reuse

00:19:44.200 --> 00:19:45.799
<v Speaker 0>these composable modules,

00:19:45.960 --> 00:19:48.440
<v Speaker 0>which is really really exciting. It doesn't matter

00:19:48.520 --> 00:19:51.000
<v Speaker 0>what language I'm using, you can use the

00:19:51.000 --> 00:19:53.400
<v Speaker 0>language of your choice and still take advantage

00:19:53.400 --> 00:19:55.640
<v Speaker 0>of this without having to generate your own

00:19:55.640 --> 00:19:58.280
<v Speaker 0>types for go, for Python, for dot net

00:19:58.385 --> 00:19:59.265
<v Speaker 0>etcetera.

00:19:59.505 --> 00:20:00.945
<v Speaker 0>Very very cool.

00:20:02.465 --> 00:20:03.265
<v Speaker 0>Alright.

00:20:03.425 --> 00:20:04.785
<v Speaker 0>That's enough waffle.

00:20:05.265 --> 00:20:07.105
<v Speaker 0>The next part of this talk I'm just

00:20:07.105 --> 00:20:08.145
<v Speaker 0>going to show you

00:20:08.465 --> 00:20:11.505
<v Speaker 0>how flexible the solution is, how composable the

00:20:11.505 --> 00:20:13.820
<v Speaker 0>solution is and how ergonomic it is to

00:20:13.820 --> 00:20:14.620
<v Speaker 0>work with.

00:20:18.300 --> 00:20:20.940
<v Speaker 0>Okay, so in my demo talk directory here

00:20:20.940 --> 00:20:24.060
<v Speaker 0>I have a base Pulumi project just initiated

00:20:24.060 --> 00:20:27.020
<v Speaker 0>with Pulumi new. I've selected the Kubernetes TypeScript

00:20:27.655 --> 00:20:29.575
<v Speaker 0>and starting point which just means that I

00:20:29.575 --> 00:20:31.655
<v Speaker 0>get a TypeScript file with some example code

00:20:31.655 --> 00:20:33.815
<v Speaker 0>which I've deleted and a package dot JSON

00:20:33.815 --> 00:20:36.135
<v Speaker 0>which I've added our packages that we're using

00:20:36.135 --> 00:20:38.455
<v Speaker 0>today. I've added the Cluster API package helpers

00:20:38.455 --> 00:20:40.570
<v Speaker 0>which is this first one. The type definitions

00:20:40.570 --> 00:20:42.009
<v Speaker 0>so I can show you how those work

00:20:42.009 --> 00:20:44.330
<v Speaker 0>and then two helpers for DigitalOcean and for

00:20:44.330 --> 00:20:45.209
<v Speaker 0>Packet Cloud.

00:20:45.690 --> 00:20:47.929
<v Speaker 0>Now when I come into the index. Ts,

00:20:47.929 --> 00:20:49.450
<v Speaker 0>the first thing I wanna do is enable

00:20:49.450 --> 00:20:51.049
<v Speaker 0>a Kubernetes provider.

00:20:51.850 --> 00:20:53.529
<v Speaker 0>Now if we don't provide one it will

00:20:53.529 --> 00:20:55.815
<v Speaker 0>use whatever is available on the system. However,

00:20:55.815 --> 00:20:57.095
<v Speaker 0>I prefer to be a little bit more

00:20:57.095 --> 00:20:58.695
<v Speaker 0>explicit about it and I'll show you why

00:20:58.695 --> 00:21:00.374
<v Speaker 0>in the second part of this demo.

00:21:00.855 --> 00:21:02.375
<v Speaker 0>To get a new provider, I can do

00:21:02.375 --> 00:21:04.215
<v Speaker 0>a case provider. We give it a name

00:21:04.215 --> 00:21:06.054
<v Speaker 0>so I'll just call it Kubernetes

00:21:06.615 --> 00:21:08.054
<v Speaker 0>and then it takes a small bit of

00:21:08.054 --> 00:21:10.630
<v Speaker 0>configuration and there's some options here which I'm

00:21:10.630 --> 00:21:12.070
<v Speaker 0>not going to bother with.

00:21:12.950 --> 00:21:14.710
<v Speaker 0>Now that we have a provider, we can

00:21:14.710 --> 00:21:16.549
<v Speaker 0>install cluster API.

00:21:16.870 --> 00:21:18.789
<v Speaker 0>So let's import

00:21:19.350 --> 00:21:20.950
<v Speaker 0>star as copy

00:21:21.030 --> 00:21:22.549
<v Speaker 0>from our helper.

00:21:23.110 --> 00:21:23.990
<v Speaker 0>Like so.

00:21:24.309 --> 00:21:25.750
<v Speaker 0>And that now means

00:21:26.275 --> 00:21:27.955
<v Speaker 0>that if I type copy dot, I have

00:21:27.955 --> 00:21:30.835
<v Speaker 0>a few helper functions available. First one initialize,

00:21:30.835 --> 00:21:33.155
<v Speaker 0>second one create cluster and then something called

00:21:33.155 --> 00:21:34.435
<v Speaker 0>a feature gate that we don't know what

00:21:34.435 --> 00:21:35.315
<v Speaker 0>that is yet.

00:21:35.955 --> 00:21:38.115
<v Speaker 0>I'm gonna hit in it and then I

00:21:38.115 --> 00:21:40.435
<v Speaker 0>can see from the type system helping you

00:21:40.435 --> 00:21:42.920
<v Speaker 0>here is that we need a cluster API

00:21:42.920 --> 00:21:43.720
<v Speaker 0>config.

00:21:43.800 --> 00:21:45.240
<v Speaker 0>I can open up an object and I

00:21:45.240 --> 00:21:47.320
<v Speaker 0>get auto complete. I can say yes, let's

00:21:47.320 --> 00:21:49.000
<v Speaker 0>install cert manager because we need it and

00:21:49.000 --> 00:21:51.000
<v Speaker 0>I don't have it previously provisioned to my

00:21:51.000 --> 00:21:52.040
<v Speaker 0>management cluster.

00:21:52.280 --> 00:21:54.040
<v Speaker 0>I can specify the version

00:21:55.080 --> 00:21:56.995
<v Speaker 0>and then I oh, I have the feature

00:21:56.995 --> 00:22:00.195
<v Speaker 0>gates, which we know by hovering over this

00:22:00.195 --> 00:22:02.595
<v Speaker 0>is a list of feature gates. We can

00:22:02.595 --> 00:22:04.434
<v Speaker 0>open up a list, we can do copy

00:22:04.434 --> 00:22:06.674
<v Speaker 0>feature gate and see what is available.

00:22:06.915 --> 00:22:08.674
<v Speaker 0>I'm gonna enable cluster resources.

00:22:09.315 --> 00:22:11.710
<v Speaker 0>Finally, we have the Kubernetes provider, which we're

00:22:11.710 --> 00:22:13.390
<v Speaker 0>just gonna use the one we generated up

00:22:13.390 --> 00:22:14.030
<v Speaker 0>above.

00:22:14.910 --> 00:22:17.470
<v Speaker 0>Now I can install providers to my cluster.

00:22:17.790 --> 00:22:18.990
<v Speaker 0>So we

00:22:18.990 --> 00:22:22.270
<v Speaker 0>also know that this emit function returns manifest.

00:22:22.270 --> 00:22:23.630
<v Speaker 0>So let's make sure we store them for

00:22:23.630 --> 00:22:23.950
<v Speaker 0>later.

00:22:25.485 --> 00:22:26.205
<v Speaker 0>Okay.

00:22:26.285 --> 00:22:29.164
<v Speaker 0>Now we have our provider

00:22:29.325 --> 00:22:30.765
<v Speaker 0>deal manifests

00:22:30.765 --> 00:22:32.525
<v Speaker 0>which is gonna be for digital ocean.

00:22:32.685 --> 00:22:33.965
<v Speaker 0>So let's import that.

00:22:34.445 --> 00:22:36.365
<v Speaker 0>Well import star as

00:22:36.685 --> 00:22:38.470
<v Speaker 0>digital ocean from

00:22:38.790 --> 00:22:39.909
<v Speaker 0>Rawkode

00:22:40.070 --> 00:22:41.190
<v Speaker 0>digital ocean.

00:22:41.750 --> 00:22:48.230
<v Speaker 0>And now we can do digitalocean.edit.

00:22:48.630 --> 00:22:50.230
<v Speaker 0>And we can see here this takes a

00:22:50.230 --> 00:22:51.270
<v Speaker 0>provider config.

00:22:51.645 --> 00:22:53.165
<v Speaker 0>If we pop that open when we use

00:22:53.165 --> 00:22:54.845
<v Speaker 0>our all complete we see oh, we need

00:22:54.845 --> 00:22:56.044
<v Speaker 0>an access token.

00:22:56.445 --> 00:22:58.044
<v Speaker 0>We need a cluster API,

00:22:58.045 --> 00:22:59.965
<v Speaker 0>which is just gonna be our manifest return

00:22:59.965 --> 00:23:02.045
<v Speaker 0>from the in it and we specifically

00:23:02.045 --> 00:23:04.445
<v Speaker 0>want the cluster API ones. That's just forms

00:23:04.445 --> 00:23:06.765
<v Speaker 0>a dependency so we don't get any waste

00:23:06.360 --> 00:23:08.519
<v Speaker 0>conditions when we apply it to the cluster.

00:23:09.320 --> 00:23:11.639
<v Speaker 0>And then we can provide our Kubernetes

00:23:11.640 --> 00:23:12.519
<v Speaker 0>provider.

00:23:13.080 --> 00:23:15.080
<v Speaker 0>Now I'm not gonna use the data ocean

00:23:15.080 --> 00:23:17.480
<v Speaker 0>provider. So I will use ABC one, three

00:23:17.480 --> 00:23:19.159
<v Speaker 0>for our access token.

00:23:19.559 --> 00:23:21.799
<v Speaker 0>Next, I'm gonna import the packet provider.

00:23:27.045 --> 00:23:28.725
<v Speaker 0>Oops. Random equals.

00:23:30.005 --> 00:23:32.405
<v Speaker 0>Auto complete. We have a packet provider here

00:23:32.405 --> 00:23:34.085
<v Speaker 0>and then I can do the same. We

00:23:34.085 --> 00:23:35.970
<v Speaker 0>can say, hey, we also want

00:23:36.210 --> 00:23:37.730
<v Speaker 0>packet manifests

00:23:37.890 --> 00:23:39.810
<v Speaker 0>where we use packet in it, which also

00:23:39.810 --> 00:23:41.330
<v Speaker 0>takes a provider config,

00:23:41.570 --> 00:23:43.250
<v Speaker 0>which needs an API key.

00:23:43.650 --> 00:23:45.250
<v Speaker 0>Also one, three.

00:23:45.730 --> 00:23:47.970
<v Speaker 0>It also needs the Kubernetes provider

00:23:48.095 --> 00:23:50.335
<v Speaker 0>and also needs the cluster API.

00:23:54.015 --> 00:23:56.415
<v Speaker 0>We save it and we're done.

00:23:57.855 --> 00:23:59.695
<v Speaker 0>Okay, let's spin this up. We can run

00:23:59.695 --> 00:24:00.415
<v Speaker 0>Pulumi up.

00:24:01.040 --> 00:24:03.520
<v Speaker 0>We provide the password for our stack. It's

00:24:03.520 --> 00:24:04.960
<v Speaker 0>gonna go away and speak to the Kubernetes

00:24:04.960 --> 00:24:06.960
<v Speaker 0>cluster, work out what has to be created

00:24:06.960 --> 00:24:08.639
<v Speaker 0>and then give us a plan.

00:24:08.880 --> 00:24:10.880
<v Speaker 0>We can then decide to apply that plan

00:24:10.880 --> 00:24:11.919
<v Speaker 0>to the cluster.

00:24:12.720 --> 00:24:13.840
<v Speaker 0>Just a moment.

00:24:14.160 --> 00:24:14.960
<v Speaker 0>We had yes.

00:24:16.054 --> 00:24:18.054
<v Speaker 0>And now that's going to deploy a 30

00:24:18.054 --> 00:24:21.015
<v Speaker 0>resources to our cluster. That's provisioning cluster API,

00:24:21.015 --> 00:24:23.254
<v Speaker 0>the touch of lotion provider and

00:24:23.414 --> 00:24:24.455
<v Speaker 0>the packet provider.

00:24:30.330 --> 00:24:31.929
<v Speaker 0>Okay. Let's take a look at a more

00:24:31.929 --> 00:24:34.970
<v Speaker 0>feature complete example. So inside providers, we have

00:24:34.970 --> 00:24:37.210
<v Speaker 0>this packet example directory and there's also a

00:24:37.210 --> 00:24:38.809
<v Speaker 0>digital ocean example too.

00:24:38.970 --> 00:24:40.490
<v Speaker 0>If we open this up, we can actually

00:24:40.490 --> 00:24:43.929
<v Speaker 0>see that we're not just provisioning the Cluster

00:24:43.929 --> 00:24:46.295
<v Speaker 0>API controllers, but we have all this commented

00:24:46.295 --> 00:24:47.174
<v Speaker 0>out code

00:24:47.495 --> 00:24:50.375
<v Speaker 0>and don't worry that project ID and API

00:24:50.375 --> 00:24:51.975
<v Speaker 0>key are no longer valid but

00:24:53.895 --> 00:24:56.455
<v Speaker 0>we can first and foremost import a few

00:24:56.455 --> 00:24:59.095
<v Speaker 0>extra helpers. We have facility enumerated

00:24:59.160 --> 00:25:00.840
<v Speaker 0>that means that all the facilities that are

00:25:00.840 --> 00:25:03.320
<v Speaker 0>available can be you know, type or part

00:25:03.320 --> 00:25:04.680
<v Speaker 0>of the type system. We also have the

00:25:04.680 --> 00:25:06.280
<v Speaker 0>same for the operating systems.

00:25:06.840 --> 00:25:09.320
<v Speaker 0>Instead of having Pulumi speak directly to our

00:25:09.320 --> 00:25:11.240
<v Speaker 0>cluster, we're gonna have it render YAML to

00:25:11.240 --> 00:25:13.480
<v Speaker 0>a local director that we can apply ourselves.

00:25:13.480 --> 00:25:15.914
<v Speaker 0>Really cool way for Pulumi to work with

00:25:15.914 --> 00:25:16.715
<v Speaker 0>Kubernetes

00:25:16.715 --> 00:25:17.595
<v Speaker 0>without

00:25:17.835 --> 00:25:19.595
<v Speaker 0>building it into your CI system.

00:25:20.315 --> 00:25:23.115
<v Speaker 0>Next we skip over all the CAPI and

00:25:23.115 --> 00:25:24.554
<v Speaker 0>packet in it but we can provide a

00:25:24.554 --> 00:25:26.955
<v Speaker 0>cluster name and a project ID and then

00:25:26.955 --> 00:25:28.635
<v Speaker 0>we have a helper for creating a new

00:25:28.635 --> 00:25:31.830
<v Speaker 0>control plane. You know, we have access still

00:25:31.830 --> 00:25:33.430
<v Speaker 0>to our type system,

00:25:33.590 --> 00:25:35.750
<v Speaker 0>very very easy to work with. We have

00:25:35.750 --> 00:25:37.750
<v Speaker 0>our enumerated types for the facility,

00:25:38.070 --> 00:25:40.390
<v Speaker 0>we have operating systems which allow us to

00:25:40.390 --> 00:25:42.470
<v Speaker 0>select the container runtime that we want. If

00:25:42.470 --> 00:25:44.150
<v Speaker 0>I don't want to run container

00:25:44.325 --> 00:25:46.405
<v Speaker 0>well I can swap it out for another

00:25:46.405 --> 00:25:49.445
<v Speaker 0>supported one by the abstractions in this library.

00:25:49.765 --> 00:25:51.765
<v Speaker 0>I can see okay, we actually want Docker

00:25:51.765 --> 00:25:54.005
<v Speaker 0>installed on this machine. We provide the machine

00:25:54.005 --> 00:25:54.565
<v Speaker 0>type.

00:25:54.885 --> 00:25:56.644
<v Speaker 0>Once we have this

00:25:57.125 --> 00:25:59.525
<v Speaker 0>here, which provides the packet integration

00:25:59.870 --> 00:26:02.110
<v Speaker 0>cluster and control plane. We can enter a

00:26:02.110 --> 00:26:04.270
<v Speaker 0>copy to create a cluster and there may

00:26:04.270 --> 00:26:05.950
<v Speaker 0>be a helper to encapsulate this but for

00:26:05.950 --> 00:26:07.470
<v Speaker 0>now it's a two step process.

00:26:07.710 --> 00:26:09.870
<v Speaker 0>So here we say copy create cluster, we

00:26:09.870 --> 00:26:11.790
<v Speaker 0>provide the name of the cluster, the Kubernetes

00:26:11.790 --> 00:26:12.190
<v Speaker 0>version,

00:26:12.615 --> 00:26:14.534
<v Speaker 0>We can tell it which

00:26:15.415 --> 00:26:17.575
<v Speaker 0>pod and service side are to use and

00:26:17.575 --> 00:26:19.415
<v Speaker 0>then we pass in our cluster and our

00:26:19.415 --> 00:26:21.095
<v Speaker 0>control plane that we got previously.

00:26:21.735 --> 00:26:24.535
<v Speaker 0>And because we're using the render to YAML

00:26:24.535 --> 00:26:26.054
<v Speaker 0>as part of the provider

00:26:26.295 --> 00:26:27.495
<v Speaker 0>from the CLI,

00:26:28.220 --> 00:26:30.380
<v Speaker 0>I can come into my example repository.

00:26:30.940 --> 00:26:32.299
<v Speaker 0>Run Pulumi up.

00:26:33.180 --> 00:26:34.940
<v Speaker 0>Let's just call this a new stack.

00:26:40.620 --> 00:26:41.995
<v Speaker 0>And this will just take a second, but

00:26:41.995 --> 00:26:44.075
<v Speaker 0>it's gonna fill a directory called rendered YAML

00:26:44.075 --> 00:26:46.475
<v Speaker 0>with the YAML that I need to apply

00:26:46.475 --> 00:26:47.275
<v Speaker 0>to my cluster.

00:27:05.480 --> 00:27:08.200
<v Speaker 0>And there is. We pop open Rider Jamo,

00:27:08.200 --> 00:27:11.160
<v Speaker 0>the manifests. We can see we have a

00:27:11.160 --> 00:27:14.135
<v Speaker 0>cluster API cluster definition with our configuration that

00:27:14.135 --> 00:27:15.815
<v Speaker 0>points to a packet cluster and a packet

00:27:15.815 --> 00:27:17.095
<v Speaker 0>control

00:27:17.095 --> 00:27:17.815
<v Speaker 0>plane.

00:27:17.895 --> 00:27:19.175
<v Speaker 0>And then we can scroll down this list

00:27:19.175 --> 00:27:20.054
<v Speaker 0>a little bit more.

00:27:21.495 --> 00:27:24.615
<v Speaker 0>Let's see. We have our machine templates. We

00:27:24.615 --> 00:27:25.735
<v Speaker 0>can see that we're running a bunch of

00:27:25.735 --> 00:27:27.895
<v Speaker 0>twenty ten. We have our machine type

00:27:28.490 --> 00:27:29.210
<v Speaker 0>and

00:27:29.370 --> 00:27:30.890
<v Speaker 0>we have our packet clusters. So you can

00:27:30.890 --> 00:27:32.970
<v Speaker 0>see this is a really easy way to

00:27:32.970 --> 00:27:34.570
<v Speaker 0>work with the Cluster API

00:27:34.570 --> 00:27:37.130
<v Speaker 0>as code. Hopefully it providing the promise of

00:27:37.130 --> 00:27:39.610
<v Speaker 0>flexibility, composability and good ergonomics.

00:27:43.934 --> 00:27:45.134
<v Speaker 0>Okay. So

00:27:45.455 --> 00:27:47.614
<v Speaker 0>what are the next steps for

00:27:47.855 --> 00:27:48.974
<v Speaker 0>this project?

00:27:51.695 --> 00:27:54.014
<v Speaker 0>So more providers are coming soon. And by

00:27:54.014 --> 00:27:55.695
<v Speaker 0>the time this talk is available to you,

00:27:55.695 --> 00:27:58.230
<v Speaker 0>there will be types for AWS Azure and

00:27:58.230 --> 00:28:00.550
<v Speaker 0>Google and a few others available within the

00:28:00.550 --> 00:28:03.270
<v Speaker 0>repository. So you can begin to use this

00:28:03.270 --> 00:28:05.990
<v Speaker 0>library to deploy cluster APIs across all of

00:28:05.990 --> 00:28:07.830
<v Speaker 0>those providers using code.

00:28:08.390 --> 00:28:09.750
<v Speaker 0>However, I wanna be able to

00:28:10.414 --> 00:28:12.895
<v Speaker 0>provide the same level of abstractions across all

00:28:12.895 --> 00:28:14.335
<v Speaker 0>the other providers and I will be reaching

00:28:14.335 --> 00:28:15.934
<v Speaker 0>out to people and friends that I have

00:28:15.934 --> 00:28:17.615
<v Speaker 0>across those other providers to see what we

00:28:17.615 --> 00:28:18.975
<v Speaker 0>can do and collaborate together.

00:28:19.615 --> 00:28:21.615
<v Speaker 0>I wanna see more abstractions on top of

00:28:21.615 --> 00:28:23.775
<v Speaker 0>this, you know, this API is still very

00:28:23.775 --> 00:28:27.110
<v Speaker 0>much being defined through my own personal usage

00:28:27.110 --> 00:28:28.790
<v Speaker 0>and I would like to encourage other people

00:28:28.790 --> 00:28:30.230
<v Speaker 0>to give it a go and see how

00:28:30.230 --> 00:28:32.070
<v Speaker 0>clean we can get this and how simple

00:28:32.070 --> 00:28:34.310
<v Speaker 0>we can make Cluster API for the end

00:28:34.310 --> 00:28:34.870
<v Speaker 0>user.

00:28:35.190 --> 00:28:36.710
<v Speaker 0>I also want to see more support for

00:28:36.710 --> 00:28:39.405
<v Speaker 0>more images across providers and more operating systems,

00:28:39.405 --> 00:28:42.205
<v Speaker 0>more container run times, more CNI implementations

00:28:42.285 --> 00:28:45.005
<v Speaker 0>and all that driven through resources as well.

00:28:45.005 --> 00:28:47.245
<v Speaker 0>Lots of lots of room for people to

00:28:47.245 --> 00:28:48.845
<v Speaker 0>come and contribute and help out with this

00:28:48.845 --> 00:28:49.805
<v Speaker 0>project as well.

00:28:50.605 --> 00:28:52.365
<v Speaker 0>Thank you very much for joining me today.

00:28:52.525 --> 00:28:55.200
<v Speaker 0>I hope this library will help commoditize

00:28:55.200 --> 00:28:57.840
<v Speaker 0>cluster API for the end user across all

00:28:57.840 --> 00:28:59.520
<v Speaker 0>of the cloud providers.

00:28:59.680 --> 00:29:06.799
<v Speaker 0>You can find a code at github.com/rawcode/preliminary-kubernetes-cluster-API.

00:29:07.520 --> 00:29:08.400
<v Speaker 0>That's pretty soon.
