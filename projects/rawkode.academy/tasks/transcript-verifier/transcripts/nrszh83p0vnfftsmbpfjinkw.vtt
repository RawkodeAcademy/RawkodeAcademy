WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 03c86259-9da0-4675-99f3-23295948c7c7
Created: 2025-04-29T18:38:38.042Z
Duration: 3447.4731
Channels: 1

00:01:06.174 --> 00:01:06.895
<v Speaker 0>Hello.

00:01:07.375 --> 00:01:11.295
<v Speaker 0>Welcome to today's episode on Rawkode Academy. I

00:01:11.295 --> 00:01:12.735
<v Speaker 0>wonder how many times I'm gonna mess that

00:01:12.735 --> 00:01:15.055
<v Speaker 0>up over the next week, but welcome.

00:01:15.775 --> 00:01:17.935
<v Speaker 0>Today, we are continuing

00:01:17.935 --> 00:01:20.370
<v Speaker 0>our journey with Rust.

00:01:20.530 --> 00:01:23.250
<v Speaker 0>We're gonna dive into one of Rust's more

00:01:23.250 --> 00:01:24.610
<v Speaker 0>unique features,

00:01:25.010 --> 00:01:27.490
<v Speaker 0>but also one of its most understood, especially

00:01:27.490 --> 00:01:28.370
<v Speaker 0>by me,

00:01:28.770 --> 00:01:30.770
<v Speaker 0>and problem domains when it comes to learning

00:01:30.770 --> 00:01:33.615
<v Speaker 0>Rust. So before we get started, a little

00:01:33.615 --> 00:01:34.575
<v Speaker 0>bit of housekeeping.

00:01:35.215 --> 00:01:38.255
<v Speaker 0>First and foremost, if you wanna chat, drop

00:01:38.255 --> 00:01:40.575
<v Speaker 0>as much comments as you want into

00:01:40.575 --> 00:01:42.335
<v Speaker 0>YouTube's comments. We will do our best to

00:01:42.335 --> 00:01:43.535
<v Speaker 0>get them on the screen. If you have

00:01:43.535 --> 00:01:44.975
<v Speaker 0>any questions, we'll do our best to answer

00:01:44.975 --> 00:01:46.815
<v Speaker 0>them. In general, just let us know how

00:01:46.815 --> 00:01:48.415
<v Speaker 0>you're getting on and how we can help.

00:01:49.110 --> 00:01:51.030
<v Speaker 0>If you're not watching live, the best place

00:01:51.030 --> 00:01:53.110
<v Speaker 0>to ask questions or join a conversation is

00:01:53.110 --> 00:01:55.110
<v Speaker 0>on the Discord. So that is available at

00:01:55.110 --> 00:01:56.390
<v Speaker 0>Rawkode.chat.

00:01:56.390 --> 00:01:58.310
<v Speaker 0>You can come in there, join anytime, and

00:01:58.310 --> 00:01:59.510
<v Speaker 0>ask any questions.

00:02:00.390 --> 00:02:03.030
<v Speaker 0>Also, since the rebrand to the Rawkode Academy,

00:02:03.030 --> 00:02:05.115
<v Speaker 0>we now have membership options available.

00:02:05.435 --> 00:02:07.355
<v Speaker 0>You can join for a very tiny, tiny,

00:02:07.355 --> 00:02:09.835
<v Speaker 0>tiny, tiny fee, and it just gets my

00:02:09.835 --> 00:02:12.075
<v Speaker 0>eternal gratitude and support. So thank you to

00:02:12.075 --> 00:02:13.675
<v Speaker 0>the members that have done that already.

00:02:14.075 --> 00:02:15.515
<v Speaker 0>Appreciate your support.

00:02:15.915 --> 00:02:17.115
<v Speaker 0>And, of course, if you don't wanna do

00:02:17.115 --> 00:02:20.555
<v Speaker 0>that, that's fine, but please subscribe and please

00:02:20.160 --> 00:02:22.400
<v Speaker 0>click the thumbs up button on the video.

00:02:22.400 --> 00:02:24.800
<v Speaker 0>This will help other people find this content.

00:02:24.800 --> 00:02:27.520
<v Speaker 0>And today's episode is really important because this

00:02:27.520 --> 00:02:28.720
<v Speaker 0>stuff is hard.

00:02:29.520 --> 00:02:31.280
<v Speaker 0>And because it's hard, I can't do this

00:02:31.280 --> 00:02:34.240
<v Speaker 0>alone. I am joined by my friend Anna.

00:02:34.240 --> 00:02:36.855
<v Speaker 0>Hey, Anna. How are you? Hi. I'm great.

00:02:36.855 --> 00:02:37.655
<v Speaker 1>How are you?

00:02:38.135 --> 00:02:39.735
<v Speaker 0>I'm very well. All the better for us

00:02:39.735 --> 00:02:42.855
<v Speaker 0>now being here covering this wonderful topic today.

00:02:43.655 --> 00:02:45.655
<v Speaker 0>Would you please do the honor of just

00:02:45.655 --> 00:02:47.895
<v Speaker 0>telling us who you are and please share

00:02:47.895 --> 00:02:49.655
<v Speaker 0>anything that you wish to with us and

00:02:49.655 --> 00:02:50.055
<v Speaker 0>the audience?

00:02:51.489 --> 00:02:53.970
<v Speaker 1>Gosh. I'm about a seven year Rust user

00:02:53.970 --> 00:02:56.930
<v Speaker 1>by now. Seven? So I've spent a lot

00:02:56.930 --> 00:02:59.330
<v Speaker 1>of years with the the Borrow Checker and

00:02:59.330 --> 00:03:00.530
<v Speaker 1>Lifetime. Still

00:03:00.930 --> 00:03:03.810
<v Speaker 1>get stumped sometime. Thankfully, the error messages are

00:03:03.810 --> 00:03:04.049
<v Speaker 1>good.

00:03:04.834 --> 00:03:07.635
<v Speaker 1>I live over in Victoria on the territory

00:03:07.715 --> 00:03:08.755
<v Speaker 1>in Canada.

00:03:08.995 --> 00:03:10.114
<v Speaker 1>This

00:03:10.114 --> 00:03:11.475
<v Speaker 1>is my dog over here.

00:03:12.515 --> 00:03:14.115
<v Speaker 1>For my work, I

00:03:15.235 --> 00:03:17.635
<v Speaker 1>basically create a toolkit that lets you write

00:03:17.635 --> 00:03:19.474
<v Speaker 1>Postgres extensions in Rust.

00:03:20.370 --> 00:03:21.330
<v Speaker 0>Awesome.

00:03:21.810 --> 00:03:22.530
<v Speaker 0>Yeah.

00:03:23.170 --> 00:03:25.970
<v Speaker 0>So you spent a lifetime learning lifetimes.

00:03:26.130 --> 00:03:27.490
<v Speaker 0>It it took me so long to hold

00:03:27.490 --> 00:03:29.090
<v Speaker 0>that in, but I'm I'm glad I got

00:03:29.090 --> 00:03:29.730
<v Speaker 0>it out.

00:03:30.370 --> 00:03:32.850
<v Speaker 1>I like it. So before I guess, I

00:03:32.850 --> 00:03:34.745
<v Speaker 0>mean, I can always just throw the the

00:03:34.745 --> 00:03:36.425
<v Speaker 0>the terminal up already, but why don't we

00:03:36.425 --> 00:03:38.105
<v Speaker 0>chat for just a little bit? Like,

00:03:39.625 --> 00:03:42.345
<v Speaker 0>Rust, I I don't think any other language

00:03:42.345 --> 00:03:45.385
<v Speaker 0>has this concept of a bottle checker and

00:03:45.385 --> 00:03:47.145
<v Speaker 0>lifetime. Is that right, or am I being

00:03:47.145 --> 00:03:47.945
<v Speaker 0>a little naive there?

00:03:48.660 --> 00:03:49.780
<v Speaker 1>I

00:03:49.780 --> 00:03:52.180
<v Speaker 1>think if you look at tooling that exists

00:03:52.180 --> 00:03:54.739
<v Speaker 1>in the C plus plus and C space

00:03:54.739 --> 00:03:56.660
<v Speaker 1>around static analysis,

00:03:56.739 --> 00:03:58.900
<v Speaker 1>a lot of them do very similar things

00:03:58.900 --> 00:04:01.220
<v Speaker 1>to what the Rust Borrowchecker

00:04:01.220 --> 00:04:02.819
<v Speaker 1>and Lifetime system give you.

00:04:04.165 --> 00:04:07.125
<v Speaker 1>Fundamentally, they they don't come with, like, clang,

00:04:07.125 --> 00:04:07.685
<v Speaker 1>though.

00:04:09.285 --> 00:04:10.005
<v Speaker 0>Okay.

00:04:11.605 --> 00:04:12.245
<v Speaker 0>And

00:04:13.605 --> 00:04:15.445
<v Speaker 0>you're gonna make this easy for me. Right?

00:04:16.110 --> 00:04:18.430
<v Speaker 1>I'm gonna try. I'm not gonna I'm not

00:04:18.430 --> 00:04:20.589
<v Speaker 1>gonna, like, stump you. I mean, I don't

00:04:20.589 --> 00:04:23.069
<v Speaker 0>often get worried except when I actually have

00:04:23.069 --> 00:04:25.789
<v Speaker 0>to show my own coding ability, in which

00:04:25.789 --> 00:04:27.150
<v Speaker 0>case I do get a little bit of

00:04:27.150 --> 00:04:28.909
<v Speaker 0>the fear. But I I I mean, I've

00:04:28.909 --> 00:04:31.069
<v Speaker 0>gotta say, I've been writing Rust now for,

00:04:31.895 --> 00:04:33.975
<v Speaker 0>I don't know, I I think nearly two

00:04:33.975 --> 00:04:36.535
<v Speaker 0>years and I I just seem to like

00:04:36.535 --> 00:04:37.255
<v Speaker 0>avoid

00:04:37.495 --> 00:04:39.495
<v Speaker 0>these these things as much as possible and

00:04:39.495 --> 00:04:41.655
<v Speaker 0>stick to writing really simple Rust code whenever

00:04:41.655 --> 00:04:43.495
<v Speaker 0>possible and that's worked really well for me.

00:04:43.590 --> 00:04:45.430
<v Speaker 0>I think in fact, I'd probably bug you

00:04:45.430 --> 00:04:46.949
<v Speaker 0>a lot now when I come across stuff

00:04:46.949 --> 00:04:49.430
<v Speaker 0>and I'm like, don't understand it. But I

00:04:49.750 --> 00:04:50.950
<v Speaker 0>mean, this stuff is

00:04:51.510 --> 00:04:54.229
<v Speaker 0>not exactly the I don't know. It's not

00:04:54.229 --> 00:04:56.470
<v Speaker 0>hard, but it's not easy either. Like I

00:04:56.470 --> 00:04:57.510
<v Speaker 0>think if you just

00:04:58.675 --> 00:05:00.515
<v Speaker 0>I'm hoping that if we just spend a

00:05:00.515 --> 00:05:02.515
<v Speaker 0>little bit of time and cover the parameters,

00:05:02.515 --> 00:05:03.955
<v Speaker 0>that this is just gonna click for me.

00:05:03.955 --> 00:05:05.395
<v Speaker 0>That's what I'm hoping. That's what I'm trying

00:05:05.395 --> 00:05:07.155
<v Speaker 0>to say. I'm hoping so too.

00:05:08.355 --> 00:05:08.835
<v Speaker 1>Know,

00:05:09.235 --> 00:05:11.475
<v Speaker 1>most of the Rust code I write is

00:05:11.130 --> 00:05:14.330
<v Speaker 1>extremely simple and, like, I call clone everywhere.

00:05:14.410 --> 00:05:14.730
<v Speaker 1>And it

00:05:15.610 --> 00:05:18.410
<v Speaker 1>you know, I feel shame sometimes, but, honestly,

00:05:18.410 --> 00:05:20.570
<v Speaker 1>it's not a big deal. Like, the the

00:05:20.570 --> 00:05:23.610
<v Speaker 1>cool thing about the Borrowchecker and Lifetime Systems

00:05:23.610 --> 00:05:25.130
<v Speaker 1>is they allow you to do a lot

00:05:25.130 --> 00:05:27.685
<v Speaker 1>of the deep subtle refinements that allow you

00:05:27.685 --> 00:05:28.485
<v Speaker 1>to process

00:05:28.885 --> 00:05:29.765
<v Speaker 1>terabytes

00:05:30.005 --> 00:05:31.605
<v Speaker 1>of code very quickly.

00:05:32.805 --> 00:05:34.725
<v Speaker 0>I've gotta be honest. I do I reach

00:05:34.725 --> 00:05:36.965
<v Speaker 0>for dot clone an awful lot in my

00:05:36.965 --> 00:05:38.565
<v Speaker 0>Rust code because I know it's just gonna

00:05:38.565 --> 00:05:40.645
<v Speaker 0>remove the error. And again, I'm I'm avoiding

00:05:41.640 --> 00:05:43.480
<v Speaker 0>having to learn that next thing that I

00:05:43.480 --> 00:05:45.000
<v Speaker 0>need to learn. Either that or if I

00:05:45.080 --> 00:05:46.280
<v Speaker 0>that's a lie. What I do first is

00:05:46.280 --> 00:05:47.720
<v Speaker 0>I add an ampersand, and if that doesn't

00:05:47.720 --> 00:05:48.760
<v Speaker 0>work, I do a clone.

00:05:49.240 --> 00:05:51.720
<v Speaker 0>And that is my entire knowledge of, like,

00:05:51.720 --> 00:05:53.480
<v Speaker 0>the borrow checker, really. I'm just like, oh,

00:05:53.480 --> 00:05:54.600
<v Speaker 0>is that gonna work? No. It's not gonna

00:05:54.600 --> 00:05:56.405
<v Speaker 0>work. And then it said they'll say, oh,

00:05:56.405 --> 00:05:58.965
<v Speaker 0>it doesn't implement copy. I'm like, why not?

00:05:59.685 --> 00:06:02.245
<v Speaker 0>And then I just try and no. It's

00:06:02.245 --> 00:06:04.005
<v Speaker 0>the oh, yeah. The clone doesn't work when

00:06:04.005 --> 00:06:05.365
<v Speaker 0>it doesn't implement copy.

00:06:05.525 --> 00:06:06.965
<v Speaker 0>And the ampersand doesn't work when it doesn't

00:06:06.965 --> 00:06:08.085
<v Speaker 0>implement something else. Anyway,

00:06:08.810 --> 00:06:10.490
<v Speaker 0>I am ruining

00:06:10.490 --> 00:06:12.810
<v Speaker 0>my description of this. We're gonna rely on

00:06:12.810 --> 00:06:15.289
<v Speaker 0>your knowledge for today. So When I'm writing

00:06:15.289 --> 00:06:17.449
<v Speaker 1>my Rust code, first I make it work,

00:06:17.449 --> 00:06:19.850
<v Speaker 1>which usually means throwing clone everywhere.

00:06:19.930 --> 00:06:21.690
<v Speaker 1>And then I make it right. And then

00:06:21.690 --> 00:06:23.050
<v Speaker 1>I worry about making it fast.

00:06:24.745 --> 00:06:26.425
<v Speaker 0>Well, I never have to ship code to

00:06:26.425 --> 00:06:28.265
<v Speaker 0>production because I'm a developer advocate, so I

00:06:28.265 --> 00:06:29.865
<v Speaker 0>don't care about the fast. But I would

00:06:29.865 --> 00:06:32.985
<v Speaker 0>definitely like to learn today how to make

00:06:32.985 --> 00:06:34.505
<v Speaker 0>my code at least a little bit more

00:06:34.505 --> 00:06:35.145
<v Speaker 0>right.

00:06:35.705 --> 00:06:39.129
<v Speaker 1>Yeah. Okay. Let's get my screen up. So

00:06:39.129 --> 00:06:41.370
<v Speaker 0>we're gonna start, and I think we'll probably

00:06:41.370 --> 00:06:43.849
<v Speaker 0>drift away from these relatively quickly and start

00:06:43.849 --> 00:06:47.289
<v Speaker 0>typing our own terrible Rust code. But the

00:06:47.289 --> 00:06:49.289
<v Speaker 0>Rustlings example are a really good way for

00:06:49.289 --> 00:06:50.969
<v Speaker 0>anyone watching that wants to learn a little

00:06:50.969 --> 00:06:51.610
<v Speaker 0>bit about Rust.

00:06:52.235 --> 00:06:54.315
<v Speaker 0>It has a whole bunch of exercises

00:06:54.315 --> 00:06:56.235
<v Speaker 0>that introduce you to some of the common

00:06:56.235 --> 00:06:56.795
<v Speaker 0>themes,

00:06:57.675 --> 00:07:00.955
<v Speaker 0>enums, functions, scenarios, modules, macros, etcetera. We're gonna

00:07:00.955 --> 00:07:01.675
<v Speaker 0>spend,

00:07:01.995 --> 00:07:03.355
<v Speaker 0>I don't know how long, but a little

00:07:03.355 --> 00:07:05.460
<v Speaker 0>bit of time on move semantics, and then

00:07:05.620 --> 00:07:08.260
<v Speaker 0>we'll dive into the other components of Rust

00:07:08.260 --> 00:07:09.220
<v Speaker 0>Odd ownership.

00:07:09.380 --> 00:07:11.940
<v Speaker 0>At least unless I've never looked at Rust

00:07:11.780 --> 00:07:14.740
<v Speaker 1>Rust You've never looked at Rust Odd. It's

00:07:14.740 --> 00:07:16.980
<v Speaker 0>because you've already got all the knowledge. Like

00:07:18.965 --> 00:07:20.485
<v Speaker 0>so yeah. Let's take a look at the

00:07:20.485 --> 00:07:21.365
<v Speaker 0>first example.

00:07:21.925 --> 00:07:23.525
<v Speaker 0>Like I said, I think we will veer

00:07:23.525 --> 00:07:25.365
<v Speaker 0>off and and type our own dot main

00:07:25.365 --> 00:07:27.045
<v Speaker 0>dot r s or or whatever and just

00:07:27.045 --> 00:07:29.525
<v Speaker 0>maybe run some code that way, but we'll

00:07:29.525 --> 00:07:31.205
<v Speaker 0>start with this. We'll see what I actually

00:07:31.205 --> 00:07:32.485
<v Speaker 0>don't know what it's gonna try and teach

00:07:32.485 --> 00:07:34.730
<v Speaker 0>us. I'm hoping that's the right stuff and

00:07:34.730 --> 00:07:36.090
<v Speaker 0>we'll just take it from there.

00:07:36.730 --> 00:07:37.370
<v Speaker 0>Now,

00:07:37.690 --> 00:07:39.210
<v Speaker 0>if I remember correctly,

00:07:39.210 --> 00:07:42.010
<v Speaker 0>a smarter person would have checked before going

00:07:42.010 --> 00:07:43.930
<v Speaker 0>live is that we can

00:07:44.890 --> 00:07:47.555
<v Speaker 0>remove the I am not done comment and

00:07:47.555 --> 00:07:50.275
<v Speaker 0>then run something on the command line and

00:07:50.275 --> 00:07:51.875
<v Speaker 0>it'll tell us if it's correct.

00:07:52.514 --> 00:07:54.435
<v Speaker 0>Seems to be the vape of Rustling.

00:07:55.955 --> 00:07:58.194
<v Speaker 0>And we've got our first bit of code

00:07:58.194 --> 00:08:00.035
<v Speaker 0>here. So what

00:08:01.715 --> 00:08:03.350
<v Speaker 0>is this doing?

00:08:05.349 --> 00:08:07.590
<v Speaker 1>So here we're here we're constructing a new

00:08:07.590 --> 00:08:08.630
<v Speaker 1>vector. Right?

00:08:09.430 --> 00:08:11.349
<v Speaker 1>So one of the first things you probably

00:08:11.349 --> 00:08:13.590
<v Speaker 1>encounter in Rust is you wanna make an

00:08:13.590 --> 00:08:15.909
<v Speaker 1>array of stuff or a list of stuff,

00:08:15.909 --> 00:08:18.705
<v Speaker 1>which usually, you know, in Python, you do

00:08:18.705 --> 00:08:20.065
<v Speaker 1>with your square brackets.

00:08:20.945 --> 00:08:23.825
<v Speaker 1>In Rust, we have those. They're called slices.

00:08:24.145 --> 00:08:26.225
<v Speaker 1>They are unowned,

00:08:26.384 --> 00:08:28.705
<v Speaker 1>which means you don't actually, like,

00:08:29.185 --> 00:08:30.705
<v Speaker 1>get to play with the array.

00:08:31.400 --> 00:08:33.960
<v Speaker 1>This is just a usually, they're pointers to

00:08:33.960 --> 00:08:34.679
<v Speaker 1>slices.

00:08:35.080 --> 00:08:38.280
<v Speaker 1>So vectors are actually owned arrays

00:08:38.440 --> 00:08:40.760
<v Speaker 1>or lists or whatever you want to call

00:08:40.760 --> 00:08:41.240
<v Speaker 1>them.

00:08:42.280 --> 00:08:44.760
<v Speaker 1>So in here, we're actually creating a heap

00:08:44.760 --> 00:08:45.800
<v Speaker 1>allocated

00:08:45.960 --> 00:08:47.505
<v Speaker 1>owned pointer

00:08:47.825 --> 00:08:51.264
<v Speaker 1>to this this memory buffer of at the

00:08:51.825 --> 00:08:53.505
<v Speaker 1>what are we filling it with? We're filling

00:08:53.505 --> 00:08:55.024
<v Speaker 1>it with I 30 twos.

00:08:55.985 --> 00:08:56.625
<v Speaker 0>Yes.

00:08:58.385 --> 00:08:59.425
<v Speaker 0>Okay.

00:08:59.584 --> 00:09:00.385
<v Speaker 0>Let's

00:09:01.600 --> 00:09:03.360
<v Speaker 0>Oh, I don't have Rust links.

00:09:06.079 --> 00:09:07.199
<v Speaker 0>Please stand by.

00:09:07.759 --> 00:09:09.519
<v Speaker 0>I mean, the Rust compeller doesn't take very

00:09:09.519 --> 00:09:11.360
<v Speaker 0>long, so this will be really fast.

00:09:11.680 --> 00:09:13.519
<v Speaker 1>Really? I think you're the first person I've

00:09:13.519 --> 00:09:15.600
<v Speaker 1>ever heard not complain about the compile time

00:09:15.600 --> 00:09:17.605
<v Speaker 1>of Rust. I was complaining about the compile

00:09:17.605 --> 00:09:18.725
<v Speaker 0>time of Rust. I think I was just

00:09:18.725 --> 00:09:20.965
<v Speaker 0>too subtle with my sarcastic under twins.

00:09:24.005 --> 00:09:26.085
<v Speaker 0>Oh, where's oh, am I gonna have to

00:09:26.085 --> 00:09:27.765
<v Speaker 0>look at the the read me?

00:09:28.325 --> 00:09:30.085
<v Speaker 0>I thought it was just cargo install.

00:09:31.900 --> 00:09:33.980
<v Speaker 0>I can't believe I removed it from last

00:09:33.980 --> 00:09:36.300
<v Speaker 0>time. There we go. That's what the curl

00:09:36.300 --> 00:09:39.500
<v Speaker 0>bash. Nothing ever happened badly from curl bash.

00:09:41.420 --> 00:09:43.020
<v Speaker 0>Don't judge me too much, Anna, please.

00:09:44.885 --> 00:09:45.925
<v Speaker 1>It's fine.

00:09:46.965 --> 00:09:49.045
<v Speaker 1>A curl bash wouldn't work on my machine

00:09:49.045 --> 00:09:51.285
<v Speaker 1>at all, so I'm kind of jealous.

00:09:52.245 --> 00:09:54.645
<v Speaker 0>Well, yeah, you've got to have derivations and

00:09:54.645 --> 00:09:57.205
<v Speaker 0>safety and protections and all of this other

00:09:57.205 --> 00:09:57.765
<v Speaker 0>stuff. Right?

00:09:58.560 --> 00:10:00.640
<v Speaker 1>Yeah. I don't have a bin bash.

00:10:03.200 --> 00:10:04.320
<v Speaker 0>Does

00:10:04.320 --> 00:10:06.400
<v Speaker 0>an external chip of, like, fake

00:10:06.960 --> 00:10:09.120
<v Speaker 0>ones that link to something else, do I

00:10:09.120 --> 00:10:11.200
<v Speaker 0>recall correctly, to try and make it sometimes

00:10:11.200 --> 00:10:11.520
<v Speaker 0>work?

00:10:12.245 --> 00:10:14.085
<v Speaker 1>Well, idiomatically,

00:10:14.165 --> 00:10:16.885
<v Speaker 1>your bash script should be calling user bin

00:10:16.885 --> 00:10:19.125
<v Speaker 1>n. Yeah. User bin n. Yeah. So

00:10:20.325 --> 00:10:22.405
<v Speaker 1>that's what NextOS supports.

00:10:23.125 --> 00:10:23.845
<v Speaker 0>That makes sense.

00:10:24.700 --> 00:10:25.420
<v Speaker 1>Yeah.

00:10:25.980 --> 00:10:28.300
<v Speaker 0>Alright. Well, it's actually gone a lot quicker

00:10:28.300 --> 00:10:30.779
<v Speaker 0>than I expected, which is which is good.

00:10:30.779 --> 00:10:32.380
<v Speaker 0>It's only got a few more packages left

00:10:32.380 --> 00:10:35.500
<v Speaker 0>to build. And then I'm assuming and I

00:10:35.500 --> 00:10:38.940
<v Speaker 0>should again know the run Rustling's

00:10:37.935 --> 00:10:39.695
<v Speaker 0>move semantics one and it should tell us

00:10:39.695 --> 00:10:41.055
<v Speaker 0>that it's failing. I don't think we need

00:10:41.055 --> 00:10:43.535
<v Speaker 0>the hint. We'll tell it to try and

00:10:43.535 --> 00:10:46.575
<v Speaker 0>run it. And normally what it does, it'll

00:10:46.575 --> 00:10:48.095
<v Speaker 0>give us an error message and then that'll

00:10:48.095 --> 00:10:49.855
<v Speaker 0>tell us what it actually wants us to

00:10:49.855 --> 00:10:50.015
<v Speaker 0>do.

00:10:53.430 --> 00:10:57.029
<v Speaker 0>Looking at it, I'm assuming the challenge here

00:10:57.029 --> 00:10:58.070
<v Speaker 0>is gonna be

00:10:59.029 --> 00:10:59.750
<v Speaker 0>this.

00:11:01.029 --> 00:11:03.829
<v Speaker 0>This println vec will be

00:11:04.149 --> 00:11:06.615
<v Speaker 0>taking ownership or something and then the push

00:11:06.615 --> 00:11:08.295
<v Speaker 0>is gonna fail. I think that's what it's

00:11:08.295 --> 00:11:09.415
<v Speaker 0>gonna yell at me for.

00:11:09.895 --> 00:11:11.095
<v Speaker 0>Do you think I'm right or am I

00:11:11.095 --> 00:11:12.055
<v Speaker 0>wrong already?

00:11:15.255 --> 00:11:16.375
<v Speaker 1>I don't know.

00:11:18.775 --> 00:11:20.295
<v Speaker 0>Let's I'm looking at it and I'm like,

00:11:20.280 --> 00:11:22.120
<v Speaker 0>okay, we've got the failed vac,

00:11:22.520 --> 00:11:24.040
<v Speaker 0>return the vector.

00:11:24.840 --> 00:11:27.080
<v Speaker 1>So so what's the exercise here? Because I

00:11:27.080 --> 00:11:28.920
<v Speaker 1>feel like this might compile.

00:11:30.680 --> 00:11:32.920
<v Speaker 0>Well, let's just run it and see. So

00:11:32.920 --> 00:11:33.720
<v Speaker 0>we don't need to

00:11:34.515 --> 00:11:36.115
<v Speaker 0>we can run Rustling.

00:11:36.915 --> 00:11:38.675
<v Speaker 0>Move semantic

00:11:39.155 --> 00:11:39.715
<v Speaker 0>one.

00:11:40.995 --> 00:11:42.435
<v Speaker 0>Oh, what's the thing?

00:11:43.795 --> 00:11:46.195
<v Speaker 1>It was in the top of the

00:11:47.410 --> 00:11:49.890
<v Speaker 1>code file. It was in top hint, and

00:11:49.890 --> 00:11:51.650
<v Speaker 0>I don't think we need the hint yet.

00:11:51.650 --> 00:11:54.850
<v Speaker 0>Oh, yeah. Run my exercise. Okay. So press

00:11:54.850 --> 00:11:56.130
<v Speaker 0>things. Run.

00:11:58.450 --> 00:12:00.130
<v Speaker 1>Oh, you type like me.

00:12:01.890 --> 00:12:02.610
<v Speaker 0>What you mean?

00:12:04.584 --> 00:12:07.464
<v Speaker 1>You also mistype all the time. Oh, yeah.

00:12:07.464 --> 00:12:09.865
<v Speaker 0>That that's just the rule of being on

00:12:09.865 --> 00:12:11.065
<v Speaker 0>a a livestream.

00:12:11.144 --> 00:12:14.265
<v Speaker 0>Yeah. Rustler, I'm not running a lot. Yeah.

00:12:14.505 --> 00:12:16.090
<v Speaker 0>Because this is the fresh colon of the

00:12:16.090 --> 00:12:17.850
<v Speaker 0>Rustlings, and I'm not gonna walk through all

00:12:17.850 --> 00:12:20.090
<v Speaker 0>of them to get to this stage.

00:12:20.810 --> 00:12:22.810
<v Speaker 0>We'll just use one. But we have our

00:12:22.810 --> 00:12:23.690
<v Speaker 0>error message.

00:12:24.010 --> 00:12:24.490
<v Speaker 0>Yeah.

00:12:26.010 --> 00:12:28.410
<v Speaker 1>So you might notice if you haven't looked

00:12:28.410 --> 00:12:31.305
<v Speaker 1>at Rust before, which you have, so that

00:12:31.305 --> 00:12:32.824
<v Speaker 1>the error messages are quite

00:12:33.305 --> 00:12:34.745
<v Speaker 1>verbose and good.

00:12:35.704 --> 00:12:38.345
<v Speaker 1>It does explain what's happening. So we have

00:12:38.345 --> 00:12:38.824
<v Speaker 1>a

00:12:39.384 --> 00:12:42.345
<v Speaker 1>we've got this VEC one that we've declared

00:12:42.345 --> 00:12:44.824
<v Speaker 1>with a let binding, and it's not mutable.

00:12:45.064 --> 00:12:47.390
<v Speaker 1>And that's because mutability is opt in in

00:12:47.390 --> 00:12:49.710
<v Speaker 1>Rust, which is a very nice thing.

00:12:51.710 --> 00:12:52.510
<v Speaker 0>Okay.

00:12:53.150 --> 00:12:55.550
<v Speaker 0>So our first error message is just telling

00:12:55.550 --> 00:12:57.150
<v Speaker 0>us that we need to make this mutable.

00:13:03.245 --> 00:13:04.445
<v Speaker 0>Done. Is that it?

00:13:05.965 --> 00:13:06.925
<v Speaker 1>Let's see.

00:13:10.525 --> 00:13:12.440
<v Speaker 0>Well, that was easy. So you were almost

00:13:12.440 --> 00:13:13.800
<v Speaker 0>right that it would compel if we just

00:13:13.800 --> 00:13:15.800
<v Speaker 0>missed immutability. And I'm over here trying to

00:13:15.800 --> 00:13:18.760
<v Speaker 0>overthink the ownership of this vector going into

00:13:18.760 --> 00:13:20.840
<v Speaker 0>the print function or the print max. So

00:13:20.840 --> 00:13:22.520
<v Speaker 1>why do you think we didn't have an

00:13:22.520 --> 00:13:25.400
<v Speaker 1>ownership problem here? Just because this fill vac

00:13:25.400 --> 00:13:27.480
<v Speaker 1>one

00:13:26.345 --> 00:13:29.225
<v Speaker 1>takes a vector and also returns it. Right?

00:13:31.465 --> 00:13:32.665
<v Speaker 0>Which line? Sorry?

00:13:33.145 --> 00:13:35.225
<v Speaker 1>So if you look at line 18,

00:13:35.225 --> 00:13:36.665
<v Speaker 1>the fillvec function

00:13:36.905 --> 00:13:37.545
<v Speaker 0>Mhmm.

00:13:37.865 --> 00:13:40.425
<v Speaker 1>It takes in an immutable vector, and it

00:13:40.425 --> 00:13:42.800
<v Speaker 1>returns a vector. Right? But you see at

00:13:42.800 --> 00:13:45.280
<v Speaker 1>line 19, we actually can opt in to

00:13:45.280 --> 00:13:46.560
<v Speaker 1>mutability there.

00:13:48.720 --> 00:13:49.600
<v Speaker 0>Oh.

00:13:50.720 --> 00:13:52.400
<v Speaker 0>Oh, yeah. Because okay. So we're getting a

00:13:52.400 --> 00:13:55.040
<v Speaker 0>vector back here that isn't mutable,

00:13:55.040 --> 00:13:57.360
<v Speaker 0>but we can actually tell it to become

00:13:56.945 --> 00:13:59.665
<v Speaker 0>mutable. So we're like, what what's happening here?

00:14:00.865 --> 00:14:01.985
<v Speaker 1>Yeah. So

00:14:02.945 --> 00:14:04.865
<v Speaker 1>two different things are happening. Right?

00:14:05.345 --> 00:14:05.904
<v Speaker 1>So

00:14:06.545 --> 00:14:08.705
<v Speaker 1>to me to push onto a vector,

00:14:09.265 --> 00:14:10.705
<v Speaker 1>you you need to mutate it.

00:14:12.540 --> 00:14:15.180
<v Speaker 1>So when we made vec zero on line

00:14:15.180 --> 00:14:15.900
<v Speaker 1>seven,

00:14:16.220 --> 00:14:18.460
<v Speaker 1>and we passed that into the function on

00:14:18.460 --> 00:14:19.420
<v Speaker 1>line nine,

00:14:20.460 --> 00:14:22.780
<v Speaker 1>so we created it as immutable,

00:14:22.780 --> 00:14:25.420
<v Speaker 1>and it arrived into the fillvec function

00:14:25.665 --> 00:14:27.665
<v Speaker 1>as an immutable vector.

00:14:29.024 --> 00:14:31.985
<v Speaker 1>And on line 19, we opted into mutability

00:14:31.985 --> 00:14:34.384
<v Speaker 1>on it, and then we returned it back

00:14:34.384 --> 00:14:35.825
<v Speaker 1>on line 25.

00:14:36.545 --> 00:14:38.785
<v Speaker 1>So you can see for line 21 through

00:14:38.785 --> 00:14:40.545
<v Speaker 1>23, we had mutability.

00:14:42.250 --> 00:14:43.130
<v Speaker 1>Oh.

00:14:43.690 --> 00:14:44.410
<v Speaker 1>Right?

00:14:44.650 --> 00:14:47.529
<v Speaker 1>But before you added that mute on line

00:14:47.529 --> 00:14:48.250
<v Speaker 1>nine,

00:14:48.650 --> 00:14:51.850
<v Speaker 1>that mutability did not persist past the function

00:14:51.850 --> 00:14:53.130
<v Speaker 1>return. Right?

00:14:54.810 --> 00:14:55.210
<v Speaker 0>Yes.

00:14:56.925 --> 00:14:59.245
<v Speaker 1>That's I think that's the lesson here.

00:14:59.565 --> 00:15:02.125
<v Speaker 0>So I'm curious about this line here. Right?

00:15:02.125 --> 00:15:04.605
<v Speaker 0>Where we're doing move back equals back. Like,

00:15:05.405 --> 00:15:07.885
<v Speaker 0>it's still just one slice in memory. Right?

00:15:07.885 --> 00:15:10.125
<v Speaker 0>There's no copy. There's no cloning. This is

00:15:10.125 --> 00:15:12.260
<v Speaker 0>just that we take a mutable reference to

00:15:12.260 --> 00:15:12.820
<v Speaker 0>it.

00:15:13.540 --> 00:15:15.860
<v Speaker 1>Yeah. This is all static. Like, the mute

00:15:15.860 --> 00:15:17.860
<v Speaker 1>goes away at compile time.

00:15:18.660 --> 00:15:20.500
<v Speaker 0>Can I do that more than once?

00:15:21.060 --> 00:15:22.100
<v Speaker 1>Yeah. You can.

00:15:24.500 --> 00:15:26.500
<v Speaker 0>Does that mean there's two mutable references to

00:15:26.500 --> 00:15:27.885
<v Speaker 0>the same slice?

00:15:28.605 --> 00:15:30.445
<v Speaker 1>This one might not work.

00:15:34.045 --> 00:15:36.524
<v Speaker 1>Yeah. Okay. See, that that one won't work.

00:15:37.725 --> 00:15:40.340
<v Speaker 1>But the first with just one, that's just

00:15:40.340 --> 00:15:43.620
<v Speaker 1>basically it's called variable shadowing.

00:15:44.740 --> 00:15:47.220
<v Speaker 0>Okay. So because nothing has

00:15:47.620 --> 00:15:50.500
<v Speaker 0>mutable ownership of the vector, we can just

00:15:50.500 --> 00:15:52.900
<v Speaker 0>take that here, but then we lose the

00:15:52.900 --> 00:15:54.660
<v Speaker 0>ability to do that again here.

00:15:55.060 --> 00:15:57.275
<v Speaker 0>Now Yeah. We return.

00:15:57.675 --> 00:16:00.154
<v Speaker 1>That teaches us one of the fundamental ownership

00:16:00.154 --> 00:16:02.154
<v Speaker 1>rules of Rust is that there can only

00:16:02.154 --> 00:16:03.675
<v Speaker 1>be one owner

00:16:04.154 --> 00:16:06.475
<v Speaker 1>of anything. There are rules?

00:16:07.035 --> 00:16:07.435
<v Speaker 1>Yes.

00:16:09.530 --> 00:16:11.370
<v Speaker 0>Okay. So there can only ever be one

00:16:11.370 --> 00:16:14.090
<v Speaker 0>owner. There's three fundamental rules to ownership in

00:16:14.090 --> 00:16:15.210
<v Speaker 1>Rust that

00:16:15.290 --> 00:16:17.210
<v Speaker 1>everything only has one owner.

00:16:18.730 --> 00:16:21.210
<v Speaker 1>There that owner can give out either

00:16:22.154 --> 00:16:24.154
<v Speaker 1>one mutable reference

00:16:24.235 --> 00:16:25.275
<v Speaker 1>to the thing

00:16:25.755 --> 00:16:29.595
<v Speaker 1>or any number of immutable references to the

00:16:29.595 --> 00:16:31.275
<v Speaker 1>thing at any given time.

00:16:33.995 --> 00:16:35.675
<v Speaker 0>Okay. Got it. That makes sense.

00:16:36.800 --> 00:16:38.160
<v Speaker 0>Yeah. So I think

00:16:38.720 --> 00:16:41.040
<v Speaker 0>I understand. Okay. So I understand this. So

00:16:41.040 --> 00:16:42.560
<v Speaker 0>this is shadowing

00:16:42.560 --> 00:16:44.800
<v Speaker 0>the return drops immutability,

00:16:44.880 --> 00:16:46.640
<v Speaker 0>but then we can pick it back up

00:16:46.640 --> 00:16:47.200
<v Speaker 0>here.

00:16:47.680 --> 00:16:50.375
<v Speaker 1>Right. Okay. And is that just something we're

00:16:50.375 --> 00:16:52.055
<v Speaker 0>supposed to know then? Like, when we have

00:16:52.055 --> 00:16:54.134
<v Speaker 0>a function and we take mutable ownership of

00:16:54.134 --> 00:16:55.894
<v Speaker 0>something and then we return

00:16:56.535 --> 00:16:58.774
<v Speaker 1>So if if you think about this modify

00:16:58.774 --> 00:17:00.375
<v Speaker 0>this? Could I could I tell it it

00:17:00.375 --> 00:17:03.254
<v Speaker 0>returns a mutable reference? No. Yeah. No. That

00:17:03.254 --> 00:17:04.775
<v Speaker 1>won't work because

00:17:05.280 --> 00:17:08.160
<v Speaker 1>one of the thing like, the fundamental ideas

00:17:08.960 --> 00:17:11.119
<v Speaker 1>of Rust that I really appreciate is

00:17:11.680 --> 00:17:14.319
<v Speaker 1>the code you're looking at is very localized.

00:17:14.320 --> 00:17:16.240
<v Speaker 1>So if I'm looking at a function,

00:17:16.960 --> 00:17:18.400
<v Speaker 1>the only thing that I'm looking at in

00:17:18.400 --> 00:17:20.474
<v Speaker 1>that function is what's gonna affect the function.

00:17:20.474 --> 00:17:22.234
<v Speaker 1>So the signature tells me

00:17:22.635 --> 00:17:24.555
<v Speaker 1>that it takes in a vector and it

00:17:24.555 --> 00:17:25.755
<v Speaker 1>returns a vector.

00:17:26.315 --> 00:17:28.315
<v Speaker 1>But the return type,

00:17:28.315 --> 00:17:31.275
<v Speaker 1>it doesn't have, like, mutability or anything

00:17:31.275 --> 00:17:32.554
<v Speaker 1>because that would

00:17:33.035 --> 00:17:35.115
<v Speaker 1>change how main was working.

00:17:36.130 --> 00:17:38.210
<v Speaker 1>And that would make it very confusing to

00:17:38.210 --> 00:17:39.010
<v Speaker 1>understand

00:17:39.010 --> 00:17:40.529
<v Speaker 1>for the programmer. Right?

00:17:41.730 --> 00:17:43.090
<v Speaker 0>Right. Got it.

00:17:43.410 --> 00:17:44.370
<v Speaker 1>If

00:17:44.370 --> 00:17:47.890
<v Speaker 1>you do want structures with mutability inside of

00:17:47.890 --> 00:17:51.835
<v Speaker 1>them without requiring your users to explicitly say

00:17:51.835 --> 00:17:52.634
<v Speaker 1>mute,

00:17:53.115 --> 00:17:54.955
<v Speaker 1>you can use techniques such as a cell

00:17:54.955 --> 00:17:55.754
<v Speaker 1>for that.

00:17:57.195 --> 00:17:58.154
<v Speaker 0>Yeah. Again,

00:17:58.715 --> 00:18:00.475
<v Speaker 0>that's one of those other constructs of Rust

00:18:00.475 --> 00:18:01.674
<v Speaker 0>I have avoided

00:18:01.914 --> 00:18:03.434
<v Speaker 0>as much as possible.

00:18:03.515 --> 00:18:05.610
<v Speaker 0>So, I mean, if we need to delve

00:18:05.610 --> 00:18:07.850
<v Speaker 0>into that today, then we definitely can. But

00:18:07.850 --> 00:18:09.050
<v Speaker 0>I I don't we don't need to for

00:18:09.050 --> 00:18:10.570
<v Speaker 0>this example right now. Right?

00:18:10.970 --> 00:18:13.210
<v Speaker 1>No. Okay.

00:18:14.890 --> 00:18:17.050
<v Speaker 0>That really, really helps. I've gotta say it

00:18:17.050 --> 00:18:17.690
<v Speaker 0>like that.

00:18:18.955 --> 00:18:20.875
<v Speaker 0>I had I had seen lines like this

00:18:20.875 --> 00:18:23.435
<v Speaker 0>before. I had just kind of ignored them.

00:18:23.435 --> 00:18:24.955
<v Speaker 0>I hadn't really understand how they worked, but

00:18:24.955 --> 00:18:27.195
<v Speaker 0>now I understand that, you know, we can

00:18:27.195 --> 00:18:29.035
<v Speaker 0>have that one owner. It takes it and

00:18:29.035 --> 00:18:32.075
<v Speaker 0>then releases it. So If you took this

00:18:31.730 --> 00:18:32.370
<v Speaker 1>code

00:18:32.530 --> 00:18:34.610
<v Speaker 1>and you moved it into the main function

00:18:34.610 --> 00:18:36.690
<v Speaker 1>instead of the fillVec thing,

00:18:37.090 --> 00:18:39.650
<v Speaker 1>and you did let mute VAC equal VAC

00:18:39.650 --> 00:18:41.410
<v Speaker 1>and then did your pushes, and then you

00:18:41.410 --> 00:18:43.409
<v Speaker 1>went let VAC equal VAC again,

00:18:43.650 --> 00:18:45.650
<v Speaker 1>you could just temporarily

00:18:45.135 --> 00:18:47.855
<v Speaker 1>opt in to mutability in your main function.

00:18:48.255 --> 00:18:50.255
<v Speaker 1>This can be really handy when you're doing

00:18:50.255 --> 00:18:53.455
<v Speaker 1>fairly complicated things where you only want temporary

00:18:53.455 --> 00:18:54.255
<v Speaker 1>mutability

00:18:54.255 --> 00:18:56.575
<v Speaker 1>so that later in the function, you're not

00:18:56.575 --> 00:18:57.695
<v Speaker 1>worried about it.

00:18:59.340 --> 00:19:00.059
<v Speaker 0>Okay.

00:19:00.460 --> 00:19:01.259
<v Speaker 0>Awesome.

00:19:02.059 --> 00:19:03.259
<v Speaker 0>Let's move on

00:19:03.580 --> 00:19:05.340
<v Speaker 0>to move semantics

00:19:05.420 --> 00:19:05.980
<v Speaker 0>two.

00:19:08.620 --> 00:19:10.299
<v Speaker 0>Let's get the error message this time and

00:19:10.299 --> 00:19:11.500
<v Speaker 0>give ourselves a

00:19:12.274 --> 00:19:13.154
<v Speaker 0>hint.

00:19:14.674 --> 00:19:17.235
<v Speaker 0>Let's see what we got here. Oh, we

00:19:17.235 --> 00:19:19.794
<v Speaker 0>actually have a move now. Oh, there's that

00:19:19.794 --> 00:19:21.394
<v Speaker 0>thing that I see all the time. That's

00:19:21.394 --> 00:19:21.874
<v Speaker 0>the one.

00:19:24.434 --> 00:19:26.434
<v Speaker 0>Oh, my face is covering it. It says

00:19:26.434 --> 00:19:28.940
<v Speaker 0>does not implement the copy tree. So yeah,

00:19:28.940 --> 00:19:31.500
<v Speaker 0>that's what I'm very familiar with. So that

00:19:31.500 --> 00:19:32.940
<v Speaker 0>is on line

00:19:34.620 --> 00:19:37.420
<v Speaker 0>line 10 is the move and we're trying

00:19:37.420 --> 00:19:39.260
<v Speaker 0>to use it on 13. So

00:19:41.180 --> 00:19:42.060
<v Speaker 0>this code looks,

00:19:42.995 --> 00:19:44.355
<v Speaker 0>oh, yeah. This function is just pretty much

00:19:44.355 --> 00:19:46.675
<v Speaker 0>the same. Right? So Yeah. It's almost the

00:19:46.675 --> 00:19:48.435
<v Speaker 1>same as before, but you can see the

00:19:48.435 --> 00:19:50.995
<v Speaker 1>print that we're doing is trying to use

00:19:50.995 --> 00:19:53.555
<v Speaker 1>the vector that we created and then passed

00:19:53.555 --> 00:19:54.595
<v Speaker 1>into fill vac.

00:19:58.550 --> 00:19:59.270
<v Speaker 0>Are there

00:20:00.950 --> 00:20:02.549
<v Speaker 0>you mean the here?

00:20:03.030 --> 00:20:05.910
<v Speaker 1>Yeah. So we create vec zero on line

00:20:05.910 --> 00:20:06.710
<v Speaker 1>eight,

00:20:06.950 --> 00:20:10.230
<v Speaker 1>and then we we consume vec zero Ah,

00:20:10.230 --> 00:20:12.950
<v Speaker 0>right. In line 10, and we give it

00:20:12.465 --> 00:20:14.065
<v Speaker 1>to the filvec function,

00:20:14.544 --> 00:20:17.184
<v Speaker 1>what filvec returns is a possibly

00:20:17.345 --> 00:20:19.184
<v Speaker 1>a completely different vector.

00:20:20.465 --> 00:20:22.865
<v Speaker 1>So Okay. The fact that doesn't exist anymore.

00:20:22.865 --> 00:20:25.664
<v Speaker 0>Right? Right. Well, after line 10, we have

00:20:25.664 --> 00:20:28.550
<v Speaker 1>no guarantee that, yeah, it it's consumed. It's

00:20:28.550 --> 00:20:29.190
<v Speaker 1>moved.

00:20:29.510 --> 00:20:29.909
<v Speaker 1>So

00:20:31.350 --> 00:20:33.750
<v Speaker 1>I think one way we could fix this

00:20:33.750 --> 00:20:36.470
<v Speaker 1>is make fill back return

00:20:36.790 --> 00:20:38.789
<v Speaker 1>or accept a pointer,

00:20:39.190 --> 00:20:39.830
<v Speaker 1>like a reference.

00:20:40.845 --> 00:20:42.845
<v Speaker 1>So this is where you do your ampersand.

00:20:42.845 --> 00:20:43.404
<v Speaker 1>Right?

00:20:45.164 --> 00:20:47.645
<v Speaker 0>So we mark the type as a reference

00:20:47.645 --> 00:20:48.284
<v Speaker 0>here.

00:20:48.684 --> 00:20:50.525
<v Speaker 0>Yeah. Do we have to also tell it

00:20:50.525 --> 00:20:51.885
<v Speaker 0>to pass in a reference? Right.

00:20:52.860 --> 00:20:54.780
<v Speaker 1>And now this won't work. Right? Because we're

00:20:54.860 --> 00:20:56.299
<v Speaker 1>we've got an immutable

00:20:56.460 --> 00:20:57.260
<v Speaker 1>reference,

00:20:57.260 --> 00:20:58.620
<v Speaker 1>and we're gonna be trying to make it

00:20:58.620 --> 00:21:01.100
<v Speaker 1>mutable. So this is gonna give us problems.

00:21:01.100 --> 00:21:02.780
<v Speaker 1>So if we try and compile this, you'll

00:21:02.780 --> 00:21:03.980
<v Speaker 1>see a fun error message.

00:21:06.105 --> 00:21:08.425
<v Speaker 0>Alright. So we get expected a vac, and

00:21:08.425 --> 00:21:10.345
<v Speaker 0>we found reference to a vac.

00:21:10.825 --> 00:21:12.585
<v Speaker 1>Oh, this is not the error message I

00:21:12.585 --> 00:21:14.745
<v Speaker 1>was expecting, but it's also one.

00:21:15.305 --> 00:21:18.345
<v Speaker 1>So fundamentally here, like, if we go back

00:21:18.345 --> 00:21:18.985
<v Speaker 1>to the code,

00:21:22.750 --> 00:21:24.830
<v Speaker 1>if we're only taking in a reference to

00:21:24.830 --> 00:21:25.710
<v Speaker 1>a vector,

00:21:25.950 --> 00:21:27.870
<v Speaker 1>we can't return an owned vector.

00:21:29.870 --> 00:21:32.350
<v Speaker 0>So just make it a reference too? Right.

00:21:32.350 --> 00:21:34.030
<v Speaker 1>But this is still immutable

00:21:34.125 --> 00:21:36.285
<v Speaker 1>this whole time. So this is just it's

00:21:36.285 --> 00:21:37.485
<v Speaker 1>really not great.

00:21:40.365 --> 00:21:42.685
<v Speaker 1>Okay. See, this is giving us error that

00:21:42.685 --> 00:21:44.684
<v Speaker 1>you're behind a a normal

00:21:45.325 --> 00:21:46.445
<v Speaker 1>immutable reference.

00:21:48.590 --> 00:21:50.990
<v Speaker 0>Okay. So I'm assuming that the approach of

00:21:50.990 --> 00:21:53.390
<v Speaker 0>passing on a reference to is

00:21:53.390 --> 00:21:54.429
<v Speaker 0>potentially

00:21:55.470 --> 00:21:58.350
<v Speaker 0>the wrong path. I mean, should we Well,

00:21:58.350 --> 00:22:00.029
<v Speaker 1>I guess what we have to consider is

00:22:00.029 --> 00:22:02.575
<v Speaker 1>what's the intent here? Is the intent to

00:22:02.575 --> 00:22:04.014
<v Speaker 1>create a new vector

00:22:04.895 --> 00:22:06.815
<v Speaker 1>and return it, or is the intent to

00:22:06.815 --> 00:22:08.735
<v Speaker 1>fill up the vector provided?

00:22:11.455 --> 00:22:14.015
<v Speaker 1>Because I think if if we made fillvec

00:22:14.015 --> 00:22:15.775
<v Speaker 1>take a mutable reference

00:22:16.750 --> 00:22:18.590
<v Speaker 1>to this this collection,

00:22:19.390 --> 00:22:21.549
<v Speaker 1>then it it wouldn't need to return

00:22:21.630 --> 00:22:22.350
<v Speaker 1>a completely

00:22:22.670 --> 00:22:25.390
<v Speaker 1>new vector. Right? It could just mutate the

00:22:25.390 --> 00:22:26.029
<v Speaker 1>argument.

00:22:26.670 --> 00:22:29.629
<v Speaker 0>Okay. So we want it to be mutable.

00:22:30.190 --> 00:22:31.950
<v Speaker 1>Yeah. So we did this,

00:22:32.725 --> 00:22:34.485
<v Speaker 0>which means we have to update the signature

00:22:34.485 --> 00:22:35.044
<v Speaker 0>here.

00:22:35.605 --> 00:22:37.365
<v Speaker 1>Correct. And then we could get rid of

00:22:37.365 --> 00:22:38.565
<v Speaker 1>the return type.

00:22:40.085 --> 00:22:41.205
<v Speaker 0>Get rid of it?

00:22:42.565 --> 00:22:45.250
<v Speaker 0>Would you Sure. Why would that? This doesn't

00:22:45.250 --> 00:22:46.850
<v Speaker 0>need this. We don't need to shadow anymore,

00:22:46.850 --> 00:22:48.049
<v Speaker 0>right, if we have a We won't need

00:22:48.049 --> 00:22:50.369
<v Speaker 1>to do that either. Yeah. This is great.

00:22:50.690 --> 00:22:51.730
<v Speaker 0>Okay. Now

00:22:51.890 --> 00:22:53.249
<v Speaker 0>would we return

00:22:53.570 --> 00:22:55.970
<v Speaker 0>this or would we return the mutable reference

00:22:55.970 --> 00:22:56.290
<v Speaker 0>again?

00:22:56.895 --> 00:22:58.415
<v Speaker 1>Well, I don't think we need to return

00:22:58.415 --> 00:23:00.415
<v Speaker 1>anything. Right? If we're not passing in the

00:23:00.415 --> 00:23:02.174
<v Speaker 1>vector, we don't need to get it back.

00:23:03.215 --> 00:23:03.934
<v Speaker 0>Oh.

00:23:07.215 --> 00:23:08.095
<v Speaker 0>So that?

00:23:08.655 --> 00:23:10.335
<v Speaker 1>Yeah. I think that would work.

00:23:11.135 --> 00:23:12.735
<v Speaker 1>And then

00:23:12.390 --> 00:23:15.429
<v Speaker 1>do have we we forgot about the

00:23:16.310 --> 00:23:18.710
<v Speaker 0>Oh, the same one. Yeah. Line 10. Yeah.

00:23:19.030 --> 00:23:20.630
<v Speaker 1>So we need to change the VEC one

00:23:20.630 --> 00:23:21.830
<v Speaker 1>calls to VEC zero.

00:23:26.425 --> 00:23:27.065
<v Speaker 1>Yeah.

00:23:30.505 --> 00:23:32.505
<v Speaker 1>But I think that'll work for us.

00:23:34.505 --> 00:23:35.865
<v Speaker 1>Oh, jeez.

00:23:36.905 --> 00:23:39.945
<v Speaker 0>Alright. So we cannot back viral as mutable

00:23:40.105 --> 00:23:41.145
<v Speaker 0>on line 15.

00:23:41.520 --> 00:23:42.960
<v Speaker 0>So what happens here?

00:23:43.680 --> 00:23:47.279
<v Speaker 1>Well, we've created vec zero as an immutable,

00:23:47.280 --> 00:23:49.200
<v Speaker 1>and now we're actually trying to mutate it

00:23:49.200 --> 00:23:51.520
<v Speaker 1>twice, which is just it's a no no.

00:23:52.160 --> 00:23:54.799
<v Speaker 1>So we're gonna have to make the vec

00:23:54.880 --> 00:23:56.880
<v Speaker 1>zero immutable on line eight.

00:23:59.485 --> 00:24:01.405
<v Speaker 1>Right? And then we'll have a mutable vec

00:24:01.405 --> 00:24:05.245
<v Speaker 1>zero to pass a mutable reference into fillvec.

00:24:05.245 --> 00:24:06.605
<v Speaker 0>I mean, could I do

00:24:08.285 --> 00:24:10.445
<v Speaker 1>I don't think this will work, but try

00:24:10.445 --> 00:24:10.685
<v Speaker 1>it.

00:24:15.380 --> 00:24:16.659
<v Speaker 1>See, still

00:24:16.900 --> 00:24:18.340
<v Speaker 1>wants a mutable one.

00:24:19.700 --> 00:24:20.900
<v Speaker 0>Alright. Okay.

00:24:21.460 --> 00:24:22.580
<v Speaker 0>So

00:24:22.580 --> 00:24:24.659
<v Speaker 0>we make it mutable from the start.

00:24:25.060 --> 00:24:27.620
<v Speaker 0>Now if so let's just I don't know.

00:24:28.035 --> 00:24:29.155
<v Speaker 0>We've got a

00:24:29.475 --> 00:24:32.755
<v Speaker 0>mutable vector here. Right? So Right. I'm curious.

00:24:32.755 --> 00:24:33.475
<v Speaker 0>Do we still need

00:24:34.595 --> 00:24:36.515
<v Speaker 0>would that not be passing a mutable reference

00:24:36.515 --> 00:24:38.595
<v Speaker 0>though or does that make it Why don't

00:24:38.595 --> 00:24:40.195
<v Speaker 1>we why don't we try it? Come on.

00:24:40.350 --> 00:24:42.510
<v Speaker 1>Like, the compiler messages are great. We could

00:24:42.510 --> 00:24:43.230
<v Speaker 1>find out.

00:24:43.789 --> 00:24:44.590
<v Speaker 0>Okay. Let's

00:24:46.270 --> 00:24:48.030
<v Speaker 1>I think you will need it there, though.

00:24:48.030 --> 00:24:50.190
<v Speaker 0>Alright. Okay. Because you need a mutable thing.

00:24:53.485 --> 00:24:56.124
<v Speaker 1>Yeah. Okay. See, it doesn't like us.

00:24:56.845 --> 00:24:59.165
<v Speaker 0>So even though it is mutable, when you're

00:24:59.165 --> 00:25:01.725
<v Speaker 0>working with function signatures, you always have to

00:25:01.725 --> 00:25:03.725
<v Speaker 0>be pretty explicit then.

00:25:04.285 --> 00:25:04.605
<v Speaker 1>Yeah.

00:25:06.650 --> 00:25:07.370
<v Speaker 0>Okay.

00:25:07.850 --> 00:25:08.650
<v Speaker 0>I'm

00:25:08.650 --> 00:25:09.210
<v Speaker 0>gonna

00:25:09.610 --> 00:25:11.610
<v Speaker 0>break that down. So we had two

00:25:11.930 --> 00:25:13.930
<v Speaker 0>we had vec zero and vec one, but

00:25:13.930 --> 00:25:15.610
<v Speaker 0>what we've found is because we're doing a

00:25:15.610 --> 00:25:17.845
<v Speaker 0>mutation and a function and then a mutation

00:25:17.845 --> 00:25:20.245
<v Speaker 0>with better function, it's actually probably just best

00:25:20.245 --> 00:25:21.445
<v Speaker 0>to have a mutable

00:25:22.644 --> 00:25:24.164
<v Speaker 0>reference anyway,

00:25:24.404 --> 00:25:26.965
<v Speaker 0>and then Well, we we discovered

00:25:26.965 --> 00:25:30.005
<v Speaker 1>that we can't use a value that we've

00:25:30.005 --> 00:25:30.725
<v Speaker 1>moved out.

00:25:32.570 --> 00:25:35.290
<v Speaker 1>So you can't use after move. So we

00:25:35.290 --> 00:25:37.210
<v Speaker 1>had to come up with some way to

00:25:37.210 --> 00:25:37.850
<v Speaker 1>keep

00:25:38.170 --> 00:25:39.929
<v Speaker 1>the original value

00:25:40.010 --> 00:25:40.889
<v Speaker 1>around

00:25:41.690 --> 00:25:43.929
<v Speaker 1>or be able to use it later.

00:25:44.090 --> 00:25:46.169
<v Speaker 1>And so we just went for mutability.

00:25:46.809 --> 00:25:47.210
<v Speaker 0>Okay.

00:25:49.154 --> 00:25:49.874
<v Speaker 0>I

00:25:50.434 --> 00:25:52.755
<v Speaker 0>don't know if this is a feeling that

00:25:52.755 --> 00:25:54.515
<v Speaker 0>I have with the right Rust, but I

00:25:54.515 --> 00:25:56.115
<v Speaker 0>I always feel like I try my best

00:25:56.115 --> 00:25:59.075
<v Speaker 0>to avoid mutability whenever possible. Is that a

00:25:59.075 --> 00:26:00.835
<v Speaker 0>goal, or is that just something I've

00:26:01.075 --> 00:26:02.674
<v Speaker 0>stuck in my head for no real rhyme

00:26:02.674 --> 00:26:05.369
<v Speaker 0>or reason? This isn't bad code. Right?

00:26:05.929 --> 00:26:06.489
<v Speaker 1>No.

00:26:06.889 --> 00:26:07.690
<v Speaker 1>I mean,

00:26:08.649 --> 00:26:10.730
<v Speaker 1>functional programming tells us you can do a

00:26:10.730 --> 00:26:13.610
<v Speaker 1>lot of things without the ability. But fundamentally,

00:26:13.610 --> 00:26:15.784
<v Speaker 1>they all end up at IO, right, which

00:26:15.784 --> 00:26:18.505
<v Speaker 1>is always mutable. So I I don't think

00:26:18.505 --> 00:26:20.505
<v Speaker 1>mutability is bad, but I don't think you

00:26:20.505 --> 00:26:23.945
<v Speaker 1>should just blindly opt into mutability on everything.

00:26:24.105 --> 00:26:24.744
<v Speaker 1>It

00:26:25.065 --> 00:26:26.664
<v Speaker 1>should be something you only add when you

00:26:26.664 --> 00:26:29.320
<v Speaker 1>need it. Remember reading a a book when

00:26:29.320 --> 00:26:30.679
<v Speaker 0>I was younger. I can't remember what it

00:26:30.679 --> 00:26:32.120
<v Speaker 0>was called, but it was like the anatomy

00:26:32.120 --> 00:26:34.679
<v Speaker 0>of a computer program or something. And it

00:26:34.679 --> 00:26:36.520
<v Speaker 0>was like halfway through the book or three

00:26:36.520 --> 00:26:37.960
<v Speaker 0>quarters through the book before they had an

00:26:37.960 --> 00:26:40.040
<v Speaker 0>assignment, and they made a note of apologizing

00:26:40.040 --> 00:26:41.480
<v Speaker 0>for having an assignment in the book.

00:26:43.655 --> 00:26:44.855
<v Speaker 1>Jeez.

00:26:45.415 --> 00:26:47.255
<v Speaker 0>It was a really good book about functional

00:26:47.255 --> 00:26:49.575
<v Speaker 0>programming and how computer programs work, but the

00:26:49.575 --> 00:26:51.415
<v Speaker 0>fact that they apologized for the assignment just

00:26:51.415 --> 00:26:53.735
<v Speaker 0>kinda always resonated with me. Not resonated, but

00:26:53.735 --> 00:26:55.335
<v Speaker 0>it stuck with me is what I mean.

00:26:55.655 --> 00:26:57.175
<v Speaker 1>I don't know. I'm a big fan of

00:26:57.175 --> 00:26:59.919
<v Speaker 1>curse code, so I'm I'm fine with that.

00:27:00.799 --> 00:27:02.080
<v Speaker 1>That kind of thing.

00:27:02.960 --> 00:27:06.559
<v Speaker 0>Alright. Well, again, we're on a second example

00:27:06.559 --> 00:27:07.919
<v Speaker 0>and this definitely

00:27:08.240 --> 00:27:08.799
<v Speaker 0>helps.

00:27:11.375 --> 00:27:13.775
<v Speaker 1>Russell seemed to have a different solution.

00:27:17.055 --> 00:27:18.815
<v Speaker 0>So you got a different feel me just

00:27:18.815 --> 00:27:20.895
<v Speaker 0>type it in the chat, Russell. We'll move

00:27:20.895 --> 00:27:23.295
<v Speaker 0>on to number three just now. I wonder,

00:27:23.295 --> 00:27:24.735
<v Speaker 0>like, if we use the hints, will it

00:27:24.735 --> 00:27:26.450
<v Speaker 0>tell us how they want to just solve

00:27:26.450 --> 00:27:27.170
<v Speaker 0>it or does it

00:27:29.010 --> 00:27:30.610
<v Speaker 0>oh, yeah. We get we get some nice

00:27:30.610 --> 00:27:31.570
<v Speaker 0>text. So

00:27:32.450 --> 00:27:35.010
<v Speaker 0>it's confirming that our vec zero was moved

00:27:35.010 --> 00:27:37.650
<v Speaker 0>into the function fillvec when we called it,

00:27:37.650 --> 00:27:40.050
<v Speaker 0>which means that it gets dropped. Okay. Dropped

00:27:40.050 --> 00:27:41.924
<v Speaker 0>towards not disappeared.

00:27:43.924 --> 00:27:46.645
<v Speaker 0>No longer exists. Dropped. Okay. That seems more

00:27:46.645 --> 00:27:49.445
<v Speaker 0>technical. We went for the third option here.

00:27:49.445 --> 00:27:51.205
<v Speaker 0>Which is to make it fill make it

00:27:51.205 --> 00:27:53.845
<v Speaker 0>mutable. Yeah. Okay. So the other options were

00:27:53.845 --> 00:27:56.725
<v Speaker 0>make another separate version of the data. So

00:27:56.280 --> 00:27:58.200
<v Speaker 0>So would that have been a a clone?

00:27:59.320 --> 00:28:00.039
<v Speaker 1>Yeah.

00:28:00.760 --> 00:28:04.120
<v Speaker 1>And then option two was we could have

00:28:06.520 --> 00:28:08.040
<v Speaker 0>oh, okay. So just do the colon and

00:28:08.040 --> 00:28:11.315
<v Speaker 0>the subsequent function. And then Yeah. Okay. So

00:28:11.315 --> 00:28:13.555
<v Speaker 0>our our options for filling mutable or clone

00:28:13.555 --> 00:28:14.914
<v Speaker 0>the data, which

00:28:16.515 --> 00:28:17.875
<v Speaker 0>there are two different ways to solve the

00:28:17.875 --> 00:28:19.555
<v Speaker 0>problem and each has a trade off depending

00:28:19.555 --> 00:28:22.435
<v Speaker 0>on each individual use case. Rust does a

00:28:22.435 --> 00:28:24.515
<v Speaker 1>good job making you feel guilty for doing

00:28:24.515 --> 00:28:25.395
<v Speaker 1>heap allocations.

00:28:29.929 --> 00:28:32.410
<v Speaker 0>Yeah. I I don't care where I allocate

00:28:32.410 --> 00:28:34.650
<v Speaker 0>things. I just want to make to add

00:28:34.650 --> 00:28:36.489
<v Speaker 1>new lines to this one.

00:28:37.450 --> 00:28:38.250
<v Speaker 0>Oh, wait. What?

00:28:42.155 --> 00:28:44.874
<v Speaker 0>No lines for multiple semicolons.

00:28:44.875 --> 00:28:47.674
<v Speaker 0>No new line. Okay. Got it. Alright. Let

00:28:47.674 --> 00:28:49.355
<v Speaker 0>me see if I can identify the problem

00:28:49.355 --> 00:28:52.235
<v Speaker 0>then with this because I'm over two so

00:28:52.235 --> 00:28:53.754
<v Speaker 0>far. So we

00:28:54.475 --> 00:28:57.330
<v Speaker 0>have a vector. We create the mutable reference

00:28:57.330 --> 00:28:59.330
<v Speaker 0>like we did before based on the result

00:28:59.330 --> 00:29:00.690
<v Speaker 0>of the fillvec.

00:29:00.850 --> 00:29:01.890
<v Speaker 0>We then

00:29:02.130 --> 00:29:04.210
<v Speaker 0>because this is the same code. No, no,

00:29:04.210 --> 00:29:06.050
<v Speaker 0>no. Okay. So the printvec one push and

00:29:06.050 --> 00:29:07.570
<v Speaker 0>then printvec one again.

00:29:09.330 --> 00:29:09.650
<v Speaker 0>So

00:29:11.385 --> 00:29:12.825
<v Speaker 0>the problem here,

00:29:16.425 --> 00:29:18.025
<v Speaker 0>that looks okay to me. I'm gonna run

00:29:18.025 --> 00:29:20.025
<v Speaker 0>it. I mean, I know it's not okay,

00:29:20.025 --> 00:29:21.465
<v Speaker 0>but I'm gonna say like,

00:29:21.705 --> 00:29:24.585
<v Speaker 0>I don't think that the push function

00:29:24.665 --> 00:29:25.945
<v Speaker 0>moves anything in

00:29:26.530 --> 00:29:27.409
<v Speaker 0>memory?

00:29:28.370 --> 00:29:29.730
<v Speaker 1>That should be okay.

00:29:31.170 --> 00:29:32.450
<v Speaker 0>Oh, no. Don't read

00:29:32.770 --> 00:29:33.250
<v Speaker 0>it.

00:29:39.010 --> 00:29:39.809
<v Speaker 0>Oh, it is.

00:29:40.385 --> 00:29:43.105
<v Speaker 0>The print has taken the ownership over here.

00:29:43.425 --> 00:29:45.745
<v Speaker 1>Yeah. So my trick

00:29:47.505 --> 00:29:48.385
<v Speaker 0>is this.

00:29:48.705 --> 00:29:50.305
<v Speaker 0>That's what I always do first.

00:29:50.625 --> 00:29:52.945
<v Speaker 0>Thanks, Rusty. No. No. I'm glad. Was great.

00:29:54.750 --> 00:29:56.909
<v Speaker 1>Yeah. We added new lines now.

00:29:58.030 --> 00:29:59.870
<v Speaker 0>Not my fault. It was Rust format or

00:29:59.870 --> 00:30:01.470
<v Speaker 0>Rust font depending on how you wanna say

00:30:01.470 --> 00:30:02.029
<v Speaker 0>it.

00:30:02.350 --> 00:30:03.070
<v Speaker 0>So

00:30:06.110 --> 00:30:07.950
<v Speaker 0>I mean, it didn't complain about me passing

00:30:07.950 --> 00:30:09.710
<v Speaker 0>these in as a reference to

00:30:10.555 --> 00:30:12.475
<v Speaker 1>Yeah. So I'm not sure why

00:30:13.115 --> 00:30:14.475
<v Speaker 0>this is telling me

00:30:15.915 --> 00:30:18.395
<v Speaker 1>So this is in Philvec though.

00:30:19.595 --> 00:30:20.395
<v Speaker 0>Oh.

00:30:21.035 --> 00:30:21.755
<v Speaker 1>Yeah.

00:30:22.075 --> 00:30:23.675
<v Speaker 0>Right. Okay. So

00:30:25.700 --> 00:30:27.220
<v Speaker 0>there's nothing to do with that print statement

00:30:27.220 --> 00:30:29.539
<v Speaker 0>at all then. Okay.

00:30:32.900 --> 00:30:35.059
<v Speaker 0>We're passing in.

00:30:35.060 --> 00:30:36.580
<v Speaker 0>Okay. I got it now.

00:30:37.645 --> 00:30:39.405
<v Speaker 0>It's not mutable when we pass it in

00:30:39.405 --> 00:30:41.085
<v Speaker 0>here. We're not doing the shadowing and we

00:30:41.085 --> 00:30:43.004
<v Speaker 0>cannot do the shadow because

00:30:43.245 --> 00:30:45.164
<v Speaker 0>we're not able to add in lines.

00:30:45.645 --> 00:30:46.365
<v Speaker 0>Gotcha.

00:30:46.525 --> 00:30:48.924
<v Speaker 0>Right. Okay. So Got it.

00:30:50.045 --> 00:30:51.725
<v Speaker 0>So we need to be able to make

00:30:52.610 --> 00:30:53.810
<v Speaker 0>okay. That's tricky.

00:30:54.610 --> 00:30:55.890
<v Speaker 0>Damn you, Rustlings.

00:31:02.370 --> 00:31:04.610
<v Speaker 0>I mean, man, even I think but we

00:31:04.610 --> 00:31:06.175
<v Speaker 0>tried that with the last one it didn't

00:31:06.175 --> 00:31:07.294
<v Speaker 0>really work. So

00:31:07.855 --> 00:31:10.495
<v Speaker 0>I I think I think that's a worthwhile

00:31:10.495 --> 00:31:12.095
<v Speaker 1>thing to pursue this time.

00:31:13.535 --> 00:31:14.575
<v Speaker 0>Okay. So what this

00:31:15.615 --> 00:31:17.455
<v Speaker 1>That will imply we have to make vec

00:31:17.455 --> 00:31:19.135
<v Speaker 1>zero also mute though.

00:31:21.220 --> 00:31:23.539
<v Speaker 0>Would this not just take ownership of it

00:31:23.620 --> 00:31:24.340
<v Speaker 0>here?

00:31:25.220 --> 00:31:26.179
<v Speaker 0>Well, no.

00:31:27.140 --> 00:31:27.779
<v Speaker 1>No.

00:31:28.580 --> 00:31:30.900
<v Speaker 1>So we in order to give out a

00:31:30.900 --> 00:31:33.299
<v Speaker 1>mutable reference, we need to have a mutable

00:31:33.780 --> 00:31:34.500
<v Speaker 1>ownership.

00:31:35.945 --> 00:31:37.065
<v Speaker 0>Right. Okay.

00:31:37.385 --> 00:31:39.705
<v Speaker 1>Yeah. So we've not added any new lanes.

00:31:40.025 --> 00:31:42.585
<v Speaker 1>No. We've only changed them so far. And

00:31:42.585 --> 00:31:44.425
<v Speaker 0>I guess this would have to be updated

00:31:44.425 --> 00:31:45.544
<v Speaker 0>to do this.

00:31:46.025 --> 00:31:46.664
<v Speaker 1>Yeah.

00:31:47.865 --> 00:31:49.225
<v Speaker 0>Does it say I can delete lanes?

00:31:51.690 --> 00:31:53.130
<v Speaker 0>I mean, that's our solution to the last

00:31:53.130 --> 00:31:55.050
<v Speaker 0>one, isn't it? Well, I don't think we

00:31:55.050 --> 00:31:56.810
<v Speaker 1>should hold on. Let's play let's play the

00:31:56.810 --> 00:31:59.450
<v Speaker 1>game properly. Right? Let's let's try and return

00:31:59.450 --> 00:32:01.850
<v Speaker 1>the the mutable pointer to the vector here.

00:32:02.345 --> 00:32:03.304
<v Speaker 0>Alright.

00:32:03.465 --> 00:32:04.265
<v Speaker 0>Like so.

00:32:04.745 --> 00:32:06.265
<v Speaker 1>Yeah. Let's do it.

00:32:06.905 --> 00:32:08.585
<v Speaker 0>It worked. Wow.

00:32:10.345 --> 00:32:11.865
<v Speaker 0>Alright. I'm confused.

00:32:13.225 --> 00:32:14.025
<v Speaker 1>Well, because,

00:32:14.580 --> 00:32:16.260
<v Speaker 1>you know, we talked about how you're allowed

00:32:16.260 --> 00:32:19.139
<v Speaker 1>to have one mutable reference passed around. Right?

00:32:19.140 --> 00:32:19.779
<v Speaker 0>Mhmm.

00:32:20.419 --> 00:32:20.979
<v Speaker 1>So

00:32:21.860 --> 00:32:22.820
<v Speaker 1>the

00:32:23.220 --> 00:32:26.259
<v Speaker 1>in nine, we create the mutable vector.

00:32:26.500 --> 00:32:27.859
<v Speaker 1>And in 11,

00:32:27.940 --> 00:32:28.900
<v Speaker 1>we get the reference.

00:32:30.185 --> 00:32:31.784
<v Speaker 1>Then down in 20,

00:32:32.105 --> 00:32:34.345
<v Speaker 1>we accept the argument also as a mutable

00:32:34.345 --> 00:32:37.145
<v Speaker 1>reference, and then we return that same reference.

00:32:37.145 --> 00:32:39.305
<v Speaker 1>So we're not creating any new reference.

00:32:41.490 --> 00:32:42.690
<v Speaker 0>Is there any value

00:32:43.330 --> 00:32:45.570
<v Speaker 0>to this approach over, like because, I mean,

00:32:45.570 --> 00:32:47.570
<v Speaker 0>we need to move the return previously. Is

00:32:47.570 --> 00:32:49.170
<v Speaker 0>that the same code or is it is

00:32:49.170 --> 00:32:50.050
<v Speaker 0>it different?

00:32:50.050 --> 00:32:51.490
<v Speaker 1>Basically the same.

00:32:52.610 --> 00:32:54.930
<v Speaker 0>Okay. This is teaching a slightly different lesson

00:32:54.930 --> 00:32:58.034
<v Speaker 1>that, you know, you can return a unique

00:32:58.115 --> 00:33:00.355
<v Speaker 1>mutable reference and still work. You can still

00:33:00.355 --> 00:33:02.434
<v Speaker 0>get a mutable reference. Right. Okay.

00:33:04.275 --> 00:33:07.075
<v Speaker 1>Do you need vec zero after line 11?

00:33:07.395 --> 00:33:09.315
<v Speaker 0>Alright. Question from Russell is,

00:33:09.950 --> 00:33:12.509
<v Speaker 0>do we need vec zero after lane 11?

00:33:12.750 --> 00:33:14.590
<v Speaker 1>I do not think we do.

00:33:16.430 --> 00:33:18.430
<v Speaker 0>Well, vec zero will accept will be dropped.

00:33:18.430 --> 00:33:20.669
<v Speaker 0>Right? Because vec one now holds the reference.

00:33:21.309 --> 00:33:24.030
<v Speaker 1>Well, no. Because it's it's a mutable reference.

00:33:24.030 --> 00:33:25.470
<v Speaker 1>Vex zero will still be around.

00:33:26.955 --> 00:33:29.355
<v Speaker 0>But doesn't vec one take ownership of it

00:33:29.355 --> 00:33:29.914
<v Speaker 0>here?

00:33:30.635 --> 00:33:32.395
<v Speaker 0>Like No. Can I I do a print

00:33:32.395 --> 00:33:33.035
<v Speaker 0>l n

00:33:35.515 --> 00:33:37.355
<v Speaker 1>Yeah? Vec zero?

00:33:37.755 --> 00:33:38.235
<v Speaker 1>Yeah.

00:33:39.150 --> 00:33:40.429
<v Speaker 0>That's gonna work?

00:33:40.750 --> 00:33:41.870
<v Speaker 1>I think so.

00:33:43.150 --> 00:33:45.390
<v Speaker 1>Oh, see. Way it's just a formatter.

00:33:47.230 --> 00:33:49.150
<v Speaker 0>That message, I know all too well to

00:33:51.470 --> 00:33:53.310
<v Speaker 1>Immutable borrow. That's fair.

00:33:55.625 --> 00:33:57.384
<v Speaker 1>So what that's saying,

00:33:57.945 --> 00:33:59.705
<v Speaker 1>if you look at that, is

00:34:00.745 --> 00:34:02.424
<v Speaker 1>on on

00:34:02.424 --> 00:34:03.465
<v Speaker 1>line 11,

00:34:04.265 --> 00:34:05.785
<v Speaker 1>we took a mutable borrow.

00:34:06.120 --> 00:34:07.960
<v Speaker 1>And then we're trying to use

00:34:08.600 --> 00:34:10.520
<v Speaker 1>that same thing we have a mutable borough

00:34:10.520 --> 00:34:12.280
<v Speaker 1>out for before

00:34:12.280 --> 00:34:14.440
<v Speaker 1>we get back that mutable borough.

00:34:17.639 --> 00:34:19.560
<v Speaker 1>So if you look at the code again,

00:34:19.560 --> 00:34:21.400
<v Speaker 1>because we have VEC one around,

00:34:22.094 --> 00:34:23.455
<v Speaker 1>it's not gonna work.

00:34:24.574 --> 00:34:27.455
<v Speaker 1>But, like, say you moved line 13 down

00:34:27.455 --> 00:34:28.574
<v Speaker 1>to line 20,

00:34:32.255 --> 00:34:35.855
<v Speaker 1>and before line on line 19, you put

00:34:35.159 --> 00:34:36.840
<v Speaker 1>drop VEC one.

00:34:39.719 --> 00:34:43.079
<v Speaker 1>Now that should work because we've explicitly dropped

00:34:43.079 --> 00:34:45.719
<v Speaker 1>VEC one, and so we we have the

00:34:45.719 --> 00:34:47.239
<v Speaker 1>only ownership over zero.

00:34:47.864 --> 00:34:49.705
<v Speaker 1>Tada. I hate computers.

00:34:50.585 --> 00:34:51.305
<v Speaker 1>Yeah.

00:34:52.745 --> 00:34:54.025
<v Speaker 1>I just assumed

00:34:54.344 --> 00:34:55.305
<v Speaker 0>that when

00:34:55.784 --> 00:34:58.105
<v Speaker 0>we did this, that this was just dropped

00:34:58.105 --> 00:34:58.585
<v Speaker 0>anyway.

00:34:59.559 --> 00:35:01.960
<v Speaker 1>Well, because you're taking a mutable reference to

00:35:01.960 --> 00:35:05.000
<v Speaker 1>it, main still owns vec zero.

00:35:05.000 --> 00:35:07.560
<v Speaker 1>It's just given out a mutable pointer.

00:35:08.680 --> 00:35:11.319
<v Speaker 1>And so fun to like, the the big

00:35:11.319 --> 00:35:14.155
<v Speaker 1>the big idea here is that if I'm

00:35:14.155 --> 00:35:16.474
<v Speaker 1>main and I give out a mutable pointer

00:35:16.474 --> 00:35:17.755
<v Speaker 1>to vex zero,

00:35:18.714 --> 00:35:19.915
<v Speaker 1>and then, you know,

00:35:20.714 --> 00:35:22.635
<v Speaker 1>I'm done and I'm finished,

00:35:22.954 --> 00:35:25.194
<v Speaker 1>but I haven't got back that vex zero

00:35:25.194 --> 00:35:25.674
<v Speaker 1>pointer.

00:35:26.500 --> 00:35:28.500
<v Speaker 1>I can't call drop on it yet until

00:35:28.500 --> 00:35:30.980
<v Speaker 1>I get back that pointer that that reference.

00:35:30.980 --> 00:35:34.100
<v Speaker 1>Right? Okay. Okay. So it it lets the

00:35:34.100 --> 00:35:35.060
<v Speaker 1>compiler

00:35:35.060 --> 00:35:37.860
<v Speaker 1>statically track when it will be able to

00:35:37.860 --> 00:35:38.740
<v Speaker 1>drop a value.

00:35:42.125 --> 00:35:43.805
<v Speaker 0>Okay. I'm getting it.

00:35:44.045 --> 00:35:46.045
<v Speaker 1>Yeah. Four, I am gonna I am gonna

00:35:46.045 --> 00:35:47.645
<v Speaker 0>get this one though. I feel like I

00:35:47.645 --> 00:35:48.205
<v Speaker 0>know

00:35:48.445 --> 00:35:50.685
<v Speaker 0>everything there is to know, which of course

00:35:50.685 --> 00:35:52.285
<v Speaker 0>is never gonna happen. But

00:35:52.685 --> 00:35:54.765
<v Speaker 0>for factor this code, so that instead of

00:35:54.765 --> 00:35:57.190
<v Speaker 0>having vec zero and creating a vector and

00:35:57.190 --> 00:35:59.990
<v Speaker 0>main, we create an infill vec.

00:36:03.030 --> 00:36:03.910
<v Speaker 0>Okay.

00:36:03.990 --> 00:36:04.710
<v Speaker 0>So

00:36:06.310 --> 00:36:08.390
<v Speaker 0>what we have here is vec zero being

00:36:08.390 --> 00:36:09.910
<v Speaker 0>created. It's read only.

00:36:12.815 --> 00:36:14.815
<v Speaker 0>And then we get a mutable back.

00:36:19.135 --> 00:36:20.575
<v Speaker 0>Wait. Why is this not that argument?

00:36:26.370 --> 00:36:29.010
<v Speaker 1>Refracture this code so that instead of having

00:36:29.010 --> 00:36:30.210
<v Speaker 1>vec zero,

00:36:30.290 --> 00:36:31.170
<v Speaker 1>we it

00:36:31.570 --> 00:36:33.810
<v Speaker 1>within fillvec and transfer the

00:36:34.210 --> 00:36:37.490
<v Speaker 0>Ah, okay. So basically, this goes away,

00:36:40.025 --> 00:36:41.305
<v Speaker 0>and we wanna be able to get a

00:36:41.305 --> 00:36:43.865
<v Speaker 0>mutable reference back from field deck.

00:36:44.664 --> 00:36:46.505
<v Speaker 0>So does that mean I think we want

00:36:46.505 --> 00:36:47.065
<v Speaker 1>ownership.

00:36:51.030 --> 00:36:52.630
<v Speaker 1>If you just stop here,

00:36:52.950 --> 00:36:54.870
<v Speaker 1>the the thing you're doing here is is

00:36:54.870 --> 00:36:55.590
<v Speaker 1>not

00:36:56.790 --> 00:36:58.550
<v Speaker 1>like, I know it's not our final code,

00:36:58.550 --> 00:37:00.950
<v Speaker 1>but this would never work because

00:37:01.270 --> 00:37:02.790
<v Speaker 1>on line 21,

00:37:02.790 --> 00:37:03.910
<v Speaker 1>you create

00:37:04.070 --> 00:37:06.150
<v Speaker 1>this memory buffer on the heap.

00:37:07.155 --> 00:37:09.795
<v Speaker 1>And then on you you return it out

00:37:09.795 --> 00:37:12.355
<v Speaker 1>of the function as a mutable reference.

00:37:13.075 --> 00:37:15.235
<v Speaker 1>But fundamentally, it won't live long enough.

00:37:15.635 --> 00:37:17.235
<v Speaker 0>Oh, I see that message all the time

00:37:17.235 --> 00:37:19.720
<v Speaker 0>too. Noise That wouldn't work. Yeah. So

00:37:19.880 --> 00:37:21.560
<v Speaker 1>in order to do that, you'd have to

00:37:21.560 --> 00:37:25.560
<v Speaker 1>return the own value. Yeah. So really what

00:37:25.560 --> 00:37:27.560
<v Speaker 0>we want is vec equals

00:37:28.040 --> 00:37:29.720
<v Speaker 1>Yeah. Like vec new or whatever.

00:37:31.815 --> 00:37:33.575
<v Speaker 0>Well, I guess it would guess a tape,

00:37:33.575 --> 00:37:36.055
<v Speaker 0>but I've I've taped it there. So Yeah.

00:37:36.055 --> 00:37:37.575
<v Speaker 0>Oh, no. But it would be vague.

00:37:39.015 --> 00:37:39.655
<v Speaker 0>Okay.

00:37:40.935 --> 00:37:43.415
<v Speaker 0>So then we have this is not mutable,

00:37:43.415 --> 00:37:45.255
<v Speaker 0>so I'm assuming we still need this. We

00:37:45.255 --> 00:37:47.730
<v Speaker 0>push push, push and then this returns.

00:37:50.610 --> 00:37:53.170
<v Speaker 0>So does this mean here because it's dropped

00:37:53.170 --> 00:37:55.010
<v Speaker 0>from fillvec, the vec one is now the

00:37:55.010 --> 00:37:56.130
<v Speaker 0>owner of this?

00:37:57.410 --> 00:37:58.450
<v Speaker 1>Yeah. So

00:37:58.690 --> 00:38:00.974
<v Speaker 1>at the end of the fillvec call, when

00:38:00.974 --> 00:38:02.655
<v Speaker 1>you return the vector,

00:38:03.535 --> 00:38:05.855
<v Speaker 1>the main becomes the new owner of that

00:38:05.855 --> 00:38:08.974
<v Speaker 1>that variable. Yeah. Okay. So

00:38:10.494 --> 00:38:13.440
<v Speaker 0>that should work. There we go. Tada.

00:38:17.280 --> 00:38:18.000
<v Speaker 0>Okay.

00:38:20.000 --> 00:38:21.680
<v Speaker 0>I get it. Kinda.

00:38:21.920 --> 00:38:22.560
<v Speaker 0>Good.

00:38:23.520 --> 00:38:25.119
<v Speaker 0>Alright. We've got one more.

00:38:26.845 --> 00:38:28.685
<v Speaker 0>Number five. Took me a long time to

00:38:28.685 --> 00:38:31.085
<v Speaker 1>search and internalize some of these rules, so

00:38:31.085 --> 00:38:32.285
<v Speaker 1>don't feel bad.

00:38:32.525 --> 00:38:34.125
<v Speaker 0>Oh, this one looks fun.

00:38:34.765 --> 00:38:36.045
<v Speaker 0>Stars everywhere.

00:38:38.049 --> 00:38:41.490
<v Speaker 0>Okay. So make me compile without adding, removing,

00:38:41.490 --> 00:38:43.970
<v Speaker 0>or changing any lanes. What?

00:38:46.849 --> 00:38:49.089
<v Speaker 0>Make me compile without changing any code.

00:38:49.730 --> 00:38:50.849
<v Speaker 0>Is that what it's doing?

00:38:54.355 --> 00:38:55.235
<v Speaker 1>Interesting.

00:38:58.355 --> 00:39:00.275
<v Speaker 0>Okay. So we have okay. Let's let's go

00:39:00.275 --> 00:39:01.795
<v Speaker 0>through this lane by lane because I I

00:39:01.795 --> 00:39:04.595
<v Speaker 0>don't understand this code. So on lane nine,

00:39:04.595 --> 00:39:06.355
<v Speaker 0>we create a mutable

00:39:07.210 --> 00:39:09.530
<v Speaker 0>variable called x, which equals

00:39:11.130 --> 00:39:12.010
<v Speaker 0>an integer.

00:39:14.810 --> 00:39:15.850
<v Speaker 0>Line 10, we

00:39:16.330 --> 00:39:17.850
<v Speaker 0>have y,

00:39:17.930 --> 00:39:19.770
<v Speaker 0>which is a mutable reference

00:39:19.770 --> 00:39:20.410
<v Speaker 0>to

00:39:20.955 --> 00:39:21.675
<v Speaker 0>that.

00:39:23.755 --> 00:39:25.995
<v Speaker 0>And then on lane 11, we've got z

00:39:25.995 --> 00:39:27.675
<v Speaker 0>which is a

00:39:28.635 --> 00:39:31.595
<v Speaker 0>mutable reference to a d referenced y which

00:39:31.595 --> 00:39:32.875
<v Speaker 0>would be x. So

00:39:33.440 --> 00:39:35.520
<v Speaker 0>I mean, that's not legal. Right?

00:39:36.480 --> 00:39:39.680
<v Speaker 1>Oh, let's try and and build this.

00:39:43.520 --> 00:39:44.320
<v Speaker 0>Okay.

00:39:44.320 --> 00:39:45.200
<v Speaker 1>Yeah. That's fair.

00:39:45.935 --> 00:39:48.095
<v Speaker 0>So this is saying that we cannot use

00:39:48.095 --> 00:39:50.415
<v Speaker 0>star y because it was mutable. Yeah. That's

00:39:50.415 --> 00:39:51.615
<v Speaker 0>what I thought. Good.

00:39:52.255 --> 00:39:55.135
<v Speaker 0>Because this is a mutable reference to x,

00:39:55.135 --> 00:39:57.215
<v Speaker 0>and this is essentially doing the same thing.

00:39:57.215 --> 00:39:59.775
<v Speaker 0>Right? Star y is x. Is that right?

00:39:59.775 --> 00:40:00.895
<v Speaker 1>Yeah. Okay. Yeah.

00:40:02.870 --> 00:40:04.710
<v Speaker 1>So so how do we fix this if

00:40:04.710 --> 00:40:07.030
<v Speaker 1>we can't change the code? I don't understand.

00:40:11.110 --> 00:40:13.670
<v Speaker 0>Make me compile without adding,

00:40:13.750 --> 00:40:14.630
<v Speaker 0>removing,

00:40:14.630 --> 00:40:15.350
<v Speaker 0>or changing.

00:40:16.135 --> 00:40:18.135
<v Speaker 0>That cannot be right.

00:40:18.535 --> 00:40:20.295
<v Speaker 1>So do we have to add stuff like

00:40:20.295 --> 00:40:21.735
<v Speaker 1>around main?

00:40:23.655 --> 00:40:25.335
<v Speaker 0>But it says we can't change any

00:40:27.095 --> 00:40:29.095
<v Speaker 0>should we have the I don't understand it.

00:40:29.095 --> 00:40:30.890
<v Speaker 1>In main. Yeah. Maybe.

00:40:34.250 --> 00:40:36.570
<v Speaker 0>Okay. Carefully reason about the range in which

00:40:36.570 --> 00:40:37.610
<v Speaker 0>each mineral reference

00:40:37.930 --> 00:40:39.530
<v Speaker 0>is in vogue.

00:40:40.410 --> 00:40:42.010
<v Speaker 0>Does it help to update the value of

00:40:42.170 --> 00:40:45.585
<v Speaker 1>Oh, oh, gosh. It says you can reorder

00:40:45.585 --> 00:40:48.145
<v Speaker 1>them, which is definitely changing them.

00:40:49.105 --> 00:40:50.865
<v Speaker 0>But that's changing the lanes.

00:40:51.185 --> 00:40:52.145
<v Speaker 1>I know.

00:40:53.585 --> 00:40:56.385
<v Speaker 1>Okay. So now with this this new knowledge

00:40:56.385 --> 00:40:58.625
<v Speaker 1>that we can reorder them, let's think about

00:40:58.625 --> 00:40:58.865
<v Speaker 1>this.

00:41:01.160 --> 00:41:02.280
<v Speaker 0>Okay. So

00:41:03.079 --> 00:41:05.720
<v Speaker 1>we know that when we have y,

00:41:06.839 --> 00:41:09.480
<v Speaker 1>we have a mutable the the unique mutable

00:41:09.480 --> 00:41:12.119
<v Speaker 1>reference to x. Right? Correct. Yes.

00:41:12.520 --> 00:41:15.455
<v Speaker 1>And when we have z, we also have

00:41:15.775 --> 00:41:17.695
<v Speaker 1>a unique mutable reference

00:41:17.775 --> 00:41:21.375
<v Speaker 1>to to x. Yeah. So I think if

00:41:21.375 --> 00:41:24.255
<v Speaker 1>we reordered it so that we did not

00:41:24.255 --> 00:41:28.335
<v Speaker 1>have z existing while we mutated y,

00:41:28.335 --> 00:41:29.055
<v Speaker 1>it might work.

00:41:31.990 --> 00:41:32.869
<v Speaker 0>Like that?

00:41:33.269 --> 00:41:34.310
<v Speaker 1>I think so.

00:41:37.430 --> 00:41:40.470
<v Speaker 0>That was easy. I knew it. Yeah. Yeah.

00:41:43.190 --> 00:41:43.589
<v Speaker 0>So

00:41:45.295 --> 00:41:48.015
<v Speaker 0>this only works. I don't know if I'm

00:41:48.895 --> 00:41:50.655
<v Speaker 0>yeah. Let let me try and articulate this.

00:41:50.655 --> 00:41:52.575
<v Speaker 0>This only works because we don't use y

00:41:52.575 --> 00:41:54.015
<v Speaker 0>anymore. Is that right?

00:41:55.295 --> 00:41:56.415
<v Speaker 1>That's correct.

00:41:56.655 --> 00:41:58.415
<v Speaker 0>Like, this one now cause it to fail

00:41:58.415 --> 00:41:58.815
<v Speaker 0>again,

00:41:59.319 --> 00:42:00.280
<v Speaker 0>I think. Yeah.

00:42:03.559 --> 00:42:07.000
<v Speaker 0>Well, that and my inability to macro.

00:42:08.119 --> 00:42:09.400
<v Speaker 0>Well, that still works.

00:42:10.039 --> 00:42:10.599
<v Speaker 1>Really?

00:42:12.145 --> 00:42:12.865
<v Speaker 1>Dog.

00:42:14.945 --> 00:42:17.425
<v Speaker 0>Oh, but we're not mutating it. Right? So

00:42:18.065 --> 00:42:19.425
<v Speaker 1>Yeah. That's fair.

00:42:20.545 --> 00:42:22.385
<v Speaker 0>There we go. Okay.

00:42:24.305 --> 00:42:26.705
<v Speaker 1>Well, that that that wasn't the right error.

00:42:26.790 --> 00:42:29.350
<v Speaker 1>But, yeah, came with the no.

00:42:32.150 --> 00:42:34.790
<v Speaker 1>That was you have to dereference the thing.

00:42:38.790 --> 00:42:41.424
<v Speaker 1>But doing this would create a create a

00:42:41.424 --> 00:42:43.905
<v Speaker 1>new integer. Oh, yeah. This is because these

00:42:43.905 --> 00:42:46.785
<v Speaker 0>these are fixed size integer. Okay. Yeah. Okay.

00:42:46.785 --> 00:42:49.905
<v Speaker 1>These are these these integers implement copy.

00:42:49.984 --> 00:42:50.224
<v Speaker 1>So

00:42:51.184 --> 00:42:51.825
<v Speaker 0>Yeah.

00:42:52.385 --> 00:42:53.984
<v Speaker 0>And Rust doesn't care about copy.

00:42:56.130 --> 00:42:58.450
<v Speaker 1>Well, copy implied some things very cheap to

00:42:58.450 --> 00:42:59.650
<v Speaker 1>make a copy of. So

00:43:00.369 --> 00:43:01.010
<v Speaker 0>Yep.

00:43:01.730 --> 00:43:03.090
<v Speaker 0>Alright.

00:43:05.410 --> 00:43:08.290
<v Speaker 0>That really helped my understanding.

00:43:08.690 --> 00:43:09.089
<v Speaker 1>Good.

00:43:10.434 --> 00:43:12.435
<v Speaker 0>So we've got around

00:43:12.755 --> 00:43:15.474
<v Speaker 0>fifteen minutes left. Will we will we tackle

00:43:15.474 --> 00:43:16.755
<v Speaker 0>lifetimes? I

00:43:17.234 --> 00:43:19.075
<v Speaker 1>don't I don't think we'll get that far,

00:43:19.075 --> 00:43:20.835
<v Speaker 1>but I'd love to chat about them a

00:43:20.835 --> 00:43:23.474
<v Speaker 1>bit. So I wanna go through that exercise

00:43:23.474 --> 00:43:25.150
<v Speaker 0>that you you did with me when I

00:43:25.150 --> 00:43:27.710
<v Speaker 0>was looking for help last week. Oh, no.

00:43:28.030 --> 00:43:29.790
<v Speaker 1>Okay. I don't know if I can remember

00:43:29.790 --> 00:43:30.830
<v Speaker 1>it, but sure.

00:43:31.070 --> 00:43:32.750
<v Speaker 0>Yeah. You have to remember all off the

00:43:32.750 --> 00:43:33.950
<v Speaker 0>top of your head. Go.

00:43:34.670 --> 00:43:35.390
<v Speaker 1>Okay.

00:43:36.750 --> 00:43:38.590
<v Speaker 0>No. Alright. Let me create

00:43:39.230 --> 00:43:41.425
<v Speaker 0>I'll just say Rawkode RS.

00:43:42.145 --> 00:43:42.785
<v Speaker 0>So

00:43:42.945 --> 00:43:44.865
<v Speaker 0>let's have a function,

00:43:46.625 --> 00:43:47.185
<v Speaker 0>main

00:43:48.704 --> 00:43:50.065
<v Speaker 0>print ln.

00:43:51.345 --> 00:43:52.945
<v Speaker 0>This is about as good as my Rust

00:43:52.945 --> 00:43:53.585
<v Speaker 0>gets.

00:43:54.065 --> 00:43:54.545
<v Speaker 0>Sure.

00:43:56.090 --> 00:43:56.970
<v Speaker 0>Cargo

00:43:56.970 --> 00:43:57.770
<v Speaker 0>run.

00:44:00.970 --> 00:44:03.050
<v Speaker 0>Really? It's gonna compare all of that for

00:44:03.050 --> 00:44:03.770
<v Speaker 0>hello

00:44:04.490 --> 00:44:06.090
<v Speaker 0>just because I'm in that directory.

00:44:08.184 --> 00:44:09.944
<v Speaker 1>Interesting.

00:44:09.944 --> 00:44:11.545
<v Speaker 0>Yeah. That's annoying. That's annoying. But I should've

00:44:11.545 --> 00:44:12.744
<v Speaker 0>used Rusty.

00:44:12.744 --> 00:44:14.505
<v Speaker 0>I don't know if that would've worked.

00:44:18.345 --> 00:44:19.944
<v Speaker 0>I guess, only has to do it once.

00:44:24.780 --> 00:44:26.140
<v Speaker 0>Oh, does that not work?

00:44:31.660 --> 00:44:33.260
<v Speaker 0>Well, that doesn't run it. How can I

00:44:33.260 --> 00:44:34.300
<v Speaker 0>just run a fail?

00:44:36.165 --> 00:44:38.085
<v Speaker 1>I think that that will have created a

00:44:38.085 --> 00:44:40.405
<v Speaker 1>binary in your directory you can run.

00:44:41.365 --> 00:44:43.045
<v Speaker 1>Yeah. To run the Rawkode.

00:44:43.365 --> 00:44:44.165
<v Speaker 0>Alright.

00:44:44.725 --> 00:44:46.805
<v Speaker 0>Okay. Can I not just tell it to

00:44:47.445 --> 00:44:49.445
<v Speaker 0>interpret and run the file? You're not really

00:44:49.445 --> 00:44:52.400
<v Speaker 1>supposed to, like, just ad hoc run Rust

00:44:52.400 --> 00:44:53.520
<v Speaker 1>files. So

00:44:55.599 --> 00:44:57.920
<v Speaker 0>I'm changing those rules today. Jeez.

00:45:02.319 --> 00:45:02.640
<v Speaker 0>So,

00:45:04.035 --> 00:45:05.875
<v Speaker 0>yeah, the exercise that you walked me through

00:45:05.875 --> 00:45:08.194
<v Speaker 0>last time, which has been infinitely beneficial to

00:45:08.194 --> 00:45:09.234
<v Speaker 0>me, and I think we should share it

00:45:09.234 --> 00:45:10.595
<v Speaker 0>with people, is that

00:45:11.234 --> 00:45:12.515
<v Speaker 0>I have ignored

00:45:12.595 --> 00:45:13.715
<v Speaker 0>lifetimes

00:45:13.795 --> 00:45:15.395
<v Speaker 0>for as long as I've been writing Rust

00:45:15.395 --> 00:45:17.474
<v Speaker 0>because I just I really don't really want

00:45:16.860 --> 00:45:17.900
<v Speaker 0>to worry about it.

00:45:18.380 --> 00:45:19.820
<v Speaker 1>Yeah. But the thing that you kind of

00:45:19.820 --> 00:45:22.140
<v Speaker 0>may help me realize is that even if

00:45:22.140 --> 00:45:24.060
<v Speaker 0>the lifetimes aren't in my code,

00:45:24.140 --> 00:45:25.260
<v Speaker 0>they are still

00:45:25.500 --> 00:45:28.380
<v Speaker 0>here. They still exist and we we can

00:45:28.380 --> 00:45:29.420
<v Speaker 0>make them explicit.

00:45:29.900 --> 00:45:31.500
<v Speaker 0>And and just that process

00:45:32.195 --> 00:45:34.035
<v Speaker 0>really helped me understand it.

00:45:34.355 --> 00:45:34.995
<v Speaker 0>So

00:45:36.915 --> 00:45:38.355
<v Speaker 0>I'm not sure if we need to type

00:45:38.355 --> 00:45:40.195
<v Speaker 0>new code or if we Yeah. We probably

00:45:40.195 --> 00:45:41.475
<v Speaker 0>will, right, won't we?

00:45:41.875 --> 00:45:43.635
<v Speaker 0>So should we have a

00:45:43.635 --> 00:45:46.355
<v Speaker 0>new function that just prints out? Here,

00:45:46.355 --> 00:45:47.395
<v Speaker 1>let's let's do like,

00:45:50.000 --> 00:45:51.520
<v Speaker 1>let's make a string.

00:45:54.800 --> 00:45:56.320
<v Speaker 1>Rawkode.

00:45:57.520 --> 00:45:59.200
<v Speaker 1>It's in here. And

00:46:04.645 --> 00:46:06.805
<v Speaker 1>we can print out that string. Right?

00:46:07.765 --> 00:46:08.645
<v Speaker 1>And then,

00:46:09.444 --> 00:46:11.684
<v Speaker 1>like, this is basically what we were doing

00:46:11.684 --> 00:46:13.125
<v Speaker 1>before. Do

00:46:13.365 --> 00:46:14.405
<v Speaker 1>do the thing.

00:46:16.700 --> 00:46:17.900
<v Speaker 0>Yeah. And my

00:46:18.539 --> 00:46:20.700
<v Speaker 0>awkward understanding of string and string and string

00:46:20.700 --> 00:46:21.500
<v Speaker 0>and string,

00:46:21.900 --> 00:46:23.819
<v Speaker 0>but just no much better now because of

00:46:23.819 --> 00:46:24.859
<v Speaker 0>this. Yeah.

00:46:25.099 --> 00:46:25.740
<v Speaker 1>So

00:46:28.059 --> 00:46:28.780
<v Speaker 1>wrong.

00:46:29.740 --> 00:46:31.420
<v Speaker 1>I don't really know what I'm doing here,

00:46:31.420 --> 00:46:32.995
<v Speaker 1>but we're going to do it.

00:46:40.755 --> 00:46:42.435
<v Speaker 1>Yeah, so this will give me

00:46:43.155 --> 00:46:43.955
<v Speaker 1>the fundamental.

00:46:45.010 --> 00:46:47.010
<v Speaker 1>We were talking about string and string and

00:46:47.010 --> 00:46:48.210
<v Speaker 1>STR. Right?

00:46:48.610 --> 00:46:51.490
<v Speaker 0>Yeah. That was right. Yeah. Yeah. So

00:46:52.130 --> 00:46:54.450
<v Speaker 1>if you have a string,

00:46:54.850 --> 00:46:56.130
<v Speaker 1>which would be this

00:46:57.410 --> 00:46:58.130
<v Speaker 1>in here,

00:47:00.265 --> 00:47:02.025
<v Speaker 1>you have ownership

00:47:02.345 --> 00:47:04.185
<v Speaker 1>of a memory buffer

00:47:04.825 --> 00:47:08.345
<v Speaker 1>of the, like, unsigned eight bit integers.

00:47:09.545 --> 00:47:10.825
<v Speaker 1>Now

00:47:12.160 --> 00:47:13.760
<v Speaker 1>if I was to

00:47:15.040 --> 00:47:17.360
<v Speaker 1>do, like, as STR here

00:47:17.600 --> 00:47:19.200
<v Speaker 1>so that I got in

00:47:22.480 --> 00:47:25.045
<v Speaker 1>some STR type, which I'm sure a lot

00:47:25.045 --> 00:47:28.005
<v Speaker 1>of people are used to seeing in Rust.

00:47:28.645 --> 00:47:29.605
<v Speaker 1>That

00:47:29.925 --> 00:47:30.965
<v Speaker 1>is unknown.

00:47:30.965 --> 00:47:32.805
<v Speaker 1>It's just a reference

00:47:33.045 --> 00:47:34.805
<v Speaker 1>to one of those same

00:47:35.365 --> 00:47:36.485
<v Speaker 1>memory buffers.

00:47:39.110 --> 00:47:39.750
<v Speaker 1>So

00:47:40.230 --> 00:47:42.230
<v Speaker 1>you can think of a reference to a

00:47:42.230 --> 00:47:44.310
<v Speaker 1>string as an STR

00:47:44.630 --> 00:47:45.350
<v Speaker 1>with

00:47:45.430 --> 00:47:46.710
<v Speaker 1>a lifetime

00:47:46.950 --> 00:47:48.710
<v Speaker 1>shorter than the string.

00:47:49.110 --> 00:47:49.670
<v Speaker 1>So

00:47:49.990 --> 00:47:51.590
<v Speaker 1>when we talk about lifetimes,

00:47:52.765 --> 00:47:55.485
<v Speaker 1>if I made some string processing function,

00:47:55.805 --> 00:47:57.405
<v Speaker 1>like split,

00:47:58.445 --> 00:47:59.405
<v Speaker 1>took in

00:48:00.765 --> 00:48:01.965
<v Speaker 1>one of these

00:48:02.685 --> 00:48:04.285
<v Speaker 1>string STRs,

00:48:04.285 --> 00:48:06.525
<v Speaker 1>which is one of these unknown slices

00:48:06.660 --> 00:48:08.580
<v Speaker 1>So I didn't own the memory.

00:48:15.859 --> 00:48:17.140
<v Speaker 1>It would essentially

00:48:17.140 --> 00:48:18.100
<v Speaker 1>be doing

00:48:18.260 --> 00:48:20.660
<v Speaker 1>this where I have this lifetime,

00:48:20.660 --> 00:48:23.305
<v Speaker 1>which is just a generic type. You know,

00:48:23.305 --> 00:48:25.465
<v Speaker 1>if you're you've written a lot of Rust,

00:48:25.465 --> 00:48:27.625
<v Speaker 1>you might be used to seeing generics like

00:48:27.625 --> 00:48:28.185
<v Speaker 1>this.

00:48:28.585 --> 00:48:31.385
<v Speaker 1>Lifetimes are just another type, basically.

00:48:34.105 --> 00:48:35.545
<v Speaker 1>What's that saying

00:48:37.059 --> 00:48:38.820
<v Speaker 1>is just that

00:48:38.980 --> 00:48:40.980
<v Speaker 1>the x str

00:48:41.299 --> 00:48:44.980
<v Speaker 1>has the same lifetime as the function's call.

00:48:46.660 --> 00:48:48.660
<v Speaker 1>So you can think of

00:48:49.265 --> 00:48:50.545
<v Speaker 1>starting

00:48:50.865 --> 00:48:51.505
<v Speaker 1>here

00:48:51.665 --> 00:48:53.185
<v Speaker 1>and then ending

00:48:53.745 --> 00:48:54.385
<v Speaker 1>here.

00:48:54.705 --> 00:48:57.025
<v Speaker 1>So when I pass in the STR up

00:48:57.025 --> 00:48:57.585
<v Speaker 1>here,

00:49:00.945 --> 00:49:02.609
<v Speaker 1>that that reference

00:49:02.609 --> 00:49:05.170
<v Speaker 1>will only be alive until line 13

00:49:06.049 --> 00:49:06.850
<v Speaker 0>Okay.

00:49:07.250 --> 00:49:09.970
<v Speaker 1>Because I'm not I'm not assigning it here.

00:49:09.970 --> 00:49:11.570
<v Speaker 1>So if I had, like, let

00:49:12.450 --> 00:49:13.170
<v Speaker 1>ref

00:49:14.849 --> 00:49:16.049
<v Speaker 1>thing equal this,

00:49:16.695 --> 00:49:18.215
<v Speaker 1>and I did return

00:49:18.295 --> 00:49:20.055
<v Speaker 1>that same STR,

00:49:21.415 --> 00:49:23.815
<v Speaker 1>it would persist all the way through to

00:49:23.815 --> 00:49:24.455
<v Speaker 1>here.

00:49:26.215 --> 00:49:28.615
<v Speaker 0>Right. Okay. Yeah.

00:49:29.575 --> 00:49:32.650
<v Speaker 1>So there's a big difference between an unowned

00:49:32.650 --> 00:49:34.570
<v Speaker 1>type and an unowned type.

00:49:34.730 --> 00:49:35.610
<v Speaker 1>References,

00:49:35.610 --> 00:49:37.850
<v Speaker 1>as we saw in wrestlings,

00:49:37.850 --> 00:49:38.410
<v Speaker 1>allow

00:49:40.170 --> 00:49:41.850
<v Speaker 1>us to work with them. But when you

00:49:41.850 --> 00:49:45.605
<v Speaker 1>get into scenarios where you references of references,

00:49:45.765 --> 00:49:48.245
<v Speaker 1>lifetimes are really powerful because,

00:49:48.805 --> 00:49:50.885
<v Speaker 1>you know, in this case, this is obvious.

00:49:50.885 --> 00:49:52.805
<v Speaker 1>You know, if you give me a string

00:49:54.165 --> 00:49:56.570
<v Speaker 1>and I return to you one of these

00:49:56.730 --> 00:49:58.490
<v Speaker 1>sorry. If you give to me an STR

00:49:58.490 --> 00:50:00.410
<v Speaker 1>and I return to you an STR,

00:50:00.570 --> 00:50:02.330
<v Speaker 1>they pretty much have to be of the

00:50:02.330 --> 00:50:03.370
<v Speaker 1>same lifetime.

00:50:04.010 --> 00:50:05.770
<v Speaker 1>Because if you give me unknown memory and

00:50:05.770 --> 00:50:07.930
<v Speaker 1>I give you a pointer to unknown memory

00:50:07.930 --> 00:50:10.170
<v Speaker 1>that's within that unknown memory, I can't do

00:50:10.170 --> 00:50:12.195
<v Speaker 1>anything other than promise that it will be

00:50:12.195 --> 00:50:13.955
<v Speaker 1>valid for as long as the unknown memory

00:50:13.955 --> 00:50:14.755
<v Speaker 1>is valid.

00:50:15.715 --> 00:50:18.915
<v Speaker 1>But let's say we were writing a split,

00:50:19.075 --> 00:50:21.315
<v Speaker 1>so we we are actually splitting up this

00:50:21.315 --> 00:50:21.955
<v Speaker 1>this

00:50:22.755 --> 00:50:24.435
<v Speaker 1>this unknown slice.

00:50:24.995 --> 00:50:28.540
<v Speaker 1>We might have some, you know, set

00:50:28.619 --> 00:50:29.340
<v Speaker 1>of

00:50:30.619 --> 00:50:33.820
<v Speaker 1>subsets of this STR. So we might return

00:50:36.140 --> 00:50:37.420
<v Speaker 1>a back of

00:50:38.780 --> 00:50:39.900
<v Speaker 1>STR instead.

00:50:42.795 --> 00:50:44.875
<v Speaker 1>It still all have the same lifetime, so

00:50:44.875 --> 00:50:46.155
<v Speaker 1>it doesn't really matter.

00:50:49.275 --> 00:50:51.755
<v Speaker 1>But I've probably written very broken code here,

00:50:51.755 --> 00:50:53.115
<v Speaker 0>so I hesitate

00:50:53.515 --> 00:50:54.875
<v Speaker 1>anyone trying to run it.

00:50:56.060 --> 00:50:58.860
<v Speaker 1>But, you know, lifetimes Sorry. Let me go.

00:50:59.180 --> 00:51:01.020
<v Speaker 1>Go ahead. I was gonna say, one of

00:51:01.020 --> 00:51:02.700
<v Speaker 0>the weird situations I always seem to get

00:51:02.700 --> 00:51:04.860
<v Speaker 0>myself into, and I've never really understood it,

00:51:04.860 --> 00:51:06.860
<v Speaker 0>has been like I write a function,

00:51:07.260 --> 00:51:09.020
<v Speaker 0>and it tells me that the value doesn't

00:51:09.020 --> 00:51:10.460
<v Speaker 0>live long enough to be returned.

00:51:11.715 --> 00:51:15.075
<v Speaker 1>So usually, that's because you're doing something like

00:51:22.035 --> 00:51:24.610
<v Speaker 1>you're trying to return a reference

00:51:26.130 --> 00:51:26.930
<v Speaker 1>to,

00:51:30.450 --> 00:51:33.090
<v Speaker 1>say I did let a equal

00:51:36.305 --> 00:51:38.464
<v Speaker 1>And then I return a. This would actually

00:51:38.464 --> 00:51:39.825
<v Speaker 1>be quite valid,

00:51:41.505 --> 00:51:42.145
<v Speaker 1>because

00:51:42.305 --> 00:51:44.785
<v Speaker 1>the let a equals thing there

00:51:44.944 --> 00:51:46.944
<v Speaker 1>is a static string

00:51:47.360 --> 00:51:49.600
<v Speaker 1>gets actually written into the binary.

00:51:49.920 --> 00:51:51.760
<v Speaker 1>So if I was to run string mean

00:51:51.760 --> 00:51:52.880
<v Speaker 0>that is

00:51:53.840 --> 00:51:54.560
<v Speaker 0>this?

00:51:54.960 --> 00:51:57.360
<v Speaker 1>Yeah. That's that. Right. So

00:51:58.080 --> 00:52:00.005
<v Speaker 1>the static means is that it's gonna be

00:52:00.005 --> 00:52:01.445
<v Speaker 1>alive for the whole time.

00:52:02.085 --> 00:52:04.645
<v Speaker 1>So, like, this is completely valid that

00:52:05.445 --> 00:52:06.725
<v Speaker 1>you could make it

00:52:07.125 --> 00:52:09.365
<v Speaker 1>like that. This is a valid function, and

00:52:09.365 --> 00:52:12.405
<v Speaker 1>it's fine. Okay. But the moment I try

00:52:12.405 --> 00:52:13.285
<v Speaker 1>and do

00:52:20.289 --> 00:52:22.210
<v Speaker 1>let's say I do this and I do

00:52:22.210 --> 00:52:24.529
<v Speaker 1>ref of a

00:52:29.095 --> 00:52:29.975
<v Speaker 1>like that.

00:52:30.775 --> 00:52:32.375
<v Speaker 1>And then I try and return ref of

00:52:32.375 --> 00:52:33.015
<v Speaker 1>a.

00:52:34.375 --> 00:52:37.335
<v Speaker 1>Because I'm trying to return a reference

00:52:38.135 --> 00:52:40.615
<v Speaker 1>to some memory that is only alive during

00:52:40.615 --> 00:52:43.335
<v Speaker 1>the function call, this owned buffer,

00:52:43.700 --> 00:52:44.420
<v Speaker 1>Mhmm.

00:52:46.420 --> 00:52:48.020
<v Speaker 1>That value is not going to be around

00:52:48.020 --> 00:52:49.620
<v Speaker 1>at the end after the end of the

00:52:49.620 --> 00:52:51.700
<v Speaker 1>function call. So in main,

00:52:51.700 --> 00:52:53.620
<v Speaker 1>when I called this up here,

00:52:54.820 --> 00:52:57.220
<v Speaker 1>one thing like this. Yep.

00:52:59.984 --> 00:53:02.065
<v Speaker 1>X in this case would be an invalid

00:53:02.065 --> 00:53:03.185
<v Speaker 1>pointer. Right?

00:53:03.984 --> 00:53:06.145
<v Speaker 0>Okay. So can we make this explicit? I

00:53:06.145 --> 00:53:08.145
<v Speaker 0>wanna see if I understand this correctly. Yeah.

00:53:08.145 --> 00:53:10.865
<v Speaker 0>We're saying all functions already have a lifetime.

00:53:10.865 --> 00:53:12.065
<v Speaker 0>Where where does that go?

00:53:12.710 --> 00:53:14.869
<v Speaker 0>Is it Yeah. So this is like an

00:53:14.869 --> 00:53:15.430
<v Speaker 0>a?

00:53:16.470 --> 00:53:18.230
<v Speaker 1>Yeah. So like you could think of all

00:53:18.230 --> 00:53:20.150
<v Speaker 1>functions having a lifetime.

00:53:20.390 --> 00:53:22.630
<v Speaker 0>Then Which means that this here

00:53:23.269 --> 00:53:25.029
<v Speaker 0>is lifetime of

00:53:25.765 --> 00:53:26.405
<v Speaker 0>a.

00:53:27.605 --> 00:53:29.605
<v Speaker 0>I don't even know what I'm like, that's

00:53:29.605 --> 00:53:31.605
<v Speaker 0>reference. Would that have the same lifetime? You

00:53:34.005 --> 00:53:34.885
<v Speaker 1>could think of this

00:53:36.965 --> 00:53:37.605
<v Speaker 1>say

00:53:38.085 --> 00:53:40.920
<v Speaker 1>say we're doing something really complicated with string

00:53:40.920 --> 00:53:43.720
<v Speaker 1>processing, you might actually see something like

00:53:44.760 --> 00:53:45.560
<v Speaker 1>this.

00:53:46.520 --> 00:53:47.800
<v Speaker 0>No. I don't like it.

00:53:48.280 --> 00:53:51.240
<v Speaker 1>Yeah. So this is about sub lifetimes.

00:53:51.320 --> 00:53:53.320
<v Speaker 1>And what this is saying is essentially, like,

00:53:53.694 --> 00:53:55.215
<v Speaker 1>all of the lifetimes

00:53:55.694 --> 00:53:56.494
<v Speaker 1>b

00:53:56.815 --> 00:53:59.775
<v Speaker 1>are shorter than or or, like, within the

00:53:59.775 --> 00:54:00.735
<v Speaker 1>realm of

00:54:01.214 --> 00:54:01.855
<v Speaker 1>a.

00:54:03.934 --> 00:54:06.095
<v Speaker 1>And, yeah, you don't like that, but that's

00:54:06.095 --> 00:54:09.340
<v Speaker 1>fundamentally what's happening. It's like, this is some

00:54:09.579 --> 00:54:12.780
<v Speaker 1>some random lifetime called who knows what.

00:54:13.020 --> 00:54:15.260
<v Speaker 1>That's a sub lifetime of a.

00:54:16.540 --> 00:54:17.580
<v Speaker 0>Right. Okay.

00:54:18.060 --> 00:54:19.579
<v Speaker 0>Yeah. I think I I need to do

00:54:19.579 --> 00:54:21.420
<v Speaker 0>some reading on life science. And I I

00:54:21.500 --> 00:54:24.105
<v Speaker 0>based actually now just on where this going,

00:54:24.105 --> 00:54:25.785
<v Speaker 0>I feel like this life science are probably

00:54:25.785 --> 00:54:28.585
<v Speaker 0>an entire episode on their own with like,

00:54:28.585 --> 00:54:30.505
<v Speaker 0>I don't even know sub life times were

00:54:30.505 --> 00:54:32.345
<v Speaker 0>a thing. Sub life times.

00:54:32.825 --> 00:54:33.545
<v Speaker 1>Yeah.

00:54:34.025 --> 00:54:35.945
<v Speaker 1>Well, I you know, we could also talk

00:54:35.945 --> 00:54:36.265
<v Speaker 1>about

00:54:36.930 --> 00:54:39.970
<v Speaker 1>ARC and RC and how boxes work. There's

00:54:39.970 --> 00:54:41.330
<v Speaker 1>lots of fun to be had.

00:54:41.730 --> 00:54:43.970
<v Speaker 0>So boxes are just something that I've only

00:54:43.970 --> 00:54:46.130
<v Speaker 0>just started using since I've been working on

00:54:46.130 --> 00:54:48.530
<v Speaker 0>Hong Kong Triad just because I have so

00:54:48.530 --> 00:54:50.125
<v Speaker 0>many different, like,

00:54:50.445 --> 00:54:52.205
<v Speaker 0>subtypes on enums

00:54:52.205 --> 00:54:53.565
<v Speaker 0>and I I kinda need to them to

00:54:53.565 --> 00:54:55.245
<v Speaker 0>pass those around. So I feel dragged

00:54:56.125 --> 00:54:58.445
<v Speaker 0>into learning that, but they're slowly starting to

00:54:58.445 --> 00:55:00.845
<v Speaker 0>make sense. And I and I understand it.

00:55:00.845 --> 00:55:02.880
<v Speaker 0>It's like we have this thing of size

00:55:02.880 --> 00:55:04.240
<v Speaker 0>and a box is a way to pass

00:55:04.240 --> 00:55:05.920
<v Speaker 0>around. Like, I think it's just a pointer

00:55:05.920 --> 00:55:08.319
<v Speaker 0>to it. Is that right? Yeah. So turning

00:55:08.319 --> 00:55:10.079
<v Speaker 1>something into a box puts it on the

00:55:10.079 --> 00:55:10.640
<v Speaker 1>heap.

00:55:11.119 --> 00:55:12.480
<v Speaker 1>And then so if you do like a

00:55:12.480 --> 00:55:13.840
<v Speaker 1>boxed in

00:55:14.240 --> 00:55:14.480
<v Speaker 1>trait,

00:55:15.295 --> 00:55:17.615
<v Speaker 1>that just basically is putting a pointer to

00:55:17.615 --> 00:55:20.095
<v Speaker 1>the v table on the on the heap.

00:55:21.455 --> 00:55:22.175
<v Speaker 0>Okay.

00:55:22.655 --> 00:55:24.975
<v Speaker 0>I think what we'll do, just given the

00:55:24.975 --> 00:55:26.815
<v Speaker 0>time and how much more stuff we could

00:55:26.815 --> 00:55:28.790
<v Speaker 0>potentially go into, is I would just chat

00:55:28.790 --> 00:55:30.630
<v Speaker 0>with you later and we'll maybe see if

00:55:30.630 --> 00:55:32.310
<v Speaker 0>you're up for doing another episode where we

00:55:32.310 --> 00:55:34.230
<v Speaker 0>look at all those other cool that I

00:55:34.230 --> 00:55:35.750
<v Speaker 0>have no idea about.

00:55:36.230 --> 00:55:37.830
<v Speaker 0>But that

00:55:37.990 --> 00:55:40.150
<v Speaker 0>was really helpful for me. Like, just going

00:55:40.150 --> 00:55:42.470
<v Speaker 0>through those most semantic things and having, you

00:55:42.470 --> 00:55:44.695
<v Speaker 0>know, your experience help guide us and and

00:55:44.695 --> 00:55:46.775
<v Speaker 0>just even explaining it all really, really helps.

00:55:46.775 --> 00:55:48.375
<v Speaker 0>And I hope that other people got value

00:55:48.375 --> 00:55:50.535
<v Speaker 0>from that as well. So Yeah. I had

00:55:50.535 --> 00:55:52.295
<v Speaker 1>a lot of fun. Next time, you'll have

00:55:52.295 --> 00:55:54.535
<v Speaker 1>to let me make some some good examples

00:55:54.535 --> 00:55:54.935
<v Speaker 1>too.

00:55:56.600 --> 00:55:58.280
<v Speaker 0>No. That's not a lie on this show.

00:55:58.280 --> 00:56:00.760
<v Speaker 0>No. No. All examples must be terrible, terrible,

00:56:00.760 --> 00:56:03.560
<v Speaker 0>terrible. Although your examples were definitely perfectly fine.

00:56:03.640 --> 00:56:04.920
<v Speaker 0>I brought the terrible.

00:56:05.480 --> 00:56:06.120
<v Speaker 0>Thank

00:56:06.440 --> 00:56:07.800
<v Speaker 0>you for I don't know. I wrote some

00:56:07.800 --> 00:56:09.000
<v Speaker 1>pretty trash code there.

00:56:11.155 --> 00:56:13.315
<v Speaker 0>Well, I think when it's in the name

00:56:13.315 --> 00:56:16.675
<v Speaker 0>of explaining concepts, that that is perfectly valid.

00:56:16.675 --> 00:56:17.955
<v Speaker 0>Perfectly valid code.

00:56:18.355 --> 00:56:20.035
<v Speaker 0>And we got a thank you from the

00:56:20.035 --> 00:56:21.075
<v Speaker 0>Nina as well.

00:56:21.795 --> 00:56:23.555
<v Speaker 0>I will reiterate that. Thank you so much

00:56:23.555 --> 00:56:25.160
<v Speaker 0>for taking time out of your day and

00:56:25.160 --> 00:56:27.400
<v Speaker 0>walking me through this. Like I said, that

00:56:27.400 --> 00:56:29.320
<v Speaker 0>was really, really, really helpful.

00:56:31.000 --> 00:56:32.600
<v Speaker 1>Looking forward me.

00:56:33.720 --> 00:56:35.800
<v Speaker 0>And I'm looking forward to hopefully having another

00:56:35.800 --> 00:56:38.360
<v Speaker 0>episode. And your dog is looking mighty cute

00:56:38.360 --> 00:56:39.560
<v Speaker 0>in the background. Yeah.

00:56:41.415 --> 00:56:43.335
<v Speaker 1>Well, feel free to connect with me on

00:56:43.335 --> 00:56:45.815
<v Speaker 1>Twitter or whatever, and happy to say hi

00:56:45.815 --> 00:56:48.615
<v Speaker 1>to all your folks. Awesome. Thanks so much.

00:56:48.935 --> 00:56:50.535
<v Speaker 0>Alright. Have a a great day, and I

00:56:50.535 --> 00:56:52.135
<v Speaker 0>will speak to you again soon. Thank you.

00:56:52.455 --> 00:56:52.935
<v Speaker 1>Bye.
