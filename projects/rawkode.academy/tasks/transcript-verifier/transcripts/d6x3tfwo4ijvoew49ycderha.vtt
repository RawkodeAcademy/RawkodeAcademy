WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: b41b8a6d-e8ba-42d6-ae5f-8bd30957a499
Created: 2025-04-29T20:57:06.674Z
Duration: 4918.051
Channels: 1

00:01:09.865 --> 00:01:12.744
<v Speaker 0>Hello, and welcome to today's episode of Rawkode

00:01:12.744 --> 00:01:14.825
<v Speaker 0>live. I'm your host, Rawkode.

00:01:15.145 --> 00:01:16.905
<v Speaker 0>Before we get started, I just wanna take

00:01:16.905 --> 00:01:18.344
<v Speaker 0>ten seconds to say thank you to my

00:01:18.344 --> 00:01:20.825
<v Speaker 0>employer, Equinix Metal. Equinix Metal is a bare

00:01:20.825 --> 00:01:24.290
<v Speaker 0>metal cloud, and they actually encouraged me to

00:01:24.370 --> 00:01:26.690
<v Speaker 0>keep producing that series and and all producing

00:01:26.690 --> 00:01:29.170
<v Speaker 0>quality cloud native content where we can all

00:01:29.170 --> 00:01:31.250
<v Speaker 0>learn together. So, you know, thank you to

00:01:31.250 --> 00:01:33.490
<v Speaker 0>them. If you wanna check out Equinix Medal,

00:01:33.490 --> 00:01:35.970
<v Speaker 0>please use the code Rawkode dash live. This

00:01:35.970 --> 00:01:38.305
<v Speaker 0>will get you $50 in credit, which is

00:01:38.305 --> 00:01:40.225
<v Speaker 0>roughly around a hundred hours of bare metal

00:01:40.225 --> 00:01:41.105
<v Speaker 0>compute time.

00:01:41.905 --> 00:01:43.425
<v Speaker 0>Alright. Today,

00:01:43.505 --> 00:01:45.265
<v Speaker 0>we're gonna be taking a look at Rust

00:01:45.265 --> 00:01:47.265
<v Speaker 0>again. This is part two. We've been walking

00:01:47.265 --> 00:01:48.945
<v Speaker 0>through the Rustlands exercises.

00:01:49.025 --> 00:01:51.505
<v Speaker 0>Today, I am joined by Manish Gorekakar,

00:01:51.950 --> 00:01:54.509
<v Speaker 0>a Rust core team member and the lead

00:01:54.509 --> 00:01:56.670
<v Speaker 0>of the Rust dev tools. Hey, Manish. How

00:01:56.670 --> 00:01:58.829
<v Speaker 0>are you? I'm doing great. How are you?

00:01:58.829 --> 00:02:01.710
<v Speaker 1>Awesome. Very well. Thank you. I'm looking forward

00:02:01.710 --> 00:02:03.710
<v Speaker 0>to learning more Rust today. So, you know,

00:02:03.710 --> 00:02:04.829
<v Speaker 0>definitely a good day.

00:02:05.604 --> 00:02:07.284
<v Speaker 0>Do you wanna just give us a little

00:02:07.284 --> 00:02:09.205
<v Speaker 0>bit of an introduction about yourself? Tell us

00:02:09.205 --> 00:02:10.405
<v Speaker 0>a little bit more about you.

00:02:10.884 --> 00:02:11.685
<v Speaker 1>Sure.

00:02:11.685 --> 00:02:14.645
<v Speaker 1>I mean, I I've been doing Rust since

00:02:14.724 --> 00:02:16.885
<v Speaker 1>2013,

00:02:16.885 --> 00:02:17.525
<v Speaker 1>'20 '14

00:02:18.450 --> 00:02:20.610
<v Speaker 1>before it was stable when Rust used to

00:02:20.610 --> 00:02:22.610
<v Speaker 1>break all the time. It was not really

00:02:22.610 --> 00:02:24.610
<v Speaker 1>a great time, but it was, pretty fun

00:02:24.610 --> 00:02:26.530
<v Speaker 1>to get involved, like, back then when there

00:02:26.530 --> 00:02:28.290
<v Speaker 1>was a lot of lot of chance to

00:02:28.290 --> 00:02:30.130
<v Speaker 1>make some impact on the language.

00:02:30.690 --> 00:02:33.185
<v Speaker 1>For the last four years, I've been,

00:02:33.585 --> 00:02:35.425
<v Speaker 1>working at Mozilla on

00:02:35.585 --> 00:02:38.545
<v Speaker 1>the Stylo web browser sorry, the Servo web

00:02:38.545 --> 00:02:39.185
<v Speaker 1>browser.

00:02:40.545 --> 00:02:42.465
<v Speaker 1>Stylo was a part of that. And,

00:02:43.700 --> 00:02:45.860
<v Speaker 1>actually, starting next week, I'm gonna be working

00:02:45.860 --> 00:02:47.540
<v Speaker 1>at Google on their internationalization

00:02:47.540 --> 00:02:49.459
<v Speaker 1>team doing a Rust internationalization

00:02:49.459 --> 00:02:50.020
<v Speaker 1>stuff.

00:02:50.739 --> 00:02:52.020
<v Speaker 0>Nice. Very cool.

00:02:52.900 --> 00:02:53.540
<v Speaker 1>Yeah.

00:02:54.659 --> 00:02:55.780
<v Speaker 0>Okay. So

00:02:56.704 --> 00:02:58.545
<v Speaker 0>I guess I should ask first. I mean,

00:02:58.545 --> 00:03:01.025
<v Speaker 0>have you've been using Rust a long time.

00:03:01.025 --> 00:03:03.105
<v Speaker 0>So you're probably not that familiar with the

00:03:03.105 --> 00:03:05.265
<v Speaker 0>Rustler's exercises. Have you done them before?

00:03:06.385 --> 00:03:08.944
<v Speaker 1>I have gone through them at some point.

00:03:08.944 --> 00:03:11.870
<v Speaker 1>I've poked around. I've suggested them to many

00:03:11.870 --> 00:03:14.750
<v Speaker 1>people, but I've not gone through them, like,

00:03:14.990 --> 00:03:16.030
<v Speaker 1>bit by bit

00:03:16.350 --> 00:03:17.150
<v Speaker 1>myself.

00:03:17.390 --> 00:03:19.630
<v Speaker 1>I've done, like, a couple and, like, read

00:03:19.630 --> 00:03:22.270
<v Speaker 1>through them. But yeah. Cool. Well, there have

00:03:22.270 --> 00:03:23.390
<v Speaker 0>I, so this should be fun.

00:03:24.315 --> 00:03:27.115
<v Speaker 0>Right. Let's oh, we have a hello.

00:03:27.515 --> 00:03:30.555
<v Speaker 0>Hey, Sangam. Nice to meet you. Hey. So

00:03:32.475 --> 00:03:34.315
<v Speaker 0>if anyone wants to do this on their

00:03:34.315 --> 00:03:35.035
<v Speaker 0>own time,

00:03:35.275 --> 00:03:36.635
<v Speaker 0>these are great exercises.

00:03:36.635 --> 00:03:38.395
<v Speaker 0>They've been recommended to me many times. So

00:03:38.395 --> 00:03:40.160
<v Speaker 0>this is why we're doing this today. They're

00:03:40.160 --> 00:03:42.320
<v Speaker 0>Rust dash Lang slash Rustlings.

00:03:42.560 --> 00:03:44.080
<v Speaker 0>We did do a few of them the

00:03:44.080 --> 00:03:46.480
<v Speaker 0>other day. Jesus. That was

00:03:46.879 --> 00:03:48.800
<v Speaker 0>Tuesday. Yeah. There we go. This is Friday.

00:03:48.800 --> 00:03:49.680
<v Speaker 0>That was Tuesday.

00:03:50.080 --> 00:03:52.319
<v Speaker 0>The way this works is I run Rustling's

00:03:52.319 --> 00:03:52.560
<v Speaker 0>watch.

00:03:53.535 --> 00:03:54.975
<v Speaker 0>It's gonna give me a few text and

00:03:54.975 --> 00:03:57.295
<v Speaker 0>say, yep, we did variables, we did functions.

00:03:57.615 --> 00:03:59.135
<v Speaker 0>I don't know why functions isn't there, but

00:03:59.135 --> 00:03:59.855
<v Speaker 0>it doesn't matter.

00:04:00.175 --> 00:04:01.455
<v Speaker 0>And so they're telling us that the next

00:04:01.455 --> 00:04:02.815
<v Speaker 0>exercise we wanna attempt

00:04:03.375 --> 00:04:06.735
<v Speaker 0>is conditional slash f statements. So we'll start

00:04:06.735 --> 00:04:08.575
<v Speaker 0>there. We may jump around a little bit

00:04:09.260 --> 00:04:10.620
<v Speaker 0>and we'll just see what happens.

00:04:11.180 --> 00:04:13.500
<v Speaker 0>We are using Versus Code live share today.

00:04:13.500 --> 00:04:15.019
<v Speaker 0>So Manish and I can both see the

00:04:15.019 --> 00:04:17.100
<v Speaker 0>same code. You also have the ability to

00:04:17.100 --> 00:04:19.019
<v Speaker 0>type and fix my very broken code, I'm

00:04:19.019 --> 00:04:19.500
<v Speaker 0>sure.

00:04:20.380 --> 00:04:21.899
<v Speaker 0>And we'll see what happens. So

00:04:23.415 --> 00:04:25.415
<v Speaker 0>if you doesn't catch us on Tuesday, the

00:04:25.415 --> 00:04:27.335
<v Speaker 0>format for these rustling seems to be that

00:04:27.335 --> 00:04:29.095
<v Speaker 0>we get some sort of test.

00:04:29.815 --> 00:04:31.815
<v Speaker 0>We then have something else that needs completed

00:04:31.815 --> 00:04:33.495
<v Speaker 0>for those tests to pass.

00:04:33.815 --> 00:04:35.095
<v Speaker 0>And then when we're happy with that, we

00:04:35.095 --> 00:04:36.980
<v Speaker 0>have to remove this I am done. Why

00:04:36.980 --> 00:04:38.100
<v Speaker 0>am I telling you we have to remove

00:04:38.100 --> 00:04:40.020
<v Speaker 0>the I am done? Because I will probably

00:04:40.020 --> 00:04:41.780
<v Speaker 0>forget. So, you know, I'll need a little

00:04:41.780 --> 00:04:42.980
<v Speaker 0>reminder, I'm sure.

00:04:44.180 --> 00:04:46.420
<v Speaker 0>If we take a look at these tests

00:04:48.275 --> 00:04:50.275
<v Speaker 0>Okay. So we have some sort of assertion

00:04:50.275 --> 00:04:51.715
<v Speaker 0>that 10

00:04:52.675 --> 00:04:54.355
<v Speaker 0>and then we get a bigger function which

00:04:54.355 --> 00:04:56.355
<v Speaker 0>should return. Alright. This seems

00:04:56.995 --> 00:04:58.915
<v Speaker 0>trivial. This is a nice easy start. Right?

00:04:58.915 --> 00:05:01.009
<v Speaker 0>This just wants me to do an f

00:05:01.009 --> 00:05:03.009
<v Speaker 0>statement to check for which number is bigger

00:05:03.009 --> 00:05:04.290
<v Speaker 0>between a and b.

00:05:04.850 --> 00:05:05.650
<v Speaker 0>Awesome.

00:05:06.850 --> 00:05:07.570
<v Speaker 0>Okay.

00:05:12.130 --> 00:05:15.265
<v Speaker 0>I remember correctly from Tuesday's session, the curly

00:05:15.265 --> 00:05:17.345
<v Speaker 0>brackets are optional in Rust. Is that right?

00:05:17.345 --> 00:05:18.625
<v Speaker 1>The

00:05:18.625 --> 00:05:21.265
<v Speaker 1>the parentheses in if and four are optional.

00:05:21.265 --> 00:05:23.025
<v Speaker 1>The curly brackets are mandatory.

00:05:23.425 --> 00:05:25.505
<v Speaker 0>Oh, yeah. Yeah. Okay. Opposite of what, like,

00:05:25.505 --> 00:05:27.905
<v Speaker 1>JavaScript and c do. This is sometimes confusing.

00:05:28.909 --> 00:05:29.710
<v Speaker 0>Okay.

00:05:30.750 --> 00:05:32.349
<v Speaker 0>So it's I start I try it. It's

00:05:32.349 --> 00:05:34.830
<v Speaker 0>like Golang in this respect. Yes. Okay. Okay.

00:05:34.830 --> 00:05:36.909
<v Speaker 0>So we can say f a is larger

00:05:36.909 --> 00:05:37.870
<v Speaker 0>than b.

00:05:38.590 --> 00:05:41.615
<v Speaker 0>Oh, and then I remembered this. So Yes.

00:05:41.695 --> 00:05:43.295
<v Speaker 1>You don't have to write the return if

00:05:43.295 --> 00:05:44.255
<v Speaker 1>it's at the end.

00:05:44.895 --> 00:05:45.615
<v Speaker 0>Yeah.

00:05:47.855 --> 00:05:50.495
<v Speaker 0>I really like them as them bindings of

00:05:50.495 --> 00:05:52.495
<v Speaker 0>Versus code. They're so annoying that every time

00:05:52.495 --> 00:05:53.935
<v Speaker 0>I get, like, a complete here, I don't

00:05:53.935 --> 00:05:55.940
<v Speaker 0>know how to make it go away. Like,

00:05:55.940 --> 00:05:56.980
<v Speaker 0>if I push up and down

00:05:57.780 --> 00:05:59.220
<v Speaker 0>left and right. There we go. See, you're

00:05:59.220 --> 00:06:00.180
<v Speaker 0>solving problems.

00:06:01.460 --> 00:06:02.260
<v Speaker 0>Now

00:06:02.980 --> 00:06:04.820
<v Speaker 0>does this code look okay to you?

00:06:05.380 --> 00:06:06.100
<v Speaker 1>Looks

00:06:06.500 --> 00:06:07.220
<v Speaker 1>fine to me.

00:06:08.065 --> 00:06:09.745
<v Speaker 0>Alright. And so

00:06:09.825 --> 00:06:12.065
<v Speaker 0>a is better than b, return b. Now

00:06:12.065 --> 00:06:13.665
<v Speaker 0>if we can just recap some things for

00:06:13.665 --> 00:06:15.425
<v Speaker 0>anyone who wasn't paying attention or wasn't even

00:06:15.425 --> 00:06:16.705
<v Speaker 0>watching on Tuesday.

00:06:17.025 --> 00:06:19.905
<v Speaker 0>This syntax puts out a semicolon, can you

00:06:19.905 --> 00:06:21.425
<v Speaker 0>give me a refresher of of what that

00:06:21.425 --> 00:06:23.025
<v Speaker 0>means? So basically,

00:06:23.610 --> 00:06:24.650
<v Speaker 1>in Rust,

00:06:24.889 --> 00:06:27.530
<v Speaker 1>at the if you have, like, a block

00:06:28.090 --> 00:06:30.009
<v Speaker 1>and you can do, like, I don't know,

00:06:30.250 --> 00:06:31.530
<v Speaker 1>some work in the block,

00:06:33.930 --> 00:06:35.930
<v Speaker 1>and the last line, if you say, like

00:06:36.090 --> 00:06:37.530
<v Speaker 1>I don't know. If I say five with

00:06:37.530 --> 00:06:40.225
<v Speaker 1>a semicolon, this means that the block doesn't

00:06:40.225 --> 00:06:42.225
<v Speaker 1>evaluate to any value. But if I don't

00:06:42.225 --> 00:06:43.664
<v Speaker 1>have a semicolon at the end of a

00:06:43.664 --> 00:06:45.745
<v Speaker 1>block, I can actually do, like, x equal

00:06:45.745 --> 00:06:46.945
<v Speaker 1>to this. And

00:06:47.664 --> 00:06:49.425
<v Speaker 1>now the value of x is gonna be

00:06:49.425 --> 00:06:51.905
<v Speaker 1>five after doing all these things, which means

00:06:51.905 --> 00:06:52.625
<v Speaker 1>that

00:06:52.890 --> 00:06:55.050
<v Speaker 1>if you want to return from a function,

00:06:55.530 --> 00:06:57.370
<v Speaker 1>you can just put, like, five here, and

00:06:57.370 --> 00:06:59.370
<v Speaker 1>it's gonna return five at the when when

00:06:59.370 --> 00:07:01.290
<v Speaker 1>it reaches the end of a function as

00:07:01.290 --> 00:07:02.890
<v Speaker 1>long as you omit the semicolon.

00:07:03.050 --> 00:07:05.450
<v Speaker 1>Similarly, you can nest that. So

00:07:05.985 --> 00:07:07.745
<v Speaker 1>now what we're doing is you can see

00:07:07.745 --> 00:07:10.145
<v Speaker 1>the highlight. Yeah. Yeah. You can. We are

00:07:10.145 --> 00:07:12.945
<v Speaker 1>returning this since there's no semicolon after the

00:07:12.945 --> 00:07:15.745
<v Speaker 1>if, this function is returning this the value

00:07:15.745 --> 00:07:17.345
<v Speaker 1>of this if block. And the value of

00:07:17.345 --> 00:07:19.185
<v Speaker 1>this if block is either a or b

00:07:19.990 --> 00:07:21.990
<v Speaker 1>because we have omitted the semicolons at the

00:07:21.990 --> 00:07:23.430
<v Speaker 1>end of each of these blocks.

00:07:24.550 --> 00:07:25.590
<v Speaker 0>Ah, okay.

00:07:26.389 --> 00:07:28.229
<v Speaker 0>So I'm I'm curious. You know, you've got

00:07:28.229 --> 00:07:29.910
<v Speaker 0>a lot of experience here.

00:07:31.030 --> 00:07:33.815
<v Speaker 0>Is this idiomatic Rust or would you do,

00:07:33.815 --> 00:07:35.895
<v Speaker 0>like, an early return here? Like, if I

00:07:35.895 --> 00:07:37.175
<v Speaker 0>mean, if you were writing this code for

00:07:37.175 --> 00:07:38.855
<v Speaker 0>yourself, you're you're happy with that. This is

00:07:38.855 --> 00:07:40.455
<v Speaker 0>good. Right? This is idiomatic.

00:07:40.535 --> 00:07:42.135
<v Speaker 1>Some people prefer doing

00:07:42.295 --> 00:07:43.175
<v Speaker 1>explicit

00:07:43.175 --> 00:07:43.975
<v Speaker 1>returns.

00:07:44.135 --> 00:07:45.495
<v Speaker 1>Like, there's some preferences.

00:07:46.180 --> 00:07:46.740
<v Speaker 1>But,

00:07:47.300 --> 00:07:50.020
<v Speaker 1>typically, it is very idiomatic to do use

00:07:50.020 --> 00:07:51.139
<v Speaker 1>the use

00:07:51.139 --> 00:07:53.300
<v Speaker 1>the remove not you don't use a semicolon

00:07:53.300 --> 00:07:55.139
<v Speaker 1>for a return at the end of the

00:07:55.139 --> 00:07:56.260
<v Speaker 1>blocks and tags.

00:07:56.740 --> 00:07:58.819
<v Speaker 0>Okay. Like, it's it's very idiomatic to do

00:07:58.819 --> 00:08:00.034
<v Speaker 1>that because then you can kind of just

00:08:00.034 --> 00:08:01.555
<v Speaker 1>look at the end of the function and

00:08:01.555 --> 00:08:03.155
<v Speaker 1>be like, this is what the function is.

00:08:03.155 --> 00:08:04.835
<v Speaker 1>If a greater than b, it's a, else

00:08:04.835 --> 00:08:06.435
<v Speaker 1>it's b. It's easier to read.

00:08:07.715 --> 00:08:09.715
<v Speaker 0>Is there a nicer syntax for that? I'm

00:08:09.715 --> 00:08:11.395
<v Speaker 0>thinking about other languages that have, like, a

00:08:11.395 --> 00:08:13.794
<v Speaker 0>turn a a ternary operator where I say

00:08:13.794 --> 00:08:15.480
<v Speaker 0>greater than b. Like, is is there a

00:08:15.480 --> 00:08:17.720
<v Speaker 0>way of the imagine Rust without the We

00:08:17.720 --> 00:08:19.320
<v Speaker 1>don't have that operator. We use the question

00:08:19.320 --> 00:08:20.760
<v Speaker 1>mark for something else as well.

00:08:22.200 --> 00:08:24.520
<v Speaker 1>And and we don't have the operator in

00:08:24.520 --> 00:08:26.520
<v Speaker 1>part because this works, so you can just

00:08:26.520 --> 00:08:27.800
<v Speaker 1>write that if statement.

00:08:28.375 --> 00:08:30.135
<v Speaker 1>Python does the same thing. Like, I mean,

00:08:30.135 --> 00:08:31.815
<v Speaker 1>in Python in Rust, you you would just

00:08:31.815 --> 00:08:33.335
<v Speaker 1>write if you wanted, like, a one line

00:08:33.335 --> 00:08:35.335
<v Speaker 1>turner, you just write if a greater than

00:08:35.335 --> 00:08:36.054
<v Speaker 1>b

00:08:36.294 --> 00:08:37.015
<v Speaker 1>a

00:08:37.495 --> 00:08:40.135
<v Speaker 1>l s b, which is kind of weird.

00:08:40.135 --> 00:08:41.575
<v Speaker 1>But in Python, you'd also do, like,

00:08:42.699 --> 00:08:45.180
<v Speaker 1>a if a greater than b l s

00:08:45.180 --> 00:08:45.820
<v Speaker 1>b,

00:08:46.060 --> 00:08:47.740
<v Speaker 1>which is similar.

00:08:50.060 --> 00:08:52.779
<v Speaker 1>But yeah. It's it's we don't have a

00:08:52.779 --> 00:08:54.540
<v Speaker 1>ternary operator, but we do have this, which

00:08:54.540 --> 00:08:55.899
<v Speaker 1>is close enough in most cases.

00:08:56.785 --> 00:08:58.065
<v Speaker 0>Okay. I'll take it.

00:08:58.785 --> 00:09:00.385
<v Speaker 0>Alright. And I'm just making sure the test

00:09:00.385 --> 00:09:02.545
<v Speaker 0>cases here don't return two numbers as the

00:09:02.545 --> 00:09:04.145
<v Speaker 0>same. That would be mean, but it doesn't

00:09:04.145 --> 00:09:07.265
<v Speaker 0>look like they do. So Yeah. Let's see.

00:09:07.265 --> 00:09:09.985
<v Speaker 0>Did that pass? It did. So we can

00:09:09.985 --> 00:09:11.185
<v Speaker 0>then move our I am done,

00:09:12.970 --> 00:09:15.130
<v Speaker 0>and it should move us on to f

00:09:15.130 --> 00:09:16.810
<v Speaker 0>two. There we go.

00:09:19.449 --> 00:09:20.410
<v Speaker 0>Alright.

00:09:21.050 --> 00:09:23.050
<v Speaker 0>Let's see what we got. We got test

00:09:23.050 --> 00:09:23.449
<v Speaker 0>for a.

00:09:39.930 --> 00:09:42.410
<v Speaker 0>Expects a string and we have an integer.

00:09:43.690 --> 00:09:45.610
<v Speaker 0>A naive implementation, I can just do that

00:09:45.610 --> 00:09:47.290
<v Speaker 0>to fix the first problem. Right?

00:09:47.770 --> 00:09:48.490
<v Speaker 1>Yep.

00:09:51.050 --> 00:09:53.050
<v Speaker 0>But then my tests fail

00:09:53.445 --> 00:09:56.405
<v Speaker 0>because we're supposed to be running or returning

00:09:57.045 --> 00:09:59.045
<v Speaker 0>baz or par. Okay. So

00:09:59.765 --> 00:10:02.245
<v Speaker 0>get the bar for fuzz and default to

00:10:02.245 --> 00:10:03.685
<v Speaker 0>baz test passing.

00:10:05.525 --> 00:10:07.445
<v Speaker 0>If I pass fuzz, I get foo. If

00:10:07.445 --> 00:10:08.805
<v Speaker 0>I pass fuzz, I get bar.

00:10:16.040 --> 00:10:17.720
<v Speaker 0>I mean, that's it seems a bit weird,

00:10:17.720 --> 00:10:19.720
<v Speaker 0>but I'm gonna just make that pass then.

00:10:19.880 --> 00:10:23.080
<v Speaker 0>Like so fuzz is foo and fuzz is

00:10:23.080 --> 00:10:23.480
<v Speaker 0>bar.

00:10:24.095 --> 00:10:24.815
<v Speaker 0>Yep.

00:10:25.215 --> 00:10:26.255
<v Speaker 0>Fuzz

00:10:27.695 --> 00:10:31.375
<v Speaker 0>fuzz

00:10:32.415 --> 00:10:34.255
<v Speaker 0>bar else.

00:10:36.735 --> 00:10:37.695
<v Speaker 0>Fuzz. Yeah.

00:10:42.880 --> 00:10:44.640
<v Speaker 0>Okay. To test

00:10:45.600 --> 00:10:47.600
<v Speaker 1>There's a small mistake. But

00:10:48.160 --> 00:10:50.960
<v Speaker 0>Oh, what's my my mistake? You'd you'd need

00:10:50.960 --> 00:10:53.120
<v Speaker 1>the physicist here as well. Yeah. Yeah. Alright.

00:10:53.120 --> 00:10:53.200
<v Speaker 0>Okay.

00:10:54.345 --> 00:10:56.425
<v Speaker 1>This isn't like a switch or a match,

00:10:57.545 --> 00:10:58.904
<v Speaker 1>but we do have that.

00:10:59.704 --> 00:11:02.665
<v Speaker 0>K. So so that passes. So this is

00:11:02.665 --> 00:11:04.584
<v Speaker 0>now not idiomatic Rust. Is that what you're

00:11:04.584 --> 00:11:06.024
<v Speaker 0>saying there? That's what probably No. No. I

00:11:06.024 --> 00:11:07.625
<v Speaker 1>was saying that you've forgotten the physic here,

00:11:07.625 --> 00:11:09.490
<v Speaker 1>but you added it. Would you use a

00:11:09.490 --> 00:11:10.610
<v Speaker 0>match here instead?

00:11:11.089 --> 00:11:12.210
<v Speaker 1>Oh, for

00:11:13.089 --> 00:11:17.010
<v Speaker 1>three cases, maybe, maybe not. I would personally

00:11:17.010 --> 00:11:19.089
<v Speaker 1>use a match. I don't know if that's

00:11:19.089 --> 00:11:20.130
<v Speaker 1>really more idiomatic.

00:11:21.445 --> 00:11:24.005
<v Speaker 1>Like, for this is fine, I think, idiomatic

00:11:24.005 --> 00:11:26.405
<v Speaker 1>wise. I would personally use a match, but

00:11:26.805 --> 00:11:28.325
<v Speaker 1>yeah. Can you do you mind showing us

00:11:28.325 --> 00:11:29.685
<v Speaker 0>the match syntax? That would be cool to

00:11:29.605 --> 00:11:30.005
<v Speaker 0>So

00:11:32.005 --> 00:11:33.925
<v Speaker 1>match syntax would look like

00:11:38.220 --> 00:11:40.220
<v Speaker 1>Oh, wait. No. It's backwards.

00:11:43.420 --> 00:11:44.940
<v Speaker 1>And fuzz.

00:11:46.460 --> 00:11:47.740
<v Speaker 1>So these are strings.

00:11:52.285 --> 00:11:53.325
<v Speaker 1>And then

00:11:55.884 --> 00:11:57.165
<v Speaker 1>that's a wildcard.

00:11:58.125 --> 00:12:00.365
<v Speaker 1>And this should probably

00:12:01.084 --> 00:12:02.524
<v Speaker 1>this should probably work.

00:12:03.005 --> 00:12:03.964
<v Speaker 0>Alright. Let's see.

00:12:05.150 --> 00:12:07.550
<v Speaker 0>Yeah. Okay. Cool. So the match sent I

00:12:07.550 --> 00:12:09.470
<v Speaker 0>mean, that looks pretty familiar. Like, a switch

00:12:09.470 --> 00:12:12.270
<v Speaker 0>case and other c derivative style languages

00:12:12.430 --> 00:12:14.270
<v Speaker 0>Yep. I guess, similar to what I've seen

00:12:14.270 --> 00:12:16.430
<v Speaker 0>in at least it follows a similar flow

00:12:16.430 --> 00:12:17.870
<v Speaker 0>to what I've seen in, like, Alexa as

00:12:17.870 --> 00:12:19.630
<v Speaker 0>well. The underscore is familiar.

00:12:20.265 --> 00:12:23.305
<v Speaker 0>Nice. Yeah. That's much cleaner. I'd probably probably

00:12:23.305 --> 00:12:24.185
<v Speaker 0>go with that one.

00:12:25.065 --> 00:12:27.225
<v Speaker 0>Okay. Let's remove. I am done.

00:12:27.625 --> 00:12:29.065
<v Speaker 0>For the people that are watching, if you

00:12:29.065 --> 00:12:30.905
<v Speaker 0>have questions or any syntax that you want

00:12:30.905 --> 00:12:32.105
<v Speaker 0>us to try and help you with, if

00:12:32.105 --> 00:12:33.465
<v Speaker 0>you've been trying to learn Rust on your

00:12:33.465 --> 00:12:35.130
<v Speaker 0>own, feel free to drop that in the

00:12:35.130 --> 00:12:36.410
<v Speaker 0>comments, and Manish and I will do our

00:12:36.410 --> 00:12:38.250
<v Speaker 0>best to try and cover that syntax too.

00:12:39.210 --> 00:12:40.650
<v Speaker 0>Okay. What do we got next?

00:12:41.290 --> 00:12:42.730
<v Speaker 0>Primitive types.

00:12:44.170 --> 00:12:46.089
<v Speaker 0>If I remember, we actually skipped these.

00:12:47.885 --> 00:12:49.964
<v Speaker 0>They were a bit derivative.

00:12:51.245 --> 00:12:53.964
<v Speaker 0>So why don't we pick something else then?

00:12:53.964 --> 00:12:54.845
<v Speaker 0>Let's see.

00:12:55.485 --> 00:12:57.084
<v Speaker 0>Anything you think would be fun that you

00:12:57.084 --> 00:12:58.285
<v Speaker 0>would like to do on this list?

00:13:01.170 --> 00:13:02.930
<v Speaker 1>I don't know. Like, have you touched any

00:13:02.930 --> 00:13:05.090
<v Speaker 1>of the moving and borrowing stuff yet?

00:13:07.330 --> 00:13:09.810
<v Speaker 0>No. But I I would love to to

00:13:09.810 --> 00:13:11.890
<v Speaker 0>move semantics where we popped up and opened.

00:13:11.890 --> 00:13:15.330
<v Speaker 1>Yeah. Alright. Okay. Let's get our test passing

00:13:15.330 --> 00:13:17.545
<v Speaker 0>then. So Rust watch

00:13:18.105 --> 00:13:20.345
<v Speaker 0>move semantics

00:13:20.665 --> 00:13:21.305
<v Speaker 0>one.

00:13:28.585 --> 00:13:30.505
<v Speaker 0>Is it moo oh, I can't spell. Is

00:13:30.505 --> 00:13:31.065
<v Speaker 0>that the problem?

00:13:33.520 --> 00:13:33.839
<v Speaker 0>That

00:13:38.320 --> 00:13:40.000
<v Speaker 0>Let's try Rustling's

00:13:40.000 --> 00:13:40.720
<v Speaker 0>run.

00:13:42.000 --> 00:13:43.600
<v Speaker 0>Yeah. That works. Let's do that. Okay.

00:13:44.285 --> 00:13:46.125
<v Speaker 0>So we have a message here. It says

00:13:46.125 --> 00:13:48.765
<v Speaker 0>we cannot borrow back one as mutable.

00:13:49.405 --> 00:13:52.205
<v Speaker 0>It's not declared as mutable. Alright. So that

00:13:53.405 --> 00:13:55.565
<v Speaker 0>doesn't seem too scary yet.

00:13:56.045 --> 00:13:56.685
<v Speaker 0>Let's see.

00:13:58.480 --> 00:13:59.840
<v Speaker 0>Oh, yeah. So this push must be the

00:13:59.840 --> 00:14:01.440
<v Speaker 0>fail. So lane 13.

00:14:02.000 --> 00:14:04.160
<v Speaker 0>Yeah. Okay. So that I can fix.

00:14:07.360 --> 00:14:08.000
<v Speaker 0>I think.

00:14:09.120 --> 00:14:09.600
<v Speaker 1>Yep.

00:14:10.964 --> 00:14:15.445
<v Speaker 1>All it wanted was to be. That's

00:14:15.445 --> 00:14:16.964
<v Speaker 0>not what I was expecting from the move

00:14:16.964 --> 00:14:19.365
<v Speaker 0>semantics first one. Maybe it's just easiness in.

00:14:19.365 --> 00:14:21.524
<v Speaker 1>This is easing us in. This

00:14:22.325 --> 00:14:23.605
<v Speaker 1>is very much easing us in.

00:14:24.540 --> 00:14:26.779
<v Speaker 1>Yeah. In fact, like, this is not a

00:14:26.779 --> 00:14:28.540
<v Speaker 1>mute this is just a mutability thing. This

00:14:28.540 --> 00:14:30.460
<v Speaker 1>is not a move semantics yet.

00:14:31.100 --> 00:14:33.019
<v Speaker 0>Oh, okay. So this one looks this one

00:14:33.019 --> 00:14:34.779
<v Speaker 0>is definitely another message to do with the

00:14:34.779 --> 00:14:37.100
<v Speaker 0>move semantics then. Move occurs because vex needle

00:14:37.100 --> 00:14:39.100
<v Speaker 0>has a type which does not implement the

00:14:39.100 --> 00:14:39.740
<v Speaker 0>copy trait.

00:14:40.275 --> 00:14:42.355
<v Speaker 0>Yeah. That seems a bit scarier. So let's

00:14:42.355 --> 00:14:43.635
<v Speaker 0>see what we're dealing with.

00:14:44.435 --> 00:14:45.075
<v Speaker 0>So

00:14:45.715 --> 00:14:47.955
<v Speaker 0>we declare a mutable vector

00:14:48.035 --> 00:14:49.395
<v Speaker 0>for this function.

00:14:49.875 --> 00:14:50.595
<v Speaker 0>Yep.

00:14:51.395 --> 00:14:54.035
<v Speaker 0>Okay. I'm assuming the effect of one push

00:14:54.035 --> 00:14:56.195
<v Speaker 0>is okay, so the error message is online.

00:15:00.070 --> 00:15:01.750
<v Speaker 0>Oh, is that 13 again?

00:15:02.630 --> 00:15:03.190
<v Speaker 1>So

00:15:03.510 --> 00:15:05.750
<v Speaker 1>let's look at the error message closer. Or

00:15:05.990 --> 00:15:07.750
<v Speaker 1>Yeah. I mean, what we can I what

00:15:07.750 --> 00:15:08.950
<v Speaker 1>I can what we can do is go

00:15:08.950 --> 00:15:10.550
<v Speaker 1>through the error message or I can explain

00:15:10.550 --> 00:15:12.235
<v Speaker 1>what move semantics are first?

00:15:13.514 --> 00:15:15.675
<v Speaker 0>Yeah. Let's let's cover that. Yeah. Me with

00:15:15.675 --> 00:15:16.394
<v Speaker 0>the basics.

00:15:16.954 --> 00:15:18.634
<v Speaker 1>So in Rust, basically,

00:15:19.194 --> 00:15:22.314
<v Speaker 1>there's some types like numbers which are copyable.

00:15:22.314 --> 00:15:24.475
<v Speaker 1>So if you have a number and you,

00:15:24.475 --> 00:15:26.634
<v Speaker 1>like, assign that number to another variable,

00:15:27.330 --> 00:15:29.410
<v Speaker 1>it'll just make a copy. So now you

00:15:29.410 --> 00:15:31.250
<v Speaker 1>have two variables with a number in them,

00:15:31.250 --> 00:15:32.850
<v Speaker 1>and they'll independently change.

00:15:33.410 --> 00:15:35.410
<v Speaker 1>But some things like so in Rust, a

00:15:35.410 --> 00:15:37.330
<v Speaker 1>vector is allocated on the heap.

00:15:38.210 --> 00:15:40.050
<v Speaker 1>So there's allocation involved,

00:15:40.210 --> 00:15:40.930
<v Speaker 1>and

00:15:41.665 --> 00:15:43.425
<v Speaker 1>it can be arbitrarily large.

00:15:43.745 --> 00:15:45.745
<v Speaker 1>You really don't wanna copy that around.

00:15:46.305 --> 00:15:47.825
<v Speaker 1>What you want to do is

00:15:48.225 --> 00:15:50.465
<v Speaker 1>if if if you assign the vector to

00:15:50.465 --> 00:15:53.345
<v Speaker 1>a different variable, that variable is now where

00:15:53.345 --> 00:15:55.665
<v Speaker 1>the vector is. And the way Rust

00:15:56.370 --> 00:15:59.010
<v Speaker 1>and and to prevent various problems, what Rust

00:15:59.010 --> 00:16:02.690
<v Speaker 1>does is that it actually stops that vector

00:16:02.690 --> 00:16:04.690
<v Speaker 1>from being used from the old variable.

00:16:05.090 --> 00:16:07.330
<v Speaker 1>Rust is very careful about sharing.

00:16:08.705 --> 00:16:10.705
<v Speaker 1>When things are being shared, it wants that

00:16:10.705 --> 00:16:13.185
<v Speaker 1>to be explicit. It wants it it uses

00:16:13.185 --> 00:16:14.225
<v Speaker 1>the ampersand

00:16:14.225 --> 00:16:16.945
<v Speaker 1>to talk about sharing often, and it wants

00:16:16.945 --> 00:16:19.345
<v Speaker 1>it to be explicit if the shared variable

00:16:19.505 --> 00:16:22.510
<v Speaker 1>is mutable, immutable, and stuff like that. So

00:16:22.510 --> 00:16:24.270
<v Speaker 1>what's going on here is

00:16:25.550 --> 00:16:26.190
<v Speaker 1>that

00:16:26.750 --> 00:16:28.589
<v Speaker 1>when you so if you look at the

00:16:28.589 --> 00:16:29.710
<v Speaker 1>fillvec

00:16:30.990 --> 00:16:34.029
<v Speaker 1>signature, what it does is that it takes

00:16:34.029 --> 00:16:36.829
<v Speaker 1>the the takes the vector by move.

00:16:38.524 --> 00:16:40.925
<v Speaker 1>Like, the vector is being moved into the

00:16:40.925 --> 00:16:44.125
<v Speaker 1>function and then returned, so it's moved out.

00:16:44.285 --> 00:16:45.645
<v Speaker 1>So vec zero

00:16:46.204 --> 00:16:47.005
<v Speaker 1>actually

00:16:48.845 --> 00:16:50.365
<v Speaker 1>vec zero basically

00:16:51.005 --> 00:16:51.644
<v Speaker 1>left,

00:16:53.340 --> 00:16:56.060
<v Speaker 1>like is is the the vector left vec

00:16:56.060 --> 00:16:58.540
<v Speaker 1>zero here. It is no longer belonging to

00:16:58.540 --> 00:17:00.460
<v Speaker 1>vec zero. It it moved into the function

00:17:00.460 --> 00:17:02.220
<v Speaker 1>and out into vec one.

00:17:03.500 --> 00:17:05.179
<v Speaker 1>So vec zero is

00:17:05.420 --> 00:17:06.060
<v Speaker 1>not

00:17:06.704 --> 00:17:08.065
<v Speaker 1>not a valid

00:17:08.704 --> 00:17:11.904
<v Speaker 1>binding anymore. There's so we cannot read it

00:17:11.904 --> 00:17:13.825
<v Speaker 1>over here because it's gone already. It has

00:17:13.825 --> 00:17:14.784
<v Speaker 1>been moved out.

00:17:15.505 --> 00:17:16.784
<v Speaker 1>Does that make sense?

00:17:17.585 --> 00:17:19.265
<v Speaker 0>It does. Yeah. It does make sense.

00:17:20.240 --> 00:17:22.000
<v Speaker 1>So basically, in this line, we did a

00:17:22.000 --> 00:17:22.559
<v Speaker 1>move.

00:17:23.040 --> 00:17:25.440
<v Speaker 1>Yeah. Okay. So whenever we pass a variable

00:17:25.440 --> 00:17:26.799
<v Speaker 0>to another function,

00:17:27.280 --> 00:17:28.400
<v Speaker 0>that's considered

00:17:28.960 --> 00:17:31.200
<v Speaker 0>moved. Is that, like, the borrowing that we

00:17:31.200 --> 00:17:33.040
<v Speaker 0>always hear about when I read about Rust?

00:17:33.040 --> 00:17:36.544
<v Speaker 1>It is the opposite or is counterpart of

00:17:36.544 --> 00:17:38.945
<v Speaker 1>the borrowing. Right. Okay. You can pass a

00:17:38.945 --> 00:17:40.625
<v Speaker 1>variable to a function in a way that

00:17:40.625 --> 00:17:41.664
<v Speaker 1>it gets borrowed,

00:17:42.065 --> 00:17:43.904
<v Speaker 1>and then then that means that the function

00:17:43.904 --> 00:17:46.544
<v Speaker 1>is temporarily looking at it, but we did

00:17:46.544 --> 00:17:48.710
<v Speaker 1>not do that yet. We passed it to

00:17:48.710 --> 00:17:50.550
<v Speaker 1>the function in a way that got moved.

00:17:51.190 --> 00:17:52.870
<v Speaker 0>Oh, so if we passed it as a

00:17:52.870 --> 00:17:54.950
<v Speaker 0>bottle, then we wouldn't have this error as

00:17:54.950 --> 00:17:57.430
<v Speaker 0>well. Was that another okay. Is this line

00:17:57.430 --> 00:17:58.070
<v Speaker 0>21?

00:17:59.595 --> 00:18:01.434
<v Speaker 0>Is that something to common in Rust, or

00:18:01.434 --> 00:18:03.754
<v Speaker 0>is that just to kinda make this code?

00:18:04.155 --> 00:18:07.114
<v Speaker 1>It's it's yeah. So that that's actually

00:18:07.914 --> 00:18:11.674
<v Speaker 1>basically, the the variable mutability is not that

00:18:11.674 --> 00:18:13.195
<v Speaker 1>big a deal. Like, you could turn it

00:18:13.195 --> 00:18:14.395
<v Speaker 1>on and off, and that's kind of how

00:18:14.395 --> 00:18:15.970
<v Speaker 1>you'll turn it on. And that what what

00:18:15.970 --> 00:18:18.370
<v Speaker 1>this is basically doing is saying it's creating

00:18:18.370 --> 00:18:20.130
<v Speaker 1>a new variable that has the same effect

00:18:20.130 --> 00:18:22.210
<v Speaker 1>of the same name as the old variable,

00:18:22.210 --> 00:18:23.090
<v Speaker 1>but it's mutable.

00:18:23.970 --> 00:18:25.809
<v Speaker 1>There's another way of doing this, and I

00:18:25.809 --> 00:18:27.170
<v Speaker 1>think it was just done so that they

00:18:27.170 --> 00:18:29.575
<v Speaker 1>didn't have to introduce the syntax. But you

00:18:29.575 --> 00:18:30.934
<v Speaker 1>can also just say this, and this would

00:18:30.934 --> 00:18:31.734
<v Speaker 1>have also worked.

00:18:32.615 --> 00:18:35.335
<v Speaker 0>Yeah. I think I've I've seen that mutability

00:18:35.335 --> 00:18:37.975
<v Speaker 0>and the function signature before, and I was

00:18:37.975 --> 00:18:39.255
<v Speaker 0>just curious. So maybe that's was the more

00:18:39.255 --> 00:18:41.095
<v Speaker 0>idiomatic way. But you're saying that's actually just

00:18:41.095 --> 00:18:43.650
<v Speaker 0>to not introduce too many new concepts, probably.

00:18:43.650 --> 00:18:45.650
<v Speaker 1>Yeah. It's, yeah, it's probably to not introduce

00:18:45.650 --> 00:18:47.330
<v Speaker 1>too many new concepts. But this is called

00:18:47.330 --> 00:18:49.730
<v Speaker 1>re this is called chat rebinding, and this

00:18:49.730 --> 00:18:51.090
<v Speaker 1>is done pretty often.

00:18:52.290 --> 00:18:55.810
<v Speaker 1>Like, in Rust, everything's mute immutable by default.

00:18:55.810 --> 00:18:58.505
<v Speaker 1>So sometimes what people do is if they

00:18:58.505 --> 00:19:00.985
<v Speaker 1>want something to be mutable, they'll only temporarily

00:19:00.985 --> 00:19:02.745
<v Speaker 1>make it mutable, and this is how you'll

00:19:02.745 --> 00:19:03.384
<v Speaker 1>do that.

00:19:04.664 --> 00:19:06.985
<v Speaker 0>There's there's a different form of temporary immutability

00:19:06.985 --> 00:19:08.825
<v Speaker 1>that we can get to later, but this

00:19:08.825 --> 00:19:11.784
<v Speaker 1>this is the the variable itself being mutable

00:19:11.784 --> 00:19:13.065
<v Speaker 1>is something you can turn on and off

00:19:13.065 --> 00:19:13.544
<v Speaker 1>very easily.

00:19:14.149 --> 00:19:15.909
<v Speaker 0>Does that mean that it's also valid to

00:19:15.909 --> 00:19:16.469
<v Speaker 0>do

00:19:16.710 --> 00:19:19.190
<v Speaker 0>that? Yes. Yes. And that and that makes

00:19:19.190 --> 00:19:21.429
<v Speaker 0>it immutable again. Right? That would yeah. Because

00:19:21.429 --> 00:19:23.750
<v Speaker 1>what's what's happening is that you're just creating

00:19:23.750 --> 00:19:26.149
<v Speaker 1>a new variable named vec that shadows the

00:19:26.149 --> 00:19:28.424
<v Speaker 1>old variable named vec, and you're moving it

00:19:28.424 --> 00:19:30.424
<v Speaker 1>from the old vec into the new vec,

00:19:30.505 --> 00:19:32.505
<v Speaker 1>the compiler easily sees that these are two

00:19:32.505 --> 00:19:34.745
<v Speaker 1>separate things. But from your point of view,

00:19:34.745 --> 00:19:35.705
<v Speaker 1>the old ones

00:19:36.345 --> 00:19:38.904
<v Speaker 1>be like, the moment you name like, you

00:19:38.904 --> 00:19:41.304
<v Speaker 1>can also do something like let vec equal

00:19:41.304 --> 00:19:42.104
<v Speaker 1>to five,

00:19:42.345 --> 00:19:43.145
<v Speaker 1>and now

00:19:43.750 --> 00:19:44.549
<v Speaker 1>the vec

00:19:44.950 --> 00:19:47.110
<v Speaker 1>there is now a new variable called vec

00:19:47.110 --> 00:19:49.350
<v Speaker 1>that's whose value is five, and that vector

00:19:49.350 --> 00:19:50.389
<v Speaker 1>is kinda gone.

00:19:51.030 --> 00:19:53.910
<v Speaker 1>You can't access it anymore. So, like, that's

00:19:53.910 --> 00:19:56.230
<v Speaker 1>that's just called shadowing. You can create variables

00:19:56.230 --> 00:19:58.230
<v Speaker 1>of the same name as old ones, and

00:19:58.755 --> 00:20:00.835
<v Speaker 1>they will you can just use them normally.

00:20:00.835 --> 00:20:02.275
<v Speaker 0>And does that take up double the amount

00:20:02.275 --> 00:20:04.275
<v Speaker 0>of space? Can I consider no? It doesn't.

00:20:04.275 --> 00:20:06.755
<v Speaker 0>Okay. Well, if you do let at vac

00:20:06.755 --> 00:20:08.995
<v Speaker 1>equal to vac, no. It is this is

00:20:09.155 --> 00:20:11.779
<v Speaker 1>this this compiles down to nothing. Alright.

00:20:11.860 --> 00:20:14.259
<v Speaker 1>Should have compiled down to nothing. Sometimes

00:20:14.820 --> 00:20:16.340
<v Speaker 1>compilers are weird, but

00:20:17.059 --> 00:20:17.619
<v Speaker 0>yeah.

00:20:18.500 --> 00:20:20.020
<v Speaker 0>Okay. So let's see if we can fix

00:20:20.020 --> 00:20:20.980
<v Speaker 0>this code then.

00:20:21.460 --> 00:20:23.540
<v Speaker 0>So what we're saying is we have this

00:20:23.540 --> 00:20:26.705
<v Speaker 0>empty vector called vec zero. Yeah. We then

00:20:26.705 --> 00:20:29.105
<v Speaker 0>pass it into a function, which then means

00:20:29.105 --> 00:20:30.865
<v Speaker 0>it's now moved.

00:20:30.945 --> 00:20:33.505
<v Speaker 0>So vec zero is no longer a reference.

00:20:33.985 --> 00:20:35.345
<v Speaker 0>Right. So

00:20:37.185 --> 00:20:38.465
<v Speaker 0>I guess we have two.

00:20:40.120 --> 00:20:41.159
<v Speaker 0>One option.

00:20:41.559 --> 00:20:43.159
<v Speaker 0>Do we make this a bottle,

00:20:44.120 --> 00:20:47.320
<v Speaker 0>or do we clone it? I'm not sure.

00:20:47.320 --> 00:20:49.399
<v Speaker 1>I guess I guess one of the

00:20:50.520 --> 00:20:53.239
<v Speaker 1>I guess one of the issues here is

00:20:53.559 --> 00:20:55.960
<v Speaker 1>what do we want

00:20:55.105 --> 00:20:55.744
<v Speaker 1>the

00:20:56.544 --> 00:20:58.224
<v Speaker 1>what do we want the

00:20:59.585 --> 00:21:01.345
<v Speaker 1>like, what do we want the actual semantics

00:21:01.345 --> 00:21:03.105
<v Speaker 1>of this program to be? Because what we

00:21:03.105 --> 00:21:04.624
<v Speaker 1>do here matters.

00:21:05.505 --> 00:21:07.024
<v Speaker 0>So it tells us not to change this

00:21:07.024 --> 00:21:08.705
<v Speaker 0>line. So from my head, we've gotta make

00:21:08.705 --> 00:21:10.969
<v Speaker 0>sure that back zero is still is still

00:21:11.289 --> 00:21:13.049
<v Speaker 0>binding to the value.

00:21:13.529 --> 00:21:16.169
<v Speaker 1>Alright. So so what we can do here

00:21:16.970 --> 00:21:17.609
<v Speaker 1>is

00:21:18.169 --> 00:21:20.490
<v Speaker 1>the the easiest way to do this is

00:21:20.490 --> 00:21:22.730
<v Speaker 1>that we copy that we create a copy

00:21:22.730 --> 00:21:24.825
<v Speaker 1>of vex zero. Like, so far, we have

00:21:24.825 --> 00:21:27.065
<v Speaker 1>not had this problem because

00:21:27.945 --> 00:21:29.865
<v Speaker 1>all the things we've been dealing with have

00:21:29.865 --> 00:21:30.905
<v Speaker 1>been copyable.

00:21:30.905 --> 00:21:32.505
<v Speaker 1>That if if you if you just say

00:21:32.505 --> 00:21:34.905
<v Speaker 1>that let mut vec one equal to fill

00:21:34.905 --> 00:21:36.820
<v Speaker 1>vec vec zero and it's vec is a

00:21:36.820 --> 00:21:37.379
<v Speaker 1>number,

00:21:38.259 --> 00:21:39.860
<v Speaker 1>it'll just copy it. You won't have this

00:21:39.860 --> 00:21:40.419
<v Speaker 1>problem.

00:21:41.059 --> 00:21:43.299
<v Speaker 1>And what's happening here is that it's what

00:21:43.299 --> 00:21:45.220
<v Speaker 1>we one way to solve this is just

00:21:45.220 --> 00:21:47.059
<v Speaker 1>to make a copy. And the way you

00:21:47.059 --> 00:21:49.059
<v Speaker 1>do that in Rust is called it's called

00:21:49.059 --> 00:21:49.460
<v Speaker 1>cloning,

00:21:49.915 --> 00:21:51.995
<v Speaker 1>and cloning is just when you make an

00:21:51.995 --> 00:21:53.434
<v Speaker 1>explicit deep copy.

00:21:54.235 --> 00:21:56.715
<v Speaker 1>This, of course, is going to create a

00:21:56.715 --> 00:21:57.755
<v Speaker 1>new vector.

00:21:58.715 --> 00:22:00.795
<v Speaker 1>It's gonna take a make a new allocation,

00:22:00.795 --> 00:22:02.795
<v Speaker 1>do an entire copy of everything in the

00:22:02.795 --> 00:22:04.635
<v Speaker 1>vector, which is right now nothing.

00:22:04.795 --> 00:22:05.675
<v Speaker 1>The vector's empty.

00:22:07.410 --> 00:22:09.650
<v Speaker 1>And then give it to this function. So

00:22:09.650 --> 00:22:11.890
<v Speaker 1>this function will have us different vector and

00:22:11.890 --> 00:22:14.769
<v Speaker 1>vex zero will stay its pristine empty self.

00:22:16.530 --> 00:22:17.169
<v Speaker 0>Okay.

00:22:17.490 --> 00:22:18.690
<v Speaker 0>So I I mean, I do have a

00:22:18.690 --> 00:22:20.835
<v Speaker 0>couple of, like, hobby projects that I've been

00:22:20.835 --> 00:22:22.275
<v Speaker 0>trying my best to write in Rust, and

00:22:22.275 --> 00:22:23.955
<v Speaker 0>then keep getting frustrated. And I do find

00:22:23.955 --> 00:22:25.875
<v Speaker 0>myself using dot clone just all the time

00:22:25.875 --> 00:22:27.635
<v Speaker 0>as, like, my escape hatch for things like

00:22:27.635 --> 00:22:28.275
<v Speaker 0>this.

00:22:28.595 --> 00:22:31.635
<v Speaker 1>That is totally fine. I think once people

00:22:31.635 --> 00:22:32.275
<v Speaker 1>understand

00:22:32.730 --> 00:22:35.130
<v Speaker 1>the I think as as a newcomer, it

00:22:35.130 --> 00:22:37.049
<v Speaker 1>is fair it's a good idea to use

00:22:37.049 --> 00:22:37.929
<v Speaker 1>clone a lot.

00:22:39.130 --> 00:22:41.610
<v Speaker 1>And, actually, I would recommend that even as

00:22:41.610 --> 00:22:43.610
<v Speaker 1>an advanced Rust programmer,

00:22:43.850 --> 00:22:45.850
<v Speaker 1>you should probably be using clone a lot.

00:22:45.995 --> 00:22:48.395
<v Speaker 1>You you'd probably know enough to be able

00:22:48.395 --> 00:22:50.715
<v Speaker 1>to write this code to avoid copies,

00:22:51.115 --> 00:22:52.155
<v Speaker 1>but you really

00:22:53.275 --> 00:22:54.955
<v Speaker 1>you really don't

00:22:54.955 --> 00:22:57.835
<v Speaker 1>need to in many cases. This is often

00:22:57.835 --> 00:22:59.355
<v Speaker 1>a premature optimization.

00:23:00.635 --> 00:23:03.309
<v Speaker 1>So if you need to clone, just clone.

00:23:03.309 --> 00:23:06.110
<v Speaker 1>And, like, if it becomes a performance issue,

00:23:06.110 --> 00:23:07.390
<v Speaker 1>you can go back and think of how

00:23:07.390 --> 00:23:08.669
<v Speaker 1>else could you have done this.

00:23:10.190 --> 00:23:12.030
<v Speaker 1>Like, one way to do this without cloning

00:23:12.110 --> 00:23:13.309
<v Speaker 1>in this case, by the way, the clone

00:23:13.309 --> 00:23:16.030
<v Speaker 1>is free because empty vectors aren't actually allocated.

00:23:16.885 --> 00:23:19.205
<v Speaker 1>But if the if the vector did have

00:23:19.205 --> 00:23:21.284
<v Speaker 1>things in it, it would not be free.

00:23:22.645 --> 00:23:23.205
<v Speaker 1>Yeah.

00:23:24.405 --> 00:23:25.445
<v Speaker 0>That's good to know.

00:23:26.005 --> 00:23:28.005
<v Speaker 0>So let's stick with the clone approach then.

00:23:28.005 --> 00:23:30.610
<v Speaker 0>I'm glad that you've validated that for me.

00:23:30.930 --> 00:23:32.450
<v Speaker 0>I always felt like I was cheating every

00:23:32.450 --> 00:23:34.050
<v Speaker 0>time I did it, but now I'm okay.

00:23:34.050 --> 00:23:35.169
<v Speaker 1>It's yeah.

00:23:35.890 --> 00:23:39.169
<v Speaker 0>Let's see. It's happy. Right? Nice. So

00:23:39.730 --> 00:23:42.450
<v Speaker 0>we've got move semantics

00:23:42.770 --> 00:23:43.010
<v Speaker 0>three.

00:23:45.565 --> 00:23:47.005
<v Speaker 0>Let's see what we're dealing with here. So

00:23:47.005 --> 00:23:47.965
<v Speaker 0>no test.

00:23:50.285 --> 00:23:52.765
<v Speaker 0>Make me compare without adding new lines.

00:23:56.100 --> 00:23:59.539
<v Speaker 0>No lines with multiple semicolons necessary.

00:24:02.260 --> 00:24:03.299
<v Speaker 0>Alright. Okay.

00:24:04.660 --> 00:24:07.139
<v Speaker 0>So we initialize an empty vector.

00:24:08.740 --> 00:24:10.260
<v Speaker 0>We do the same thing here.

00:24:11.155 --> 00:24:13.475
<v Speaker 0>And then this one hasn't printed in back

00:24:13.475 --> 00:24:15.315
<v Speaker 0>zero, so that should be fine. We then

00:24:15.315 --> 00:24:16.595
<v Speaker 0>gotta push here,

00:24:17.315 --> 00:24:18.754
<v Speaker 0>but with no assignment.

00:24:18.995 --> 00:24:21.555
<v Speaker 0>So the problem is here that sec one

00:24:21.555 --> 00:24:22.434
<v Speaker 0>is no longer

00:24:24.290 --> 00:24:26.210
<v Speaker 0>at the same location. Is that right?

00:24:29.570 --> 00:24:32.130
<v Speaker 1>That might vac one equal to fill vac

00:24:32.130 --> 00:24:33.090
<v Speaker 1>vac zero.

00:24:33.570 --> 00:24:34.370
<v Speaker 1>Print

00:24:34.370 --> 00:24:36.769
<v Speaker 1>vac one and vac one dot push.

00:24:38.290 --> 00:24:39.825
<v Speaker 0>I guess I should read the error message.

00:24:39.825 --> 00:24:40.945
<v Speaker 0>Because I'm trying to work out, is this

00:24:40.945 --> 00:24:42.945
<v Speaker 0>vec dot one dot push part of the

00:24:42.945 --> 00:24:45.105
<v Speaker 0>move semantics because it's a function on a

00:24:45.105 --> 00:24:47.025
<v Speaker 0>struct? No? No. So this is a function

00:24:47.025 --> 00:24:49.665
<v Speaker 1>that takes a mutable borrow. Actually, if you

00:24:49.825 --> 00:24:51.105
<v Speaker 1>I guess, Versus code will do this. If

00:24:51.105 --> 00:24:52.840
<v Speaker 1>you highlight on the push, like, if you

00:24:52.840 --> 00:24:54.440
<v Speaker 1>just put your cursor on the push, it

00:24:54.440 --> 00:24:56.999
<v Speaker 1>should do you see the and mute self?

00:24:57.240 --> 00:24:59.080
<v Speaker 1>Yep. Yeah. That is that

00:24:59.480 --> 00:25:01.720
<v Speaker 1>is a mutable borrow. And what that is

00:25:01.720 --> 00:25:04.679
<v Speaker 1>saying is that for the duration of this

00:25:04.679 --> 00:25:05.000
<v Speaker 1>function,

00:25:05.554 --> 00:25:09.315
<v Speaker 1>please give me exclusive access to mutate and

00:25:09.315 --> 00:25:10.595
<v Speaker 1>read this object.

00:25:11.235 --> 00:25:13.554
<v Speaker 1>And once I'm done with this function, you

00:25:13.554 --> 00:25:15.715
<v Speaker 1>can go back to having it. So that's

00:25:15.715 --> 00:25:17.554
<v Speaker 1>where the borrowing comes in.

00:25:18.990 --> 00:25:20.750
<v Speaker 1>And that, of course, we that's not actually

00:25:20.750 --> 00:25:22.830
<v Speaker 1>moving it. That's, like, temporarily

00:25:22.830 --> 00:25:25.710
<v Speaker 1>doing something. So move semantics

00:25:25.870 --> 00:25:28.110
<v Speaker 1>it it doesn't break the move semantics.

00:25:28.510 --> 00:25:30.430
<v Speaker 0>Okay. Let me get the actual error message

00:25:30.430 --> 00:25:32.030
<v Speaker 0>then instead of guessing. That would probably be

00:25:32.030 --> 00:25:32.590
<v Speaker 0>a good start.

00:25:34.674 --> 00:25:35.554
<v Speaker 0>Okay.

00:25:35.794 --> 00:25:38.434
<v Speaker 0>So we've got cannot borrow vec as multiple

00:25:38.674 --> 00:25:39.634
<v Speaker 0>oh, okay.

00:25:42.034 --> 00:25:43.874
<v Speaker 0>So oh, yeah. The problem's here.

00:25:45.154 --> 00:25:48.330
<v Speaker 0>Yeah. So the syntax you used showed us

00:25:48.330 --> 00:25:49.690
<v Speaker 0>was we could do that, but we could

00:25:49.690 --> 00:25:51.929
<v Speaker 0>also have done Yeah. But we're not allowed

00:25:51.929 --> 00:25:54.490
<v Speaker 1>to add lines. Yeah. So now we know

00:25:54.490 --> 00:25:56.090
<v Speaker 1>why it didn't use that syntax in the

00:25:56.090 --> 00:25:57.610
<v Speaker 1>last case because it wanted to teach us

00:25:57.610 --> 00:26:01.144
<v Speaker 1>the syntax here. Yeah. There was methods there.

00:26:01.385 --> 00:26:01.945
<v Speaker 1>Yeah.

00:26:02.825 --> 00:26:05.065
<v Speaker 0>If let's see how far that gets. That's

00:26:05.065 --> 00:26:07.705
<v Speaker 0>it. Alright. Okay. So I'm sitting here looking

00:26:07.705 --> 00:26:09.625
<v Speaker 0>for some sort of move semantic in this

00:26:09.625 --> 00:26:12.265
<v Speaker 0>function that doesn't even exist. No. Okay. No.

00:26:12.265 --> 00:26:14.790
<v Speaker 1>The Rustlings try not to introduce, like, a

00:26:14.790 --> 00:26:16.149
<v Speaker 1>billion concepts,

00:26:16.309 --> 00:26:18.710
<v Speaker 1>like, one after the other. So they it's

00:26:18.710 --> 00:26:20.389
<v Speaker 1>it's a very smooth ride.

00:26:21.990 --> 00:26:22.629
<v Speaker 0>Nice.

00:26:22.790 --> 00:26:24.710
<v Speaker 0>Okay. Let's read the error message before I

00:26:24.710 --> 00:26:25.590
<v Speaker 0>open the file then.

00:26:27.295 --> 00:26:29.455
<v Speaker 0>So move semantics four

00:26:29.535 --> 00:26:30.335
<v Speaker 0>is

00:26:30.735 --> 00:26:32.414
<v Speaker 0>found macro vac.

00:26:33.855 --> 00:26:36.015
<v Speaker 0>Okay. Yeah. So missing

00:26:36.015 --> 00:26:38.735
<v Speaker 0>the exclamation mark. Right? Let's see.

00:26:40.095 --> 00:26:40.575
<v Speaker 1>Is it?

00:26:43.580 --> 00:26:46.140
<v Speaker 1>Or or well, okay. So it says use

00:26:46.140 --> 00:26:47.899
<v Speaker 0>this to invoke the macro.

00:26:48.299 --> 00:26:49.019
<v Speaker 0>Yeah.

00:26:52.540 --> 00:26:52.860
<v Speaker 0>And

00:26:55.025 --> 00:26:57.265
<v Speaker 0>okay. Refactor this code so that instead of

00:26:57.265 --> 00:26:59.184
<v Speaker 0>having vec zero and creating

00:27:00.065 --> 00:27:02.544
<v Speaker 0>the vector and function main, we instead create

00:27:02.544 --> 00:27:04.624
<v Speaker 0>it within the fill back. Okay. So

00:27:05.105 --> 00:27:07.345
<v Speaker 0>Yep. Does the macro need the parens as

00:27:07.345 --> 00:27:10.579
<v Speaker 0>well? Yeah. It needs some form of yeah.

00:27:10.580 --> 00:27:12.499
<v Speaker 1>Okay. It needs a parens or yeah.

00:27:12.740 --> 00:27:13.700
<v Speaker 1>Doesn't matter.

00:27:14.100 --> 00:27:14.979
<v Speaker 0>Oh, really?

00:27:15.380 --> 00:27:18.100
<v Speaker 1>Oh, yeah. Rust macros there are some some

00:27:18.100 --> 00:27:20.820
<v Speaker 1>depicts here, but, like, Rust macros, the ones

00:27:20.820 --> 00:27:21.940
<v Speaker 1>that are like this one,

00:27:22.635 --> 00:27:24.235
<v Speaker 1>you can do this. You can even do

00:27:24.235 --> 00:27:24.875
<v Speaker 1>this.

00:27:25.355 --> 00:27:26.554
<v Speaker 1>It does not matter,

00:27:26.875 --> 00:27:28.795
<v Speaker 1>which is why but people use this because

00:27:28.795 --> 00:27:30.875
<v Speaker 1>this looks like the array syntax. So if

00:27:30.875 --> 00:27:32.475
<v Speaker 1>you're making a vector, you'll make it look

00:27:32.475 --> 00:27:33.355
<v Speaker 1>like an array.

00:27:33.995 --> 00:27:35.595
<v Speaker 1>Also means that if you wanna fix stack

00:27:35.595 --> 00:27:37.435
<v Speaker 1>array, you can just kinda remove that if

00:27:37.435 --> 00:27:39.190
<v Speaker 1>you want. Alright.

00:27:39.190 --> 00:27:39.830
<v Speaker 0>Okay.

00:27:41.510 --> 00:27:43.349
<v Speaker 0>Well, let's see if that's all at once.

00:27:43.750 --> 00:27:45.589
<v Speaker 0>No. We got more. Okay.

00:27:46.149 --> 00:27:48.309
<v Speaker 0>Ah, yes. So we're still passing in,

00:27:49.429 --> 00:27:50.549
<v Speaker 0>you know, so we can.

00:27:51.895 --> 00:27:53.735
<v Speaker 1>Yeah. We don't need to do that anymore.

00:27:55.175 --> 00:27:56.054
<v Speaker 0>There we go.

00:27:56.295 --> 00:27:59.255
<v Speaker 1>This is also more idiomatic Rust because you

00:27:59.255 --> 00:28:01.415
<v Speaker 1>typically want if if a function is, like,

00:28:01.415 --> 00:28:03.415
<v Speaker 1>returning something, you want the and and the

00:28:03.415 --> 00:28:05.575
<v Speaker 1>function needs it freshly created, it's better if

00:28:05.575 --> 00:28:07.919
<v Speaker 1>the function creates it. There's no need to

00:28:07.919 --> 00:28:10.400
<v Speaker 1>freshly create it and pass it in. We

00:28:10.400 --> 00:28:12.559
<v Speaker 1>don't do out parameters and stuff like that.

00:28:13.280 --> 00:28:15.519
<v Speaker 0>Alright. Okay. That's good to know as well.

00:28:16.400 --> 00:28:18.640
<v Speaker 0>So that's most semantics. That that means I

00:28:18.640 --> 00:28:20.320
<v Speaker 0>know everything I need to know now about

00:28:20.635 --> 00:28:21.195
<v Speaker 0>that,

00:28:21.914 --> 00:28:24.155
<v Speaker 0>which I don't think is really true yet.

00:28:24.155 --> 00:28:26.075
<v Speaker 1>So There's there's borrowing and I like, we

00:28:26.075 --> 00:28:27.674
<v Speaker 1>touched a little bit on borrowing. I don't

00:28:27.674 --> 00:28:29.034
<v Speaker 1>actually know if they're tits,

00:28:29.275 --> 00:28:31.434
<v Speaker 1>if they're Rustlings for that,

00:28:31.595 --> 00:28:33.880
<v Speaker 1>but there probably are somewhere. I I I

00:28:33.880 --> 00:28:36.600
<v Speaker 1>suspect Rustlings in my I in my recollection,

00:28:36.600 --> 00:28:38.120
<v Speaker 1>Rustling kind of teaches

00:28:38.120 --> 00:28:41.240
<v Speaker 1>you borrowing bit by bit, like, in pieces

00:28:41.560 --> 00:28:43.400
<v Speaker 1>instead of, like, having a here is a

00:28:43.400 --> 00:28:45.160
<v Speaker 1>thing where we'll teach you just borrowing.

00:28:46.125 --> 00:28:46.924
<v Speaker 1>So

00:28:47.165 --> 00:28:48.525
<v Speaker 1>yeah. Okay.

00:28:48.765 --> 00:28:49.485
<v Speaker 0>Well,

00:28:50.125 --> 00:28:52.125
<v Speaker 0>let's pick something else. And then if we

00:28:52.125 --> 00:28:54.685
<v Speaker 0>don't find anything else that maybe hints towards

00:28:54.685 --> 00:28:56.365
<v Speaker 0>what the borrowing stuff is, we can always

00:28:56.365 --> 00:28:57.165
<v Speaker 0>reopen

00:28:57.165 --> 00:28:59.245
<v Speaker 0>move semantics for later and then just make

00:28:59.245 --> 00:29:01.100
<v Speaker 0>that function to borrow and kinda go through

00:29:01.100 --> 00:29:02.300
<v Speaker 0>that process. We don't want it to do

00:29:02.300 --> 00:29:03.660
<v Speaker 1>a borrow in this case. It's

00:29:04.860 --> 00:29:07.100
<v Speaker 1>yeah. There but we can we can have

00:29:07.100 --> 00:29:09.340
<v Speaker 1>examples of borrowing at some point, I think.

00:29:10.140 --> 00:29:13.740
<v Speaker 0>Alright. Okay. Let's see. Let me just

00:29:14.265 --> 00:29:16.825
<v Speaker 0>I'll pick one at random. How about

00:29:18.985 --> 00:29:19.625
<v Speaker 0>options?

00:29:20.025 --> 00:29:21.225
<v Speaker 0>Sure. Yeah.

00:29:21.865 --> 00:29:23.545
<v Speaker 0>Alright. So we got option one.

00:29:29.110 --> 00:29:30.869
<v Speaker 0>Back error message? Okay.

00:29:31.990 --> 00:29:35.110
<v Speaker 0>So print number function expects an option and

00:29:35.110 --> 00:29:36.789
<v Speaker 0>it found an integer.

00:29:37.669 --> 00:29:38.230
<v Speaker 0>Okay.

00:29:41.745 --> 00:29:42.945
<v Speaker 0>So it's kind of

00:29:43.505 --> 00:29:45.345
<v Speaker 0>looks like generic syntax.

00:29:45.665 --> 00:29:48.385
<v Speaker 1>Yes. You can you kinda just maybe walk

00:29:48.385 --> 00:29:50.545
<v Speaker 0>me through this for a second? And Sure.

00:29:50.545 --> 00:29:52.065
<v Speaker 1>What this is saying is that there is

00:29:52.065 --> 00:29:53.585
<v Speaker 1>a type option

00:29:54.440 --> 00:29:55.799
<v Speaker 1>which has

00:29:55.880 --> 00:29:57.399
<v Speaker 1>a generic parameter,

00:29:58.200 --> 00:29:59.480
<v Speaker 1>which means that that type can be

00:30:00.280 --> 00:30:02.360
<v Speaker 1>it it's a type option that you give

00:30:02.360 --> 00:30:04.680
<v Speaker 1>another type to to make the actual final

00:30:04.680 --> 00:30:04.920
<v Speaker 1>type.

00:30:06.355 --> 00:30:08.514
<v Speaker 1>So you can have an option of an

00:30:08.514 --> 00:30:10.115
<v Speaker 1>integer. You can have an option of a

00:30:10.115 --> 00:30:11.394
<v Speaker 1>string. You can have an option of a

00:30:11.394 --> 00:30:12.755
<v Speaker 1>vec. You can have an option of any

00:30:12.755 --> 00:30:15.075
<v Speaker 1>type in this case. And what we're doing

00:30:15.075 --> 00:30:16.835
<v Speaker 1>here is we have an option of an

00:30:16.835 --> 00:30:19.475
<v Speaker 1>integer, which in the standard library, the option

00:30:19.475 --> 00:30:20.835
<v Speaker 1>type is basically

00:30:21.650 --> 00:30:23.409
<v Speaker 1>either something or nothing,

00:30:24.450 --> 00:30:26.529
<v Speaker 1>which which basically is

00:30:27.090 --> 00:30:29.409
<v Speaker 1>either you it's it's kind of a nullable

00:30:29.409 --> 00:30:30.690
<v Speaker 1>type. It is

00:30:31.090 --> 00:30:33.650
<v Speaker 1>either you have an integer or you have

00:30:33.650 --> 00:30:36.895
<v Speaker 1>what's called none in Rust, or some languages

00:30:36.895 --> 00:30:39.294
<v Speaker 1>call it null. Rust calls it none.

00:30:40.335 --> 00:30:40.895
<v Speaker 1>Yeah.

00:30:41.855 --> 00:30:44.255
<v Speaker 0>Okay. Kinda reminds me of TypeScript.

00:30:44.255 --> 00:30:45.615
<v Speaker 0>I'm not sure if you're Yeah. Yeah. Right.

00:30:45.615 --> 00:30:47.855
<v Speaker 1>TypeScript also has I think it's called option

00:30:47.855 --> 00:30:50.730
<v Speaker 1>or maybe. I forgot. Yeah. It's it's it's

00:30:50.730 --> 00:30:53.050
<v Speaker 0>the it's the same option syntax. Well, very

00:30:53.050 --> 00:30:54.570
<v Speaker 0>similar at least. Yeah.

00:30:56.170 --> 00:30:58.330
<v Speaker 0>So the error then being is that when

00:30:58.330 --> 00:31:00.490
<v Speaker 0>we call this print number function is that

00:31:00.490 --> 00:31:02.884
<v Speaker 0>we're passing on just an explicit type. So

00:31:02.884 --> 00:31:06.484
<v Speaker 0>we need to wrap this somehow and Yeah.

00:31:06.644 --> 00:31:07.445
<v Speaker 0>Option.

00:31:07.924 --> 00:31:08.644
<v Speaker 0>That just

00:31:09.205 --> 00:31:10.804
<v Speaker 1>No. Some. So

00:31:12.325 --> 00:31:14.244
<v Speaker 1>have you done one of the enums

00:31:14.325 --> 00:31:15.365
<v Speaker 1>exercises yet?

00:31:17.590 --> 00:31:19.990
<v Speaker 0>I haven't done the enums exercises. No. Should

00:31:19.990 --> 00:31:22.150
<v Speaker 0>we go there? We could go there. We

00:31:22.150 --> 00:31:24.470
<v Speaker 1>could go through this first and, like, looking

00:31:24.950 --> 00:31:27.350
<v Speaker 1>at how options use will make you understand

00:31:27.350 --> 00:31:28.150
<v Speaker 1>enums better.

00:31:29.035 --> 00:31:31.275
<v Speaker 1>But I think it it I was I

00:31:31.275 --> 00:31:32.795
<v Speaker 1>was just wondering how how much I should

00:31:32.795 --> 00:31:33.914
<v Speaker 1>explain. But

00:31:34.235 --> 00:31:36.154
<v Speaker 1>yeah. So what option is is that

00:31:36.395 --> 00:31:39.275
<v Speaker 1>the the way it actually exist is

00:31:42.635 --> 00:31:43.115
<v Speaker 1>oops.

00:31:45.160 --> 00:31:46.200
<v Speaker 1>Like that.

00:31:46.600 --> 00:31:48.040
<v Speaker 1>And what it's what it is is that

00:31:48.040 --> 00:31:51.000
<v Speaker 1>it's either some and it contains

00:31:51.160 --> 00:31:52.040
<v Speaker 1>a thing

00:31:52.200 --> 00:31:53.880
<v Speaker 1>of the type that we passed in. So

00:31:53.880 --> 00:31:55.320
<v Speaker 1>in this case, because it's

00:31:55.720 --> 00:31:57.880
<v Speaker 1>it's u 16, what it actually is is

00:31:57.880 --> 00:31:59.240
<v Speaker 1>that this is a u 16,

00:32:02.575 --> 00:32:03.615
<v Speaker 1>something like that.

00:32:04.415 --> 00:32:06.095
<v Speaker 1>And and the none is

00:32:06.735 --> 00:32:08.095
<v Speaker 1>the null case.

00:32:09.295 --> 00:32:11.775
<v Speaker 1>So what we're doing is we're wrapping it

00:32:11.775 --> 00:32:14.175
<v Speaker 1>in sum to create an instance of option

00:32:14.175 --> 00:32:15.135
<v Speaker 1>of u 16 here.

00:32:16.850 --> 00:32:18.769
<v Speaker 0>Alright. Cool. And that's what the unwrap is

00:32:18.769 --> 00:32:20.210
<v Speaker 0>doing. We're just saying

00:32:20.850 --> 00:32:23.169
<v Speaker 0>either get me the none back or the

00:32:23.169 --> 00:32:24.130
<v Speaker 0>u 16

00:32:24.529 --> 00:32:26.769
<v Speaker 1>No. Unwrap is actually if it's none, I

00:32:26.769 --> 00:32:29.250
<v Speaker 1>I unwrap is I didn't don't expect it

00:32:29.250 --> 00:32:30.769
<v Speaker 1>to be none here. So if it was

00:32:30.769 --> 00:32:31.330
<v Speaker 1>none

00:32:31.695 --> 00:32:33.134
<v Speaker 1>and, like, basically,

00:32:34.495 --> 00:32:36.494
<v Speaker 1>in the program, it it caused a panic.

00:32:37.855 --> 00:32:40.095
<v Speaker 0>Alright. So I mean, I'm gonna do that

00:32:40.095 --> 00:32:40.654
<v Speaker 0>now.

00:32:41.615 --> 00:32:42.414
<v Speaker 1>Oops.

00:32:42.815 --> 00:32:44.494
<v Speaker 1>There we go. Like, if we did that,

00:32:44.735 --> 00:32:45.695
<v Speaker 1>it's going to panic.

00:32:46.370 --> 00:32:49.170
<v Speaker 0>Alright. Let's try that. So option one.

00:32:50.530 --> 00:32:52.130
<v Speaker 0>Oh, we've got another have to fix fix

00:32:52.130 --> 00:32:53.250
<v Speaker 1>other things first.

00:32:53.410 --> 00:32:55.650
<v Speaker 0>Okay. Yep. So we got oh, we expect

00:32:55.650 --> 00:32:57.570
<v Speaker 0>an option here for the number to add.

00:32:57.570 --> 00:32:59.170
<v Speaker 1>Oh, I guess we didn't fix all of

00:32:59.170 --> 00:32:59.570
<v Speaker 1>the cases.

00:33:02.745 --> 00:33:06.184
<v Speaker 0>Oh, yeah. Numbers as an array of option

00:33:06.184 --> 00:33:08.905
<v Speaker 0>type size five. Right? That's kinda a syntax

00:33:08.905 --> 00:33:09.544
<v Speaker 0>to send?

00:33:10.265 --> 00:33:11.065
<v Speaker 1>Yes.

00:33:12.184 --> 00:33:14.265
<v Speaker 0>Which means

00:33:13.450 --> 00:33:16.090
<v Speaker 0>this needs to be some number Yes. To

00:33:16.090 --> 00:33:16.650
<v Speaker 0>add.

00:33:17.610 --> 00:33:18.330
<v Speaker 1>Yep.

00:33:19.370 --> 00:33:19.850
<v Speaker 1>And

00:33:20.330 --> 00:33:22.250
<v Speaker 0>I haven't seen the syntax before.

00:33:22.490 --> 00:33:22.730
<v Speaker 0>So

00:33:23.530 --> 00:33:25.450
<v Speaker 1>Yeah. This is this is this is the

00:33:25.450 --> 00:33:27.705
<v Speaker 1>type, by the way. So if you say

00:33:27.705 --> 00:33:30.825
<v Speaker 1>let x so so the full, like, let

00:33:30.825 --> 00:33:32.825
<v Speaker 1>syntax is, like, let x

00:33:33.065 --> 00:33:35.865
<v Speaker 1>colon u 60 equals five.

00:33:36.345 --> 00:33:37.625
<v Speaker 1>And, of course, you can have a mut

00:33:37.625 --> 00:33:38.265
<v Speaker 1>here if you want.

00:33:39.350 --> 00:33:41.110
<v Speaker 1>And this is this is a type.

00:33:41.430 --> 00:33:43.430
<v Speaker 1>So using a colon, you can put a

00:33:43.430 --> 00:33:44.230
<v Speaker 1>type in.

00:33:44.630 --> 00:33:46.550
<v Speaker 1>And, also, you can do

00:33:47.110 --> 00:33:48.310
<v Speaker 1>you can do

00:33:49.190 --> 00:33:49.830
<v Speaker 1>well,

00:33:50.390 --> 00:33:51.510
<v Speaker 1>there's actually

00:33:52.455 --> 00:33:53.975
<v Speaker 1>if you compile, you'll see that there's a

00:33:53.975 --> 00:33:55.174
<v Speaker 1>compiler error here.

00:33:55.735 --> 00:33:57.174
<v Speaker 0>Okay. Let's do that.

00:34:00.855 --> 00:34:01.655
<v Speaker 0>And that's save.

00:34:04.960 --> 00:34:06.320
<v Speaker 1>Can can you go back? Actually, I didn't

00:34:06.320 --> 00:34:07.440
<v Speaker 1>see what the error was.

00:34:08.639 --> 00:34:10.400
<v Speaker 0>Oh, it it said that

00:34:10.880 --> 00:34:12.159
<v Speaker 0>I'm gonna run it again just in case

00:34:12.159 --> 00:34:13.600
<v Speaker 0>I hadn't saved. Yeah. I think it was

00:34:13.600 --> 00:34:16.400
<v Speaker 0>it. Okay. Yeah. And now we have possibly

00:34:16.400 --> 00:34:17.359
<v Speaker 0>uninitialized

00:34:17.359 --> 00:34:18.160
<v Speaker 0>numbers.

00:34:18.320 --> 00:34:18.639
<v Speaker 1>Yes.

00:34:19.295 --> 00:34:21.375
<v Speaker 0>Oh, yeah. That's the error you were gonna

00:34:21.375 --> 00:34:24.095
<v Speaker 0>say there. Right? So what we've done so

00:34:24.095 --> 00:34:26.015
<v Speaker 1>in Rust, you can, but you can do,

00:34:26.015 --> 00:34:28.735
<v Speaker 1>like, let x and not say what x

00:34:28.735 --> 00:34:30.335
<v Speaker 1>is and then, like, 10 lines later, say

00:34:30.335 --> 00:34:31.375
<v Speaker 1>x equal to 10.

00:34:31.775 --> 00:34:33.670
<v Speaker 1>But you have to do it in a

00:34:33.670 --> 00:34:36.550
<v Speaker 1>way that Rust knows that x is x

00:34:36.550 --> 00:34:38.150
<v Speaker 1>cannot be used in this part.

00:34:39.590 --> 00:34:41.910
<v Speaker 1>Wait. Oh, yeah. X cannot be used in

00:34:41.910 --> 00:34:43.670
<v Speaker 1>this part, and you have to do it

00:34:43.670 --> 00:34:45.190
<v Speaker 1>in a way that Rust knows that x

00:34:45.190 --> 00:34:47.635
<v Speaker 1>is fully initialized at the end. So here,

00:34:47.635 --> 00:34:48.435
<v Speaker 1>this array,

00:34:49.075 --> 00:34:51.075
<v Speaker 1>we start off with an uninitialized array, and

00:34:51.075 --> 00:34:52.195
<v Speaker 1>then we kind of just, like, fill it

00:34:52.195 --> 00:34:55.075
<v Speaker 1>with a for loop. And Rust cannot prove

00:34:55.395 --> 00:34:57.875
<v Speaker 1>that, like, you're actually creating the full array

00:34:57.875 --> 00:34:59.635
<v Speaker 1>here. So what you want to do

00:35:01.235 --> 00:35:01.955
<v Speaker 1>is

00:35:02.109 --> 00:35:04.110
<v Speaker 1>we can we can just do

00:35:06.349 --> 00:35:07.230
<v Speaker 1>like that.

00:35:08.030 --> 00:35:08.910
<v Speaker 1>Oops. That

00:35:09.950 --> 00:35:10.590
<v Speaker 1>and

00:35:12.030 --> 00:35:14.589
<v Speaker 1>it is this this part is actually unnecessary

00:35:14.589 --> 00:35:14.910
<v Speaker 1>now.

00:35:15.435 --> 00:35:17.435
<v Speaker 1>So this part is a type annotation, and

00:35:17.435 --> 00:35:20.075
<v Speaker 1>as you've seen in Rust, let statements usually

00:35:20.075 --> 00:35:21.755
<v Speaker 1>don't need type annotations.

00:35:22.155 --> 00:35:23.995
<v Speaker 1>In this case, we're adding one it it

00:35:23.995 --> 00:35:25.915
<v Speaker 1>was there to help us, I think, but

00:35:26.715 --> 00:35:28.315
<v Speaker 1>and what it's saying is that it's of

00:35:28.315 --> 00:35:29.515
<v Speaker 1>type option u 16.

00:35:30.000 --> 00:35:31.920
<v Speaker 1>Oh, it's a it's an array a fixed

00:35:31.920 --> 00:35:34.080
<v Speaker 1>size array of length five of type option

00:35:34.080 --> 00:35:34.960
<v Speaker 1>u 16,

00:35:35.440 --> 00:35:37.360
<v Speaker 1>but I think this will also work. And

00:35:37.360 --> 00:35:39.360
<v Speaker 1>this is a way of quickly initializing

00:35:39.360 --> 00:35:40.560
<v Speaker 1>an empty array

00:35:41.280 --> 00:35:42.080
<v Speaker 1>or

00:35:42.160 --> 00:35:44.744
<v Speaker 1>quickly initializing an array that has the same

00:35:44.744 --> 00:35:46.664
<v Speaker 1>same thing in its value. So you can

00:35:46.664 --> 00:35:47.785
<v Speaker 1>initialize

00:35:47.785 --> 00:35:50.025
<v Speaker 1>an array of integers like this.

00:35:51.545 --> 00:35:53.704
<v Speaker 1>You can initialize an array of strings like

00:35:53.704 --> 00:35:54.265
<v Speaker 1>this,

00:35:55.224 --> 00:35:56.744
<v Speaker 1>and they will all have the same value.

00:36:00.270 --> 00:36:00.910
<v Speaker 0>Okay.

00:36:01.150 --> 00:36:02.590
<v Speaker 0>So what's,

00:36:02.590 --> 00:36:04.830
<v Speaker 0>you know trying to think about, you know,

00:36:04.830 --> 00:36:06.510
<v Speaker 0>lessons that I take away from this is

00:36:06.510 --> 00:36:09.470
<v Speaker 0>idiomatic Rust. Do when you're doing a let

00:36:09.470 --> 00:36:09.950
<v Speaker 0>statement,

00:36:10.775 --> 00:36:13.815
<v Speaker 0>you rely on the syntax or, you know,

00:36:13.815 --> 00:36:16.055
<v Speaker 0>do you have a preference towards doing something?

00:36:16.055 --> 00:36:18.695
<v Speaker 0>When do you include them or not? You

00:36:18.695 --> 00:36:21.895
<v Speaker 1>include the type when Rust when Rust cannot

00:36:22.295 --> 00:36:24.615
<v Speaker 1>the idiomatic answer is you include the type

00:36:24.615 --> 00:36:27.070
<v Speaker 1>when Rust cannot compile without you doing it,

00:36:27.230 --> 00:36:30.510
<v Speaker 1>which typically occurs in more complicated cases.

00:36:32.030 --> 00:36:33.630
<v Speaker 1>So, like well, this is

00:36:35.069 --> 00:36:37.390
<v Speaker 1>but yeah. Yeah. Rust.

00:36:37.630 --> 00:36:38.190
<v Speaker 1>Yeah.

00:36:38.430 --> 00:36:38.750
<v Speaker 1>The

00:36:39.245 --> 00:36:41.325
<v Speaker 1>in this case, Rust knows that this is

00:36:41.325 --> 00:36:43.805
<v Speaker 1>a a a an a stir. So Rust

00:36:43.965 --> 00:36:46.045
<v Speaker 1>there's no point telling Rust it's a stir.

00:36:46.605 --> 00:36:48.445
<v Speaker 1>The only reason you do this if there's

00:36:48.445 --> 00:36:50.765
<v Speaker 1>some clarity that's lost for the reader,

00:36:51.900 --> 00:36:53.500
<v Speaker 1>and that can happen if you have some

00:36:53.500 --> 00:36:56.380
<v Speaker 1>really complicated type and you want the reader

00:36:56.380 --> 00:36:57.819
<v Speaker 1>of the code to know what the type

00:36:57.819 --> 00:36:58.380
<v Speaker 1>is.

00:36:59.420 --> 00:37:01.660
<v Speaker 1>But sometimes also you can have some complicated

00:37:01.660 --> 00:37:03.900
<v Speaker 1>type stuff going on, and you need to

00:37:03.900 --> 00:37:06.695
<v Speaker 1>tell Rust what the return type there is.

00:37:07.735 --> 00:37:10.215
<v Speaker 1>And Rust does have, like, some complicated things

00:37:10.215 --> 00:37:12.295
<v Speaker 1>that so for so I think a good

00:37:12.295 --> 00:37:13.655
<v Speaker 1>example of this is,

00:37:15.095 --> 00:37:18.535
<v Speaker 1>now this this this introduces a lot of

00:37:17.570 --> 00:37:19.410
<v Speaker 1>syntax at once, but I'm not gonna, like,

00:37:19.410 --> 00:37:20.450
<v Speaker 1>explain everything.

00:37:21.730 --> 00:37:22.850
<v Speaker 1>I'm just gonna say, like

00:37:25.410 --> 00:37:28.290
<v Speaker 1>so let's say we have, like, I don't

00:37:28.290 --> 00:37:28.450
<v Speaker 1>know.

00:37:30.335 --> 00:37:31.535
<v Speaker 1>That's an array.

00:37:37.214 --> 00:37:39.135
<v Speaker 1>So what I'm doing is, like, I'm creating

00:37:39.135 --> 00:37:40.974
<v Speaker 1>a I'm iterating over it,

00:37:41.214 --> 00:37:43.055
<v Speaker 1>and I'm adding one to each element.

00:37:44.510 --> 00:37:46.349
<v Speaker 1>And then what I'm doing is I'm saying,

00:37:46.349 --> 00:37:48.349
<v Speaker 1>give me a new vector made out of

00:37:48.349 --> 00:37:51.390
<v Speaker 1>this. And the thing is that this collect

00:37:51.390 --> 00:37:52.030
<v Speaker 1>function

00:37:52.190 --> 00:37:54.349
<v Speaker 1>can return a whole different set of types.

00:37:54.349 --> 00:37:55.790
<v Speaker 1>Like, you can get a vector out of

00:37:55.790 --> 00:37:57.070
<v Speaker 1>it. You can get a hash map out

00:37:57.070 --> 00:37:58.914
<v Speaker 1>of it. You can get a b tree

00:37:58.914 --> 00:38:00.515
<v Speaker 1>map out of it. You can get all

00:38:00.515 --> 00:38:02.035
<v Speaker 1>kinds of things. So here, I have to

00:38:02.035 --> 00:38:02.595
<v Speaker 1>say,

00:38:05.234 --> 00:38:05.555
<v Speaker 1>like

00:38:06.515 --> 00:38:08.195
<v Speaker 1>and doesn't matter really.

00:38:09.075 --> 00:38:11.075
<v Speaker 1>If to tell Rust that when you call

00:38:11.075 --> 00:38:12.994
<v Speaker 1>collect, I want the vector out of it.

00:38:13.910 --> 00:38:15.750
<v Speaker 1>And Rust will figure out what you're trying

00:38:15.750 --> 00:38:17.110
<v Speaker 1>to ask for. And there are some cases

00:38:17.190 --> 00:38:18.710
<v Speaker 1>so there are some cases where you're forced

00:38:18.710 --> 00:38:19.510
<v Speaker 1>to do this,

00:38:20.070 --> 00:38:20.950
<v Speaker 1>and you can also do

00:38:24.230 --> 00:38:27.190
<v Speaker 0>Okay. And I'm assuming that's just because those

00:38:27.455 --> 00:38:30.495
<v Speaker 0>types implement some sort of collect trait.

00:38:30.815 --> 00:38:32.655
<v Speaker 0>Is that what makes that work? It's called

00:38:32.655 --> 00:38:34.415
<v Speaker 1>from iterator. But yes. Exactly.

00:38:35.295 --> 00:38:37.135
<v Speaker 1>And the collect function is

00:38:37.855 --> 00:38:40.095
<v Speaker 1>generic over the from iterator type.

00:38:41.790 --> 00:38:44.190
<v Speaker 0>Gotcha. I mean, I understand a little bit

00:38:44.190 --> 00:38:45.790
<v Speaker 0>of that. So Yeah.

00:38:46.350 --> 00:38:47.870
<v Speaker 0>Okay. So the the automatic

00:38:48.510 --> 00:38:51.070
<v Speaker 0>you know, if I the more Rust I

00:38:51.070 --> 00:38:53.550
<v Speaker 0>write is, like, just don't bother with the

00:38:53.550 --> 00:38:55.605
<v Speaker 0>type annotations. Let the compiler do it. I

00:38:55.605 --> 00:38:57.365
<v Speaker 0>mean, the dev tools are pretty good too.

00:38:57.365 --> 00:38:59.205
<v Speaker 0>Right? If I hover over numbers here

00:38:59.605 --> 00:39:00.485
<v Speaker 0>Yeah.

00:39:00.405 --> 00:39:01.765
<v Speaker 0>Or no. It doesn't seem to know what

00:39:01.765 --> 00:39:02.405
<v Speaker 0>that is.

00:39:04.325 --> 00:39:06.645
<v Speaker 1>Maybe because the code doesn't compile yet.

00:39:07.125 --> 00:39:07.765
<v Speaker 0>I

00:39:08.725 --> 00:39:10.640
<v Speaker 1>I don't know if it does. It does.

00:39:10.640 --> 00:39:11.200
<v Speaker 1>Okay.

00:39:11.520 --> 00:39:13.360
<v Speaker 1>No idea why that doesn't work then.

00:39:15.120 --> 00:39:17.920
<v Speaker 0>Oh, it said Rust analyzer is currently indexing.

00:39:18.160 --> 00:39:19.120
<v Speaker 1>Okay.

00:39:19.280 --> 00:39:20.320
<v Speaker 1>That can happen.

00:39:20.560 --> 00:39:22.400
<v Speaker 1>So if if you run the code with

00:39:22.400 --> 00:39:24.795
<v Speaker 1>this, you'll see a panic, which is what

00:39:24.795 --> 00:39:25.995
<v Speaker 1>we're trying to do earlier.

00:39:28.315 --> 00:39:30.875
<v Speaker 1>Yeah. Right. Okay. So whenever we use the

00:39:30.875 --> 00:39:32.315
<v Speaker 0>unwrap function,

00:39:32.635 --> 00:39:34.475
<v Speaker 0>we we have to be very confident as

00:39:34.475 --> 00:39:36.715
<v Speaker 0>the developers that it's never Yes. Gonna have

00:39:36.715 --> 00:39:39.710
<v Speaker 0>a non value. Okay. Yes. And yeah.

00:39:40.750 --> 00:39:42.990
<v Speaker 0>Okay. Nice. Okay. Let's take a look at

00:39:42.990 --> 00:39:44.350
<v Speaker 0>options too.

00:39:50.109 --> 00:39:50.910
<v Speaker 0>Okay.

00:39:50.910 --> 00:39:53.390
<v Speaker 0>So expected one off. Okay. I've seen this

00:39:53.390 --> 00:39:54.190
<v Speaker 0>message before.

00:39:55.994 --> 00:39:57.434
<v Speaker 0>Don't remember what it meant, but I've seen

00:39:57.434 --> 00:39:58.155
<v Speaker 0>it before.

00:39:58.714 --> 00:40:00.235
<v Speaker 0>And then we expected

00:40:01.275 --> 00:40:03.035
<v Speaker 0>okay. So this looks like maybe it's a

00:40:03.035 --> 00:40:04.075
<v Speaker 0>syntax header.

00:40:04.315 --> 00:40:07.115
<v Speaker 1>It's mostly syntax, but there's more as far

00:40:07.115 --> 00:40:07.675
<v Speaker 1>as I can tell.

00:40:09.300 --> 00:40:11.060
<v Speaker 1>So let let's see which things you catch

00:40:11.060 --> 00:40:12.660
<v Speaker 1>first. Option two.

00:40:13.060 --> 00:40:14.020
<v Speaker 0>Yep.

00:40:14.020 --> 00:40:15.780
<v Speaker 0>There we go. I was closing those other

00:40:15.780 --> 00:40:18.100
<v Speaker 0>windows to see if Rust analyzer would

00:40:18.900 --> 00:40:19.860
<v Speaker 1>Oh, yeah.

00:40:21.300 --> 00:40:22.020
<v Speaker 0>Catch up with me again.

00:40:22.755 --> 00:40:24.515
<v Speaker 0>Don't wanna restart Versus Code because of our

00:40:24.515 --> 00:40:26.195
<v Speaker 0>session, so I'll just leave it. Okay.

00:40:29.154 --> 00:40:32.115
<v Speaker 0>Okay. So it's complaining here. Well, there's no

00:40:32.115 --> 00:40:33.234
<v Speaker 0>edge statement.

00:40:34.595 --> 00:40:35.234
<v Speaker 1>Well, yeah.

00:40:37.360 --> 00:40:38.240
<v Speaker 0>Is that it?

00:40:40.960 --> 00:40:42.560
<v Speaker 1>Kind of, but not really.

00:40:44.080 --> 00:40:46.000
<v Speaker 0>Alright. Let's see what new error message is

00:40:46.000 --> 00:40:47.040
<v Speaker 1>for You should look at the error and

00:40:47.040 --> 00:40:47.840
<v Speaker 1>see what it says.

00:40:50.465 --> 00:40:51.185
<v Speaker 1>It's

00:40:52.705 --> 00:40:54.705
<v Speaker 1>That's that's that's still another error. We can

00:40:54.705 --> 00:40:56.065
<v Speaker 1>fix that one later. We can fix this

00:40:56.065 --> 00:40:57.585
<v Speaker 1>one first. Or, I mean, depends on what

00:40:57.585 --> 00:40:59.745
<v Speaker 1>you want. Yeah. I can do that. I'll

00:40:59.745 --> 00:41:01.800
<v Speaker 0>I'll just text where I I mean, I'll

00:41:01.800 --> 00:41:03.480
<v Speaker 0>do my best. Well, no. I mean, I've

00:41:03.480 --> 00:41:04.360
<v Speaker 0>angered it.

00:41:06.200 --> 00:41:08.760
<v Speaker 0>Okay. So cannot find value and scope.

00:41:11.640 --> 00:41:12.840
<v Speaker 0>Yeah. We don't have a value.

00:41:14.184 --> 00:41:17.224
<v Speaker 1>Yeah. So make this an let statement whose

00:41:17.224 --> 00:41:19.625
<v Speaker 0>value is some type. Yes.

00:41:20.345 --> 00:41:20.984
<v Speaker 1>So

00:41:22.424 --> 00:41:23.944
<v Speaker 1>have you seen if let before?

00:41:26.710 --> 00:41:28.710
<v Speaker 0>Yeah. But I I found it a little

00:41:28.710 --> 00:41:31.030
<v Speaker 0>bit confusing. So, you know, let's just pretend

00:41:31.030 --> 00:41:31.830
<v Speaker 0>I haven't.

00:41:32.630 --> 00:41:35.430
<v Speaker 1>Yeah. So what's so what if let is

00:41:35.430 --> 00:41:36.310
<v Speaker 1>is that

00:41:37.510 --> 00:41:38.150
<v Speaker 1>so

00:41:38.790 --> 00:41:39.110
<v Speaker 1>see,

00:41:39.684 --> 00:41:41.525
<v Speaker 1>when when you say let x equal to,

00:41:41.525 --> 00:41:43.845
<v Speaker 1>like, five, what you're saying is that

00:41:44.565 --> 00:41:46.244
<v Speaker 1>so x is actually a pattern,

00:41:46.805 --> 00:41:47.285
<v Speaker 1>but

00:41:47.605 --> 00:41:49.365
<v Speaker 1>I I don't think it's a good point

00:41:49.365 --> 00:41:51.285
<v Speaker 1>to it's not a good idea to explain

00:41:51.285 --> 00:41:53.680
<v Speaker 1>patterns fully yet. But Well, that's the same

00:41:53.680 --> 00:41:55.120
<v Speaker 0>as Alexa. I think you said that as

00:41:55.120 --> 00:41:57.120
<v Speaker 0>of Alexa. They must do something similar there.

00:41:57.120 --> 00:41:59.040
<v Speaker 0>They say assignments aren't assignments. They're actually a

00:41:59.040 --> 00:42:00.640
<v Speaker 0>pattern match. I don't know if that's the

00:42:00.640 --> 00:42:01.600
<v Speaker 0>same here. So

00:42:01.920 --> 00:42:03.920
<v Speaker 1>this is syntactically

00:42:03.920 --> 00:42:05.280
<v Speaker 1>valid though, Rust.

00:42:05.520 --> 00:42:06.880
<v Speaker 1>So this is this is a range.

00:42:07.635 --> 00:42:10.515
<v Speaker 1>And you're saying that let the range from

00:42:10.515 --> 00:42:12.195
<v Speaker 1>five to six be five. This makes no

00:42:12.195 --> 00:42:14.755
<v Speaker 1>sense because if it this this doesn't this

00:42:14.755 --> 00:42:17.555
<v Speaker 1>doesn't make sense, but this is syntactically valid.

00:42:17.635 --> 00:42:19.235
<v Speaker 1>What goes in the let is a pattern

00:42:19.235 --> 00:42:20.355
<v Speaker 1>and what you're saying

00:42:20.755 --> 00:42:21.235
<v Speaker 1>and,

00:42:21.890 --> 00:42:23.490
<v Speaker 1>so you can do, like, let wild card

00:42:23.490 --> 00:42:25.410
<v Speaker 1>equal to five, and Rust will be like,

00:42:25.490 --> 00:42:26.050
<v Speaker 1>yes.

00:42:26.370 --> 00:42:29.010
<v Speaker 1>This this five is a wild card. Like,

00:42:29.650 --> 00:42:31.570
<v Speaker 1>good. And it will do nothing.

00:42:32.850 --> 00:42:34.850
<v Speaker 1>So and and and and in patterns, you

00:42:34.850 --> 00:42:38.125
<v Speaker 1>can put variable bindings, basically say that match

00:42:38.125 --> 00:42:40.285
<v Speaker 1>it to this and set set whatever match

00:42:40.285 --> 00:42:41.885
<v Speaker 1>to this variable. This is kind of like

00:42:41.885 --> 00:42:43.245
<v Speaker 1>regex capture groups,

00:42:44.125 --> 00:42:45.165
<v Speaker 1>but not really.

00:42:47.005 --> 00:42:49.565
<v Speaker 1>And so, normally, this this pattern needs to

00:42:49.565 --> 00:42:51.520
<v Speaker 1>be irrefutable. It needs to be such that

00:42:51.680 --> 00:42:53.359
<v Speaker 1>in a let statement, it needs to be

00:42:53.359 --> 00:42:54.240
<v Speaker 1>such that whatever

00:42:54.720 --> 00:42:56.319
<v Speaker 1>the input here needs to be able to

00:42:56.319 --> 00:42:58.400
<v Speaker 1>match to this. And that's that's fine for

00:42:58.400 --> 00:42:59.440
<v Speaker 1>x because

00:42:59.680 --> 00:43:01.599
<v Speaker 1>any input will match to x and set

00:43:01.599 --> 00:43:03.599
<v Speaker 1>to that value. That's fine for the wildcard

00:43:03.599 --> 00:43:06.455
<v Speaker 1>because anything matches to wildcard. That's not fine

00:43:06.455 --> 00:43:07.095
<v Speaker 1>for

00:43:07.255 --> 00:43:08.855
<v Speaker 1>let some phi

00:43:09.175 --> 00:43:11.655
<v Speaker 1>let some x equal to

00:43:14.295 --> 00:43:16.055
<v Speaker 1>because if if if this

00:43:16.375 --> 00:43:19.335
<v Speaker 1>oops. Alright. My keyboard shortcuts don't work, so

00:43:19.335 --> 00:43:20.535
<v Speaker 1>I'm gonna

00:43:23.020 --> 00:43:25.420
<v Speaker 1>if if if it were let sum x

00:43:25.420 --> 00:43:27.340
<v Speaker 1>equal to none, this would not match.

00:43:27.660 --> 00:43:30.220
<v Speaker 1>And then you've told you've told Rust to

00:43:30.220 --> 00:43:32.619
<v Speaker 1>say that this is the value of x,

00:43:32.615 --> 00:43:35.414
<v Speaker 1>but it can't execute this because it won't.

00:43:35.414 --> 00:43:37.335
<v Speaker 1>But this is where if let comes in

00:43:37.335 --> 00:43:38.055
<v Speaker 1>place,

00:43:38.454 --> 00:43:40.055
<v Speaker 1>where you can actually say

00:43:40.454 --> 00:43:42.214
<v Speaker 1>so if you say if let some value

00:43:42.214 --> 00:43:44.695
<v Speaker 1>equal to optional value, what you're saying is,

00:43:45.174 --> 00:43:45.494
<v Speaker 1>alright.

00:43:46.590 --> 00:43:49.550
<v Speaker 1>Try to match optional value against the pattern

00:43:49.550 --> 00:43:50.670
<v Speaker 1>sum of value.

00:43:51.390 --> 00:43:52.670
<v Speaker 1>If it succeeds,

00:43:52.990 --> 00:43:54.110
<v Speaker 1>this branch

00:43:54.270 --> 00:43:55.150
<v Speaker 1>will run,

00:43:55.550 --> 00:43:58.510
<v Speaker 1>and, also, this branch will have the value

00:43:58.510 --> 00:43:59.070
<v Speaker 1>from here.

00:44:01.305 --> 00:44:04.025
<v Speaker 1>And if not, the else branch.

00:44:05.145 --> 00:44:06.425
<v Speaker 1>So it's like

00:44:06.744 --> 00:44:07.945
<v Speaker 1>it's an if

00:44:08.105 --> 00:44:10.345
<v Speaker 1>with a little inbuilt match.

00:44:11.865 --> 00:44:12.585
<v Speaker 0>Okay.

00:44:12.984 --> 00:44:14.825
<v Speaker 0>That actually helps a lot. Okay.

00:44:17.550 --> 00:44:19.870
<v Speaker 0>It's like is that it fixed? I'm assuming

00:44:19.870 --> 00:44:21.550
<v Speaker 0>we probably want the same

00:44:21.870 --> 00:44:22.430
<v Speaker 1>Yes.

00:44:22.670 --> 00:44:23.310
<v Speaker 1>Here.

00:44:26.190 --> 00:44:27.390
<v Speaker 0>So if

00:44:27.630 --> 00:44:29.950
<v Speaker 0>optional value is a none, it's just gonna

00:44:29.950 --> 00:44:32.565
<v Speaker 0>run the second branch. Right? Yeah.

00:44:33.045 --> 00:44:35.445
<v Speaker 1>Yes. If it's none and it's not none,

00:44:35.445 --> 00:44:38.485
<v Speaker 1>but it will run the second second branch.

00:44:39.125 --> 00:44:40.885
<v Speaker 1>And you can try that out if you

00:44:40.885 --> 00:44:41.925
<v Speaker 1>want. But

00:44:43.925 --> 00:44:45.685
<v Speaker 0>It's not quite happy yet. Let's see.

00:44:51.200 --> 00:44:54.080
<v Speaker 0>Cannot find value lane 22.

00:44:55.760 --> 00:44:56.480
<v Speaker 1>Oh,

00:44:56.720 --> 00:44:59.200
<v Speaker 1>because I didn't type let. My bad.

00:45:00.720 --> 00:45:01.360
<v Speaker 0>Alright.

00:45:04.085 --> 00:45:07.045
<v Speaker 0>And it's saying option cannot be formatted on

00:45:07.045 --> 00:45:08.085
<v Speaker 0>lane 23.

00:45:18.820 --> 00:45:20.500
<v Speaker 0>So I wouldn't expect that to be an

00:45:20.500 --> 00:45:21.540
<v Speaker 0>option there.

00:45:29.140 --> 00:45:31.700
<v Speaker 0>K. So it's a vector of optional

00:45:32.285 --> 00:45:33.005
<v Speaker 1>Yes.

00:45:33.245 --> 00:45:34.765
<v Speaker 0>Eight bit integers.

00:45:36.125 --> 00:45:38.685
<v Speaker 0>So that's just the pop first. Right? And

00:45:38.685 --> 00:45:41.645
<v Speaker 0>then does the comparison against the sum values.

00:45:41.645 --> 00:45:43.165
<v Speaker 0>The same, it should be the the

00:45:44.710 --> 00:45:47.110
<v Speaker 1>It's the same thing. Yeah. So it's gonna

00:45:47.110 --> 00:45:48.390
<v Speaker 1>just yeah.

00:45:50.150 --> 00:45:51.750
<v Speaker 0>But the option type is still what's been

00:45:51.750 --> 00:45:53.270
<v Speaker 0>passed to print lane.

00:45:56.630 --> 00:45:57.190
<v Speaker 1>Wait. What?

00:45:59.984 --> 00:46:01.345
<v Speaker 1>That error

00:46:01.345 --> 00:46:03.105
<v Speaker 1>does not makes oh.

00:46:04.065 --> 00:46:06.545
<v Speaker 1>Oh, I see. So there's a fun fun

00:46:06.545 --> 00:46:08.625
<v Speaker 1>thing here, which is that pop itself returns

00:46:08.625 --> 00:46:09.105
<v Speaker 1>an option.

00:46:10.900 --> 00:46:13.620
<v Speaker 1>Because if the new vector's empty, what's it

00:46:13.620 --> 00:46:14.980
<v Speaker 1>gonna return? Nothing.

00:46:15.300 --> 00:46:17.700
<v Speaker 1>So it returns an option of the type.

00:46:17.860 --> 00:46:19.940
<v Speaker 1>So because we have a vector of options,

00:46:21.220 --> 00:46:23.140
<v Speaker 1>when pop returns an option of an option.

00:46:23.724 --> 00:46:25.645
<v Speaker 1>Does that make sense? Yeah. So we can

00:46:25.645 --> 00:46:26.925
<v Speaker 0>do that sum sum value.

00:46:32.365 --> 00:46:32.925
<v Speaker 0>Oh.

00:46:33.645 --> 00:46:35.645
<v Speaker 0>Did I not save it? Yeah. There we

00:46:35.645 --> 00:46:36.205
<v Speaker 0>go.

00:46:37.165 --> 00:46:37.805
<v Speaker 0>There.

00:46:38.444 --> 00:46:38.765
<v Speaker 1>Yeah.

00:46:39.640 --> 00:46:41.480
<v Speaker 1>And what it wants us to do here

00:46:41.480 --> 00:46:43.240
<v Speaker 1>is it wants us to

00:46:43.720 --> 00:46:45.400
<v Speaker 1>oh, and it it it it actually says

00:46:45.400 --> 00:46:47.320
<v Speaker 1>that vector dot pop adds another layer of

00:46:47.320 --> 00:46:48.200
<v Speaker 1>option t,

00:46:48.520 --> 00:46:50.600
<v Speaker 1>and you can just stack option t's. And

00:46:50.600 --> 00:46:52.040
<v Speaker 1>what it wants us to do is turn

00:46:52.040 --> 00:46:53.160
<v Speaker 1>it into a while let.

00:46:53.675 --> 00:46:56.795
<v Speaker 1>A while let is is like, so if

00:46:56.795 --> 00:46:58.715
<v Speaker 1>let is the sort of

00:46:59.035 --> 00:47:00.955
<v Speaker 1>pattern matchy version of if,

00:47:01.435 --> 00:47:03.355
<v Speaker 1>while let is kind of the pattern matchy

00:47:03.355 --> 00:47:04.395
<v Speaker 1>version of while,

00:47:04.715 --> 00:47:05.595
<v Speaker 1>which it does this

00:47:06.309 --> 00:47:09.349
<v Speaker 1>instead of saying if a condition do something,

00:47:09.349 --> 00:47:11.670
<v Speaker 1>it's as long as the condition is true,

00:47:12.069 --> 00:47:13.990
<v Speaker 1>do the thing. So it's a while loop,

00:47:14.069 --> 00:47:16.390
<v Speaker 1>but it's going to match on the

00:47:16.869 --> 00:47:19.430
<v Speaker 1>it's gonna match on the value and the

00:47:19.430 --> 00:47:22.255
<v Speaker 1>the results of this statement and give you

00:47:22.415 --> 00:47:24.655
<v Speaker 1>a value each time. So what this will

00:47:24.655 --> 00:47:26.015
<v Speaker 0>do is Oh, okay.

00:47:26.335 --> 00:47:27.455
<v Speaker 1>Whole thing and

00:47:28.015 --> 00:47:29.455
<v Speaker 1>return each value

00:47:29.855 --> 00:47:31.455
<v Speaker 1>until it stops

00:47:31.615 --> 00:47:32.415
<v Speaker 1>being

00:47:32.575 --> 00:47:33.535
<v Speaker 1>some some value.

00:47:36.599 --> 00:47:37.240
<v Speaker 0>Okay.

00:47:38.440 --> 00:47:39.880
<v Speaker 0>That makes sense. So it's just gonna keep

00:47:39.880 --> 00:47:42.200
<v Speaker 0>popping all those values off. Yep.

00:47:42.760 --> 00:47:43.800
<v Speaker 0>Is the

00:47:45.160 --> 00:47:46.839
<v Speaker 0>so is that something that does that mean

00:47:46.839 --> 00:47:49.755
<v Speaker 0>semantically, like, the actual con no. I don't

00:47:49.755 --> 00:47:51.194
<v Speaker 0>know if you'd say concrete one, but the

00:47:51.194 --> 00:47:52.795
<v Speaker 0>the pattern on the left and then the

00:47:52.795 --> 00:47:54.315
<v Speaker 0>concrete value on the right, is that always

00:47:54.315 --> 00:47:56.394
<v Speaker 0>the case? Can I swap those around? No.

00:47:56.394 --> 00:47:58.954
<v Speaker 1>You cannot. They're the patterns these are syntactically

00:47:58.954 --> 00:47:59.755
<v Speaker 1>two different

00:48:00.075 --> 00:48:01.515
<v Speaker 1>things. So, like, on the left, you have

00:48:01.515 --> 00:48:01.835
<v Speaker 1>a pattern.

00:48:02.559 --> 00:48:04.319
<v Speaker 1>Okay. So you you can also put something

00:48:04.319 --> 00:48:06.079
<v Speaker 1>like and and this will cause an infinite

00:48:06.079 --> 00:48:07.599
<v Speaker 1>loop, but you can put a wildcard pattern

00:48:07.599 --> 00:48:09.359
<v Speaker 1>there. But you can't put a wildcard pattern

00:48:09.359 --> 00:48:10.320
<v Speaker 1>on the other side.

00:48:11.280 --> 00:48:12.960
<v Speaker 0>Got it. Okay. Yeah.

00:48:13.359 --> 00:48:15.119
<v Speaker 0>Yeah. I think that's how Alexa works too,

00:48:15.119 --> 00:48:16.559
<v Speaker 0>but I can't really remember off the top

00:48:16.559 --> 00:48:17.359
<v Speaker 0>of my head. So

00:48:18.215 --> 00:48:20.375
<v Speaker 0>that passes. Now I'm just gonna break it

00:48:20.375 --> 00:48:21.015
<v Speaker 0>again

00:48:21.655 --> 00:48:22.775
<v Speaker 0>and do none.

00:48:25.175 --> 00:48:26.455
<v Speaker 0>And not break it, but that should print

00:48:26.455 --> 00:48:28.375
<v Speaker 0>the value doesn't contain anything. Right?

00:48:29.655 --> 00:48:30.055
<v Speaker 1>Yeah.

00:48:36.500 --> 00:48:37.460
<v Speaker 1>Oh, because

00:48:37.940 --> 00:48:39.940
<v Speaker 1>it doesn't know the type. And this is

00:48:39.940 --> 00:48:41.300
<v Speaker 1>where you use the syntax.

00:48:41.860 --> 00:48:43.300
<v Speaker 1>Well, it needs to be option of u

00:48:43.300 --> 00:48:45.220
<v Speaker 1>eight. This is not gonna compile either.

00:48:46.655 --> 00:48:47.295
<v Speaker 1>Yeah.

00:48:49.055 --> 00:48:51.615
<v Speaker 1>This is exactly where the syntax comes useful.

00:48:51.615 --> 00:48:54.415
<v Speaker 1>Not not that not that there's any point

00:48:54.415 --> 00:48:56.655
<v Speaker 1>to this kind of code really existing

00:48:56.895 --> 00:48:59.375
<v Speaker 1>because you're creating a value and then checking

00:48:59.375 --> 00:49:00.655
<v Speaker 1>what it is immediately.

00:49:01.214 --> 00:49:01.695
<v Speaker 1>So

00:49:02.200 --> 00:49:03.400
<v Speaker 1>but yeah.

00:49:03.960 --> 00:49:05.880
<v Speaker 1>It's gonna say it doesn't contain anything.

00:49:06.120 --> 00:49:08.120
<v Speaker 0>Yeah. I I guess the reason for typing

00:49:08.120 --> 00:49:09.800
<v Speaker 0>this kind of code is educational.

00:49:09.800 --> 00:49:11.000
<v Speaker 1>It's Exactly.

00:49:11.400 --> 00:49:12.600
<v Speaker 0>Me understand it.

00:49:13.880 --> 00:49:16.194
<v Speaker 1>Yeah. So in this case, Rust had no

00:49:16.194 --> 00:49:17.475
<v Speaker 1>idea what the type was.

00:49:18.675 --> 00:49:20.835
<v Speaker 1>Like, because it it you gave it none,

00:49:20.835 --> 00:49:22.035
<v Speaker 1>so it didn't know what was in the

00:49:22.035 --> 00:49:24.035
<v Speaker 1>option. It knew it was an option, but

00:49:24.035 --> 00:49:25.395
<v Speaker 1>it didn't know what went in it, so

00:49:25.395 --> 00:49:27.075
<v Speaker 1>it didn't have a complete type. And

00:49:28.000 --> 00:49:29.680
<v Speaker 1>it didn't need to because it would never

00:49:29.680 --> 00:49:31.280
<v Speaker 1>hit the branch that needed to, but it

00:49:31.280 --> 00:49:33.360
<v Speaker 1>it wants to know all the types completely.

00:49:33.360 --> 00:49:34.880
<v Speaker 1>So you have to tell it what the

00:49:34.880 --> 00:49:35.520
<v Speaker 1>type is.

00:49:36.800 --> 00:49:39.040
<v Speaker 0>Okay. One more thing before we move on

00:49:39.040 --> 00:49:39.600
<v Speaker 0>then.

00:49:39.920 --> 00:49:41.440
<v Speaker 0>Just because what you're talking about there is

00:49:41.440 --> 00:49:43.440
<v Speaker 0>the compiler trying to

00:49:44.205 --> 00:49:46.845
<v Speaker 0>infer the thing. Can I remove

00:49:49.005 --> 00:49:51.325
<v Speaker 0>the option here because it knows the x

00:49:51.325 --> 00:49:52.365
<v Speaker 0>isn't in?

00:49:53.485 --> 00:49:55.085
<v Speaker 0>Or because there's no none value. Right? So

00:49:55.085 --> 00:49:57.565
<v Speaker 1>so you can't remove it. You can replace

00:49:57.565 --> 00:49:59.920
<v Speaker 1>it with an a wildcard.

00:50:00.240 --> 00:50:02.800
<v Speaker 1>So types can have wildcards too. I suspect

00:50:02.800 --> 00:50:04.960
<v Speaker 1>this and, actually, in that case, because you

00:50:04.960 --> 00:50:07.280
<v Speaker 1>used VEC new here, so Rust already knows

00:50:07.280 --> 00:50:09.280
<v Speaker 1>that this is a VEC of something. It

00:50:09.280 --> 00:50:11.925
<v Speaker 1>doesn't know what that something is. I suspect

00:50:11.925 --> 00:50:14.805
<v Speaker 1>it won't compile. There's no reason why Rust

00:50:15.445 --> 00:50:18.005
<v Speaker 1>won't like, Rust could make this compile at

00:50:18.005 --> 00:50:20.245
<v Speaker 1>some point. My suspicion is that right now

00:50:20.245 --> 00:50:21.365
<v Speaker 1>this won't compile.

00:50:21.765 --> 00:50:22.165
<v Speaker 1>And

00:50:23.285 --> 00:50:26.170
<v Speaker 1>this is basically that. Or okay. It does.

00:50:26.410 --> 00:50:28.330
<v Speaker 1>So it's it's smart enough to be like,

00:50:28.330 --> 00:50:30.650
<v Speaker 1>it's a Vec, and it's it it's like,

00:50:30.650 --> 00:50:32.410
<v Speaker 1>I'll calm down. I won't I won't

00:50:33.690 --> 00:50:35.130
<v Speaker 1>I know you haven't told me what the

00:50:35.130 --> 00:50:36.570
<v Speaker 1>whole of Vec is, but I'll wait a

00:50:36.570 --> 00:50:38.010
<v Speaker 1>little bit and see if you can tell

00:50:38.010 --> 00:50:39.865
<v Speaker 1>me eventually. And so it's like, right now,

00:50:39.865 --> 00:50:41.065
<v Speaker 1>all I know is that it's a VEK

00:50:41.065 --> 00:50:43.545
<v Speaker 1>of something. And, oh, okay. You pushed something

00:50:43.545 --> 00:50:44.905
<v Speaker 1>to it. Now I know what it is.

00:50:45.945 --> 00:50:47.785
<v Speaker 1>But there there will be some cases that

00:50:47.785 --> 00:50:49.865
<v Speaker 1>are similar to this where it won't. So

00:50:51.250 --> 00:50:53.010
<v Speaker 1>yeah. What what I what I always do

00:50:53.010 --> 00:50:54.450
<v Speaker 1>is just, like,

00:50:54.850 --> 00:50:56.450
<v Speaker 1>write it without the types. And then if

00:50:56.450 --> 00:50:58.210
<v Speaker 1>it complains about types that I know what

00:50:58.210 --> 00:50:59.730
<v Speaker 1>they are, I just add them in.

00:51:00.050 --> 00:51:00.770
<v Speaker 0>Alright.

00:51:01.010 --> 00:51:01.890
<v Speaker 0>Clever compiler.

00:51:03.965 --> 00:51:05.885
<v Speaker 0>Okay. So that was options.

00:51:05.885 --> 00:51:08.445
<v Speaker 0>Let's you wanna jump over to enums then?

00:51:08.605 --> 00:51:10.685
<v Speaker 1>Sure. Yeah. Alright.

00:51:10.925 --> 00:51:13.085
<v Speaker 0>Let's run the test.

00:51:13.085 --> 00:51:14.125
<v Speaker 0>Enums

00:51:14.205 --> 00:51:14.445
<v Speaker 0>one.

00:51:16.640 --> 00:51:17.360
<v Speaker 0>Okay.

00:51:17.760 --> 00:51:20.080
<v Speaker 0>What have I got here? So no variant

00:51:20.080 --> 00:51:23.200
<v Speaker 0>or associated item named quit. Fan for enum

00:51:23.200 --> 00:51:25.200
<v Speaker 0>message lane 12.

00:51:27.680 --> 00:51:29.600
<v Speaker 1>There's a nice big fat to do saying,

00:51:29.600 --> 00:51:30.960
<v Speaker 1>well Yeah. So

00:51:31.355 --> 00:51:33.595
<v Speaker 0>that's just an empty enum. Right? It's it's

00:51:33.595 --> 00:51:35.994
<v Speaker 0>actually got no definitions types.

00:51:37.275 --> 00:51:37.915
<v Speaker 0>Okay.

00:51:40.315 --> 00:51:41.115
<v Speaker 0>I mean

00:51:41.674 --> 00:51:42.315
<v Speaker 1>Yeah.

00:51:42.555 --> 00:51:45.194
<v Speaker 0>We're assuming this is gonna work? That is

00:51:45.194 --> 00:51:45.835
<v Speaker 1>gonna work. Yeah.

00:51:47.270 --> 00:51:49.830
<v Speaker 0>Are the commas optional, mandatory?

00:51:50.230 --> 00:51:51.510
<v Speaker 1>Mandatory. Okay.

00:51:52.630 --> 00:51:53.350
<v Speaker 1>Yeah.

00:51:53.510 --> 00:51:55.670
<v Speaker 1>Commas are optional in a few cases, but

00:51:55.670 --> 00:51:56.470
<v Speaker 1>not for enums.

00:51:59.285 --> 00:52:01.204
<v Speaker 1>The last one is optional, but

00:52:02.164 --> 00:52:02.724
<v Speaker 1>yeah.

00:52:02.964 --> 00:52:05.444
<v Speaker 0>Yeah. I think if if they're mandatory anywhere,

00:52:05.444 --> 00:52:06.565
<v Speaker 0>I'll probably just put it on the last

00:52:06.565 --> 00:52:07.285
<v Speaker 0>one too.

00:52:08.325 --> 00:52:09.045
<v Speaker 0>Alright.

00:52:09.204 --> 00:52:12.164
<v Speaker 0>That works. So this syntax is

00:52:13.040 --> 00:52:15.280
<v Speaker 0>is that how we always let's see if

00:52:15.280 --> 00:52:17.920
<v Speaker 0>I can get auto complete. Yeah. Okay. That's

00:52:17.920 --> 00:52:19.520
<v Speaker 0>just how we reference members of a a

00:52:19.520 --> 00:52:20.320
<v Speaker 0>new node.

00:52:21.200 --> 00:52:22.400
<v Speaker 1>Yeah. Basically

00:52:22.720 --> 00:52:24.960
<v Speaker 1>so have you seen, like, pads and modules

00:52:24.960 --> 00:52:26.480
<v Speaker 1>yet? Like, have you seen the use statement?

00:52:28.164 --> 00:52:29.204
<v Speaker 0>Yes.

00:52:29.204 --> 00:52:32.005
<v Speaker 0>I have. So, like, this is this is

00:52:32.005 --> 00:52:33.605
<v Speaker 1>just a variant of that. And what's what's

00:52:33.605 --> 00:52:36.325
<v Speaker 1>going on here is that the enum message

00:52:36.325 --> 00:52:38.085
<v Speaker 1>kind of has children,

00:52:38.964 --> 00:52:39.845
<v Speaker 1>and they're

00:52:40.005 --> 00:52:40.964
<v Speaker 1>scoped under message.

00:52:41.660 --> 00:52:43.980
<v Speaker 1>So you can also do, like, use if

00:52:43.980 --> 00:52:45.580
<v Speaker 1>you did use message

00:52:46.060 --> 00:52:47.820
<v Speaker 1>quit, then you could just say quit.

00:52:49.980 --> 00:52:52.140
<v Speaker 1>You could just say quit. And that's what

00:52:52.140 --> 00:52:53.820
<v Speaker 1>happens with option, by the way. Because if

00:52:53.820 --> 00:52:55.820
<v Speaker 1>you notice, we didn't have to do option

00:52:55.820 --> 00:52:57.420
<v Speaker 1>some and option

00:52:57.755 --> 00:53:01.115
<v Speaker 1>none, and that's because by default, Rust directly

00:53:01.115 --> 00:53:02.715
<v Speaker 1>imports none and sum.

00:53:03.355 --> 00:53:04.235
<v Speaker 0>Alright.

00:53:04.235 --> 00:53:05.035
<v Speaker 0>Cool.

00:53:05.195 --> 00:53:05.675
<v Speaker 0>Yeah.

00:53:06.635 --> 00:53:08.635
<v Speaker 0>Can you know, I've used the syntax and

00:53:08.635 --> 00:53:10.155
<v Speaker 0>never really known what it does. Can you

00:53:10.155 --> 00:53:12.315
<v Speaker 0>maybe explain that to me too? Oh, sure.

00:53:13.010 --> 00:53:14.210
<v Speaker 1>So the print

00:53:14.450 --> 00:53:16.130
<v Speaker 1>this is the this is the print format

00:53:16.130 --> 00:53:18.290
<v Speaker 1>string the format string syntax in Rust is

00:53:18.290 --> 00:53:19.730
<v Speaker 1>pretty robust. And

00:53:21.650 --> 00:53:23.810
<v Speaker 1>oh, well, that didn't autocomplete.

00:53:25.250 --> 00:53:28.015
<v Speaker 1>So, like, when when you don't when you

00:53:28.015 --> 00:53:30.095
<v Speaker 1>use this, it means that this is

00:53:30.655 --> 00:53:31.695
<v Speaker 1>this parameter.

00:53:31.695 --> 00:53:33.935
<v Speaker 1>And you can also, like, number parameters.

00:53:34.575 --> 00:53:36.495
<v Speaker 1>You can even name them, like,

00:53:37.455 --> 00:53:38.655
<v Speaker 1>and you can say,

00:53:39.375 --> 00:53:41.349
<v Speaker 1>equal to five. You can do all kinds

00:53:41.349 --> 00:53:42.230
<v Speaker 1>of stuff here.

00:53:42.470 --> 00:53:45.750
<v Speaker 1>But when when you're just using braces with

00:53:45.750 --> 00:53:48.470
<v Speaker 1>no question mark, this means use what's called

00:53:48.470 --> 00:53:49.990
<v Speaker 1>the display implementation.

00:53:50.230 --> 00:53:52.390
<v Speaker 1>So there's a trait called display, and it's

00:53:52.390 --> 00:53:53.190
<v Speaker 1>it's

00:53:53.190 --> 00:53:54.550
<v Speaker 1>implemented for types

00:53:55.015 --> 00:53:55.895
<v Speaker 1>that have

00:53:57.175 --> 00:53:59.335
<v Speaker 1>that are intended to be displayed to the

00:53:59.335 --> 00:54:00.935
<v Speaker 1>to to the end user,

00:54:01.175 --> 00:54:03.335
<v Speaker 1>and the implementation tells you how you do

00:54:03.335 --> 00:54:04.215
<v Speaker 1>that display.

00:54:06.135 --> 00:54:07.895
<v Speaker 1>This thing means debug,

00:54:07.895 --> 00:54:09.255
<v Speaker 1>and what it means is that

00:54:09.810 --> 00:54:12.210
<v Speaker 1>this output might be ugly, and you probably

00:54:12.210 --> 00:54:13.810
<v Speaker 1>don't want to actually display it to the

00:54:13.810 --> 00:54:16.130
<v Speaker 1>user. In this case, actually, what the user

00:54:16.130 --> 00:54:17.810
<v Speaker 1>would see is just the words quit, echo,

00:54:17.810 --> 00:54:20.290
<v Speaker 1>move, or change color because so this this

00:54:20.290 --> 00:54:24.085
<v Speaker 1>custom this this derive is automatically deriving an

00:54:24.085 --> 00:54:24.964
<v Speaker 1>implementation.

00:54:25.365 --> 00:54:27.445
<v Speaker 1>But, for example, if you did

00:54:28.724 --> 00:54:29.445
<v Speaker 1>oh,

00:54:32.005 --> 00:54:34.565
<v Speaker 1>if you did derive on debug and then

00:54:34.565 --> 00:54:35.765
<v Speaker 1>destruct foo,

00:54:40.460 --> 00:54:43.580
<v Speaker 1>the the debug implementation would print some something

00:54:43.580 --> 00:54:44.060
<v Speaker 1>like

00:54:47.580 --> 00:54:49.580
<v Speaker 1>which you probably don't wanna show users.

00:54:49.980 --> 00:54:50.460
<v Speaker 1>Yeah.

00:54:51.555 --> 00:54:54.835
<v Speaker 1>So display is and, typically, display is something

00:54:54.835 --> 00:54:56.515
<v Speaker 1>that is written manually.

00:54:56.994 --> 00:54:58.835
<v Speaker 1>You will you will you will look at

00:54:58.835 --> 00:55:00.515
<v Speaker 1>your type, and you will decide how best

00:55:00.515 --> 00:55:02.275
<v Speaker 1>it is to how best to display it

00:55:02.275 --> 00:55:03.635
<v Speaker 1>to the user, and you'll write a manual

00:55:03.635 --> 00:55:07.190
<v Speaker 1>implementation, whereas debug is almost always custom derived

00:55:07.190 --> 00:55:07.990
<v Speaker 1>that way.

00:55:08.470 --> 00:55:09.030
<v Speaker 1>So

00:55:09.510 --> 00:55:11.670
<v Speaker 1>this is basically while debugging, if you use

00:55:11.670 --> 00:55:13.589
<v Speaker 1>the colon question marks and tags, you can

00:55:13.589 --> 00:55:13.830
<v Speaker 1>just

00:55:14.550 --> 00:55:17.110
<v Speaker 1>this is how you'll see your own types,

00:55:17.349 --> 00:55:19.349
<v Speaker 1>and it will show you basically everything that's

00:55:19.349 --> 00:55:19.589
<v Speaker 1>in them.

00:55:20.625 --> 00:55:22.465
<v Speaker 0>Okay. So I I just wanna confirm I

00:55:22.465 --> 00:55:24.305
<v Speaker 0>understood that correctly. If I had to move

00:55:24.305 --> 00:55:26.305
<v Speaker 0>that's arrived debug in this, will this fail

00:55:26.305 --> 00:55:28.145
<v Speaker 0>to compile? Nope. Yeah.

00:55:30.305 --> 00:55:32.465
<v Speaker 0>Cool. Yes. Alright. That makes a lot of

00:55:32.465 --> 00:55:34.560
<v Speaker 0>sense. You know, all you need is someone

00:55:34.560 --> 00:55:36.320
<v Speaker 0>just to explain it and, like, boom. Like,

00:55:36.320 --> 00:55:36.960
<v Speaker 0>cool. Alright.

00:55:37.840 --> 00:55:39.760
<v Speaker 1>So it's very it's very normal to just

00:55:39.760 --> 00:55:42.800
<v Speaker 1>slap derived debug on basically everything you write,

00:55:42.800 --> 00:55:45.360
<v Speaker 1>every structured enum in your program because at

00:55:45.360 --> 00:55:46.720
<v Speaker 1>some point or the other, you're gonna print

00:55:46.720 --> 00:55:47.840
<v Speaker 1>it out for debugging.

00:55:49.944 --> 00:55:53.305
<v Speaker 0>Cool. Good to know. Alright. Let's pop open

00:55:53.305 --> 00:55:54.585
<v Speaker 0>enums two.

00:55:56.105 --> 00:55:58.345
<v Speaker 0>Let's see. So we don't have any variants

00:55:58.345 --> 00:56:00.665
<v Speaker 0>for our message one, but I can see

00:56:00.665 --> 00:56:02.905
<v Speaker 0>here we do oh, these ones are getting

00:56:02.905 --> 00:56:03.305
<v Speaker 0>fancy.

00:56:04.140 --> 00:56:04.780
<v Speaker 0>Okay.

00:56:05.420 --> 00:56:07.260
<v Speaker 0>Oh, we got a plain move and a

00:56:07.260 --> 00:56:08.460
<v Speaker 0>plain quit.

00:56:09.420 --> 00:56:11.660
<v Speaker 1>We don't have a plain move, but we'll

00:56:11.660 --> 00:56:12.300
<v Speaker 1>get to that. Oh,

00:56:13.020 --> 00:56:14.700
<v Speaker 0>yeah. Let's do the other two because you've

00:56:14.700 --> 00:56:15.980
<v Speaker 1>seen the syntax there before.

00:56:21.375 --> 00:56:23.694
<v Speaker 0>Okay. So we got oh, well, let me

00:56:23.694 --> 00:56:25.615
<v Speaker 0>start from this. So we got change color.

00:56:25.615 --> 00:56:28.895
<v Speaker 0>Alright. So change color is a triple. Right?

00:56:28.895 --> 00:56:31.650
<v Speaker 0>So that means I did that. Yep. I

00:56:38.290 --> 00:56:39.330
<v Speaker 0>echo

00:56:43.010 --> 00:56:44.610
<v Speaker 0>triple of string.

00:56:44.770 --> 00:56:45.170
<v Speaker 1>Yep.

00:56:46.385 --> 00:56:47.345
<v Speaker 0>Yeah.

00:56:48.945 --> 00:56:50.545
<v Speaker 0>It's a stellar triple of this one, I

00:56:50.545 --> 00:56:51.984
<v Speaker 0>guess, so maybe I think it It's just

00:56:52.065 --> 00:56:54.464
<v Speaker 1>we just most enum variants look like this,

00:56:54.464 --> 00:56:56.785
<v Speaker 1>so we don't actually they're called technically called

00:56:56.785 --> 00:56:59.825
<v Speaker 1>tuple variants, but we just call them variants

00:57:00.305 --> 00:57:01.744
<v Speaker 1>or data full variants

00:57:02.680 --> 00:57:05.480
<v Speaker 1>because almost always, they look like this. Almost

00:57:05.480 --> 00:57:07.080
<v Speaker 1>always, they use the parentheses and not the

00:57:07.080 --> 00:57:09.240
<v Speaker 1>braces. The braces are actually pretty rare,

00:57:09.960 --> 00:57:12.200
<v Speaker 1>and you you use them when like, over

00:57:12.200 --> 00:57:14.440
<v Speaker 1>here, it's pretty obvious that this is red,

00:57:14.440 --> 00:57:16.595
<v Speaker 1>green, and blue. But if you had, like,

00:57:16.595 --> 00:57:18.835
<v Speaker 1>a bunch of u 30 twos and they

00:57:18.835 --> 00:57:21.315
<v Speaker 1>all were different things that, like, were different

00:57:21.315 --> 00:57:22.035
<v Speaker 1>concepts,

00:57:22.275 --> 00:57:24.515
<v Speaker 1>it is often better to just name them.

00:57:24.835 --> 00:57:26.915
<v Speaker 1>And that's where the thing used for move

00:57:26.915 --> 00:57:28.595
<v Speaker 1>comes in, where you actually have to give

00:57:28.595 --> 00:57:29.075
<v Speaker 1>them a name.

00:57:29.720 --> 00:57:32.039
<v Speaker 1>And that that you just do, but, like,

00:57:32.039 --> 00:57:33.960
<v Speaker 1>it it uses the struct syntax

00:57:37.400 --> 00:57:38.440
<v Speaker 1>like that.

00:57:41.640 --> 00:57:43.000
<v Speaker 0>Nice. So enums

00:57:44.225 --> 00:57:48.065
<v Speaker 0>can really be a pretty flexible component then.

00:57:48.065 --> 00:57:49.825
<v Speaker 1>Yes. And I can I mean, one of

00:57:49.825 --> 00:57:50.785
<v Speaker 0>the things I'm thinking of in my head

00:57:50.785 --> 00:57:52.225
<v Speaker 0>as soon as I've seen this is, like,

00:57:52.225 --> 00:57:52.945
<v Speaker 0>you know,

00:57:53.265 --> 00:57:55.665
<v Speaker 0>if I wanna write endpoints that take gRPC

00:57:55.665 --> 00:57:57.359
<v Speaker 0>messages, like, that could just be an email

00:57:57.359 --> 00:57:58.960
<v Speaker 0>of all the different messages I can receive

00:57:58.960 --> 00:58:00.720
<v Speaker 0>on an endpoint, and I could match

00:58:01.040 --> 00:58:03.200
<v Speaker 0>and work on that or something? Exactly. Yes.

00:58:03.200 --> 00:58:04.720
<v Speaker 1>And match is how you usually deal with

00:58:04.720 --> 00:58:05.520
<v Speaker 1>enums.

00:58:07.440 --> 00:58:09.040
<v Speaker 1>Like, I mean, I I showed the match

00:58:09.040 --> 00:58:12.000
<v Speaker 1>with just values earlier, and I'm sure that

00:58:11.435 --> 00:58:13.195
<v Speaker 1>probably the next exercise will have this. But

00:58:13.195 --> 00:58:15.435
<v Speaker 1>I showed the match with values earlier, but

00:58:15.435 --> 00:58:17.275
<v Speaker 1>the match statement takes patterns. So you can

00:58:17.275 --> 00:58:18.395
<v Speaker 1>do things like match

00:58:19.115 --> 00:58:20.795
<v Speaker 1>match message and say,

00:58:21.115 --> 00:58:22.635
<v Speaker 1>move x y

00:58:22.795 --> 00:58:25.035
<v Speaker 1>something, quit something, echo something.

00:58:25.890 --> 00:58:28.770
<v Speaker 0>Ah, cool. I like it. Alright. Let's see

00:58:28.770 --> 00:58:29.970
<v Speaker 0>if we fixed this then.

00:58:31.010 --> 00:58:33.730
<v Speaker 0>Items too. We did. Okay.

00:58:36.130 --> 00:58:37.890
<v Speaker 0>What's this call function?

00:58:37.970 --> 00:58:39.970
<v Speaker 0>Oh, no. It's just the ah, okay.

00:58:40.734 --> 00:58:42.095
<v Speaker 1>And all it does is it uses the

00:58:42.095 --> 00:58:43.375
<v Speaker 1>debug implementation.

00:58:43.855 --> 00:58:45.535
<v Speaker 1>And I guess if you run it, you'll

00:58:45.535 --> 00:58:47.615
<v Speaker 1>realize that the debug implementation of this enum

00:58:47.615 --> 00:58:49.135
<v Speaker 1>is not very pretty.

00:58:49.695 --> 00:58:51.455
<v Speaker 1>It's not something you'll wanna show to the

00:58:51.455 --> 00:58:51.695
<v Speaker 1>user.

00:58:54.860 --> 00:58:56.860
<v Speaker 0>This one? Yeah. This is this

00:58:58.780 --> 00:59:00.540
<v Speaker 1>like, this is not something

00:59:01.100 --> 00:59:02.940
<v Speaker 1>like, if if if you had a user,

00:59:02.940 --> 00:59:05.580
<v Speaker 1>end user, not a programmer using your application,

00:59:05.580 --> 00:59:07.855
<v Speaker 1>you probably wouldn't wanna show them change color

00:59:07.855 --> 00:59:09.775
<v Speaker 1>200, two 50 five, two 50 five. You'd

00:59:09.775 --> 00:59:10.975
<v Speaker 1>wanna show them, like,

00:59:11.295 --> 00:59:13.055
<v Speaker 1>change the color to

00:59:13.535 --> 00:59:17.135
<v Speaker 1>this color or something. So Yeah. Okay. Also,

00:59:17.135 --> 00:59:18.735
<v Speaker 1>this is the this is probably an internal

00:59:18.735 --> 00:59:20.255
<v Speaker 1>message, so you'd never show it to the

00:59:20.255 --> 00:59:22.015
<v Speaker 1>user in the first place. But yeah.

00:59:22.750 --> 00:59:25.070
<v Speaker 0>Oh, you'd hope so. But, you know, I'm

00:59:25.070 --> 00:59:26.190
<v Speaker 0>a bit of a caretaker all of this

00:59:26.190 --> 00:59:26.990
<v Speaker 0>stuff. So

00:59:27.390 --> 00:59:29.070
<v Speaker 0>I'm just gonna make them smaller and make

00:59:29.070 --> 00:59:30.270
<v Speaker 0>this bigger. Is that gonna

00:59:30.830 --> 00:59:33.310
<v Speaker 0>does the compiler know? The compiler does know.

00:59:34.865 --> 00:59:36.145
<v Speaker 0>I'm your compiler.

00:59:36.944 --> 00:59:37.665
<v Speaker 0>Cool.

00:59:37.905 --> 00:59:39.185
<v Speaker 0>And is there I mean,

00:59:39.744 --> 00:59:41.105
<v Speaker 0>U S R A 2 is not exactly

00:59:41.105 --> 00:59:42.865
<v Speaker 0>massive. Right? I mean, is there only special

00:59:42.865 --> 00:59:45.025
<v Speaker 0>circumstances you would choose anything smaller? Like, is

00:59:45.025 --> 00:59:47.345
<v Speaker 0>there any rules around that? There's nothing smaller

00:59:47.345 --> 00:59:49.025
<v Speaker 1>than u eight. I mean, in this case,

00:59:49.550 --> 00:59:51.550
<v Speaker 1>if you're talking about two fifty six bit

00:59:51.550 --> 00:59:52.190
<v Speaker 1>color,

00:59:53.470 --> 00:59:55.150
<v Speaker 1>you probably wanna use a u eight so

00:59:55.150 --> 00:59:56.750
<v Speaker 1>people don't give you a number that's too

00:59:56.750 --> 00:59:57.230
<v Speaker 1>big.

00:59:59.869 --> 01:00:02.430
<v Speaker 1>Yeah. Like, that that's basically when you start

01:00:02.430 --> 01:00:03.630
<v Speaker 1>using u eights. And often,

01:00:04.145 --> 01:00:06.865
<v Speaker 1>you actually want to size optimize. Often, like

01:00:07.345 --> 01:00:09.265
<v Speaker 1>I mean, I've worked on browsers and stuff,

01:00:09.265 --> 01:00:10.865
<v Speaker 1>and in browsers, you often have these trucks

01:00:10.865 --> 01:00:12.305
<v Speaker 1>that are just everywhere.

01:00:12.704 --> 01:00:15.984
<v Speaker 1>Like, for example, the node type in JavaScript,

01:00:16.800 --> 01:00:18.640
<v Speaker 1>like, doc for elements,

01:00:18.960 --> 01:00:21.280
<v Speaker 1>everything is a node, you need to allocate

01:00:21.280 --> 01:00:22.960
<v Speaker 1>that again and again. So if you if

01:00:22.960 --> 01:00:24.160
<v Speaker 1>you can just shave off, like

01:00:24.880 --> 01:00:26.480
<v Speaker 1>if you can pack a bunch of things

01:00:26.480 --> 01:00:29.285
<v Speaker 1>that don't need to be 32 bit integers

01:00:29.285 --> 01:00:31.125
<v Speaker 1>into eight bit integers, then you can just

01:00:31.125 --> 01:00:33.525
<v Speaker 1>have more of them, and you don't end

01:00:33.525 --> 01:00:35.605
<v Speaker 1>up allocating so much because you're allocating them

01:00:35.605 --> 01:00:37.285
<v Speaker 1>thousands and thousands of times.

01:00:38.565 --> 01:00:40.005
<v Speaker 0>Cool. That's good to know.

01:00:42.180 --> 01:00:44.020
<v Speaker 0>Alright. Let's see what this last one is,

01:00:44.020 --> 01:00:45.859
<v Speaker 0>and then we'll decide what we wanna finish

01:00:45.859 --> 01:00:46.900
<v Speaker 0>on. So

01:00:48.260 --> 01:00:50.020
<v Speaker 0>in a message, a struck point

01:00:50.740 --> 01:00:52.660
<v Speaker 0>oh, yeah. I'm gonna need a another message

01:00:52.660 --> 01:00:53.220
<v Speaker 0>here.

01:00:53.940 --> 01:00:54.900
<v Speaker 0>So let's see.

01:00:59.795 --> 01:01:00.755
<v Speaker 1>Oh, I see.

01:01:01.075 --> 01:01:04.035
<v Speaker 0>So variant or associated item change color is

01:01:04.035 --> 01:01:06.755
<v Speaker 0>not found here, and this is on

01:01:07.635 --> 01:01:09.795
<v Speaker 0>Lane 54.

01:01:12.099 --> 01:01:12.740
<v Speaker 1>Yeah.

01:01:14.580 --> 01:01:16.740
<v Speaker 0>So this is the state

01:01:16.740 --> 01:01:18.020
<v Speaker 0>process.

01:01:18.980 --> 01:01:20.980
<v Speaker 0>Oh, so I'm assuming this process maybe doesn't

01:01:20.980 --> 01:01:21.780
<v Speaker 0>match?

01:01:23.060 --> 01:01:25.865
<v Speaker 1>Yes. Except we have to write it. Ah,

01:01:26.265 --> 01:01:27.225
<v Speaker 0>there we go.

01:01:28.105 --> 01:01:30.585
<v Speaker 0>This will create a match expression to process

01:01:30.585 --> 01:01:32.585
<v Speaker 0>the different message variants.

01:01:32.585 --> 01:01:33.065
<v Speaker 0>Sorry.

01:01:33.385 --> 01:01:34.105
<v Speaker 0>The

01:01:36.265 --> 01:01:36.665
<v Speaker 0>message.

01:01:39.740 --> 01:01:41.660
<v Speaker 0>What does it pass in? Just a straight

01:01:41.660 --> 01:01:43.900
<v Speaker 0>up type. So that's just gonna be, like,

01:01:43.900 --> 01:01:44.860
<v Speaker 0>this. Right?

01:01:46.540 --> 01:01:47.260
<v Speaker 1>Yeah.

01:01:49.099 --> 01:01:49.740
<v Speaker 1>Well,

01:01:50.460 --> 01:01:52.780
<v Speaker 1>not quite. But we should first define the

01:01:52.780 --> 01:01:53.500
<v Speaker 1>enum

01:01:53.855 --> 01:01:55.695
<v Speaker 1>because that's also not done.

01:01:58.494 --> 01:01:59.135
<v Speaker 0>Yeah.

01:01:59.934 --> 01:02:00.575
<v Speaker 0>Okay.

01:02:02.494 --> 01:02:04.734
<v Speaker 0>Alright. What do we got then? Let's just

01:02:04.734 --> 01:02:05.535
<v Speaker 0>copy these.

01:02:22.875 --> 01:02:25.435
<v Speaker 1>You also won't want the message colon colon.

01:02:27.195 --> 01:02:27.915
<v Speaker 0>Yeah.

01:02:29.355 --> 01:02:30.075
<v Speaker 1>Yeah.

01:02:33.675 --> 01:02:35.275
<v Speaker 0>So we got our quick message. We've got

01:02:35.275 --> 01:02:36.475
<v Speaker 0>our change color,

01:02:36.955 --> 01:02:39.040
<v Speaker 0>which actually needs to be

01:02:42.240 --> 01:02:44.240
<v Speaker 1>So there's a subtle difference between this one

01:02:44.240 --> 01:02:46.240
<v Speaker 1>and the last one. And if you compile

01:02:46.240 --> 01:02:47.360
<v Speaker 1>it, you might notice.

01:02:48.000 --> 01:02:49.599
<v Speaker 0>What was that? Just double brackets. So it's

01:02:49.599 --> 01:02:51.840
<v Speaker 0>actually expecting a triple of

01:02:52.240 --> 01:02:55.045
<v Speaker 1>Yeah. It's what it's decided what they've decided

01:02:55.045 --> 01:02:56.885
<v Speaker 1>is that the color type that they're using

01:02:56.885 --> 01:02:59.445
<v Speaker 1>is a triple itself. Yeah. Okay.

01:03:00.165 --> 01:03:02.965
<v Speaker 0>This one just has to be string and

01:03:02.965 --> 01:03:04.405
<v Speaker 0>this one just needs to know.

01:03:05.260 --> 01:03:05.900
<v Speaker 0>Oh,

01:03:06.140 --> 01:03:07.740
<v Speaker 0>well, this is a type. Right? So can

01:03:07.740 --> 01:03:09.340
<v Speaker 0>I just do This

01:03:09.740 --> 01:03:11.100
<v Speaker 1>is just like the string one? So now

01:03:11.100 --> 01:03:12.300
<v Speaker 1>this is they've made it a little bit

01:03:12.300 --> 01:03:13.020
<v Speaker 1>clearer,

01:03:13.900 --> 01:03:14.620
<v Speaker 1>cleaner,

01:03:14.780 --> 01:03:17.595
<v Speaker 1>and so now there's just a point type.

01:03:17.675 --> 01:03:20.315
<v Speaker 0>So the Rust compiler doesn't care. The structure

01:03:20.315 --> 01:03:22.475
<v Speaker 0>is defined after the enum, none of the

01:03:22.475 --> 01:03:25.435
<v Speaker 0>ordering matters. Okay. Cool. Within the same crate,

01:03:25.675 --> 01:03:27.835
<v Speaker 1>everything can find everything. I mean, if if

01:03:27.835 --> 01:03:30.635
<v Speaker 1>you create something recursive that it doesn't like,

01:03:30.635 --> 01:03:33.339
<v Speaker 1>it might cause a problem. But you you

01:03:33.339 --> 01:03:34.780
<v Speaker 1>can you can have you can have self

01:03:34.780 --> 01:03:36.220
<v Speaker 1>referential stuff as well.

01:03:37.579 --> 01:03:38.220
<v Speaker 0>Okay.

01:03:38.619 --> 01:03:40.540
<v Speaker 0>State looks fine. So now we're back to

01:03:40.540 --> 01:03:42.700
<v Speaker 0>this match statement then. Yeah.

01:03:44.619 --> 01:03:47.260
<v Speaker 0>So we're matching on message, and we wanna

01:03:49.525 --> 01:03:51.525
<v Speaker 0>alright. What was this? Quiet was just empty,

01:03:51.525 --> 01:03:52.485
<v Speaker 0>wasn't it? Yep.

01:03:54.965 --> 01:03:56.885
<v Speaker 1>So well, we want okay. We can just

01:03:56.885 --> 01:03:58.885
<v Speaker 1>do an empty for now. Yeah. I thought

01:03:58.885 --> 01:04:00.165
<v Speaker 0>maybe if I could just get it to

01:04:00.165 --> 01:04:00.645
<v Speaker 0>compile.

01:04:01.180 --> 01:04:02.460
<v Speaker 1>Yeah. That's a good point.

01:04:06.860 --> 01:04:08.700
<v Speaker 1>The test failed, so it compiled.

01:04:09.260 --> 01:04:10.220
<v Speaker 0>That's good.

01:04:10.460 --> 01:04:11.100
<v Speaker 0>Yeah.

01:04:11.420 --> 01:04:13.820
<v Speaker 0>So what's it actually expecting? It wants me

01:04:13.820 --> 01:04:15.340
<v Speaker 0>to

01:04:18.395 --> 01:04:21.035
<v Speaker 0>set the properties on the state to be

01:04:21.035 --> 01:04:23.755
<v Speaker 0>the values. Right? Yeah. But the but the

01:04:23.755 --> 01:04:26.955
<v Speaker 1>state function already has methods that do this.

01:04:26.955 --> 01:04:28.155
<v Speaker 1>So I think we just need to call

01:04:28.155 --> 01:04:28.395
<v Speaker 1>them.

01:04:29.780 --> 01:04:31.780
<v Speaker 0>Ah, okay. So for quit, we're just calling

01:04:31.780 --> 01:04:32.500
<v Speaker 0>quit?

01:04:32.660 --> 01:04:34.500
<v Speaker 1>Self dot quit. But yeah.

01:04:37.060 --> 01:04:38.740
<v Speaker 0>And then we wanna handle message,

01:04:38.740 --> 01:04:39.619
<v Speaker 0>change color,

01:04:44.315 --> 01:04:45.275
<v Speaker 0>message.

01:04:45.755 --> 01:04:46.635
<v Speaker 0>Right?

01:04:46.714 --> 01:04:47.435
<v Speaker 1>Nope.

01:04:47.755 --> 01:04:49.675
<v Speaker 1>Remember what we did in the if let

01:04:49.675 --> 01:04:52.155
<v Speaker 1>to get access to the thing inside the

01:04:52.155 --> 01:04:52.955
<v Speaker 1>enum?

01:04:54.395 --> 01:04:55.915
<v Speaker 0>Oh, yeah. So

01:04:56.670 --> 01:04:57.869
<v Speaker 0>we need to do

01:04:59.549 --> 01:05:00.350
<v Speaker 0>that?

01:05:00.430 --> 01:05:01.470
<v Speaker 1>Yep. K.

01:05:02.030 --> 01:05:02.750
<v Speaker 1>Yeah.

01:05:03.309 --> 01:05:04.270
<v Speaker 1>Also,

01:05:04.270 --> 01:05:04.910
<v Speaker 1>just

01:05:05.390 --> 01:05:08.270
<v Speaker 1>to note because so remember when we when

01:05:08.270 --> 01:05:10.109
<v Speaker 1>the color was not a tuple?

01:05:13.495 --> 01:05:15.735
<v Speaker 1>If if it was like this, you'd do

01:05:15.735 --> 01:05:16.695
<v Speaker 1>something like this,

01:05:18.135 --> 01:05:19.255
<v Speaker 1>if that makes sense.

01:05:19.575 --> 01:05:21.655
<v Speaker 0>Oh, yeah. Yeah. Okay. Yeah. Because this tuple

01:05:21.655 --> 01:05:23.895
<v Speaker 0>is encapsulated. Just a single this is just

01:05:23.895 --> 01:05:25.735
<v Speaker 1>a single thing. Yep. Okay.

01:05:27.000 --> 01:05:29.080
<v Speaker 0>And we've got one more, don't we? So

01:05:29.400 --> 01:05:30.920
<v Speaker 0>Echo. Echo.

01:05:33.320 --> 01:05:35.320
<v Speaker 0>It also takes a param. So

01:05:40.484 --> 01:05:41.125
<v Speaker 0>See.

01:05:42.885 --> 01:05:43.605
<v Speaker 1>Neat.

01:05:44.404 --> 01:05:47.684
<v Speaker 0>Cool. And I'm assuming removing this, the compiler

01:05:47.684 --> 01:05:49.204
<v Speaker 0>is gonna complain that we don't handle all

01:05:49.204 --> 01:05:50.484
<v Speaker 0>the cases. Exactly.

01:05:52.630 --> 01:05:53.350
<v Speaker 0>Yep.

01:05:54.070 --> 01:05:56.230
<v Speaker 0>We we could just do that, but then

01:05:56.230 --> 01:05:56.790
<v Speaker 0>the

01:05:57.190 --> 01:05:58.869
<v Speaker 0>test will fail. So No. The test will

01:05:58.869 --> 01:05:59.750
<v Speaker 1>actually pass

01:06:00.230 --> 01:06:02.070
<v Speaker 1>because the echo thing doesn't do anything that

01:06:02.070 --> 01:06:02.790
<v Speaker 1>can be tested.

01:06:05.865 --> 01:06:07.385
<v Speaker 0>Alright. We'll leave it like that.

01:06:08.905 --> 01:06:10.345
<v Speaker 0>Alright. Let's pick one

01:06:10.825 --> 01:06:11.625
<v Speaker 0>more.

01:06:12.025 --> 01:06:12.505
<v Speaker 0>Yeah.

01:06:13.465 --> 01:06:15.305
<v Speaker 0>Anything you think would be fun to do?

01:06:15.305 --> 01:06:16.025
<v Speaker 0>I mean

01:06:17.145 --> 01:06:19.349
<v Speaker 1>I I mean, what what do you what

01:06:19.349 --> 01:06:20.390
<v Speaker 1>would you like to do?

01:06:20.869 --> 01:06:22.710
<v Speaker 0>Okay. So there's a couple of things. I

01:06:22.710 --> 01:06:24.549
<v Speaker 0>think let's pick the one that you're most

01:06:24.549 --> 01:06:27.589
<v Speaker 0>interested in. Now I think maybe doing something

01:06:27.589 --> 01:06:29.910
<v Speaker 0>around testing would be cool. Clippy's jumping out

01:06:29.910 --> 01:06:31.109
<v Speaker 0>at me because I don't know what Clippy

01:06:31.109 --> 01:06:31.349
<v Speaker 0>is.

01:06:33.395 --> 01:06:35.075
<v Speaker 0>Yeah. Maybe one of those two.

01:06:35.954 --> 01:06:37.555
<v Speaker 1>So Clippy is

01:06:37.795 --> 01:06:39.955
<v Speaker 1>Clippy is Rust's linting tool,

01:06:41.315 --> 01:06:42.994
<v Speaker 1>and the Rust compiler tells you when your

01:06:42.994 --> 01:06:45.395
<v Speaker 1>code's wrong. Clippy tells you when your code's

01:06:45.635 --> 01:06:46.194
<v Speaker 1>bad

01:06:46.500 --> 01:06:47.620
<v Speaker 1>or not

01:06:48.020 --> 01:06:48.740
<v Speaker 1>perfect.

01:06:49.460 --> 01:06:50.260
<v Speaker 0>Okay.

01:06:50.420 --> 01:06:51.140
<v Speaker 1>Yeah.

01:06:52.020 --> 01:06:53.300
<v Speaker 0>Alright. Yeah.

01:06:53.540 --> 01:06:54.660
<v Speaker 0>Well, I guess we could take a really

01:06:54.660 --> 01:06:56.580
<v Speaker 0>quick look at Clippy, and then maybe we'll

01:06:56.580 --> 01:06:58.740
<v Speaker 0>take a quick look at tests, we'll that

01:06:58.740 --> 01:07:00.580
<v Speaker 0>should take us up to our time. So

01:07:00.555 --> 01:07:01.355
<v Speaker 0>Yeah.

01:07:01.515 --> 01:07:03.435
<v Speaker 0>So Clippy is a tool

01:07:03.595 --> 01:07:05.675
<v Speaker 0>is a collection of lens to analyze your

01:07:05.675 --> 01:07:06.315
<v Speaker 0>code.

01:07:07.835 --> 01:07:10.234
<v Speaker 0>Okay. Let's run Clippy one and see. Is

01:07:10.234 --> 01:07:12.555
<v Speaker 0>it I saw it just run Rustling Stone.

01:07:13.700 --> 01:07:15.780
<v Speaker 1>I'm not actually sure how they do the

01:07:16.099 --> 01:07:16.820
<v Speaker 1>thing.

01:07:17.140 --> 01:07:17.700
<v Speaker 1>But

01:07:18.019 --> 01:07:20.259
<v Speaker 1>ah, okay. Yeah. They've they've set it up

01:07:20.259 --> 01:07:21.940
<v Speaker 1>so that it fails to compile when Clippy

01:07:21.940 --> 01:07:24.339
<v Speaker 1>has an issue. So the Clippy Clippy warnings

01:07:24.339 --> 01:07:26.819
<v Speaker 1>show up as Rust warnings when you use

01:07:26.819 --> 01:07:27.540
<v Speaker 1>Clippy.

01:07:27.779 --> 01:07:28.660
<v Speaker 1>So they look the same.

01:07:30.215 --> 01:07:31.975
<v Speaker 0>Okay. And we've got a whole bunch okay.

01:07:31.975 --> 01:07:33.495
<v Speaker 0>So this is, like, one of these Lent

01:07:33.495 --> 01:07:36.135
<v Speaker 0>rules is on by default, which means that

01:07:36.135 --> 01:07:38.375
<v Speaker 0>it's telling us our code could be better.

01:07:38.935 --> 01:07:41.255
<v Speaker 0>Yeah. And this is telling us that we're

01:07:41.255 --> 01:07:43.575
<v Speaker 0>comparing a 32 bit float with a 64

01:07:43.575 --> 01:07:45.500
<v Speaker 0>bit float, which is maybe bad. Oh, no.

01:07:45.500 --> 01:07:47.020
<v Speaker 1>We're just comparing floats.

01:07:47.260 --> 01:07:49.980
<v Speaker 1>It like, we're comparing floats for equality.

01:07:51.660 --> 01:07:54.140
<v Speaker 1>And the problem with comparing floats for equality

01:07:54.140 --> 01:07:55.420
<v Speaker 1>is, for example,

01:07:55.740 --> 01:07:56.860
<v Speaker 1>things like

01:07:57.980 --> 01:07:58.300
<v Speaker 1>one

01:07:59.020 --> 01:07:59.819
<v Speaker 1>three

01:08:00.474 --> 01:08:03.755
<v Speaker 1>divided by two point is not actually 1.5

01:08:04.714 --> 01:08:06.315
<v Speaker 1>because floats are weird.

01:08:06.555 --> 01:08:08.395
<v Speaker 0>Yeah. This is the weird precision thing. I

01:08:08.395 --> 01:08:10.555
<v Speaker 0>think every language has that. Right? Everything. Yeah.

01:08:10.555 --> 01:08:13.035
<v Speaker 1>Everything with I I three floats has has

01:08:13.035 --> 01:08:14.930
<v Speaker 1>that. So so the

01:08:15.170 --> 01:08:18.210
<v Speaker 1>the idiomatic way of doing float comparison where

01:08:18.210 --> 01:08:20.210
<v Speaker 1>you're comparing for equality, like, x greater than

01:08:20.210 --> 01:08:22.050
<v Speaker 1>y is fine, but x equal to y

01:08:22.050 --> 01:08:24.289
<v Speaker 1>or not equal to y is

01:08:25.170 --> 01:08:25.969
<v Speaker 1>you

01:08:27.115 --> 01:08:29.274
<v Speaker 1>you what you do is you compare them

01:08:29.274 --> 01:08:31.354
<v Speaker 1>up to, like, a small delta,

01:08:31.515 --> 01:08:33.035
<v Speaker 1>like, a small error value.

01:08:34.555 --> 01:08:37.354
<v Speaker 1>And what people often do is so if

01:08:37.354 --> 01:08:38.715
<v Speaker 1>you look at the error message, it actually

01:08:38.715 --> 01:08:39.515
<v Speaker 1>tells you what to do.

01:08:43.590 --> 01:08:44.550
<v Speaker 0>Use absolute

01:08:48.950 --> 01:08:50.550
<v Speaker 0>I'll just copy this.

01:08:52.790 --> 01:08:53.510
<v Speaker 0>So

01:08:53.590 --> 01:08:54.310
<v Speaker 0>if

01:08:59.045 --> 01:09:01.045
<v Speaker 1>and we need to pick pick an error

01:09:01.045 --> 01:09:01.765
<v Speaker 1>value.

01:09:02.645 --> 01:09:04.564
<v Speaker 1>So you could just put point zero zero

01:09:04.564 --> 01:09:05.365
<v Speaker 1>one there.

01:09:05.925 --> 01:09:07.765
<v Speaker 1>It's a pretty big number, but you like,

01:09:07.765 --> 01:09:07.925
<v Speaker 1>yep.

01:09:09.610 --> 01:09:10.970
<v Speaker 0>What did you tell me to put that?

01:09:10.970 --> 01:09:14.250
<v Speaker 0>Point zero Some some small number. Probably smaller

01:09:14.250 --> 01:09:15.930
<v Speaker 1>than that, actually. Like, just a bunch of

01:09:15.930 --> 01:09:16.569
<v Speaker 1>zeros.

01:09:17.850 --> 01:09:19.930
<v Speaker 1>The the clip, yeah, actually goes on something

01:09:19.930 --> 01:09:21.610
<v Speaker 1>else. Yeah. You're you're using, like, a very

01:09:21.610 --> 01:09:23.690
<v Speaker 1>small error value. You're saying that I'm

01:09:24.024 --> 01:09:26.585
<v Speaker 1>I I consider these to be equal if

01:09:26.585 --> 01:09:29.385
<v Speaker 1>they're close if they're closer than that number.

01:09:30.024 --> 01:09:31.785
<v Speaker 0>Yeah. I understand that. Yes. So we're doing

01:09:31.785 --> 01:09:34.505
<v Speaker 0>y minus x. Absolute. And then checking to

01:09:34.505 --> 01:09:36.665
<v Speaker 0>see if the differential is bigger than the

01:09:36.665 --> 01:09:38.104
<v Speaker 0>small number that we're willing to accept as

01:09:38.104 --> 01:09:40.239
<v Speaker 0>an error margin. Okay. Yeah.

01:09:40.880 --> 01:09:43.120
<v Speaker 0>Cool. And the message probably would have told

01:09:43.120 --> 01:09:44.960
<v Speaker 0>me that. I'm not sure. Said there's an

01:09:44.960 --> 01:09:47.920
<v Speaker 1>f 32 epsilon. So the Rust standard library

01:09:47.920 --> 01:09:49.040
<v Speaker 1>you has

01:09:50.080 --> 01:09:51.760
<v Speaker 1>like, you can also what you can put

01:09:51.760 --> 01:09:53.040
<v Speaker 1>here, and I think you might have to

01:09:53.040 --> 01:09:53.760
<v Speaker 1>import it. But

01:09:55.575 --> 01:09:56.775
<v Speaker 1>if you do this

01:09:57.255 --> 01:09:58.855
<v Speaker 1>or f 64

01:09:58.935 --> 01:10:01.175
<v Speaker 1>because we're using f 60 fours. If you

01:10:01.175 --> 01:10:01.975
<v Speaker 1>do this,

01:10:02.615 --> 01:10:05.495
<v Speaker 1>it will that is the value the Rust

01:10:05.495 --> 01:10:06.615
<v Speaker 1>standard library recommends.

01:10:07.650 --> 01:10:09.489
<v Speaker 0>Yeah. That worked. Compiled and

01:10:11.890 --> 01:10:13.409
<v Speaker 0>And the Epsilon is just

01:10:14.770 --> 01:10:18.530
<v Speaker 0>Rust standard library accepted marginal value, I guess.

01:10:19.489 --> 01:10:20.370
<v Speaker 1>Yeah. Actually

01:10:21.655 --> 01:10:23.655
<v Speaker 0>Does it define it if I hover? Or

01:10:23.655 --> 01:10:25.974
<v Speaker 0>not because my analyzers are not okay.

01:10:28.135 --> 01:10:29.175
<v Speaker 1>This is this

01:10:29.415 --> 01:10:31.735
<v Speaker 1>is the difference between one and the next

01:10:31.735 --> 01:10:33.494
<v Speaker 1>largest representable number.

01:10:33.815 --> 01:10:34.695
<v Speaker 1>So

01:10:35.600 --> 01:10:37.440
<v Speaker 1>this is actually kind of, like, the smallest

01:10:37.440 --> 01:10:40.639
<v Speaker 1>difference. Often, you will want something, like, bigger.

01:10:41.360 --> 01:10:43.360
<v Speaker 1>It like, epsilon's very small. So it depends

01:10:43.360 --> 01:10:45.599
<v Speaker 1>on what you want. Like, if it's if,

01:10:46.240 --> 01:10:48.320
<v Speaker 1>like, if you really care about that much

01:10:48.320 --> 01:10:50.425
<v Speaker 1>precision and your numbers are that precise, you

01:10:50.425 --> 01:10:52.585
<v Speaker 1>would use Epsilon. But in this case, maybe

01:10:52.585 --> 01:10:53.705
<v Speaker 1>not. Like,

01:10:53.945 --> 01:10:55.465
<v Speaker 1>in this case, you just figure out where

01:10:55.465 --> 01:10:56.825
<v Speaker 1>you want things to be the same.

01:10:57.305 --> 01:10:58.425
<v Speaker 0>Alright. Sweet.

01:10:59.065 --> 01:10:59.545
<v Speaker 0>Alright.

01:11:00.185 --> 01:11:02.025
<v Speaker 0>What does Clippy two tell me then? Let's

01:11:02.025 --> 01:11:02.665
<v Speaker 0>just run it.

01:11:04.220 --> 01:11:06.780
<v Speaker 1>Also, if you're, like, on your own projects

01:11:06.780 --> 01:11:09.180
<v Speaker 1>to run Clippy, you just run cargo Clippy.

01:11:11.100 --> 01:11:13.340
<v Speaker 0>Oh, yeah. I I don't know how this

01:11:13.340 --> 01:11:15.100
<v Speaker 0>project is set up, I don't wanna run

01:11:15.100 --> 01:11:17.420
<v Speaker 0>that against everything here. But This is this

01:11:17.420 --> 01:11:18.540
<v Speaker 1>project is set up differently.

01:11:20.795 --> 01:11:23.355
<v Speaker 0>So this is complaining because

01:11:23.435 --> 01:11:24.475
<v Speaker 0>it says

01:11:24.715 --> 01:11:26.395
<v Speaker 0>for loop over an option, which is an

01:11:26.395 --> 01:11:27.114
<v Speaker 0>option.

01:11:27.355 --> 01:11:29.114
<v Speaker 0>This is more readable.

01:11:29.195 --> 01:11:30.555
<v Speaker 0>Okay. So this is telling me that my

01:11:30.555 --> 01:11:31.915
<v Speaker 0>code is just more readable if I change

01:11:31.915 --> 01:11:32.635
<v Speaker 0>it to an outlet.

01:11:33.590 --> 01:11:35.190
<v Speaker 1>Yeah. Like like I said, it doesn't tell

01:11:35.190 --> 01:11:36.389
<v Speaker 1>you your code is wrong. It tells you

01:11:36.389 --> 01:11:37.349
<v Speaker 1>your code is bad.

01:11:39.510 --> 01:11:41.590
<v Speaker 0>Alright. Okay. Used to its warnings then, I

01:11:41.590 --> 01:11:42.550
<v Speaker 0>guess. Yeah.

01:11:44.070 --> 01:11:45.590
<v Speaker 1>And you can also not it's not that

01:11:45.590 --> 01:11:47.185
<v Speaker 1>big a deal to not use Clippy. Some

01:11:47.185 --> 01:11:49.505
<v Speaker 1>people it it often teaches you things, so

01:11:49.505 --> 01:11:50.864
<v Speaker 1>people like to use it as a learning

01:11:50.864 --> 01:11:51.425
<v Speaker 1>tool.

01:11:52.065 --> 01:11:52.624
<v Speaker 1>But

01:11:53.025 --> 01:11:54.864
<v Speaker 1>so what it's saying here is that

01:11:55.185 --> 01:11:56.465
<v Speaker 1>so you know how you can do, like,

01:11:56.465 --> 01:11:57.824
<v Speaker 1>four x in vector?

01:11:59.105 --> 01:12:01.600
<v Speaker 1>So vector is an iterable, which means you

01:12:01.600 --> 01:12:03.520
<v Speaker 1>can give it to a for loop or

01:12:03.520 --> 01:12:04.720
<v Speaker 1>iterator functions.

01:12:05.040 --> 01:12:06.720
<v Speaker 1>So it turns out option is also an

01:12:06.720 --> 01:12:09.120
<v Speaker 1>iterable, and it it's an iterable that either

01:12:09.280 --> 01:12:10.720
<v Speaker 1>if it's some, it gives you that one

01:12:10.720 --> 01:12:12.240
<v Speaker 1>value. If it's none, it gives you nothing.

01:12:13.885 --> 01:12:15.485
<v Speaker 1>Just like a vector is an iterable that

01:12:15.485 --> 01:12:17.085
<v Speaker 1>gives you all the values it has.

01:12:17.645 --> 01:12:18.844
<v Speaker 1>So sometimes

01:12:20.045 --> 01:12:21.965
<v Speaker 1>this sometimes causes confusion.

01:12:21.965 --> 01:12:25.005
<v Speaker 1>You you rarely want to say iterate over

01:12:25.005 --> 01:12:27.245
<v Speaker 1>everything in this option because that's just an

01:12:27.245 --> 01:12:27.725
<v Speaker 1>if let.

01:12:29.130 --> 01:12:30.489
<v Speaker 1>So what Clippy is telling you to do

01:12:30.489 --> 01:12:32.010
<v Speaker 1>is just use an if let here

01:12:32.330 --> 01:12:35.210
<v Speaker 1>because this is confusing because people don't usually

01:12:35.210 --> 01:12:37.210
<v Speaker 1>remember that an option isn't iterable.

01:12:37.610 --> 01:12:39.610
<v Speaker 1>It's like, there there are good reasons for

01:12:39.610 --> 01:12:41.370
<v Speaker 1>option to be an iterable, but it also

01:12:41.370 --> 01:12:44.555
<v Speaker 1>leads to sharp edges like this where you

01:12:44.555 --> 01:12:45.915
<v Speaker 1>have a four loop and you're like, oh,

01:12:45.915 --> 01:12:47.915
<v Speaker 1>this is looping over many objects. And it

01:12:47.915 --> 01:12:49.675
<v Speaker 1>turns out it's only looping over the option,

01:12:49.675 --> 01:12:51.195
<v Speaker 1>so it's only looping over one.

01:12:52.635 --> 01:12:53.435
<v Speaker 0>Yeah. That makes sense.

01:12:54.800 --> 01:12:55.520
<v Speaker 0>Okay.

01:12:56.000 --> 01:12:58.400
<v Speaker 0>And if yeah. Okay. That makes sense.

01:12:59.440 --> 01:12:59.920
<v Speaker 0>Let's

01:13:00.480 --> 01:13:02.720
<v Speaker 0>yeah. We don't need to save that one.

01:13:03.360 --> 01:13:04.640
<v Speaker 0>Let's go for

01:13:05.200 --> 01:13:06.480
<v Speaker 0>let's trace tests.

01:13:08.895 --> 01:13:10.495
<v Speaker 0>So, I mean, we've already kinda seen this

01:13:10.495 --> 01:13:12.255
<v Speaker 0>syntax a few times now because some of

01:13:12.255 --> 01:13:15.375
<v Speaker 0>the rustling exercises actually ship with a test.

01:13:15.375 --> 01:13:15.855
<v Speaker 0>So

01:13:16.975 --> 01:13:19.295
<v Speaker 0>are assertions always macros?

01:13:20.495 --> 01:13:20.815
<v Speaker 1>Yeah.

01:13:22.390 --> 01:13:24.310
<v Speaker 1>Assertions are macros because

01:13:25.110 --> 01:13:27.670
<v Speaker 1>they're macros because they actually kind of

01:13:28.630 --> 01:13:28.950
<v Speaker 1>they

01:13:29.590 --> 01:13:31.910
<v Speaker 1>the like, if you if you say assert,

01:13:31.910 --> 01:13:33.830
<v Speaker 1>like, one equal to two,

01:13:34.605 --> 01:13:37.405
<v Speaker 1>it will actually print this part out along

01:13:37.405 --> 01:13:38.925
<v Speaker 1>with the assertion. And I think you can

01:13:38.925 --> 01:13:41.245
<v Speaker 1>use you can even use format string syntax

01:13:41.245 --> 01:13:42.685
<v Speaker 1>if it fails. Like

01:13:43.165 --> 01:13:45.005
<v Speaker 1>actually, I'm not sure. I don't think I

01:13:45.005 --> 01:13:46.605
<v Speaker 1>don't think you can, but

01:13:46.840 --> 01:13:48.360
<v Speaker 1>it it will actually print this out. So

01:13:48.360 --> 01:13:50.120
<v Speaker 1>they're they're macros so that that can look

01:13:50.120 --> 01:13:50.600
<v Speaker 1>good.

01:13:52.360 --> 01:13:53.000
<v Speaker 0>Okay.

01:13:53.640 --> 01:13:55.800
<v Speaker 1>Otherwise, you'll just get assertion failed and then,

01:13:55.800 --> 01:13:57.320
<v Speaker 1>like, a string if you added one. But

01:13:57.320 --> 01:13:58.200
<v Speaker 1>if you yeah.

01:13:58.945 --> 01:14:01.505
<v Speaker 1>Over here I'm just asserting that the statement

01:14:01.505 --> 01:14:03.825
<v Speaker 0>evaluates to true instead of brackets. That's Yeah.

01:14:03.825 --> 01:14:04.785
<v Speaker 0>That's it. Okay.

01:14:06.545 --> 01:14:07.585
<v Speaker 0>Run

01:14:07.585 --> 01:14:08.465
<v Speaker 0>test

01:14:08.625 --> 01:14:09.425
<v Speaker 0>one.

01:14:10.225 --> 01:14:10.945
<v Speaker 1>Yep.

01:14:11.185 --> 01:14:13.185
<v Speaker 1>And if if if it were if it

01:14:13.185 --> 01:14:14.545
<v Speaker 1>one one equal equal to two,

01:14:15.159 --> 01:14:17.479
<v Speaker 1>you'll see that it'll say assertion failed

01:14:17.639 --> 01:14:19.480
<v Speaker 1>one equal equal to two. So it needs

01:14:19.480 --> 01:14:20.760
<v Speaker 1>to be a macro so it can actually

01:14:20.760 --> 01:14:23.079
<v Speaker 1>say that one equal equal to two because

01:14:23.079 --> 01:14:24.440
<v Speaker 1>if it was just a function, the function

01:14:24.440 --> 01:14:25.479
<v Speaker 1>has no idea

01:14:26.199 --> 01:14:28.119
<v Speaker 1>what expression you put in its parameters. It

01:14:28.119 --> 01:14:29.639
<v Speaker 1>only knows the value of that expression.

01:14:30.185 --> 01:14:32.105
<v Speaker 1>So that that's that's why it's a macro.

01:14:33.225 --> 01:14:34.505
<v Speaker 0>Alright. Cool.

01:14:34.825 --> 01:14:35.465
<v Speaker 0>And

01:14:35.945 --> 01:14:38.264
<v Speaker 0>what is this CFG test?

01:14:39.225 --> 01:14:40.505
<v Speaker 1>So

01:14:41.305 --> 01:14:45.219
<v Speaker 1>so in in in Rust, basically, this is

01:14:45.380 --> 01:14:48.020
<v Speaker 1>this is saying only do this in test

01:14:48.020 --> 01:14:51.059
<v Speaker 1>mode. Only compile this module in test mode.

01:14:51.300 --> 01:14:53.460
<v Speaker 1>So right now, it doesn't really matter. If

01:14:53.460 --> 01:14:54.340
<v Speaker 1>you just did

01:14:55.460 --> 01:14:57.699
<v Speaker 1>if you just took this function and put

01:14:57.699 --> 01:15:00.305
<v Speaker 1>it outside, it wouldn't matter. But often, sometimes

01:15:00.305 --> 01:15:02.145
<v Speaker 1>you'll have, like, imports and stuff

01:15:02.785 --> 01:15:04.785
<v Speaker 1>that you're using in your tests.

01:15:06.305 --> 01:15:08.945
<v Speaker 1>It is standard practice to put all of

01:15:08.945 --> 01:15:11.505
<v Speaker 1>your unit tests in, like, modules that are

01:15:11.505 --> 01:15:13.760
<v Speaker 1>called test or tests, and you put a

01:15:13.760 --> 01:15:16.160
<v Speaker 1>CFG test on it. So the normal normal

01:15:16.160 --> 01:15:18.320
<v Speaker 1>compilers don't even see that code.

01:15:18.800 --> 01:15:19.360
<v Speaker 1>And,

01:15:20.239 --> 01:15:22.239
<v Speaker 1>when it's in test mode to see if,

01:15:22.560 --> 01:15:25.120
<v Speaker 1>their compilers invoked with CFG test on,

01:15:25.725 --> 01:15:28.765
<v Speaker 1>And now then suddenly this module is enabled,

01:15:28.925 --> 01:15:30.925
<v Speaker 1>and then it finds the test. It's it

01:15:30.925 --> 01:15:33.005
<v Speaker 1>it prevents it prevents like, if you're writing

01:15:33.005 --> 01:15:35.565
<v Speaker 1>a library because, again, like, these are you

01:15:35.565 --> 01:15:35.885
<v Speaker 1>use

01:15:36.685 --> 01:15:38.045
<v Speaker 1>this is this is how you'd write a

01:15:38.045 --> 01:15:39.165
<v Speaker 1>unit test, typically.

01:15:39.645 --> 01:15:41.750
<v Speaker 1>And if your library has lots of unit

01:15:41.750 --> 01:15:43.830
<v Speaker 1>tests, you don't want downstream crates to care

01:15:43.830 --> 01:15:46.230
<v Speaker 1>about them, and you don't you don't want,

01:15:46.230 --> 01:15:48.070
<v Speaker 1>like, your imports to be mixed in with

01:15:48.070 --> 01:15:49.830
<v Speaker 1>the other imports. For example, in your test,

01:15:49.830 --> 01:15:51.910
<v Speaker 1>you might be importing some test dependencies,

01:15:53.385 --> 01:15:55.065
<v Speaker 1>and you want to be able to import

01:15:55.065 --> 01:15:56.744
<v Speaker 1>them without the rest of the code having

01:15:56.744 --> 01:15:59.224
<v Speaker 1>to also import it. So you use CFG

01:15:59.224 --> 01:16:00.905
<v Speaker 1>and you do some cargo feature stuff and

01:16:00.905 --> 01:16:02.905
<v Speaker 1>a bunch you use a bunch of things.

01:16:02.905 --> 01:16:03.704
<v Speaker 1>But yeah.

01:16:04.824 --> 01:16:05.224
<v Speaker 0>Okay.

01:16:06.780 --> 01:16:08.619
<v Speaker 0>And that just tells that that that's a

01:16:08.619 --> 01:16:10.859
<v Speaker 0>test that should be run to evaluate the

01:16:10.860 --> 01:16:13.099
<v Speaker 0>a a service or not? Does that mean

01:16:13.099 --> 01:16:14.780
<v Speaker 0>I can have functions inside of this module

01:16:14.780 --> 01:16:16.940
<v Speaker 0>block that don't get run as tests? Yep.

01:16:16.940 --> 01:16:19.739
<v Speaker 1>Only things that are pound test are evaluated

01:16:19.739 --> 01:16:20.380
<v Speaker 1>as tests.

01:16:21.875 --> 01:16:23.955
<v Speaker 0>Okay. And you said that unit tests should

01:16:23.955 --> 01:16:26.515
<v Speaker 0>be in this format. So, like, integration,

01:16:26.515 --> 01:16:28.195
<v Speaker 0>acceptance test, they all live in a test

01:16:28.195 --> 01:16:30.515
<v Speaker 0>folder then, I guess. Yes. There's a test

01:16:30.515 --> 01:16:33.554
<v Speaker 1>folder, and you still write tests with pound

01:16:33.554 --> 01:16:35.990
<v Speaker 1>test, but you won't use CFG test because

01:16:35.990 --> 01:16:38.710
<v Speaker 1>that folder will always be invoked with CFG

01:16:38.710 --> 01:16:39.270
<v Speaker 1>test.

01:16:39.750 --> 01:16:41.430
<v Speaker 0>Okay. Gotcha. Cool.

01:16:41.910 --> 01:16:43.670
<v Speaker 0>Alright. Let's pop

01:16:43.910 --> 01:16:45.510
<v Speaker 0>over one more. So

01:16:46.070 --> 01:16:47.990
<v Speaker 0>are these just introducing new macros?

01:16:49.165 --> 01:16:50.844
<v Speaker 0>Okay. That was a bit different. Okay.

01:16:52.045 --> 01:16:54.685
<v Speaker 0>So this isn't a set equals?

01:16:54.685 --> 01:16:56.685
<v Speaker 0>I mean, I feel like we just didn't

01:16:56.685 --> 01:16:58.204
<v Speaker 0>necessarily calls. Right?

01:16:59.085 --> 01:17:01.324
<v Speaker 0>Oh, is that because alright. Okay. That's gonna

01:17:01.324 --> 01:17:02.605
<v Speaker 0>accept this syntax. Right?

01:17:04.440 --> 01:17:05.080
<v Speaker 1>Yep.

01:17:05.640 --> 01:17:08.440
<v Speaker 1>And and we we actually want to fix

01:17:08.440 --> 01:17:11.160
<v Speaker 1>this so that assert can just do this.

01:17:11.400 --> 01:17:13.320
<v Speaker 1>But what the reason it's a separate macro

01:17:13.320 --> 01:17:15.480
<v Speaker 1>is so that if it's not equal, it

01:17:15.480 --> 01:17:17.320
<v Speaker 1>can actually just tell you these are the

01:17:17.320 --> 01:17:17.880
<v Speaker 1>two values.

01:17:19.215 --> 01:17:21.855
<v Speaker 1>Instead of just saying assertion failed, it'll say

01:17:21.855 --> 01:17:24.335
<v Speaker 1>assertion failed because one is not equal to

01:17:24.335 --> 01:17:24.895
<v Speaker 1>two.

01:17:26.415 --> 01:17:28.095
<v Speaker 0>Okay. I guess that's not really a problem

01:17:28.095 --> 01:17:30.175
<v Speaker 0>for simple cases where it's just two numbers.

01:17:30.175 --> 01:17:31.455
<v Speaker 0>But for maybe you're comparing

01:17:31.920 --> 01:17:33.840
<v Speaker 0>two objects to structs, something like that, it

01:17:33.840 --> 01:17:36.080
<v Speaker 0>may be more important for those Yes. For

01:17:36.080 --> 01:17:38.640
<v Speaker 0>two numbers. Separately. It often it actually often

01:17:38.640 --> 01:17:40.719
<v Speaker 1>matters for numbers. Like, you might do assert

01:17:40.719 --> 01:17:41.760
<v Speaker 1>equal

01:17:41.920 --> 01:17:43.440
<v Speaker 1>vec dot len

01:17:43.679 --> 01:17:44.960
<v Speaker 1>and zero

01:17:45.465 --> 01:17:47.065
<v Speaker 1>to make sure that it's zero. There's you

01:17:47.065 --> 01:17:49.225
<v Speaker 1>can also assert that it's empty. But if

01:17:49.225 --> 01:17:50.905
<v Speaker 1>it's not zero, you might wanna know, like,

01:17:50.905 --> 01:17:52.185
<v Speaker 1>does it have one thing? Does it have

01:17:52.185 --> 01:17:52.985
<v Speaker 1>500?

01:17:53.945 --> 01:17:55.625
<v Speaker 1>So, like, you often do it that. Even

01:17:55.705 --> 01:17:57.225
<v Speaker 1>like, I've I've used this for integers.

01:17:57.890 --> 01:17:58.610
<v Speaker 0>Okay.

01:17:59.250 --> 01:18:01.250
<v Speaker 0>I'm assuming there's other. Yeah. There we go.

01:18:01.250 --> 01:18:03.090
<v Speaker 0>Those are not equals. So Yep.

01:18:03.970 --> 01:18:06.370
<v Speaker 1>Also, there's, like, I think, a proxy. There's

01:18:06.370 --> 01:18:07.330
<v Speaker 1>there's a bunch.

01:18:09.250 --> 01:18:11.010
<v Speaker 0>I lost the message just now, so I'll

01:18:11.010 --> 01:18:11.889
<v Speaker 0>stick with that.

01:18:12.370 --> 01:18:14.724
<v Speaker 0>That's on test two. It's happy.

01:18:16.325 --> 01:18:17.045
<v Speaker 0>Just

01:18:17.285 --> 01:18:18.085
<v Speaker 0>find out.

01:18:20.885 --> 01:18:21.525
<v Speaker 1>Yeah.

01:18:23.525 --> 01:18:25.925
<v Speaker 0>Yeah. Because because they're two different parameters, it

01:18:25.925 --> 01:18:27.765
<v Speaker 0>can actually separate them on this view. Yes.

01:18:27.765 --> 01:18:27.925
<v Speaker 1>Okay.

01:18:30.430 --> 01:18:32.190
<v Speaker 0>Alright. Let's see what this last one is,

01:18:32.190 --> 01:18:34.989
<v Speaker 0>and then we can finish up there. So

01:18:36.350 --> 01:18:39.070
<v Speaker 0>we have a function doing modules even,

01:18:39.550 --> 01:18:40.510
<v Speaker 0>returns a bill,

01:18:43.335 --> 01:18:44.775
<v Speaker 0>and we have to just write the test

01:18:44.775 --> 01:18:46.614
<v Speaker 0>to make sure the function works.

01:18:48.215 --> 01:18:48.934
<v Speaker 0>K.

01:18:50.295 --> 01:18:52.695
<v Speaker 0>So if I call as even

01:18:53.574 --> 01:18:54.614
<v Speaker 0>before,

01:18:55.175 --> 01:18:58.099
<v Speaker 0>we would expect that to be true.

01:18:58.179 --> 01:18:58.820
<v Speaker 1>Yep.

01:19:01.780 --> 01:19:02.739
<v Speaker 0>You

01:19:07.699 --> 01:19:09.139
<v Speaker 1>don't actually have to have the equal equal

01:19:09.139 --> 01:19:09.540
<v Speaker 1>to true.

01:19:13.015 --> 01:19:15.415
<v Speaker 0>Alright. Okay. Yeah. Of course. Yeah. Because the

01:19:15.415 --> 01:19:18.295
<v Speaker 0>the statement within the macro has to evaluate.

01:19:18.295 --> 01:19:18.935
<v Speaker 0>Okay.

01:19:19.975 --> 01:19:21.495
<v Speaker 1>Well, you'd have to And this one does.

01:19:21.495 --> 01:19:23.495
<v Speaker 0>Right? Or You can just put a not

01:19:23.495 --> 01:19:26.000
<v Speaker 1>there. Some people actually do prefer the equal

01:19:26.000 --> 01:19:28.239
<v Speaker 1>equal to false over the not just because

01:19:28.639 --> 01:19:31.039
<v Speaker 1>you it's easy to forget the not. It's

01:19:31.039 --> 01:19:32.960
<v Speaker 1>easy to miss it while reading. But yeah.

01:19:32.960 --> 01:19:35.599
<v Speaker 0>Yeah. Yeah. I've always been taught to try

01:19:35.599 --> 01:19:37.840
<v Speaker 0>and, like, I had this drummed into me

01:19:37.840 --> 01:19:38.320
<v Speaker 0>from

01:19:39.005 --> 01:19:41.645
<v Speaker 0>very early days. They always put the static

01:19:41.645 --> 01:19:43.085
<v Speaker 0>value on the left so it's easier to

01:19:43.085 --> 01:19:44.845
<v Speaker 0>read. I don't know if that's true, but

01:19:45.165 --> 01:19:45.965
<v Speaker 0>Yeah. That's true.

01:19:46.845 --> 01:19:49.565
<v Speaker 1>Those are called Yoda conditions. Yoda conditions. Yeah.

01:19:49.565 --> 01:19:50.125
<v Speaker 0>Yeah.

01:19:50.365 --> 01:19:51.885
<v Speaker 0>I just always had that in green with

01:19:51.885 --> 01:19:53.165
<v Speaker 0>me and this kind of stuck. So I'll

01:19:53.165 --> 01:19:56.199
<v Speaker 0>just I'll just copy that too. Alright. I've

01:19:56.199 --> 01:19:58.599
<v Speaker 0>got one more test to do. So alright.

01:19:58.600 --> 01:19:59.880
<v Speaker 0>I already did that.

01:20:05.560 --> 01:20:05.960
<v Speaker 0>Oh.

01:20:08.155 --> 01:20:08.795
<v Speaker 1>Well

01:20:10.235 --> 01:20:11.195
<v Speaker 1>no. Wait.

01:20:17.515 --> 01:20:18.955
<v Speaker 0>Is false then odd?

01:20:21.570 --> 01:20:23.810
<v Speaker 0>Left is one. Right is two.

01:20:23.890 --> 01:20:25.730
<v Speaker 1>Oh, it's it's failing on test two. It's

01:20:25.730 --> 01:20:26.929
<v Speaker 1>failing on the other test.

01:20:29.650 --> 01:20:31.090
<v Speaker 1>You're running the wrong test.

01:20:31.410 --> 01:20:32.210
<v Speaker 0>Oh.

01:20:32.370 --> 01:20:35.010
<v Speaker 1>Sorry. Oh, you're running the wrong file. Yeah.

01:20:35.330 --> 01:20:37.010
<v Speaker 1>Yeah. Each file has multiple tests.

01:20:37.485 --> 01:20:38.605
<v Speaker 1>That was confusing.

01:20:38.925 --> 01:20:40.365
<v Speaker 0>But I don't I don't like when I

01:20:40.365 --> 01:20:41.725
<v Speaker 0>look at trivial code and I can't work

01:20:41.725 --> 01:20:43.085
<v Speaker 0>at what's going on. So that's good.

01:20:43.485 --> 01:20:45.565
<v Speaker 0>Alright. Awesome. Thank you for that. That was

01:20:45.565 --> 01:20:46.445
<v Speaker 0>really good fun.

01:20:47.005 --> 01:20:47.325
<v Speaker 1>Yeah.

01:20:49.530 --> 01:20:51.610
<v Speaker 0>So that was we got through quite a

01:20:51.610 --> 01:20:52.730
<v Speaker 0>lot there. I think that was a really

01:20:52.730 --> 01:20:55.130
<v Speaker 0>good exploration of pretty much everything that was

01:20:55.130 --> 01:20:56.730
<v Speaker 0>left in these exercises. There's only a few

01:20:56.730 --> 01:20:57.290
<v Speaker 0>things

01:20:57.770 --> 01:20:58.489
<v Speaker 0>there.

01:20:58.810 --> 01:20:59.369
<v Speaker 0>So

01:20:59.690 --> 01:21:01.690
<v Speaker 0>I just wanna say thank you for, you

01:21:01.690 --> 01:21:03.370
<v Speaker 0>know, taking the time out of your day.

01:21:03.370 --> 01:21:04.364
<v Speaker 0>I know you must have a lot on

01:21:04.364 --> 01:21:06.284
<v Speaker 0>your plate. You're starting a new role next

01:21:06.284 --> 01:21:07.965
<v Speaker 0>week. So, you know, thank you for making

01:21:07.965 --> 01:21:09.885
<v Speaker 0>the time here and and kinda guiding me

01:21:09.885 --> 01:21:11.405
<v Speaker 0>through this and sharing your knowledge. It was

01:21:11.405 --> 01:21:13.324
<v Speaker 0>it was really really really good. I enjoyed

01:21:13.324 --> 01:21:15.804
<v Speaker 0>it. Yeah. You're welcome. This is really fun.

01:21:16.429 --> 01:21:18.590
<v Speaker 0>Thank you. Well, you have a great rest

01:21:18.590 --> 01:21:20.350
<v Speaker 0>of your day. Enjoy your weekend. Good luck

01:21:20.350 --> 01:21:22.030
<v Speaker 0>with your new job at Google next week

01:21:22.030 --> 01:21:23.949
<v Speaker 0>and thank you again. Yeah.

01:21:24.270 --> 01:21:25.790
<v Speaker 1>Cheers. Thank you for having me. It was

01:21:25.790 --> 01:21:26.429
<v Speaker 1>great.

01:21:26.750 --> 01:21:27.150
<v Speaker 0>Cheers.
