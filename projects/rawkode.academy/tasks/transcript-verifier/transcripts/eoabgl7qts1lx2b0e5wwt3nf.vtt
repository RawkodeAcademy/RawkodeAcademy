WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 117ad69b-c8fd-44f0-95db-58a61af92be3
Created: 2025-04-29T13:45:50.266Z
Duration: 2728.8157
Channels: 1

00:00:00.000 --> 00:00:02.480
<v Speaker 0>Welcome to the show, Frank. Please take a

00:00:02.480 --> 00:00:03.919
<v Speaker 0>moment to tell us a little bit more

00:00:03.919 --> 00:00:05.279
<v Speaker 0>about you and what you've been up to

00:00:05.279 --> 00:00:05.920
<v Speaker 0>lately.

00:00:06.319 --> 00:00:09.200
<v Speaker 1>Cool. Thanks thanks, David, for having me on,

00:00:09.200 --> 00:00:09.999
<v Speaker 1>first of all.

00:00:10.719 --> 00:00:14.880
<v Speaker 1>Well, for everybody out there, I'm Frank. I'm

00:00:15.304 --> 00:00:18.505
<v Speaker 1>a currently a staff engineer at Personio, which

00:00:18.505 --> 00:00:20.985
<v Speaker 1>is a big HR company based out of

00:00:20.985 --> 00:00:22.025
<v Speaker 1>Germany.

00:00:22.425 --> 00:00:23.625
<v Speaker 1>I joined

00:00:23.625 --> 00:00:24.505
<v Speaker 1>Personio

00:00:24.505 --> 00:00:25.384
<v Speaker 1>about

00:00:25.865 --> 00:00:28.265
<v Speaker 1>a year ago. Before that, I did a

00:00:28.265 --> 00:00:30.585
<v Speaker 1>couple years in in fintech, which

00:00:31.679 --> 00:00:33.840
<v Speaker 1>gave me a lot of appreciation

00:00:33.840 --> 00:00:36.160
<v Speaker 1>for the sort of more consistent side of

00:00:36.160 --> 00:00:36.879
<v Speaker 1>things. Like,

00:00:38.160 --> 00:00:40.480
<v Speaker 1>losing a transaction is not something that fintech

00:00:40.480 --> 00:00:41.440
<v Speaker 1>really

00:00:41.440 --> 00:00:42.559
<v Speaker 1>really accepts. So

00:00:43.375 --> 00:00:44.975
<v Speaker 1>especially in sort of

00:00:45.535 --> 00:00:47.774
<v Speaker 1>larger distributed systems

00:00:47.774 --> 00:00:49.855
<v Speaker 1>with many systems integrating

00:00:50.574 --> 00:00:52.335
<v Speaker 1>often with events

00:00:52.335 --> 00:00:53.295
<v Speaker 1>and messages,

00:00:53.534 --> 00:00:55.295
<v Speaker 1>that was a really interesting

00:00:55.534 --> 00:00:56.015
<v Speaker 1>experience.

00:00:56.800 --> 00:00:58.800
<v Speaker 1>Before that, I did a lot of work

00:00:58.800 --> 00:00:59.360
<v Speaker 1>for

00:00:59.840 --> 00:01:02.239
<v Speaker 1>Circle, the airports here nearby.

00:01:02.559 --> 00:01:05.840
<v Speaker 1>I did a fully event driven real time

00:01:05.840 --> 00:01:06.720
<v Speaker 1>dashboard

00:01:06.720 --> 00:01:08.800
<v Speaker 1>application for their internal

00:01:08.800 --> 00:01:09.600
<v Speaker 1>operation

00:01:09.920 --> 00:01:11.840
<v Speaker 1>with highly sensitive data.

00:01:12.465 --> 00:01:14.784
<v Speaker 1>That was in TypeScript. And for the rest,

00:01:14.784 --> 00:01:16.625
<v Speaker 1>I've done a lot of stuff in in

00:01:16.625 --> 00:01:17.585
<v Speaker 1>PHP.

00:01:18.705 --> 00:01:22.145
<v Speaker 1>My current day job is more with Kotlin.

00:01:22.145 --> 00:01:24.945
<v Speaker 1>So for me, like, languages or

00:01:25.560 --> 00:01:26.520
<v Speaker 1>whatever.

00:01:27.000 --> 00:01:28.520
<v Speaker 1>And so I've been doing this for a

00:01:28.520 --> 00:01:31.640
<v Speaker 1>while now. Think, like, I'm close

00:01:31.640 --> 00:01:34.920
<v Speaker 1>to fifteen years of of doing this stuff.

00:01:35.320 --> 00:01:38.440
<v Speaker 1>So yeah. And I'm looking forward to doing

00:01:38.440 --> 00:01:40.280
<v Speaker 1>it at least fifteen years more.

00:01:41.455 --> 00:01:44.575
<v Speaker 0>Yeah. Awesome. Alright. Thank you for sharing. So,

00:01:44.575 --> 00:01:46.655
<v Speaker 0>yeah, I I kinda you know, I've followed

00:01:46.655 --> 00:01:48.255
<v Speaker 0>you for a while with Tati before in

00:01:48.255 --> 00:01:49.774
<v Speaker 0>the past, and I knew you from the

00:01:49.774 --> 00:01:51.455
<v Speaker 0>PHP ecosystem, but I did see that you

00:01:51.455 --> 00:01:53.774
<v Speaker 0>were doing Java and Kotlin and TypeScript as

00:01:53.774 --> 00:01:54.655
<v Speaker 0>well. Like,

00:01:54.975 --> 00:01:57.460
<v Speaker 0>it's I think it's always interesting that the

00:01:57.460 --> 00:01:58.979
<v Speaker 0>more we do this, the more the language

00:01:58.979 --> 00:02:00.899
<v Speaker 0>becomes less important. Right? And it's more about

00:02:00.899 --> 00:02:02.180
<v Speaker 0>all the things you'd learn

00:02:02.420 --> 00:02:04.899
<v Speaker 0>along the way. So, hopefully, we'll we'll get

00:02:04.899 --> 00:02:06.180
<v Speaker 0>into that in more detail as we go

00:02:06.180 --> 00:02:09.220
<v Speaker 0>through the episodes. Yeah. I, I totally agree.

00:02:09.220 --> 00:02:11.855
<v Speaker 1>Right? So you see, all of things sort

00:02:11.855 --> 00:02:14.655
<v Speaker 1>of lumping together and doesn't at the end,

00:02:14.655 --> 00:02:16.575
<v Speaker 1>it doesn't really matter what tool we use

00:02:16.575 --> 00:02:19.535
<v Speaker 1>anymore. But it also means that you're gonna

00:02:19.535 --> 00:02:21.694
<v Speaker 1>encounter the same problems in just in in

00:02:21.694 --> 00:02:22.895
<v Speaker 1>different flavors.

00:02:23.135 --> 00:02:23.455
<v Speaker 1>Yeah.

00:02:24.110 --> 00:02:26.590
<v Speaker 0>Yeah. Or rewrite the same library 14 times

00:02:26.590 --> 00:02:28.590
<v Speaker 0>on other languages that you're gonna work with.

00:02:29.150 --> 00:02:29.790
<v Speaker 1>Wow.

00:02:30.030 --> 00:02:30.750
<v Speaker 1>Like,

00:02:32.030 --> 00:02:34.430
<v Speaker 1>I have written or rewritten

00:02:34.910 --> 00:02:35.790
<v Speaker 1>EventSauce,

00:02:35.790 --> 00:02:38.670
<v Speaker 1>which is an open source library that I

00:02:39.084 --> 00:02:39.885
<v Speaker 1>maintain.

00:02:39.885 --> 00:02:42.045
<v Speaker 1>I've rewritten that in a couple of languages

00:02:42.045 --> 00:02:45.085
<v Speaker 1>now, which is always an interesting experience because

00:02:45.405 --> 00:02:47.485
<v Speaker 1>while the majority of the things that you

00:02:47.485 --> 00:02:50.205
<v Speaker 1>do sort of maintain or they are the

00:02:50.205 --> 00:02:53.724
<v Speaker 1>same, but some things you really adjust towards

00:02:53.724 --> 00:02:56.660
<v Speaker 1>what's kind of language mechanics you have. And

00:02:56.660 --> 00:02:58.020
<v Speaker 1>that's always an interesting

00:02:58.180 --> 00:03:00.819
<v Speaker 1>routes to explore when whenever I'm doing that

00:03:00.819 --> 00:03:01.940
<v Speaker 1>in a new language.

00:03:02.180 --> 00:03:04.500
<v Speaker 0>Yeah. I mean, I I I don't have

00:03:04.500 --> 00:03:06.420
<v Speaker 0>the first question. I'll pan out, but I'm

00:03:06.420 --> 00:03:08.099
<v Speaker 0>gonna skip it right now. It's go down

00:03:08.099 --> 00:03:10.020
<v Speaker 0>this little path where we're talking because

00:03:10.525 --> 00:03:12.125
<v Speaker 0>one of the things I found most important

00:03:12.125 --> 00:03:13.485
<v Speaker 0>in my career, and I think you just

00:03:13.485 --> 00:03:15.005
<v Speaker 0>kind of alluded to it there as well,

00:03:15.005 --> 00:03:16.845
<v Speaker 0>is that when I wrote c, I learned

00:03:16.845 --> 00:03:18.125
<v Speaker 0>how to write c code. When I did

00:03:18.125 --> 00:03:19.805
<v Speaker 0>PHP, learned how to write PHP code. When

00:03:19.805 --> 00:03:21.085
<v Speaker 0>I did Alexa, I learned how to write

00:03:21.085 --> 00:03:22.605
<v Speaker 0>Alexa code and so forth and so forth.

00:03:22.605 --> 00:03:25.005
<v Speaker 0>Right? Go and Rust, like I love experimenting

00:03:25.005 --> 00:03:25.565
<v Speaker 0>with languages.

00:03:26.150 --> 00:03:28.550
<v Speaker 0>But what I love more is learning from

00:03:28.550 --> 00:03:29.510
<v Speaker 0>the idiomatics

00:03:29.510 --> 00:03:32.710
<v Speaker 0>of each language. Like, concurrency and Go is

00:03:32.710 --> 00:03:35.030
<v Speaker 0>very different from what I've done in PHP.

00:03:35.430 --> 00:03:37.270
<v Speaker 0>Concurrency and Alexa is very different to Go

00:03:37.270 --> 00:03:39.350
<v Speaker 0>as well because it has this actor based

00:03:39.350 --> 00:03:42.235
<v Speaker 0>process model. And, like, it's just through the

00:03:42.235 --> 00:03:44.155
<v Speaker 0>combination of all of these different

00:03:44.475 --> 00:03:45.515
<v Speaker 0>idiosyncrasies,

00:03:45.515 --> 00:03:46.395
<v Speaker 0>I don't even know if that's the right

00:03:46.395 --> 00:03:48.555
<v Speaker 0>word, of each of these languages and runtimes.

00:03:48.555 --> 00:03:50.715
<v Speaker 0>But you build up a different picture of

00:03:50.715 --> 00:03:52.395
<v Speaker 0>what software should look like in your head

00:03:52.395 --> 00:03:54.710
<v Speaker 0>regardless of the language. Like, I don't think

00:03:54.710 --> 00:03:56.230
<v Speaker 0>I would be the developer I am today

00:03:56.230 --> 00:03:57.830
<v Speaker 0>if I hadn't worked in all of those

00:03:57.830 --> 00:04:00.550
<v Speaker 0>languages and learned all of the different things

00:04:00.550 --> 00:04:02.390
<v Speaker 0>they do different in their ecosystem.

00:04:02.390 --> 00:04:03.350
<v Speaker 0>Does that make sense?

00:04:03.750 --> 00:04:07.030
<v Speaker 1>Absolutely. Like, one of the first, conference talks

00:04:07.030 --> 00:04:08.230
<v Speaker 1>that I ever

00:04:08.455 --> 00:04:10.375
<v Speaker 1>did was at Lericon,

00:04:10.375 --> 00:04:14.055
<v Speaker 1>I think, in, like, when was this? 02/2012

00:04:14.055 --> 00:04:16.294
<v Speaker 1>or something like that? And it was a

00:04:16.294 --> 00:04:18.615
<v Speaker 1>talk called the knowledge of others. And it

00:04:18.615 --> 00:04:21.415
<v Speaker 1>was basically a talk about looking at various

00:04:22.230 --> 00:04:23.910
<v Speaker 1>ways of solving a problem.

00:04:24.230 --> 00:04:26.630
<v Speaker 1>And during the talk, I sort of looked

00:04:26.630 --> 00:04:28.230
<v Speaker 1>at different types

00:04:28.230 --> 00:04:30.550
<v Speaker 1>of problems and then looked at what languages

00:04:30.550 --> 00:04:31.270
<v Speaker 1>are

00:04:31.590 --> 00:04:32.630
<v Speaker 1>most

00:04:32.630 --> 00:04:35.910
<v Speaker 1>likely to solve that's that's that problem.

00:04:36.445 --> 00:04:39.165
<v Speaker 1>So for example, like in in JavaScript, you

00:04:39.165 --> 00:04:40.925
<v Speaker 1>have a lot of sort of in process

00:04:40.925 --> 00:04:42.205
<v Speaker 1>events driven

00:04:42.205 --> 00:04:43.965
<v Speaker 1>stuff. So I looked at like, hey, what's

00:04:44.045 --> 00:04:45.565
<v Speaker 1>what does an event

00:04:45.885 --> 00:04:47.245
<v Speaker 1>emitter dispatcher

00:04:47.245 --> 00:04:49.645
<v Speaker 1>look like in in JavaScript and how can

00:04:49.645 --> 00:04:51.180
<v Speaker 1>we sort of get the same kind kind

00:04:51.180 --> 00:04:54.140
<v Speaker 1>of capabilities in, for example, a a language

00:04:54.140 --> 00:04:55.340
<v Speaker 1>like PHP

00:04:55.660 --> 00:04:58.380
<v Speaker 1>and also what's missing or what's not fitting

00:04:58.860 --> 00:05:00.860
<v Speaker 1>very well and how can you overcome that?

00:05:00.860 --> 00:05:02.300
<v Speaker 1>Like, I think that's a very

00:05:02.860 --> 00:05:05.420
<v Speaker 1>interesting way of looking at it. But you

00:05:05.565 --> 00:05:07.965
<v Speaker 1>you look at these languages and how they

00:05:07.965 --> 00:05:10.205
<v Speaker 1>frame it and the idiomatic

00:05:11.085 --> 00:05:11.885
<v Speaker 1>solutions

00:05:11.885 --> 00:05:14.365
<v Speaker 1>always provide a certain type of framing. Right?

00:05:14.365 --> 00:05:16.605
<v Speaker 1>So for for Go, like you mentioned Go,

00:05:16.605 --> 00:05:19.165
<v Speaker 1>I think the the model of concurrency there

00:05:19.480 --> 00:05:22.600
<v Speaker 1>is is very interesting to to to look

00:05:22.600 --> 00:05:25.000
<v Speaker 1>at and it's very like or the way

00:05:25.000 --> 00:05:26.760
<v Speaker 1>that I did it at least was very

00:05:26.760 --> 00:05:29.000
<v Speaker 1>channel based. Right? This is what's go, the

00:05:29.000 --> 00:05:31.560
<v Speaker 1>programming language where it really promotes and they've

00:05:31.560 --> 00:05:33.575
<v Speaker 1>got a very strong sense of how you

00:05:33.575 --> 00:05:36.295
<v Speaker 1>should route write code like that. And using

00:05:36.295 --> 00:05:39.815
<v Speaker 1>stuff like that in like, trying to replicate

00:05:39.815 --> 00:05:42.055
<v Speaker 1>that in in different languages is

00:05:42.215 --> 00:05:44.135
<v Speaker 1>sort of an interesting exercise.

00:05:44.710 --> 00:05:47.270
<v Speaker 1>It doesn't always play out, but you can

00:05:47.270 --> 00:05:50.310
<v Speaker 1>definitely take some learnings from one idiomatic approach

00:05:50.310 --> 00:05:53.590
<v Speaker 1>and apply it in a different different space.

00:05:53.590 --> 00:05:55.510
<v Speaker 1>If anything, it's a lot of fun. Yes.

00:05:55.510 --> 00:05:57.725
<v Speaker 0>I will 100% agree with that. And I

00:05:57.725 --> 00:05:59.405
<v Speaker 0>have taken a note about the knowledge of

00:05:59.405 --> 00:06:01.085
<v Speaker 0>others LaraCon talk. So I'll make sure there's

00:06:01.085 --> 00:06:02.205
<v Speaker 0>a link to that in the show notes

00:06:02.205 --> 00:06:03.805
<v Speaker 0>so that I can find that online for

00:06:03.805 --> 00:06:05.805
<v Speaker 0>people to to check it. I was like,

00:06:05.805 --> 00:06:07.005
<v Speaker 0>I don't wanna watch it myself. So

00:06:07.725 --> 00:06:10.205
<v Speaker 0>Well, I I don't think it's probably not

00:06:10.205 --> 00:06:12.605
<v Speaker 1>my my best, talk ever. Like, I think

00:06:12.605 --> 00:06:14.820
<v Speaker 1>it was one of the first talks that

00:06:14.820 --> 00:06:16.979
<v Speaker 1>I ever did in public, and I actually

00:06:16.979 --> 00:06:19.139
<v Speaker 1>don't remember a lot of it because, like,

00:06:19.139 --> 00:06:22.180
<v Speaker 1>being on stage, especially that point was, like,

00:06:22.180 --> 00:06:24.740
<v Speaker 1>such a sort of high intensity, high stress

00:06:24.740 --> 00:06:27.139
<v Speaker 1>moments that, you know, my brain blocked to

00:06:27.139 --> 00:06:27.539
<v Speaker 1>mature.

00:06:28.705 --> 00:06:31.585
<v Speaker 1>So mind you, the quality might be not

00:06:31.585 --> 00:06:34.145
<v Speaker 1>what you expect it to be. Awesome. Alright.

00:06:34.145 --> 00:06:35.825
<v Speaker 0>Let's go back to the planned first question

00:06:35.825 --> 00:06:39.185
<v Speaker 0>then. So, obviously, we've discussed event sourcing.

00:06:39.665 --> 00:06:42.305
<v Speaker 0>Before, you've already mentioned event source, your library,

00:06:42.305 --> 00:06:44.145
<v Speaker 0>you've now written it in multiple languages,

00:06:44.750 --> 00:06:46.110
<v Speaker 0>and it's a great way for people to

00:06:46.110 --> 00:06:48.669
<v Speaker 0>get started with event sourcing. But what I

00:06:48.669 --> 00:06:51.229
<v Speaker 0>want to understand is how did you even

00:06:51.229 --> 00:06:55.070
<v Speaker 0>end up in this event driven architecture ecosystem?

00:06:55.070 --> 00:06:57.495
<v Speaker 0>How what led you from writing,

00:06:57.495 --> 00:07:00.135
<v Speaker 0>you know, your your PSP and just writing

00:07:00.135 --> 00:07:01.415
<v Speaker 0>web apps or whatever it was you were

00:07:01.415 --> 00:07:03.575
<v Speaker 0>doing back in the day to go, crap.

00:07:03.575 --> 00:07:05.495
<v Speaker 0>Like, I want everything to be event driven.

00:07:05.495 --> 00:07:07.015
<v Speaker 0>What was the path like for you there?

00:07:07.255 --> 00:07:10.169
<v Speaker 1>Well, so, I was very fortunate enough to

00:07:10.169 --> 00:07:12.490
<v Speaker 1>work on a couple of projects where this

00:07:12.490 --> 00:07:13.290
<v Speaker 1>was just

00:07:13.530 --> 00:07:15.690
<v Speaker 1>needed. Like, the only way to do things

00:07:15.690 --> 00:07:18.090
<v Speaker 1>was an event driven way.

00:07:18.410 --> 00:07:19.290
<v Speaker 1>The first

00:07:19.850 --> 00:07:22.810
<v Speaker 1>project where it was really relevant was the

00:07:22.810 --> 00:07:24.490
<v Speaker 1>website for Schiphol.

00:07:24.784 --> 00:07:26.465
<v Speaker 1>So that was still in sort of the

00:07:26.465 --> 00:07:27.665
<v Speaker 1>website y

00:07:27.985 --> 00:07:29.905
<v Speaker 1>area, but it it got a little bit

00:07:29.905 --> 00:07:33.344
<v Speaker 1>more complex with some some logic there. But

00:07:33.344 --> 00:07:36.465
<v Speaker 1>effectively, the way that we had to ingest

00:07:36.625 --> 00:07:39.745
<v Speaker 1>flight information needed to be as close to

00:07:39.745 --> 00:07:42.199
<v Speaker 1>real time as possible. Right? So as soon

00:07:42.199 --> 00:07:44.360
<v Speaker 1>as possible, view on what the planes were

00:07:44.360 --> 00:07:44.840
<v Speaker 1>doing.

00:07:45.160 --> 00:07:47.160
<v Speaker 1>As a customer, you wanted to know like,

00:07:47.160 --> 00:07:49.720
<v Speaker 1>hey, I'm going on a KLM flight and

00:07:49.720 --> 00:07:52.120
<v Speaker 1>I'm going to London. What's the status of

00:07:52.120 --> 00:07:53.400
<v Speaker 1>the of the flight?

00:07:53.639 --> 00:07:56.275
<v Speaker 1>I want to, in my web app, follow

00:07:56.275 --> 00:07:59.395
<v Speaker 1>that flights, keep keep track of it. And

00:07:59.395 --> 00:08:02.275
<v Speaker 1>whenever something new is up, I would want

00:08:02.275 --> 00:08:03.715
<v Speaker 1>to see that. Now

00:08:03.875 --> 00:08:06.115
<v Speaker 1>the only real way to do that for

00:08:06.194 --> 00:08:08.354
<v Speaker 1>the scale that we were at, like, doing

00:08:08.354 --> 00:08:10.435
<v Speaker 1>that for all of the passengers

00:08:10.480 --> 00:08:12.400
<v Speaker 1>that go through simple,

00:08:12.560 --> 00:08:14.480
<v Speaker 1>you can't do that on a polling basis

00:08:14.480 --> 00:08:16.240
<v Speaker 1>and then figure out the delta between all

00:08:16.240 --> 00:08:18.560
<v Speaker 1>of the flights that are there everywhere. Right?

00:08:18.560 --> 00:08:21.440
<v Speaker 1>So one, it's it's it's not efficient enough,

00:08:21.440 --> 00:08:23.440
<v Speaker 1>but that's also not quick enough. Right? You

00:08:23.440 --> 00:08:25.360
<v Speaker 1>want it as soon as it's as it

00:08:25.360 --> 00:08:25.680
<v Speaker 1>happens.

00:08:26.225 --> 00:08:28.865
<v Speaker 1>So we built a a whole event based

00:08:28.865 --> 00:08:30.065
<v Speaker 1>integration

00:08:30.145 --> 00:08:32.304
<v Speaker 1>there and that was really on the consuming

00:08:32.304 --> 00:08:34.705
<v Speaker 1>side of an event stream. So I I

00:08:34.705 --> 00:08:36.465
<v Speaker 1>would say that's a relatively

00:08:36.544 --> 00:08:39.184
<v Speaker 1>comfortable way of starting out in the events

00:08:39.184 --> 00:08:40.065
<v Speaker 1>driven space

00:08:40.370 --> 00:08:42.610
<v Speaker 1>is to be a consumer of events.

00:08:42.769 --> 00:08:44.690
<v Speaker 1>Right? So you can sort of skip the

00:08:44.690 --> 00:08:45.730
<v Speaker 1>whole how,

00:08:46.209 --> 00:08:48.850
<v Speaker 1>when, and in what form should I be

00:08:48.850 --> 00:08:50.930
<v Speaker 1>producing this and just see it as a

00:08:50.930 --> 00:08:51.730
<v Speaker 1>stream of information

00:08:52.385 --> 00:08:54.465
<v Speaker 1>that you can respond to, that you can

00:08:54.465 --> 00:08:55.905
<v Speaker 1>create projections

00:08:56.145 --> 00:08:58.705
<v Speaker 1>from and all that. So that was my

00:08:58.705 --> 00:09:00.305
<v Speaker 1>sort of initial

00:09:00.305 --> 00:09:03.905
<v Speaker 1>introduction into the event driven space, which was

00:09:03.905 --> 00:09:07.185
<v Speaker 1>soon followed by going into the event sourced

00:09:07.185 --> 00:09:10.330
<v Speaker 1>space. For this same airport, we created a

00:09:10.330 --> 00:09:13.370
<v Speaker 1>way to book parking spots for Schiphol which

00:09:13.370 --> 00:09:16.730
<v Speaker 1>for an airport is a huge revenue stream.

00:09:16.970 --> 00:09:19.370
<v Speaker 1>And so it's being a huge revenue stream.

00:09:19.370 --> 00:09:20.970
<v Speaker 1>You also want to get a high level

00:09:20.970 --> 00:09:23.845
<v Speaker 1>of insight into what is going on and

00:09:23.845 --> 00:09:26.085
<v Speaker 1>why things are going the way they are.

00:09:26.245 --> 00:09:28.645
<v Speaker 1>So for example, if you're booking parking spots,

00:09:28.645 --> 00:09:30.005
<v Speaker 1>you get multiple

00:09:30.005 --> 00:09:33.285
<v Speaker 1>types of parking spots made available for you

00:09:33.285 --> 00:09:35.285
<v Speaker 1>which are at different price ranges.

00:09:35.730 --> 00:09:37.730
<v Speaker 1>So you also want to know as a

00:09:37.730 --> 00:09:39.730
<v Speaker 1>vendor of these parking spots,

00:09:39.890 --> 00:09:42.370
<v Speaker 1>like what does the positioning of those parking

00:09:42.370 --> 00:09:45.570
<v Speaker 1>spots do for the general choice of the

00:09:45.570 --> 00:09:48.450
<v Speaker 1>parking spots afterwards. Right? So you can do

00:09:48.450 --> 00:09:50.450
<v Speaker 1>this with just

00:09:49.995 --> 00:09:53.035
<v Speaker 1>an API call and record the response, then

00:09:53.035 --> 00:09:55.595
<v Speaker 1>track where you positioned it, and then do

00:09:55.595 --> 00:09:58.235
<v Speaker 1>a separate call afterwards to say, hey, which

00:09:58.235 --> 00:09:58.715
<v Speaker 1>one

00:09:59.035 --> 00:10:00.075
<v Speaker 1>was picked?

00:10:00.155 --> 00:10:02.395
<v Speaker 1>But it's very indirect. And a more direct

00:10:02.395 --> 00:10:05.115
<v Speaker 1>way is to just record that all of

00:10:04.740 --> 00:10:07.380
<v Speaker 1>as events and then make sure that you

00:10:07.380 --> 00:10:09.860
<v Speaker 1>use those events to gain those insights along

00:10:09.860 --> 00:10:11.940
<v Speaker 1>the way. There I was very fortunate to

00:10:11.940 --> 00:10:13.940
<v Speaker 1>work with Marine Heisenfeldt

00:10:13.940 --> 00:10:16.740
<v Speaker 1>who was doing event sourcing, like, I think

00:10:16.740 --> 00:10:18.660
<v Speaker 1>maybe even before I started programming.

00:10:19.055 --> 00:10:21.454
<v Speaker 1>So I had a very, like a veteran

00:10:21.454 --> 00:10:23.055
<v Speaker 1>of event sourcing

00:10:23.375 --> 00:10:26.095
<v Speaker 1>as a mentor and as somebody who guided

00:10:26.095 --> 00:10:28.334
<v Speaker 1>that entire project. So I was very much

00:10:28.334 --> 00:10:31.295
<v Speaker 1>in a following capacity when I was executing

00:10:31.295 --> 00:10:34.810
<v Speaker 1>that and Marine was really leading that effort

00:10:34.810 --> 00:10:36.090
<v Speaker 1>there. Nice.

00:10:36.490 --> 00:10:38.170
<v Speaker 0>Well, yeah. I I I got a couple

00:10:38.170 --> 00:10:40.650
<v Speaker 0>of questions. Right? So you can imagine event

00:10:40.650 --> 00:10:42.650
<v Speaker 0>driven and then event sourcing.

00:10:42.970 --> 00:10:45.130
<v Speaker 0>And, you know, to the people that are

00:10:45.130 --> 00:10:47.530
<v Speaker 0>listening, I'm gonna ask you very the same

00:10:47.530 --> 00:10:49.584
<v Speaker 0>question twice, but for each of those. And

00:10:49.584 --> 00:10:50.865
<v Speaker 0>you can just say yes or no. You

00:10:50.865 --> 00:10:52.705
<v Speaker 0>can give more information if you want. Right?

00:10:52.865 --> 00:10:54.385
<v Speaker 0>But would you say that

00:10:54.785 --> 00:10:56.945
<v Speaker 0>most applications could benefit

00:10:57.105 --> 00:10:59.825
<v Speaker 0>from adopting some event driven aspects?

00:11:00.500 --> 00:11:03.860
<v Speaker 0>Yes. Alright. What about event sourcing? Is this

00:11:04.020 --> 00:11:05.700
<v Speaker 0>what the question I'm really getting at here

00:11:05.700 --> 00:11:07.620
<v Speaker 0>is what is the decision? What what thought

00:11:07.620 --> 00:11:09.220
<v Speaker 0>process do people need to make before they

00:11:09.220 --> 00:11:10.980
<v Speaker 0>say, I'm gonna bring event sourcing into my

00:11:10.980 --> 00:11:12.980
<v Speaker 0>application? Can they do it for all applications

00:11:12.980 --> 00:11:15.220
<v Speaker 0>or is it a very specific requirement need?

00:11:15.675 --> 00:11:17.995
<v Speaker 0>How how do you make that decision? Yeah.

00:11:17.995 --> 00:11:19.995
<v Speaker 1>For me, it needs to be the core

00:11:19.995 --> 00:11:23.035
<v Speaker 1>core business that you're that you're modeling.

00:11:23.755 --> 00:11:25.755
<v Speaker 1>And there needs to be a

00:11:26.075 --> 00:11:27.755
<v Speaker 1>like, I like it when there is a

00:11:27.755 --> 00:11:28.795
<v Speaker 1>temporal

00:11:28.795 --> 00:11:32.400
<v Speaker 1>effect to it. So multiple things happening

00:11:32.400 --> 00:11:34.880
<v Speaker 1>after each other. There's a sequence to it.

00:11:35.600 --> 00:11:36.880
<v Speaker 1>And what

00:11:37.200 --> 00:11:37.920
<v Speaker 1>happens

00:11:38.160 --> 00:11:41.440
<v Speaker 1>is sometimes as interesting as the state that

00:11:41.440 --> 00:11:43.455
<v Speaker 1>you end up with. So if you compare

00:11:43.455 --> 00:11:46.654
<v Speaker 1>it to CRUD applications, right, CRUD applications, you

00:11:46.654 --> 00:11:49.455
<v Speaker 1>have a state, something happens, you overwrite something,

00:11:49.455 --> 00:11:51.535
<v Speaker 1>you have a new state, you overwrite the

00:11:51.535 --> 00:11:54.335
<v Speaker 1>past effectively. This also means that you lose

00:11:54.335 --> 00:11:56.750
<v Speaker 1>that state. Right? So you forget about the

00:11:56.750 --> 00:11:58.990
<v Speaker 1>past, but you also forget the delta. With

00:11:58.990 --> 00:12:00.110
<v Speaker 1>event sourcing,

00:12:00.270 --> 00:12:03.390
<v Speaker 1>you store everything that happens as a general

00:12:03.390 --> 00:12:04.190
<v Speaker 1>principle

00:12:04.430 --> 00:12:07.310
<v Speaker 1>as events and then you just append those

00:12:07.310 --> 00:12:09.915
<v Speaker 1>events. So this also means that you retain

00:12:09.915 --> 00:12:12.235
<v Speaker 1>all of the information over time, but you

00:12:12.235 --> 00:12:15.595
<v Speaker 1>also retain all of the delta. In fact,

00:12:15.675 --> 00:12:18.315
<v Speaker 1>the thing that you retain is the delta.

00:12:18.315 --> 00:12:21.115
<v Speaker 1>So you're always able to get from where

00:12:21.115 --> 00:12:23.115
<v Speaker 1>you were to where you are now.

00:12:23.610 --> 00:12:25.370
<v Speaker 1>And there are a couple of benefits to

00:12:25.370 --> 00:12:28.570
<v Speaker 1>that, which some problems are more prone to

00:12:28.570 --> 00:12:30.330
<v Speaker 1>benefits from than others.

00:12:30.650 --> 00:12:33.290
<v Speaker 1>So for example, if you have changing policies

00:12:33.370 --> 00:12:36.330
<v Speaker 1>and those policies need to be applied even

00:12:36.330 --> 00:12:37.529
<v Speaker 1>though something

00:12:37.529 --> 00:12:40.375
<v Speaker 1>was vetted through the process before and was

00:12:40.375 --> 00:12:41.335
<v Speaker 1>deemed okay.

00:12:41.654 --> 00:12:43.654
<v Speaker 1>Now a new policy is added, things no

00:12:43.654 --> 00:12:45.095
<v Speaker 1>longer valid.

00:12:45.255 --> 00:12:47.015
<v Speaker 1>How do you deal with that? Right? Having

00:12:47.015 --> 00:12:49.015
<v Speaker 1>that stream of events and not just the

00:12:49.015 --> 00:12:51.575
<v Speaker 1>outcome of something is valid, yes or no,

00:12:51.575 --> 00:12:54.910
<v Speaker 1>right, is useful in in such a case.

00:12:54.910 --> 00:12:57.630
<v Speaker 1>If you're doing something that's purely crud, right,

00:12:57.630 --> 00:12:59.870
<v Speaker 1>I need to get an inventory

00:12:59.950 --> 00:13:01.790
<v Speaker 1>or I need to have

00:13:02.029 --> 00:13:04.029
<v Speaker 1>what is it? A user management, all of

00:13:04.029 --> 00:13:07.605
<v Speaker 1>those things probably not useful because you're you're

00:13:07.605 --> 00:13:08.165
<v Speaker 1>only

00:13:08.485 --> 00:13:11.205
<v Speaker 1>interested in really the current state of things.

00:13:11.205 --> 00:13:13.765
<v Speaker 1>Like how how things got there, you don't

00:13:13.765 --> 00:13:16.565
<v Speaker 1>really care about it. Permission management, right, you

00:13:16.565 --> 00:13:19.365
<v Speaker 1>don't care about how the permissions got to

00:13:19.365 --> 00:13:20.880
<v Speaker 1>the state where they were, but you care

00:13:20.880 --> 00:13:22.880
<v Speaker 1>about what your current permissions are and how

00:13:22.880 --> 00:13:25.760
<v Speaker 1>to apply them. So not all problem areas

00:13:25.760 --> 00:13:28.560
<v Speaker 1>really benefit from. You got to understand

00:13:28.800 --> 00:13:30.640
<v Speaker 0>your domain to the point where you understand

00:13:30.640 --> 00:13:33.360
<v Speaker 0>there's value and those missing pieces of information

00:13:33.360 --> 00:13:35.279
<v Speaker 0>that we purge with a standard current based

00:13:35.279 --> 00:13:37.194
<v Speaker 0>operating system. I kind of understand that. Right?

00:13:37.194 --> 00:13:39.834
<v Speaker 0>Yeah. But then by saying that we wouldn't

00:13:39.834 --> 00:13:41.915
<v Speaker 0>adopt event sourcing for a current application,

00:13:41.995 --> 00:13:43.754
<v Speaker 0>I think what the subtext is saying there

00:13:43.754 --> 00:13:45.754
<v Speaker 0>is that there's a cost of adopting event

00:13:45.754 --> 00:13:48.475
<v Speaker 0>sourcing within your organization. Yeah. And so it's

00:13:48.475 --> 00:13:49.035
<v Speaker 0>it's not

00:13:49.709 --> 00:13:51.790
<v Speaker 0>always just four lanes of code and I've

00:13:51.790 --> 00:13:54.269
<v Speaker 0>got an event sourced application anymore. So I'll

00:13:54.269 --> 00:13:55.790
<v Speaker 0>come at this from two different angles then.

00:13:55.790 --> 00:13:57.389
<v Speaker 0>It's like, what what is the cost? Why

00:13:57.389 --> 00:13:59.230
<v Speaker 0>is it challenging for people to bring event

00:13:59.230 --> 00:14:00.990
<v Speaker 0>sourcing into an application to their team, to

00:14:00.990 --> 00:14:01.630
<v Speaker 0>their organization?

00:14:02.714 --> 00:14:05.355
<v Speaker 0>And part two of that as well, what

00:14:05.435 --> 00:14:07.755
<v Speaker 0>is it our future where event sourcing becomes

00:14:07.755 --> 00:14:09.755
<v Speaker 0>more of a commodity where it's easier to

00:14:09.755 --> 00:14:12.634
<v Speaker 0>bring into a project without that cost? Yeah.

00:14:12.634 --> 00:14:15.060
<v Speaker 1>So there's definitely a cost to it. I

00:14:15.060 --> 00:14:18.980
<v Speaker 1>would argue that the cost is mostly misinterpreted

00:14:18.980 --> 00:14:20.580
<v Speaker 1>or misassigned.

00:14:20.580 --> 00:14:23.940
<v Speaker 1>The biggest cost is probably that on people.

00:14:24.180 --> 00:14:27.060
<v Speaker 1>So if you're looking at experience for crowd

00:14:27.060 --> 00:14:30.180
<v Speaker 1>based application development, it's there in abundance.

00:14:31.035 --> 00:14:34.235
<v Speaker 1>If you're looking at the experience in building

00:14:34.235 --> 00:14:36.395
<v Speaker 1>event driven architectures,

00:14:36.475 --> 00:14:39.035
<v Speaker 1>there are still plenty, but it's a lot

00:14:39.035 --> 00:14:40.235
<v Speaker 1>fewer than,

00:14:40.395 --> 00:14:42.795
<v Speaker 1>like, finding people who can build good crop

00:14:42.795 --> 00:14:43.755
<v Speaker 1>applications

00:14:43.950 --> 00:14:47.070
<v Speaker 1>Where people usually attribute the cost of of

00:14:47.070 --> 00:14:48.670
<v Speaker 1>event driven architectures

00:14:48.910 --> 00:14:51.470
<v Speaker 1>is saying like, hey, now I need a

00:14:51.470 --> 00:14:53.950
<v Speaker 1>queue. Now I need all of these background

00:14:53.950 --> 00:14:55.070
<v Speaker 1>processes.

00:14:55.550 --> 00:14:57.550
<v Speaker 1>Now I need all this orchestration.

00:14:58.154 --> 00:15:00.394
<v Speaker 1>And I would just say like that's that's

00:15:00.394 --> 00:15:03.595
<v Speaker 1>not inherent to event driven architecture. So you

00:15:03.595 --> 00:15:05.195
<v Speaker 1>can do event

00:15:05.595 --> 00:15:06.315
<v Speaker 1>sourcing,

00:15:06.714 --> 00:15:09.675
<v Speaker 1>which is a very event centric approach of

00:15:09.675 --> 00:15:11.195
<v Speaker 1>modeling domains.

00:15:11.730 --> 00:15:14.690
<v Speaker 1>You can do that in a single threaded

00:15:14.690 --> 00:15:16.770
<v Speaker 1>language like PHP without

00:15:16.930 --> 00:15:20.130
<v Speaker 1>a queue. Right? You can do in process

00:15:20.130 --> 00:15:21.250
<v Speaker 1>consumers

00:15:21.410 --> 00:15:24.904
<v Speaker 1>where the events that you record are passed

00:15:24.904 --> 00:15:27.225
<v Speaker 1>in the same web request to the consumers

00:15:27.225 --> 00:15:30.345
<v Speaker 1>that project their state, send their emails,

00:15:30.665 --> 00:15:34.024
<v Speaker 1>send send out API calls to other kinds

00:15:34.024 --> 00:15:34.824
<v Speaker 1>of services.

00:15:35.225 --> 00:15:37.625
<v Speaker 1>That's all possible. Is it ideal?

00:15:37.785 --> 00:15:39.865
<v Speaker 1>No. But it is a good starting point.

00:15:39.900 --> 00:15:42.060
<v Speaker 1>Right? If you have a tiny application

00:15:42.460 --> 00:15:44.300
<v Speaker 1>that needs to do need to do a

00:15:44.300 --> 00:15:46.780
<v Speaker 1>couple of things, reliability is not yet a

00:15:46.780 --> 00:15:47.820
<v Speaker 1>big concern,

00:15:48.060 --> 00:15:50.140
<v Speaker 1>then you can really reduce the cost by

00:15:50.140 --> 00:15:52.540
<v Speaker 1>turning down all of these levers. Right? You

00:15:52.540 --> 00:15:55.385
<v Speaker 1>don't need fully false tolerance,

00:15:55.465 --> 00:15:56.425
<v Speaker 1>everything

00:15:56.425 --> 00:15:58.825
<v Speaker 1>at the start of a project. Right? So

00:15:58.665 --> 00:15:59.385
<v Speaker 1>yeah.

00:16:00.345 --> 00:16:03.545
<v Speaker 0>Okay. So let's pivot the question again one

00:16:03.545 --> 00:16:06.105
<v Speaker 0>more degree. You've got this team of engineers.

00:16:06.150 --> 00:16:07.990
<v Speaker 0>You're on it. Right? You're you're kicking ass.

00:16:07.990 --> 00:16:09.670
<v Speaker 0>You built an event driven system before. You've

00:16:09.670 --> 00:16:12.470
<v Speaker 0>got event source and 2,000 languages. Anybody can

00:16:12.470 --> 00:16:14.950
<v Speaker 0>build event source application nice and easy. Would

00:16:14.950 --> 00:16:15.590
<v Speaker 0>you

00:16:15.990 --> 00:16:17.430
<v Speaker 0>personally, just you,

00:16:17.670 --> 00:16:19.030
<v Speaker 0>if I came across and said, I have

00:16:19.030 --> 00:16:20.790
<v Speaker 0>this really simple CRUD based application

00:16:21.345 --> 00:16:23.185
<v Speaker 0>or microservice that we need as part of

00:16:23.185 --> 00:16:24.305
<v Speaker 0>a larger application.

00:16:24.545 --> 00:16:25.824
<v Speaker 0>At that point, is it easier for you

00:16:25.824 --> 00:16:27.505
<v Speaker 0>to do it with event sourcing, or is

00:16:27.505 --> 00:16:29.345
<v Speaker 0>there still a cost for you to do

00:16:29.345 --> 00:16:31.505
<v Speaker 0>it? Like, I'm wondering if, like, if I

00:16:31.505 --> 00:16:33.024
<v Speaker 0>have the experience, if we have a team

00:16:33.024 --> 00:16:35.280
<v Speaker 0>of experienced people, like, would you default to

00:16:35.280 --> 00:16:37.280
<v Speaker 0>event sourcing or would you go just credit

00:16:37.280 --> 00:16:40.880
<v Speaker 0>just credit? No. So defaulting

00:16:40.880 --> 00:16:43.360
<v Speaker 1>to any type of technology for me always

00:16:43.360 --> 00:16:45.760
<v Speaker 1>sounds like a very dogmatic thing to do.

00:16:45.760 --> 00:16:48.080
<v Speaker 1>So you need to balance it with,

00:16:48.320 --> 00:16:49.360
<v Speaker 1>like, the benefits

00:16:49.915 --> 00:16:52.875
<v Speaker 1>of implementing some something and the cost of

00:16:52.875 --> 00:16:55.915
<v Speaker 1>it. And so especially when you have a

00:16:55.915 --> 00:16:58.715
<v Speaker 1>large team around you, if you

00:16:59.115 --> 00:17:02.315
<v Speaker 1>don't have any event driven experience within a

00:17:02.315 --> 00:17:04.760
<v Speaker 1>a company, then you're saying like, hey, we're

00:17:04.760 --> 00:17:07.560
<v Speaker 1>gonna change this core component and we're gonna

00:17:07.560 --> 00:17:09.800
<v Speaker 1>switch it from a more crowd based to

00:17:09.800 --> 00:17:12.760
<v Speaker 1>a events driven approach.

00:17:13.080 --> 00:17:15.720
<v Speaker 1>I that has a serious expense to it.

00:17:15.720 --> 00:17:18.885
<v Speaker 1>So it it's more that the expenses that

00:17:18.885 --> 00:17:21.605
<v Speaker 1>you're gonna the organization will need to learn

00:17:21.605 --> 00:17:24.325
<v Speaker 1>about event driven architectures and that means that

00:17:24.325 --> 00:17:26.964
<v Speaker 1>they're gonna fail at at it for some

00:17:26.964 --> 00:17:27.444
<v Speaker 1>time.

00:17:27.925 --> 00:17:29.760
<v Speaker 1>And so you need to find a a

00:17:29.760 --> 00:17:32.480
<v Speaker 1>mode within the company that they're able to

00:17:32.480 --> 00:17:33.039
<v Speaker 1>fail.

00:17:33.440 --> 00:17:35.600
<v Speaker 1>And sometimes the expense is

00:17:36.320 --> 00:17:38.720
<v Speaker 1>is high, but even even then it can

00:17:38.720 --> 00:17:41.120
<v Speaker 1>be okay enough to to to do it.

00:17:41.120 --> 00:17:43.680
<v Speaker 1>So for example, in in some systems that

00:17:43.680 --> 00:17:45.905
<v Speaker 1>I worked on, all of the adjacent business

00:17:45.905 --> 00:17:48.945
<v Speaker 1>processes were taking direct database access,

00:17:49.105 --> 00:17:50.945
<v Speaker 1>to the columns that they needed,

00:17:51.185 --> 00:17:53.585
<v Speaker 1>to get their information from. Well, this also

00:17:53.585 --> 00:17:56.145
<v Speaker 1>meant that it was very difficult to change

00:17:56.145 --> 00:17:56.705
<v Speaker 1>that system.

00:17:57.250 --> 00:18:00.289
<v Speaker 1>So by introducing events, we allowed the second

00:18:00.610 --> 00:18:04.769
<v Speaker 1>secondary business processes to decouple from those internals,

00:18:04.929 --> 00:18:08.850
<v Speaker 1>giving the internals the freedom to change. Right?

00:18:08.850 --> 00:18:11.330
<v Speaker 1>So because this was a very necessary change

00:18:11.330 --> 00:18:12.049
<v Speaker 1>for the system,

00:18:12.565 --> 00:18:15.045
<v Speaker 1>the rewards were higher than the cost. Right?

00:18:15.045 --> 00:18:16.645
<v Speaker 1>And so in those cases, you can do

00:18:16.645 --> 00:18:17.125
<v Speaker 1>that.

00:18:17.445 --> 00:18:19.045
<v Speaker 1>But you need to have seen sort of

00:18:19.045 --> 00:18:20.725
<v Speaker 1>the other side in order to make that

00:18:20.725 --> 00:18:23.365
<v Speaker 1>assessment. And that's sometimes difficult. Right? If you

00:18:23.365 --> 00:18:26.165
<v Speaker 1>have decision makers within the same company who

00:18:26.165 --> 00:18:29.360
<v Speaker 1>haven't yet seen that that benefits,

00:18:29.520 --> 00:18:31.840
<v Speaker 1>then it's hard to sell them based on

00:18:31.840 --> 00:18:34.160
<v Speaker 1>the on the claims and the merits of

00:18:34.160 --> 00:18:35.679
<v Speaker 1>those those solutions.

00:18:35.680 --> 00:18:37.680
<v Speaker 0>Yeah. I love that you mentioned the the

00:18:37.680 --> 00:18:39.440
<v Speaker 0>failure aspect there. I think what a lot

00:18:39.440 --> 00:18:42.044
<v Speaker 0>of people often forget is that people with

00:18:42.044 --> 00:18:44.124
<v Speaker 0>experience or people that are good at

00:18:44.365 --> 00:18:47.885
<v Speaker 0>rating Kotlin that doing Kubernetes about a microservices,

00:18:47.885 --> 00:18:48.924
<v Speaker 0>doing event sourcing.

00:18:49.485 --> 00:18:51.485
<v Speaker 0>They weren't magically good at it because they've

00:18:51.485 --> 00:18:52.924
<v Speaker 0>done a lot. They're they're good at it

00:18:52.924 --> 00:18:54.524
<v Speaker 0>because they've done it wrong more times than

00:18:54.524 --> 00:18:56.284
<v Speaker 0>anyone else. Right? And it's

00:18:56.480 --> 00:18:58.880
<v Speaker 0>yeah. Teams have to build up that competency.

00:18:58.880 --> 00:18:59.600
<v Speaker 0>And sadly,

00:19:00.560 --> 00:19:02.320
<v Speaker 0>fastest way to do it is to get

00:19:02.320 --> 00:19:04.559
<v Speaker 0>a lot of shit wrong. So Yeah.

00:19:05.920 --> 00:19:07.039
<v Speaker 1>Yeah. Sort of,

00:19:07.360 --> 00:19:09.760
<v Speaker 1>like, eat dirt, get up and continue.

00:19:10.425 --> 00:19:13.225
<v Speaker 0>Alright. Look. We've chatted for, like, twenty minutes

00:19:13.225 --> 00:19:13.865
<v Speaker 0>now,

00:19:14.345 --> 00:19:16.425
<v Speaker 0>and we haven't really tackled for anyone who's

00:19:16.425 --> 00:19:18.425
<v Speaker 0>new to event source and CQRS and event

00:19:18.425 --> 00:19:20.665
<v Speaker 0>driven architectures, I kind of overview. Now we

00:19:20.665 --> 00:19:22.665
<v Speaker 0>have covered a little bit of it through

00:19:22.665 --> 00:19:24.585
<v Speaker 0>your conversation. You've talked about squashing

00:19:25.000 --> 00:19:27.480
<v Speaker 0>or losing history and maintaining history and stuff

00:19:27.480 --> 00:19:29.080
<v Speaker 0>like that. But maybe we could give people

00:19:29.080 --> 00:19:31.399
<v Speaker 0>a quick five minute overview on

00:19:31.640 --> 00:19:34.440
<v Speaker 0>EDA event sourcing and CQRS and how those

00:19:34.440 --> 00:19:37.080
<v Speaker 0>work together. Yeah. Alright. I I will start

00:19:37.080 --> 00:19:39.080
<v Speaker 1>with with event sourcing.

00:19:39.080 --> 00:19:39.480
<v Speaker 1>So

00:19:39.965 --> 00:19:43.005
<v Speaker 1>event sourcing is really a way to model

00:19:43.005 --> 00:19:44.765
<v Speaker 1>problem domains.

00:19:45.005 --> 00:19:47.885
<v Speaker 1>We're using events as the the primitive

00:19:47.885 --> 00:19:51.164
<v Speaker 1>to record what's happened with the store states.

00:19:51.645 --> 00:19:53.485
<v Speaker 1>In event sourcing specifically,

00:19:53.910 --> 00:19:55.990
<v Speaker 1>you also say that the states that you

00:19:55.990 --> 00:19:59.110
<v Speaker 1>use in order to base new decisions upon

00:19:59.510 --> 00:20:00.230
<v Speaker 1>are

00:20:00.310 --> 00:20:03.190
<v Speaker 1>in essence sourced by the events that you

00:20:03.190 --> 00:20:06.630
<v Speaker 1>record. And this usually means that you reconstitute

00:20:06.630 --> 00:20:07.430
<v Speaker 1>your

00:20:07.430 --> 00:20:10.665
<v Speaker 1>domain model by reapplying all of the events

00:20:10.665 --> 00:20:13.705
<v Speaker 1>of the past, putting you in a condition

00:20:13.705 --> 00:20:15.384
<v Speaker 1>to make a decision

00:20:15.625 --> 00:20:18.264
<v Speaker 1>that will then again result

00:20:18.505 --> 00:20:19.304
<v Speaker 1>into

00:20:19.625 --> 00:20:21.784
<v Speaker 1>a newly recorded event.

00:20:22.184 --> 00:20:23.865
<v Speaker 1>This is different from traditional

00:20:24.700 --> 00:20:26.700
<v Speaker 1>entity based and state based

00:20:26.940 --> 00:20:27.900
<v Speaker 1>modeling

00:20:27.980 --> 00:20:29.660
<v Speaker 1>where you overwrite

00:20:29.660 --> 00:20:31.500
<v Speaker 1>the past. A

00:20:32.060 --> 00:20:35.660
<v Speaker 1>reason why this is was introduced is effectively

00:20:35.660 --> 00:20:36.940
<v Speaker 1>for not

00:20:37.054 --> 00:20:40.975
<v Speaker 1>losing the history that you have recorded along

00:20:40.975 --> 00:20:43.614
<v Speaker 1>the way. It's very inspired by accounting.

00:20:43.934 --> 00:20:46.655
<v Speaker 1>If you have a bank account somewhere and

00:20:46.655 --> 00:20:47.134
<v Speaker 1>you

00:20:48.174 --> 00:20:50.975
<v Speaker 1>deducted too much money somewhere, right, you don't

00:20:50.975 --> 00:20:52.255
<v Speaker 1>get that row

00:20:53.230 --> 00:20:54.109
<v Speaker 1>adjusted.

00:20:54.110 --> 00:20:56.749
<v Speaker 1>You get a counter transaction

00:20:56.990 --> 00:20:58.990
<v Speaker 1>that says like, hey, I'm gonna file a

00:20:58.990 --> 00:21:00.190
<v Speaker 1>correction now.

00:21:00.510 --> 00:21:04.909
<v Speaker 1>So for example, I overbooked some money, removed

00:21:05.150 --> 00:21:06.190
<v Speaker 1>120,

00:21:06.755 --> 00:21:10.035
<v Speaker 1>but I meant to deduct 100.

00:21:10.035 --> 00:21:13.395
<v Speaker 1>Now I'm gonna sort of reimburse you 20.

00:21:13.635 --> 00:21:15.555
<v Speaker 1>We all know how this happened and how

00:21:15.555 --> 00:21:17.075
<v Speaker 1>we got to the end state. We know

00:21:17.075 --> 00:21:19.570
<v Speaker 1>how the correction happens. Well, for some business

00:21:19.570 --> 00:21:22.769
<v Speaker 1>processes, this is really important to to have

00:21:22.769 --> 00:21:24.209
<v Speaker 1>us as context.

00:21:24.690 --> 00:21:27.490
<v Speaker 1>Now that sort of event sourcing in its

00:21:27.490 --> 00:21:28.849
<v Speaker 1>in its essence.

00:21:29.169 --> 00:21:29.409
<v Speaker 1>So

00:21:30.544 --> 00:21:32.384
<v Speaker 1>sometimes it helps to

00:21:33.025 --> 00:21:35.265
<v Speaker 1>relate back to other primitives

00:21:35.265 --> 00:21:38.065
<v Speaker 1>to sort of see how it really works.

00:21:38.385 --> 00:21:41.424
<v Speaker 1>I usually say like, hey, an aggregate which

00:21:41.424 --> 00:21:43.745
<v Speaker 1>is what's or an aggregate root which is

00:21:43.745 --> 00:21:46.139
<v Speaker 1>what you refer to in event sourcing terms

00:21:46.139 --> 00:21:48.940
<v Speaker 1>as as the entity is sort of the

00:21:49.179 --> 00:21:50.860
<v Speaker 1>you have a stream of events and you

00:21:50.860 --> 00:21:52.219
<v Speaker 1>sort of map reduce

00:21:52.299 --> 00:21:55.580
<v Speaker 1>that those events into a state. You use

00:21:55.580 --> 00:21:57.659
<v Speaker 1>this state in order to provide the context

00:21:57.659 --> 00:22:00.065
<v Speaker 1>for your next decision and then afterwards are

00:22:00.065 --> 00:22:02.544
<v Speaker 1>more events and that's what you get out.

00:22:02.945 --> 00:22:04.785
<v Speaker 1>The benefit of this is that it becomes

00:22:04.785 --> 00:22:06.145
<v Speaker 1>really deterministic.

00:22:06.225 --> 00:22:08.785
<v Speaker 1>If you have state based application,

00:22:09.025 --> 00:22:09.585
<v Speaker 1>applications,

00:22:10.145 --> 00:22:11.985
<v Speaker 1>you need to set the state and whether

00:22:11.985 --> 00:22:13.825
<v Speaker 1>that state is something that you would end

00:22:13.825 --> 00:22:16.490
<v Speaker 1>up in or not. Right? That's that's out

00:22:16.490 --> 00:22:18.010
<v Speaker 1>of the question. And then you need to

00:22:18.010 --> 00:22:20.730
<v Speaker 1>make a decision and then new state is

00:22:20.730 --> 00:22:22.409
<v Speaker 1>what you actually assert on.

00:22:22.650 --> 00:22:25.850
<v Speaker 1>In events driven systems, especially event sourced ones,

00:22:25.929 --> 00:22:27.850
<v Speaker 1>you can have a really nice given when

00:22:27.850 --> 00:22:28.809
<v Speaker 1>then structure

00:22:28.995 --> 00:22:31.635
<v Speaker 1>which says like, given these events, when I

00:22:31.635 --> 00:22:32.674
<v Speaker 1>do this action,

00:22:33.155 --> 00:22:35.795
<v Speaker 1>now I ex expect these events to be

00:22:35.795 --> 00:22:38.195
<v Speaker 1>recorded. And that's very deterministic.

00:22:38.195 --> 00:22:39.875
<v Speaker 1>It's almost like mathematical

00:22:39.875 --> 00:22:40.995
<v Speaker 1>in that sense.

00:22:41.475 --> 00:22:43.600
<v Speaker 1>You can sort of see that as a

00:22:43.600 --> 00:22:46.240
<v Speaker 1>proof of the system working without having to

00:22:46.240 --> 00:22:48.640
<v Speaker 1>manipulate any inner parts of the system. So

00:22:48.640 --> 00:22:52.240
<v Speaker 1>that's that's very nice. So I think does

00:22:52.240 --> 00:22:55.120
<v Speaker 1>that sort of clarify the whole event sourcing

00:22:55.440 --> 00:22:58.065
<v Speaker 1>part? Yeah. I think that was spot on.

00:22:58.145 --> 00:22:59.825
<v Speaker 0>I'm I'm gonna add one example that I

00:22:59.825 --> 00:23:02.305
<v Speaker 0>found really useful. I can't remember who it

00:23:02.305 --> 00:23:04.385
<v Speaker 0>was. It was either you, Tomi, and the

00:23:04.385 --> 00:23:05.505
<v Speaker 0>pub, or maybe it was Greg going on

00:23:05.505 --> 00:23:06.865
<v Speaker 0>one of his talks. But it was the

00:23:06.865 --> 00:23:07.825
<v Speaker 0>ecommerce example

00:23:08.410 --> 00:23:08.970
<v Speaker 0>where

00:23:09.290 --> 00:23:11.130
<v Speaker 0>if you think about building an Amazon or

00:23:11.130 --> 00:23:12.730
<v Speaker 0>someone adds something to a car and removes

00:23:12.730 --> 00:23:13.770
<v Speaker 0>it from the car and they do that

00:23:13.770 --> 00:23:15.690
<v Speaker 0>5,000 times and then they buy one item,

00:23:15.770 --> 00:23:17.770
<v Speaker 0>there's 5,000 items there that you can upsell

00:23:17.770 --> 00:23:20.570
<v Speaker 0>them later if you track that they added

00:23:20.570 --> 00:23:22.845
<v Speaker 0>it and removed it from the car. And

00:23:22.845 --> 00:23:24.285
<v Speaker 0>that that was the one and I still

00:23:24.285 --> 00:23:26.765
<v Speaker 0>remember that example clear as data today.

00:23:26.925 --> 00:23:28.365
<v Speaker 0>It's the one when I went, oh, there

00:23:28.365 --> 00:23:29.805
<v Speaker 0>is a lot of value in some of

00:23:29.805 --> 00:23:31.804
<v Speaker 0>that information that we've always parched

00:23:31.885 --> 00:23:34.125
<v Speaker 0>in the past. Yeah. I think one of

00:23:34.125 --> 00:23:36.365
<v Speaker 1>the situations that I think is

00:23:36.750 --> 00:23:38.110
<v Speaker 1>often underutilized

00:23:38.110 --> 00:23:39.789
<v Speaker 1>even in event sourcing

00:23:39.950 --> 00:23:42.029
<v Speaker 1>is recording of failure.

00:23:42.430 --> 00:23:45.870
<v Speaker 1>So if you if you, for example, want

00:23:45.870 --> 00:23:47.950
<v Speaker 1>to pay for something but you have insufficient

00:23:47.950 --> 00:23:50.975
<v Speaker 1>budget, right? In a entity based system or

00:23:50.975 --> 00:23:53.374
<v Speaker 1>a state based system, right, you say, I'm

00:23:53.375 --> 00:23:55.775
<v Speaker 1>I'm entering the methods. Do I have enough

00:23:55.775 --> 00:23:59.215
<v Speaker 1>balance? If no, throw exception.

00:23:59.215 --> 00:24:01.934
<v Speaker 1>If yes, mutate the states. Only then it

00:24:01.934 --> 00:24:02.495
<v Speaker 1>has effect.

00:24:02.980 --> 00:24:05.619
<v Speaker 1>Within the event source system, you might say,

00:24:06.899 --> 00:24:08.499
<v Speaker 1>into the to

00:24:08.899 --> 00:24:10.019
<v Speaker 1>the methods,

00:24:10.580 --> 00:24:13.059
<v Speaker 1>see if there is enough balance. If not,

00:24:13.059 --> 00:24:15.779
<v Speaker 1>record an event and throw an exception and

00:24:15.779 --> 00:24:18.975
<v Speaker 1>you always store any type of events that

00:24:18.975 --> 00:24:21.135
<v Speaker 1>you record. So usually you put that in

00:24:21.135 --> 00:24:23.774
<v Speaker 1>a try and then finally block where even

00:24:23.774 --> 00:24:25.855
<v Speaker 1>if there is an exception, you store all

00:24:25.855 --> 00:24:27.214
<v Speaker 1>of the recorded events.

00:24:27.455 --> 00:24:28.815
<v Speaker 1>And all of the sudden,

00:24:29.054 --> 00:24:32.174
<v Speaker 1>have insights into all of your unhappy parts.

00:24:32.390 --> 00:24:34.630
<v Speaker 1>Right? So you can capture the context of

00:24:34.630 --> 00:24:35.590
<v Speaker 1>the failure

00:24:35.830 --> 00:24:38.710
<v Speaker 1>and that's really like where you see the

00:24:38.710 --> 00:24:41.510
<v Speaker 1>users have friction with your product or with

00:24:41.510 --> 00:24:44.230
<v Speaker 1>your business process or anything in relation to

00:24:44.230 --> 00:24:47.905
<v Speaker 1>that. Nice. Great example. Alright. Let's tackle the

00:24:47.905 --> 00:24:50.465
<v Speaker 0>the next one then. So CQRS.

00:24:50.865 --> 00:24:52.865
<v Speaker 1>Yeah. So CQRS

00:24:52.865 --> 00:24:55.745
<v Speaker 1>like I'm I'm bigger on event sourcing than

00:24:55.745 --> 00:24:57.345
<v Speaker 1>I am on CQRS.

00:24:57.345 --> 00:25:00.305
<v Speaker 1>So CQRS I often see or when it's

00:25:00.305 --> 00:25:03.665
<v Speaker 1>talked about in the community, it's talked about

00:25:02.580 --> 00:25:04.899
<v Speaker 1>applying it in a very dogmatic way. And

00:25:04.899 --> 00:25:06.979
<v Speaker 1>so you're you have to separate

00:25:07.380 --> 00:25:08.580
<v Speaker 1>everything

00:25:08.580 --> 00:25:12.179
<v Speaker 1>that's an instruction to the system so that

00:25:12.260 --> 00:25:14.259
<v Speaker 1>that tells the system to do something.

00:25:14.500 --> 00:25:16.019
<v Speaker 1>And the other part is really how to

00:25:16.019 --> 00:25:19.524
<v Speaker 1>get information out. The reason they they want

00:25:19.524 --> 00:25:21.364
<v Speaker 1>that is to allow

00:25:21.365 --> 00:25:24.884
<v Speaker 1>for different models on how you query that

00:25:24.884 --> 00:25:27.764
<v Speaker 1>data which are optimized for querying and the

00:25:27.764 --> 00:25:30.565
<v Speaker 1>decision model is not necessarily

00:25:30.965 --> 00:25:31.684
<v Speaker 1>the best

00:25:32.419 --> 00:25:35.700
<v Speaker 1>model to also query it. So for example,

00:25:36.020 --> 00:25:39.059
<v Speaker 1>if you have an order based system and

00:25:39.059 --> 00:25:41.940
<v Speaker 1>you want to aggregate how many orders there

00:25:41.940 --> 00:25:43.700
<v Speaker 1>were today and what their cumulative

00:25:43.700 --> 00:25:45.945
<v Speaker 1>amount was, right, you can do a sort

00:25:45.945 --> 00:25:49.145
<v Speaker 1>of SQL aggregation over that. But it might

00:25:49.145 --> 00:25:50.985
<v Speaker 1>not be very efficient if you have a

00:25:50.985 --> 00:25:54.265
<v Speaker 1>large amount of customers. Right? So using events

00:25:54.265 --> 00:25:57.544
<v Speaker 1>to then say like, hey, I'm gonna record

00:25:57.544 --> 00:25:59.304
<v Speaker 1>all of the events of the purchases and

00:25:59.304 --> 00:26:01.304
<v Speaker 1>then I've got a secondary model, which is

00:26:01.519 --> 00:26:03.759
<v Speaker 1>the accumulation of all of the amounts that

00:26:03.759 --> 00:26:06.320
<v Speaker 1>were stored for a day. You have a

00:26:06.320 --> 00:26:08.399
<v Speaker 1>a sort of a live view of what

00:26:08.399 --> 00:26:11.120
<v Speaker 1>that means across the day and querying it

00:26:11.120 --> 00:26:14.159
<v Speaker 1>is just basically querying a column within a

00:26:14.159 --> 00:26:15.679
<v Speaker 1>database. Right? Very efficient.

00:26:16.184 --> 00:26:19.865
<v Speaker 1>And so there's definitely value in separating

00:26:19.865 --> 00:26:21.224
<v Speaker 1>out these models,

00:26:21.865 --> 00:26:25.304
<v Speaker 1>but always doing that. Right? I think lacks

00:26:25.304 --> 00:26:27.384
<v Speaker 1>a bit of nuance in that sense. Right?

00:26:28.510 --> 00:26:30.750
<v Speaker 1>For many of the the problems that you

00:26:30.750 --> 00:26:32.109
<v Speaker 1>have, the original

00:26:32.110 --> 00:26:34.190
<v Speaker 1>decision model has enough

00:26:34.830 --> 00:26:37.390
<v Speaker 1>data points that you can use for reads.

00:26:37.390 --> 00:26:40.429
<v Speaker 1>And also always doing it, how do you

00:26:40.429 --> 00:26:42.665
<v Speaker 1>say this? A lot of people applying

00:26:42.665 --> 00:26:43.785
<v Speaker 1>CQRS

00:26:43.865 --> 00:26:45.545
<v Speaker 1>also say like, hey, then you put it

00:26:45.545 --> 00:26:46.825
<v Speaker 1>on a message bus.

00:26:46.905 --> 00:26:48.665
<v Speaker 1>And so that means that the state that

00:26:48.665 --> 00:26:50.505
<v Speaker 1>you want to query maybe in the same

00:26:50.505 --> 00:26:52.905
<v Speaker 1>request is already eventual consistent.

00:26:53.350 --> 00:26:54.870
<v Speaker 1>Right? So then you need to deal with

00:26:54.870 --> 00:26:55.989
<v Speaker 1>that fact again.

00:26:56.549 --> 00:26:59.590
<v Speaker 1>Well, people create all kinds of ways to

00:26:59.590 --> 00:27:01.990
<v Speaker 1>to work around that problem. So one is

00:27:01.990 --> 00:27:03.909
<v Speaker 1>like your aggregate

00:27:03.990 --> 00:27:05.269
<v Speaker 1>has versioning

00:27:05.269 --> 00:27:07.429
<v Speaker 1>and now your projections have versions as well.

00:27:07.774 --> 00:27:10.335
<v Speaker 1>You're just gonna pull the the read model

00:27:10.335 --> 00:27:12.014
<v Speaker 1>until you get the right version if you

00:27:12.014 --> 00:27:14.255
<v Speaker 1>want to get the response for that that

00:27:14.255 --> 00:27:15.134
<v Speaker 1>version.

00:27:15.375 --> 00:27:18.335
<v Speaker 1>Right? That's a possibility, but it's also very

00:27:18.335 --> 00:27:21.054
<v Speaker 1>cumbersome. Right? So you get some dogmatic things

00:27:21.054 --> 00:27:24.089
<v Speaker 1>like command buses shouldn't return any,

00:27:24.490 --> 00:27:26.809
<v Speaker 1>values and all that shenanigan.

00:27:26.970 --> 00:27:29.529
<v Speaker 1>Like those shenanigans, I think it's too dogmatic.

00:27:29.529 --> 00:27:32.490
<v Speaker 1>So I think as a pattern, like being

00:27:32.490 --> 00:27:36.215
<v Speaker 1>able to separate those things, fine. Always doing

00:27:36.215 --> 00:27:38.615
<v Speaker 1>that, I don't really see the value in

00:27:38.615 --> 00:27:40.615
<v Speaker 1>that. Okay. Let's touch on one more thing

00:27:40.615 --> 00:27:42.135
<v Speaker 0>and then we'll move on with the questions.

00:27:42.135 --> 00:27:44.934
<v Speaker 0>But you've covered event sourcing. Great. CQRS.

00:27:44.935 --> 00:27:47.175
<v Speaker 0>Perfect. So if we have all of these

00:27:47.175 --> 00:27:48.775
<v Speaker 0>events, we have to build projections.

00:27:49.620 --> 00:27:51.220
<v Speaker 0>We have message buses.

00:27:51.300 --> 00:27:53.140
<v Speaker 0>A lot of what we're seeing here, right,

00:27:53.140 --> 00:27:55.220
<v Speaker 0>kinda maps to what I'm seeing in a

00:27:55.220 --> 00:27:58.020
<v Speaker 0>different ecosystem, which is cloud native Kubernetes.

00:27:58.100 --> 00:28:00.500
<v Speaker 0>Right? We're seeing micro service adoption,

00:28:00.900 --> 00:28:03.540
<v Speaker 0>which is being built on event

00:28:03.195 --> 00:28:05.594
<v Speaker 0>architectures where people are preferring

00:28:05.995 --> 00:28:06.714
<v Speaker 0>to do

00:28:07.034 --> 00:28:10.634
<v Speaker 0>publish events to Nats or Kafka, RabbitMQ, etcetera.

00:28:10.634 --> 00:28:12.875
<v Speaker 0>And all of these service are independent.

00:28:12.875 --> 00:28:15.195
<v Speaker 0>Right? The goal is to be loosely coupled.

00:28:15.195 --> 00:28:17.650
<v Speaker 0>And it feels like there's actually a lot

00:28:17.650 --> 00:28:18.690
<v Speaker 0>of crossover

00:28:18.770 --> 00:28:21.090
<v Speaker 0>and benefits to both of these architectures maybe

00:28:21.090 --> 00:28:22.450
<v Speaker 0>working together.

00:28:23.010 --> 00:28:24.930
<v Speaker 0>But I'm curious if this is something that

00:28:24.930 --> 00:28:26.690
<v Speaker 0>you've seen a lot of from the event

00:28:26.690 --> 00:28:28.050
<v Speaker 0>sourcing ecosystem.

00:28:28.050 --> 00:28:29.570
<v Speaker 0>Are people doing microservices?

00:28:29.570 --> 00:28:31.555
<v Speaker 0>Are projections of microservice? Like, how do these

00:28:31.555 --> 00:28:34.674
<v Speaker 0>two different tangential things work together or correlate?

00:28:34.675 --> 00:28:36.835
<v Speaker 1>Yeah. And so I think they're just the

00:28:36.835 --> 00:28:38.995
<v Speaker 1>same thing at the different scale. Right? So

00:28:38.995 --> 00:28:41.955
<v Speaker 1>if you've got a monolithic application

00:28:42.195 --> 00:28:44.675
<v Speaker 1>that is recording messages that the that it's

00:28:44.675 --> 00:28:47.600
<v Speaker 1>consuming itself in order to record state as

00:28:47.600 --> 00:28:48.480
<v Speaker 1>a projection

00:28:48.560 --> 00:28:50.560
<v Speaker 1>that it's surfing on a different rest end

00:28:50.560 --> 00:28:53.200
<v Speaker 1>point. That's for me the same as two

00:28:53.200 --> 00:28:55.600
<v Speaker 1>services which are which there is a dependency

00:28:55.600 --> 00:28:57.760
<v Speaker 1>between which where you have a source system

00:28:57.760 --> 00:29:00.575
<v Speaker 1>for information and a dependent system and it's

00:29:00.575 --> 00:29:03.215
<v Speaker 1>using messages to be kept up to date.

00:29:03.215 --> 00:29:05.615
<v Speaker 1>Right? So in essence, it's the same thing

00:29:05.615 --> 00:29:08.015
<v Speaker 1>but then scaled up and maybe with a

00:29:08.015 --> 00:29:10.255
<v Speaker 1>higher infrastructural cost associated

00:29:10.255 --> 00:29:12.655
<v Speaker 1>with it. But in principle, it's it's just

00:29:12.655 --> 00:29:15.535
<v Speaker 1>the same. The thing where where deviates

00:29:15.535 --> 00:29:16.095
<v Speaker 1>is

00:29:16.470 --> 00:29:17.350
<v Speaker 1>in the

00:29:18.470 --> 00:29:20.630
<v Speaker 1>coupling and knowledge area.

00:29:20.630 --> 00:29:22.629
<v Speaker 1>So if you have two different services,

00:29:22.790 --> 00:29:25.590
<v Speaker 1>you know that the services have a different

00:29:25.590 --> 00:29:29.429
<v Speaker 1>level of detail regarding a particular subject.

00:29:29.975 --> 00:29:32.375
<v Speaker 1>So if you're in a monolithic situation

00:29:32.375 --> 00:29:35.175
<v Speaker 1>where you're the consumer of events, you tend

00:29:35.175 --> 00:29:37.175
<v Speaker 1>to have a a high level of detail

00:29:37.175 --> 00:29:39.095
<v Speaker 1>and a high level of volatility of the

00:29:39.095 --> 00:29:40.695
<v Speaker 1>information that you're consuming.

00:29:41.015 --> 00:29:44.135
<v Speaker 1>So if you're modeling your business processes with

00:29:44.135 --> 00:29:47.710
<v Speaker 1>events, then innovating on that business model means

00:29:47.710 --> 00:29:48.990
<v Speaker 1>changing events.

00:29:49.310 --> 00:29:51.790
<v Speaker 1>If you're doing that for yourself, you're exposed

00:29:51.790 --> 00:29:54.270
<v Speaker 1>to your own volatility. Right? So that means

00:29:54.270 --> 00:29:56.670
<v Speaker 1>that you need to if there is a

00:29:56.670 --> 00:29:58.590
<v Speaker 1>new version of something, you need to account

00:29:58.590 --> 00:30:00.825
<v Speaker 1>for the backwards compatibility at least for the

00:30:00.825 --> 00:30:03.784
<v Speaker 1>periods where you're exposed to those changing events.

00:30:04.265 --> 00:30:07.225
<v Speaker 1>Now if you amplify this to the microservice

00:30:07.225 --> 00:30:08.984
<v Speaker 1>world, this volatility

00:30:09.145 --> 00:30:10.504
<v Speaker 1>means usually

00:30:10.745 --> 00:30:13.784
<v Speaker 1>that you're gonna be disrupting other services unless

00:30:13.784 --> 00:30:16.500
<v Speaker 1>they accommodate for this change as well. And

00:30:16.500 --> 00:30:19.460
<v Speaker 1>especially in larger organizations where those

00:30:19.700 --> 00:30:20.500
<v Speaker 1>services

00:30:20.660 --> 00:30:22.900
<v Speaker 1>are not maintained by the same people, this

00:30:22.900 --> 00:30:25.300
<v Speaker 1>is where you get up into Shit Creek

00:30:25.300 --> 00:30:28.180
<v Speaker 1>area. Right? So if you're changing the event

00:30:28.180 --> 00:30:30.020
<v Speaker 1>stream that somebody else is consuming

00:30:30.365 --> 00:30:33.005
<v Speaker 1>and you're not informing them and allowing them

00:30:33.005 --> 00:30:34.365
<v Speaker 1>to accommodate this

00:30:34.765 --> 00:30:37.325
<v Speaker 1>in in some way, shape, or form, you're

00:30:37.325 --> 00:30:39.565
<v Speaker 1>gonna cause a disruption in production.

00:30:39.805 --> 00:30:42.285
<v Speaker 1>And so that's more difficult. Now luckily, there

00:30:42.285 --> 00:30:43.645
<v Speaker 1>are patterns to deal with it.

00:30:44.210 --> 00:30:47.090
<v Speaker 1>But this usually like you asked before like,

00:30:47.090 --> 00:30:50.610
<v Speaker 1>hey, what's the cost of introducing event driven

00:30:50.610 --> 00:30:52.929
<v Speaker 1>stuff into into projects?

00:30:53.010 --> 00:30:55.330
<v Speaker 1>It's learning this and learning the ways to

00:30:55.330 --> 00:30:56.770
<v Speaker 1>deal with it. So

00:30:57.170 --> 00:30:59.410
<v Speaker 1>in event driven architectures,

00:30:59.775 --> 00:31:02.895
<v Speaker 1>usually say like, hey, just expose everything.

00:31:02.895 --> 00:31:04.735
<v Speaker 1>Right? So as a first

00:31:04.895 --> 00:31:05.775
<v Speaker 1>iteration,

00:31:06.015 --> 00:31:08.095
<v Speaker 1>I've got all my internal domain events.

00:31:08.335 --> 00:31:10.735
<v Speaker 1>Well, now they're all external domain events and

00:31:10.735 --> 00:31:12.175
<v Speaker 1>everybody can listen to everything.

00:31:12.690 --> 00:31:15.409
<v Speaker 1>Now I want to change something. I've done

00:31:15.409 --> 00:31:17.489
<v Speaker 1>the whole integration part before.

00:31:17.809 --> 00:31:19.729
<v Speaker 1>Now I want to change anything.

00:31:19.730 --> 00:31:21.409
<v Speaker 1>Now I need to change all of my

00:31:21.409 --> 00:31:22.210
<v Speaker 1>integrations.

00:31:22.210 --> 00:31:25.730
<v Speaker 1>Right? And so while event driven architecture is

00:31:25.730 --> 00:31:28.774
<v Speaker 1>usually attributed that is great for decoupling,

00:31:28.935 --> 00:31:31.575
<v Speaker 1>unless you do that on the information level,

00:31:31.655 --> 00:31:34.535
<v Speaker 1>you're still just very highly coupled from business

00:31:34.535 --> 00:31:37.015
<v Speaker 1>process to business process and you still need

00:31:37.015 --> 00:31:40.135
<v Speaker 1>to do sort of diligent information disclosure and

00:31:40.135 --> 00:31:42.135
<v Speaker 1>deliberate information disclosure

00:31:42.289 --> 00:31:45.570
<v Speaker 1>in order to prevent that. Right? So within

00:31:45.570 --> 00:31:47.090
<v Speaker 1>object oriented stuff,

00:31:47.330 --> 00:31:49.970
<v Speaker 1>we say, well, we've got an interface and

00:31:49.970 --> 00:31:52.690
<v Speaker 1>then you can touch these public things, but

00:31:52.690 --> 00:31:55.424
<v Speaker 1>you cannot touch these private things. Right? Within

00:31:55.424 --> 00:31:57.105
<v Speaker 1>events or different architectures,

00:31:57.105 --> 00:31:59.265
<v Speaker 1>especially if your implementations

00:31:59.265 --> 00:32:00.144
<v Speaker 1>mature,

00:32:00.304 --> 00:32:02.225
<v Speaker 1>you see the same effects. Right? You've got

00:32:02.225 --> 00:32:03.105
<v Speaker 1>internal

00:32:03.105 --> 00:32:04.384
<v Speaker 1>information streams,

00:32:04.465 --> 00:32:05.745
<v Speaker 1>you've got external

00:32:05.745 --> 00:32:09.105
<v Speaker 1>information streams, and you you act differently

00:32:09.870 --> 00:32:12.430
<v Speaker 1>With object oriented, you say like, hey, I'm

00:32:12.430 --> 00:32:14.750
<v Speaker 1>maintaining sort of a backwards compatibility

00:32:14.750 --> 00:32:16.830
<v Speaker 1>for a large degree and sometimes

00:32:16.910 --> 00:32:17.950
<v Speaker 1>I'm creating

00:32:18.190 --> 00:32:20.669
<v Speaker 1>APIs with a new version. Right?

00:32:21.070 --> 00:32:23.790
<v Speaker 1>That same applies to event driven architectures.

00:32:23.790 --> 00:32:26.350
<v Speaker 1>But there then you're

00:32:25.684 --> 00:32:28.645
<v Speaker 1>accommodating that by versioning the payloads that you

00:32:28.645 --> 00:32:32.085
<v Speaker 1>send and then putting anti corruption layers in

00:32:32.085 --> 00:32:34.485
<v Speaker 1>place, which are either on the producing end

00:32:34.485 --> 00:32:36.965
<v Speaker 1>or on the consuming end that smooth over

00:32:36.965 --> 00:32:40.300
<v Speaker 1>the differences between these versions. So that means,

00:32:40.300 --> 00:32:42.940
<v Speaker 1>so for example, if you are producing

00:32:42.940 --> 00:32:45.100
<v Speaker 1>a new version of your event

00:32:45.100 --> 00:32:46.140
<v Speaker 1>which has

00:32:46.780 --> 00:32:49.980
<v Speaker 1>more fields or fields that are just formatted

00:32:49.980 --> 00:32:51.020
<v Speaker 1>a little bit different,

00:32:51.434 --> 00:32:54.474
<v Speaker 1>something that's really backwards incompatible,

00:32:54.715 --> 00:32:57.274
<v Speaker 1>then what you can do is have sort

00:32:57.274 --> 00:33:00.075
<v Speaker 1>of a mechanism on the producing end that

00:33:00.075 --> 00:33:03.434
<v Speaker 1>says like, hey, I'm gonna consume this stream

00:33:03.660 --> 00:33:06.060
<v Speaker 1>and I'm gonna convert it to the older

00:33:06.060 --> 00:33:08.380
<v Speaker 1>version and publish that as well.

00:33:08.700 --> 00:33:12.220
<v Speaker 1>And so a mechanism like that gives other

00:33:12.220 --> 00:33:13.660
<v Speaker 1>parties a

00:33:14.140 --> 00:33:17.665
<v Speaker 1>lenience period where they can still rely on

00:33:17.665 --> 00:33:21.265
<v Speaker 1>the old information stream, but then also have

00:33:21.265 --> 00:33:22.705
<v Speaker 1>at their disposal

00:33:22.705 --> 00:33:24.225
<v Speaker 1>an opt event

00:33:24.225 --> 00:33:27.345
<v Speaker 1>stream, which they can consume in parallel

00:33:27.505 --> 00:33:29.105
<v Speaker 1>and then try it out for a bit

00:33:29.105 --> 00:33:31.105
<v Speaker 1>and then convert all of their integrations

00:33:31.450 --> 00:33:33.450
<v Speaker 1>without needing to do it as as a

00:33:33.450 --> 00:33:35.930
<v Speaker 1>hard cut. Can I just confirm something there?

00:33:35.930 --> 00:33:37.770
<v Speaker 0>Because that was really really interesting to me

00:33:37.770 --> 00:33:40.330
<v Speaker 0>personally. Right? Because versioning is hard.

00:33:40.810 --> 00:33:42.330
<v Speaker 0>And when we talk about challenges of this,

00:33:42.330 --> 00:33:43.450
<v Speaker 0>I'm sure versioning is gonna be one of

00:33:43.450 --> 00:33:45.450
<v Speaker 0>the biggest ones. So maybe we'll come back

00:33:45.450 --> 00:33:46.250
<v Speaker 0>to it. But

00:33:46.650 --> 00:33:48.315
<v Speaker 0>I never really thought of it publishing or

00:33:48.315 --> 00:33:50.395
<v Speaker 0>having a producer who already has all the

00:33:50.395 --> 00:33:52.075
<v Speaker 0>knowledge of the versions. Right? Because it's their

00:33:52.075 --> 00:33:52.794
<v Speaker 0>domain.

00:33:53.115 --> 00:33:55.115
<v Speaker 0>Do you publish them as separate events with

00:33:55.115 --> 00:33:56.795
<v Speaker 0>the different versions or do you, like, wrap

00:33:56.795 --> 00:33:58.155
<v Speaker 0>them in an envelope and publish them as

00:33:58.155 --> 00:34:00.155
<v Speaker 0>one event with multiple versions as a payload?

00:34:00.500 --> 00:34:02.420
<v Speaker 0>Like, how how does that work in practice?

00:34:02.500 --> 00:34:05.860
<v Speaker 1>In practice, it's so if you need to

00:34:05.940 --> 00:34:08.179
<v Speaker 1>couple them in the same message,

00:34:08.420 --> 00:34:10.739
<v Speaker 1>they needed to be produced atomically.

00:34:10.900 --> 00:34:12.820
<v Speaker 1>Right? So thinking of this a little bit

00:34:12.820 --> 00:34:15.255
<v Speaker 1>longer, I think you you can do it

00:34:15.255 --> 00:34:19.094
<v Speaker 1>like that even if the producer doesn't produce

00:34:19.094 --> 00:34:20.695
<v Speaker 1>them both versions.

00:34:21.014 --> 00:34:23.175
<v Speaker 1>But what would the benefit be? Well, I

00:34:23.175 --> 00:34:25.974
<v Speaker 0>was thinking if the producer emits version three

00:34:25.974 --> 00:34:27.815
<v Speaker 0>of an event Yeah. Has a function to

00:34:27.815 --> 00:34:29.415
<v Speaker 0>downcast it to v one and v two,

00:34:29.780 --> 00:34:31.860
<v Speaker 0>wraps them in an envelope and publishes it,

00:34:32.099 --> 00:34:33.940
<v Speaker 0>then the consumers can kinda cherry pick out

00:34:33.940 --> 00:34:35.300
<v Speaker 0>the version that they understand

00:34:35.460 --> 00:34:37.380
<v Speaker 0>the most or the latest version that they

00:34:37.380 --> 00:34:39.460
<v Speaker 0>Yeah. React to and and handle it. But

00:34:39.460 --> 00:34:41.540
<v Speaker 0>then, I guess, you you she also went

00:34:41.540 --> 00:34:43.699
<v Speaker 0>downstream to be working through the latest version

00:34:43.699 --> 00:34:47.085
<v Speaker 0>too. Yeah. Yeah. Tough problem. So that is

00:34:47.085 --> 00:34:47.965
<v Speaker 1>possible.

00:34:47.965 --> 00:34:50.045
<v Speaker 1>You would be publishing

00:34:50.045 --> 00:34:51.565
<v Speaker 1>multiple versions

00:34:51.885 --> 00:34:53.565
<v Speaker 1>of the same event inside

00:34:53.565 --> 00:34:56.205
<v Speaker 1>of the same event stream. Right? So what

00:34:56.205 --> 00:34:58.765
<v Speaker 1>you sometimes have is that upgrading

00:34:58.765 --> 00:35:01.890
<v Speaker 1>event versions or entire streams, they're used as

00:35:01.890 --> 00:35:04.530
<v Speaker 1>an opportunity also to reprovision

00:35:04.530 --> 00:35:06.130
<v Speaker 1>all of the infrastructure

00:35:06.130 --> 00:35:08.690
<v Speaker 1>that's behind it. So if you need more

00:35:08.690 --> 00:35:11.170
<v Speaker 1>topics on your Kafka stream, right, having a

00:35:11.170 --> 00:35:12.050
<v Speaker 1>new stream

00:35:12.365 --> 00:35:14.125
<v Speaker 1>is sort of an opportunity to say like,

00:35:14.125 --> 00:35:15.964
<v Speaker 1>hey, I'm gonna over provision a little bit

00:35:15.964 --> 00:35:18.125
<v Speaker 1>again. So I've got some breathing room for

00:35:18.125 --> 00:35:19.085
<v Speaker 1>my concurrency,

00:35:19.325 --> 00:35:20.525
<v Speaker 1>for my consumers.

00:35:20.605 --> 00:35:22.444
<v Speaker 1>So usually you want to have that as

00:35:22.444 --> 00:35:23.325
<v Speaker 1>a possibility.

00:35:23.805 --> 00:35:26.444
<v Speaker 1>And now a consumer will rarely

00:35:26.444 --> 00:35:29.620
<v Speaker 1>in one business process consume multiple

00:35:29.700 --> 00:35:32.180
<v Speaker 1>versions of the same events. Right? So usually

00:35:32.180 --> 00:35:32.820
<v Speaker 1>what

00:35:32.980 --> 00:35:34.580
<v Speaker 1>you do as a consumer is you're gonna

00:35:34.580 --> 00:35:37.620
<v Speaker 1>put side by side multiple consumers that do

00:35:37.700 --> 00:35:39.780
<v Speaker 1>version a and version b side by side

00:35:39.780 --> 00:35:42.175
<v Speaker 1>and then you can sort of compute. Like

00:35:42.175 --> 00:35:44.655
<v Speaker 1>if you want to do a parallel run

00:35:44.734 --> 00:35:48.655
<v Speaker 1>and you can check for for differences afterwards.

00:35:48.895 --> 00:35:51.375
<v Speaker 1>So they just have one thing. So you

00:35:51.375 --> 00:35:53.535
<v Speaker 1>you can you can certainly do it. I've

00:35:53.535 --> 00:35:55.710
<v Speaker 1>never seen it being done like that. So

00:35:55.710 --> 00:35:57.869
<v Speaker 1>usually what you what you see and what

00:35:57.869 --> 00:36:00.190
<v Speaker 1>I think is idiomatic in that space is

00:36:00.190 --> 00:36:03.390
<v Speaker 1>that you have either on the same stream,

00:36:03.869 --> 00:36:05.630
<v Speaker 1>you have that payloads

00:36:05.630 --> 00:36:07.070
<v Speaker 1>of multiple

00:36:07.070 --> 00:36:08.750
<v Speaker 1>versions. So you have a type and a

00:36:08.750 --> 00:36:11.285
<v Speaker 1>version of the type and it's published over

00:36:11.285 --> 00:36:12.325
<v Speaker 1>the same stream.

00:36:12.644 --> 00:36:15.444
<v Speaker 1>Or if the entire stream is being upgraded

00:36:15.444 --> 00:36:18.085
<v Speaker 1>from one version to another, which is usually

00:36:18.325 --> 00:36:21.045
<v Speaker 1>the case if the structure of the data

00:36:21.045 --> 00:36:23.990
<v Speaker 1>or the payloads are fundamentally changing.

00:36:23.990 --> 00:36:26.710
<v Speaker 1>So either there's something changing in the envelope,

00:36:26.869 --> 00:36:29.350
<v Speaker 1>that's usually a case where everything got bumps

00:36:29.350 --> 00:36:30.390
<v Speaker 1>up one version.

00:36:30.550 --> 00:36:33.510
<v Speaker 1>Then you see more often that an entire

00:36:33.510 --> 00:36:36.070
<v Speaker 1>new stream of events is being introduced for

00:36:36.070 --> 00:36:37.430
<v Speaker 1>those games. Nice.

00:36:38.575 --> 00:36:40.575
<v Speaker 0>Well, it feels only fitting that we're talking

00:36:40.575 --> 00:36:42.415
<v Speaker 0>about some of the hard stuff then with

00:36:42.415 --> 00:36:44.815
<v Speaker 0>event sourcing that we maybe see. Are there

00:36:44.815 --> 00:36:48.255
<v Speaker 0>any other challenges that you've faced adopting event

00:36:48.255 --> 00:36:50.255
<v Speaker 0>sourcing as capital and other places that you

00:36:50.255 --> 00:36:52.530
<v Speaker 0>wanna share with people like, you know, assuming

00:36:52.530 --> 00:36:55.090
<v Speaker 0>some masochist listening to this podcast is when,

00:36:55.090 --> 00:36:56.770
<v Speaker 0>you know what? This sounds really cool.

00:36:57.010 --> 00:36:59.250
<v Speaker 0>Hard, but really, really cool. Like, what else

00:36:59.250 --> 00:37:00.610
<v Speaker 0>should they be looking at for? What else

00:37:00.610 --> 00:37:01.970
<v Speaker 0>have you worked through?

00:37:02.290 --> 00:37:04.770
<v Speaker 1>Yeah. So one of the areas where it's

00:37:04.770 --> 00:37:07.250
<v Speaker 1>both a virtue and a and a curse

00:37:07.155 --> 00:37:08.995
<v Speaker 1>to have event driven architectures

00:37:08.995 --> 00:37:09.795
<v Speaker 1>in place

00:37:10.115 --> 00:37:11.955
<v Speaker 1>is disaster recovery.

00:37:11.955 --> 00:37:14.995
<v Speaker 1>So as soon as sort of metaphorical ship

00:37:14.995 --> 00:37:18.195
<v Speaker 1>hits the fan and maybe you have catastrophic

00:37:18.195 --> 00:37:19.075
<v Speaker 1>infrastructure

00:37:19.075 --> 00:37:21.395
<v Speaker 1>failure and the consuming system

00:37:21.840 --> 00:37:23.680
<v Speaker 1>loses all of their state, they need to

00:37:23.680 --> 00:37:26.720
<v Speaker 1>rebuild that state from somewhere. So in more

00:37:26.720 --> 00:37:28.560
<v Speaker 1>state based systems,

00:37:28.560 --> 00:37:30.640
<v Speaker 1>you either work off of maybe a database

00:37:30.640 --> 00:37:33.600
<v Speaker 1>replica or something else. You sort of like

00:37:33.600 --> 00:37:37.985
<v Speaker 1>ingest or restart that whole replication process

00:37:38.065 --> 00:37:41.825
<v Speaker 1>with database native technologies. You're in in place

00:37:41.825 --> 00:37:42.625
<v Speaker 1>relatively

00:37:42.625 --> 00:37:43.905
<v Speaker 1>relatively quick.

00:37:44.305 --> 00:37:46.145
<v Speaker 1>For event driven architectures,

00:37:46.145 --> 00:37:47.825
<v Speaker 1>it can be more cumbersome and you need

00:37:47.825 --> 00:37:50.240
<v Speaker 1>to design for it. So for example, if

00:37:50.240 --> 00:37:52.320
<v Speaker 1>you need to if you've got a projection

00:37:52.560 --> 00:37:54.480
<v Speaker 1>and you need to recreate all of your

00:37:54.480 --> 00:37:57.280
<v Speaker 1>current state based on everything that's been recorded

00:37:57.280 --> 00:37:58.000
<v Speaker 1>before,

00:37:58.080 --> 00:38:00.400
<v Speaker 1>the question is always like, how far back

00:38:00.400 --> 00:38:01.920
<v Speaker 1>do you need to go in order to

00:38:01.920 --> 00:38:03.680
<v Speaker 1>figure out what to reconstitute from?

00:38:04.105 --> 00:38:05.945
<v Speaker 1>Are you gonna do that from the epoch

00:38:05.945 --> 00:38:07.945
<v Speaker 1>of your business, right, from day one of

00:38:07.945 --> 00:38:10.345
<v Speaker 1>your business? Or are you gonna have some

00:38:10.345 --> 00:38:13.305
<v Speaker 1>intermittent states where you're gonna say, like, alright,

00:38:13.385 --> 00:38:15.385
<v Speaker 1>I've got a snapshot of the of the

00:38:15.385 --> 00:38:16.960
<v Speaker 1>state that it was at, and now I'm

00:38:16.960 --> 00:38:18.400
<v Speaker 1>gonna reconstitute

00:38:18.400 --> 00:38:20.960
<v Speaker 1>from from that point and out and reconsume.

00:38:21.120 --> 00:38:24.240
<v Speaker 1>Now that is not something that is very

00:38:24.240 --> 00:38:26.880
<v Speaker 1>trivial to design for. And you need to

00:38:26.880 --> 00:38:30.255
<v Speaker 1>apply a couple of sort of supporting practices

00:38:30.255 --> 00:38:31.455
<v Speaker 1>which help you,

00:38:31.855 --> 00:38:34.335
<v Speaker 1>to do that. I think Kafka as a

00:38:34.335 --> 00:38:35.135
<v Speaker 1>technology

00:38:35.535 --> 00:38:38.095
<v Speaker 1>makes it easier to do some of those

00:38:38.095 --> 00:38:41.455
<v Speaker 1>things mostly because they have a incremental offset

00:38:41.455 --> 00:38:44.520
<v Speaker 1>based storage strategy where you know where you

00:38:44.520 --> 00:38:46.280
<v Speaker 1>left off and if you have a snapshot

00:38:46.280 --> 00:38:48.520
<v Speaker 1>that's at a particular Kafka

00:38:48.520 --> 00:38:49.400
<v Speaker 1>partition

00:38:49.640 --> 00:38:50.680
<v Speaker 1>combination,

00:38:50.920 --> 00:38:53.000
<v Speaker 1>you can take that state and know, alright,

00:38:53.000 --> 00:38:55.320
<v Speaker 1>I'm I was exactly there and I can

00:38:55.320 --> 00:38:57.560
<v Speaker 1>go on and reconsume

00:38:57.965 --> 00:39:00.525
<v Speaker 1>the rest. If you don't have such a

00:39:00.525 --> 00:39:02.285
<v Speaker 1>system and you have got your own sort

00:39:02.285 --> 00:39:05.405
<v Speaker 1>of like delivery mechanism, if you're going through

00:39:05.485 --> 00:39:06.365
<v Speaker 1>RabbitMQ

00:39:06.365 --> 00:39:08.765
<v Speaker 1>or any type of other like sort of

00:39:08.765 --> 00:39:10.125
<v Speaker 1>transient message

00:39:10.125 --> 00:39:11.245
<v Speaker 1>queue implementation,

00:39:11.690 --> 00:39:14.170
<v Speaker 1>Right? You need a way to inform the

00:39:14.170 --> 00:39:17.450
<v Speaker 1>producer of those events to re flush whatever

00:39:17.450 --> 00:39:19.770
<v Speaker 1>they had. So reconstitution

00:39:19.770 --> 00:39:20.490
<v Speaker 1>of

00:39:20.650 --> 00:39:21.290
<v Speaker 1>these

00:39:21.530 --> 00:39:23.930
<v Speaker 1>read models becomes a lot more involved.

00:39:24.525 --> 00:39:28.045
<v Speaker 1>So it's it's not all cherries and rainbows

00:39:28.525 --> 00:39:30.605
<v Speaker 1>in that sense. One of the things that

00:39:30.605 --> 00:39:34.765
<v Speaker 1>you can actually do is use your partitioning

00:39:34.845 --> 00:39:35.725
<v Speaker 1>strategy

00:39:35.964 --> 00:39:39.645
<v Speaker 1>and your log compaction strategy on Kafka

00:39:39.860 --> 00:39:42.340
<v Speaker 1>to always ensure that all of the leave

00:39:42.340 --> 00:39:43.060
<v Speaker 1>notes,

00:39:43.540 --> 00:39:46.100
<v Speaker 1>retain the latest bit of information. And if

00:39:46.100 --> 00:39:49.140
<v Speaker 1>that fits your domain model, then you can

00:39:49.140 --> 00:39:51.300
<v Speaker 1>use that as a way to quickly get

00:39:51.300 --> 00:39:54.335
<v Speaker 1>to the latest state of everything. Because effectively

00:39:54.335 --> 00:39:56.255
<v Speaker 1>on all of those partitions,

00:39:56.415 --> 00:39:59.375
<v Speaker 1>you guarantee with like every key,

00:39:59.535 --> 00:40:02.015
<v Speaker 1>the last message of that key contains

00:40:02.255 --> 00:40:04.895
<v Speaker 1>the last state that I'm interested in in

00:40:04.895 --> 00:40:06.734
<v Speaker 1>order to get to the to the current

00:40:06.734 --> 00:40:09.280
<v Speaker 1>state. But that's very much like in the

00:40:09.280 --> 00:40:12.720
<v Speaker 1>details of of your implementation already. So there

00:40:12.720 --> 00:40:14.720
<v Speaker 1>are opportunities there, but you really need to

00:40:14.720 --> 00:40:17.760
<v Speaker 1>understand whether those solutions really match the problem

00:40:17.760 --> 00:40:19.920
<v Speaker 1>space where you're applying it. And that's not

00:40:19.920 --> 00:40:21.359
<v Speaker 1>always the case. Awesome.

00:40:22.125 --> 00:40:24.045
<v Speaker 0>Alright. I'm not sure how many people still

00:40:24.045 --> 00:40:26.685
<v Speaker 0>wanna build events or systems after hearing that,

00:40:26.685 --> 00:40:27.165
<v Speaker 0>but

00:40:28.205 --> 00:40:30.685
<v Speaker 0>it definitely is. It's fun. At least you're

00:40:30.765 --> 00:40:32.685
<v Speaker 1>Well, so sometimes you don't have a choice.

00:40:32.685 --> 00:40:34.605
<v Speaker 1>Right? So for example, if you have a

00:40:34.605 --> 00:40:36.519
<v Speaker 1>source system which is unreliable

00:40:36.519 --> 00:40:39.079
<v Speaker 1>and you have a high value system that's

00:40:39.079 --> 00:40:42.200
<v Speaker 1>dependent on it, right, are you gonna accept

00:40:42.200 --> 00:40:45.079
<v Speaker 1>the downtime of this system as a limiter

00:40:45.079 --> 00:40:47.960
<v Speaker 1>for your value creation stream? Like, no. Right?

00:40:47.960 --> 00:40:50.025
<v Speaker 1>So you want to be kept up to

00:40:50.025 --> 00:40:52.345
<v Speaker 1>date with the with the latest information.

00:40:52.345 --> 00:40:54.425
<v Speaker 1>So, yeah, you're gonna swallow some of those

00:40:54.425 --> 00:40:56.425
<v Speaker 1>costs and, and difficulties

00:40:56.425 --> 00:40:59.625
<v Speaker 1>that are associated with event driven architectures.

00:40:59.945 --> 00:41:02.984
<v Speaker 1>Usually, you're just trading one bag of problems

00:41:02.984 --> 00:41:05.579
<v Speaker 1>for another where you hope that the the

00:41:05.579 --> 00:41:07.180
<v Speaker 1>downsides of those problems

00:41:07.420 --> 00:41:09.660
<v Speaker 1>will affect you less and that the upsides

00:41:09.660 --> 00:41:11.420
<v Speaker 1>of having done that will reap you more

00:41:11.420 --> 00:41:14.539
<v Speaker 1>benefits. Exactly. The the classic answer, it depends.

00:41:14.539 --> 00:41:16.539
<v Speaker 0>Right? Like, you got you got to pick

00:41:16.539 --> 00:41:17.900
<v Speaker 0>your trade offs. You got to pick

00:41:18.645 --> 00:41:20.565
<v Speaker 0>which level of complexity you need for your

00:41:20.565 --> 00:41:23.605
<v Speaker 0>application. And event sourcing has a very

00:41:25.205 --> 00:41:26.165
<v Speaker 0>interesting

00:41:26.245 --> 00:41:29.845
<v Speaker 0>and applicable and useful and value add and

00:41:29.845 --> 00:41:31.845
<v Speaker 0>some domains that you really need to go

00:41:31.845 --> 00:41:32.565
<v Speaker 0>down the rabbit hole.

00:41:33.970 --> 00:41:35.650
<v Speaker 1>But definitely not all. Yeah.

00:41:36.530 --> 00:41:39.010
<v Speaker 0>Alright. Well, I'm curious then.

00:41:39.330 --> 00:41:42.770
<v Speaker 0>What are you excited about these days? What

00:41:42.770 --> 00:41:45.010
<v Speaker 0>new shiny things are you playing with, experiment,

00:41:45.010 --> 00:41:46.930
<v Speaker 0>whatever, even just interested in you've not attempted

00:41:46.930 --> 00:41:48.805
<v Speaker 0>to play with yet? Like, what what's in

00:41:48.805 --> 00:41:51.685
<v Speaker 0>the future for Frank? So I'm I'm curious

00:41:51.685 --> 00:41:54.645
<v Speaker 1>to see if we like, on the sort

00:41:54.725 --> 00:41:58.245
<v Speaker 1>of real time aspect of ingesting data, there

00:41:58.245 --> 00:42:00.085
<v Speaker 1>is a lot of, like, experience that I

00:42:00.085 --> 00:42:03.089
<v Speaker 1>have on implementing that. The one area where

00:42:03.089 --> 00:42:04.930
<v Speaker 1>I have lots less

00:42:05.010 --> 00:42:07.970
<v Speaker 1>experience is on the sort of on the

00:42:07.970 --> 00:42:10.690
<v Speaker 1>controlling side of it. Right? So real time

00:42:10.690 --> 00:42:11.490
<v Speaker 1>interactions

00:42:11.490 --> 00:42:12.930
<v Speaker 1>with with system,

00:42:13.089 --> 00:42:16.130
<v Speaker 1>systems which can also be message based from

00:42:16.185 --> 00:42:17.305
<v Speaker 1>so imagine

00:42:17.305 --> 00:42:20.025
<v Speaker 1>you have a react UI and that's a

00:42:20.105 --> 00:42:22.985
<v Speaker 1>that's not a blog or another type of

00:42:22.985 --> 00:42:26.025
<v Speaker 1>sort of simple information system, but more like

00:42:26.025 --> 00:42:28.105
<v Speaker 1>a system that you really interact with hands

00:42:28.105 --> 00:42:30.210
<v Speaker 1>on to see like, hey, how can you

00:42:30.210 --> 00:42:32.850
<v Speaker 1>interact with that system in real time and

00:42:32.850 --> 00:42:35.330
<v Speaker 1>then get real time responses out.

00:42:35.730 --> 00:42:38.130
<v Speaker 1>So I know that PHP is not really

00:42:38.130 --> 00:42:40.770
<v Speaker 1>a language where that's super easy to do

00:42:41.065 --> 00:42:44.185
<v Speaker 1>In the sort of TypeScript node worlds, there's

00:42:44.185 --> 00:42:44.905
<v Speaker 1>definitely

00:42:45.065 --> 00:42:48.105
<v Speaker 1>some precedence for that. And in the Java,

00:42:48.105 --> 00:42:50.585
<v Speaker 1>like JVM ecosystem,

00:42:50.585 --> 00:42:53.065
<v Speaker 1>there's also a bit of that. But I

00:42:53.065 --> 00:42:55.190
<v Speaker 1>also want to learn more about Rust, so

00:42:55.190 --> 00:42:57.270
<v Speaker 1>maybe I will just use Rust as my

00:42:57.270 --> 00:43:00.630
<v Speaker 1>next language to experiment with and implement that.

00:43:00.950 --> 00:43:01.750
<v Speaker 1>So, yeah,

00:43:02.230 --> 00:43:04.550
<v Speaker 1>that's a general area, but it's still really

00:43:04.550 --> 00:43:05.670
<v Speaker 1>fuzzy for me

00:43:06.790 --> 00:43:08.630
<v Speaker 1>in terms of like, hey, what does that

00:43:08.630 --> 00:43:11.405
<v Speaker 1>really look like and what type of

00:43:12.045 --> 00:43:14.205
<v Speaker 1>systems can I study in order to learn

00:43:14.205 --> 00:43:17.005
<v Speaker 1>more about it? Sweet. Alright. Well, I'm looking

00:43:17.005 --> 00:43:19.245
<v Speaker 0>forward to seeing Event Source and Rust then.

00:43:19.245 --> 00:43:20.765
<v Speaker 0>I think that's gonna be a

00:43:21.565 --> 00:43:22.765
<v Speaker 0>lot of fun for you to watch. I'm

00:43:22.765 --> 00:43:26.205
<v Speaker 1>I'm I'm guessing it should probably like if

00:43:25.560 --> 00:43:28.120
<v Speaker 1>I'm looking at Rust, it probably involves some

00:43:28.120 --> 00:43:29.320
<v Speaker 1>kind of macros.

00:43:29.400 --> 00:43:29.720
<v Speaker 1>So

00:43:30.760 --> 00:43:32.440
<v Speaker 0>I mean, you could write some really sweet

00:43:32.440 --> 00:43:35.480
<v Speaker 0>procedural macros in Rust to handle the replay

00:43:35.480 --> 00:43:36.680
<v Speaker 0>logic within

00:43:36.920 --> 00:43:39.015
<v Speaker 0>structs. I think that would be super cool,

00:43:39.015 --> 00:43:41.415
<v Speaker 0>and everything would work within an implementation block.

00:43:41.494 --> 00:43:44.135
<v Speaker 0>I think the developer experience and the API

00:43:44.135 --> 00:43:45.895
<v Speaker 0>you could provide for event sourcing in Rust

00:43:45.895 --> 00:43:48.695
<v Speaker 0>would far surpass any other language. Alright. Because

00:43:48.695 --> 00:43:51.680
<v Speaker 0>as really great macro support. Metaprogramming in Rust

00:43:51.680 --> 00:43:53.920
<v Speaker 0>is good. Metaprogramming in Go Not so good.

00:43:54.160 --> 00:43:55.040
<v Speaker 1>So much. No.

00:43:55.839 --> 00:43:57.920
<v Speaker 1>No. Like, in in Go, there are some

00:43:57.920 --> 00:44:00.400
<v Speaker 1>awkward bits if you need to do event

00:44:00.400 --> 00:44:01.440
<v Speaker 1>sourcing

00:44:02.135 --> 00:44:04.375
<v Speaker 1>there because, like, it's very difficult to do

00:44:04.375 --> 00:44:06.455
<v Speaker 1>anything very dynamic and

00:44:06.775 --> 00:44:10.055
<v Speaker 1>event stuff is usually usually benefits from some

00:44:10.055 --> 00:44:12.615
<v Speaker 1>dynamic forms of programming. We'll we'll go to

00:44:12.615 --> 00:44:14.694
<v Speaker 0>that generic support in one

00:44:15.090 --> 00:44:17.570
<v Speaker 0>eighteen or one nineteen. So I think that

00:44:17.570 --> 00:44:19.970
<v Speaker 0>landscape is now wide open for some innovation,

00:44:19.970 --> 00:44:22.530
<v Speaker 0>but certainly prior to that, it it's been

00:44:22.530 --> 00:44:24.530
<v Speaker 0>tedious at best. So

00:44:25.410 --> 00:44:27.170
<v Speaker 0>this has been awesome. Thank you so much

00:44:27.170 --> 00:44:29.490
<v Speaker 0>for spending the last hour of your life

00:44:29.055 --> 00:44:31.135
<v Speaker 0>sharing your event sourcing journey with me and

00:44:31.135 --> 00:44:33.055
<v Speaker 0>lots of interesting information for people listening at

00:44:33.055 --> 00:44:34.734
<v Speaker 0>home. And then I'll give you just a

00:44:34.734 --> 00:44:36.175
<v Speaker 0>minute and say you wanna share your Twitter

00:44:36.175 --> 00:44:39.375
<v Speaker 0>handle, plug your website, your company, open source

00:44:39.375 --> 00:44:41.369
<v Speaker 0>projects, now would be the time to to

00:44:41.369 --> 00:44:42.570
<v Speaker 0>plug away. Cool.

00:44:42.730 --> 00:44:46.250
<v Speaker 1>So if you have any file system needs

00:44:46.250 --> 00:44:48.250
<v Speaker 1>within the PHP ecosystem,

00:44:48.250 --> 00:44:50.089
<v Speaker 1>check out Flysystem,

00:44:50.089 --> 00:44:53.369
<v Speaker 1>which is the main PHP file system abstraction

00:44:53.369 --> 00:44:53.769
<v Speaker 1>library.

00:44:54.734 --> 00:44:57.454
<v Speaker 1>If you need to build anything event sourced

00:44:57.454 --> 00:45:01.055
<v Speaker 1>also in PHP, check out EventSauce

00:45:01.134 --> 00:45:03.695
<v Speaker 1>or check out EventSauce.io.

00:45:05.454 --> 00:45:08.335
<v Speaker 1>Check out my employer. They're called Personio. If

00:45:08.335 --> 00:45:09.375
<v Speaker 1>you're

00:45:09.410 --> 00:45:11.090
<v Speaker 1>a company that needs to

00:45:11.490 --> 00:45:14.370
<v Speaker 1>work with HR processes or any other type

00:45:14.370 --> 00:45:16.770
<v Speaker 1>of HR tooling, that's what they provide. So

00:45:16.770 --> 00:45:18.210
<v Speaker 1>do check them out.

00:45:18.610 --> 00:45:21.250
<v Speaker 1>And when I have the time, I blog

00:45:21.250 --> 00:45:22.370
<v Speaker 1>on my personal website,

00:45:22.820 --> 00:45:26.740
<v Speaker 1>which is blog @frankdejonga.nl.

00:45:26.820 --> 00:45:28.180
<v Speaker 0>Alright. Thank you very much.
