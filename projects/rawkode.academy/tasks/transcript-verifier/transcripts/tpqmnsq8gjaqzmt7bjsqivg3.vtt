WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 49e92427-8567-4f59-977e-f53b5ccff075
Created: 2025-04-29T19:26:27.607Z
Duration: 1950.0299
Channels: 1

00:00:00.640 --> 00:00:03.760
<v Speaker 0>Hello, and welcome to my session, cluster API

00:00:03.760 --> 00:00:04.800
<v Speaker 0>as code.

00:00:05.920 --> 00:00:07.520
<v Speaker 0>My name is David McKay,

00:00:07.839 --> 00:00:10.080
<v Speaker 0>and I am a CNCF ambassador

00:00:10.160 --> 00:00:12.960
<v Speaker 0>and senior developer advocate for Equinix Medal.

00:00:17.615 --> 00:00:19.455
<v Speaker 0>And I am from Glasgow in sunny sunny

00:00:19.455 --> 00:00:20.255
<v Speaker 0>Scotland.

00:00:21.295 --> 00:00:23.375
<v Speaker 0>I have a menagerie of animals in my

00:00:23.375 --> 00:00:23.935
<v Speaker 0>office.

00:00:24.255 --> 00:00:26.814
<v Speaker 0>I have chinchillas, taggers, a ferret, and a

00:00:26.814 --> 00:00:27.055
<v Speaker 0>dog.

00:00:29.189 --> 00:00:32.470
<v Speaker 0>I'm also a prolific livestreamer, streaming multiple times

00:00:32.470 --> 00:00:33.190
<v Speaker 0>per week,

00:00:33.430 --> 00:00:35.110
<v Speaker 0>trying to cover all of the cloud native

00:00:35.110 --> 00:00:36.629
<v Speaker 0>landscape technologies.

00:00:37.270 --> 00:00:39.510
<v Speaker 0>Hopefully, providing learning materials so we can all

00:00:39.510 --> 00:00:40.469
<v Speaker 0>learn together.

00:00:41.350 --> 00:00:43.910
<v Speaker 0>And, of course, I'm also supporting my wonderful

00:00:44.525 --> 00:00:46.925
<v Speaker 0>COVID hair. You're welcome.

00:00:50.445 --> 00:00:52.684
<v Speaker 0>And I am definitely a member of the

00:00:52.684 --> 00:00:53.725
<v Speaker 0>Pineapple Pizza Club.

00:00:59.530 --> 00:01:00.890
<v Speaker 0>So let's get started.

00:01:02.489 --> 00:01:05.369
<v Speaker 0>So what is Cluster API project?

00:01:06.250 --> 00:01:06.970
<v Speaker 0>Well,

00:01:07.290 --> 00:01:10.090
<v Speaker 0>it is a sub project of Kubernetes

00:01:09.955 --> 00:01:11.795
<v Speaker 0>that aims to commoditize

00:01:11.795 --> 00:01:15.075
<v Speaker 0>the creation and provisioning of new Kubernetes clusters,

00:01:15.555 --> 00:01:18.515
<v Speaker 0>provided you have a Kubernetes cluster.

00:01:21.555 --> 00:01:24.515
<v Speaker 0>The cluster API provides a declarative API,

00:01:25.430 --> 00:01:27.509
<v Speaker 0>just like we're used to with Kubernetes,

00:01:27.909 --> 00:01:30.310
<v Speaker 0>for managing our Kubernetes clusters.

00:01:31.110 --> 00:01:33.670
<v Speaker 0>Its responsibilities are to create and provision Kubernetes

00:01:33.670 --> 00:01:35.750
<v Speaker 0>clusters. It will handle upgrades

00:01:36.070 --> 00:01:39.190
<v Speaker 0>and day to day operations, including remediation when

00:01:39.190 --> 00:01:39.670
<v Speaker 0>required.

00:01:42.524 --> 00:01:44.844
<v Speaker 0>It is currently in an alpha state, which

00:01:44.844 --> 00:01:47.005
<v Speaker 0>means it's volatile and changing quickly,

00:01:47.244 --> 00:01:48.685
<v Speaker 0>but it doesn't mean that you can't use

00:01:48.685 --> 00:01:49.965
<v Speaker 0>it in production today.

00:01:51.405 --> 00:01:53.564
<v Speaker 0>And it is an extremely collaborative project,

00:01:54.370 --> 00:01:56.210
<v Speaker 0>with members from AWS,

00:01:56.210 --> 00:01:57.010
<v Speaker 0>DigitalOcean,

00:01:57.010 --> 00:01:59.409
<v Speaker 0>Google Cloud, Equinix Metal, and more.

00:01:59.810 --> 00:02:02.850
<v Speaker 0>Almost every cloud provider has a cluster API

00:02:02.850 --> 00:02:05.970
<v Speaker 0>provider for spinning up that next Kubernetes cluster.

00:02:08.794 --> 00:02:11.355
<v Speaker 0>Okay. So let's cover some basic capability that

00:02:11.355 --> 00:02:13.035
<v Speaker 0>you need to get started with the cluster

00:02:13.035 --> 00:02:13.835
<v Speaker 0>API.

00:02:14.155 --> 00:02:16.795
<v Speaker 0>Firstly, the documentation will make mention of a

00:02:16.795 --> 00:02:17.675
<v Speaker 0>management cluster.

00:02:18.810 --> 00:02:21.690
<v Speaker 0>This can be an existing Kubernetes cluster that

00:02:21.690 --> 00:02:23.770
<v Speaker 0>you have available within your organization,

00:02:24.730 --> 00:02:27.370
<v Speaker 0>or something as simple as Docker for Mac,

00:02:27.370 --> 00:02:28.970
<v Speaker 0>Minikube or Kind.

00:02:31.210 --> 00:02:32.810
<v Speaker 0>This cluster will run

00:02:33.335 --> 00:02:34.775
<v Speaker 0>the controllers

00:02:34.935 --> 00:02:36.615
<v Speaker 0>for creating subsequent

00:02:36.615 --> 00:02:38.615
<v Speaker 0>or target workload clusters.

00:02:40.215 --> 00:02:43.255
<v Speaker 0>The documentation will also mention infrastructure providers.

00:02:44.055 --> 00:02:46.455
<v Speaker 0>The cluster API aims to work across all

00:02:46.455 --> 00:02:47.415
<v Speaker 0>major cloud providers.

00:02:48.540 --> 00:02:51.100
<v Speaker 0>So a provider could be Google,

00:02:51.340 --> 00:02:52.140
<v Speaker 0>Amazon,

00:02:52.220 --> 00:02:53.580
<v Speaker 0>or Equinix Medal.

00:02:54.620 --> 00:02:55.420
<v Speaker 0>Perfect.

00:02:59.099 --> 00:03:01.525
<v Speaker 0>And then there's the workload cluster. Workload cluster

00:03:01.525 --> 00:03:02.885
<v Speaker 0>is the clusters that we're gonna have the

00:03:02.885 --> 00:03:05.925
<v Speaker 0>cluster API create and provision for us.

00:03:07.365 --> 00:03:09.525
<v Speaker 0>Then we have machines. These could be virtual

00:03:09.525 --> 00:03:10.805
<v Speaker 0>machines or VMs

00:03:10.805 --> 00:03:11.525
<v Speaker 0>on

00:03:11.605 --> 00:03:12.485
<v Speaker 0>AWS,

00:03:12.485 --> 00:03:13.205
<v Speaker 0>GCP,

00:03:13.285 --> 00:03:15.125
<v Speaker 0>or bare metal instances on Equinix.

00:03:15.720 --> 00:03:17.400
<v Speaker 0>We then have the concept of a machine

00:03:17.400 --> 00:03:18.200
<v Speaker 0>deployment.

00:03:18.680 --> 00:03:20.520
<v Speaker 0>This is a high level

00:03:20.760 --> 00:03:22.680
<v Speaker 0>request for the cluster API

00:03:22.920 --> 00:03:24.680
<v Speaker 0>to create one or more machines.

00:03:25.800 --> 00:03:28.680
<v Speaker 0>The machine deployment is responsible for maintaining and

00:03:28.680 --> 00:03:31.125
<v Speaker 0>creating machine sets. As we make changes to

00:03:31.125 --> 00:03:32.325
<v Speaker 0>our machine deployments,

00:03:32.485 --> 00:03:34.325
<v Speaker 0>new machine sets are created.

00:03:34.725 --> 00:03:37.125
<v Speaker 0>The machine sets are then responsible for creating

00:03:37.125 --> 00:03:38.005
<v Speaker 0>the machines.

00:03:38.725 --> 00:03:40.565
<v Speaker 0>We also have machine health checks to make

00:03:40.565 --> 00:03:42.245
<v Speaker 0>sure that the clusters and the nodes that

00:03:42.245 --> 00:03:44.560
<v Speaker 0>we provide are always healthy.

00:03:46.080 --> 00:03:48.480
<v Speaker 0>This should feel extremely familiar.

00:03:49.120 --> 00:03:50.879
<v Speaker 0>This is very similar to the resources that

00:03:50.879 --> 00:03:52.080
<v Speaker 0>we work with day in and day out

00:03:52.080 --> 00:03:53.040
<v Speaker 0>on Kubernetes,

00:03:53.040 --> 00:03:53.920
<v Speaker 0>deployments,

00:03:54.160 --> 00:03:55.920
<v Speaker 0>replica sets, pods,

00:03:56.375 --> 00:03:57.495
<v Speaker 0>and probes.

00:03:58.694 --> 00:03:59.415
<v Speaker 0>Okay.

00:03:59.495 --> 00:04:01.655
<v Speaker 0>Now that that stuff's out the way, let's

00:04:01.655 --> 00:04:03.255
<v Speaker 0>take a very brief look at how you

00:04:03.255 --> 00:04:05.495
<v Speaker 0>get started with the cluster API today.

00:04:08.430 --> 00:04:10.750
<v Speaker 0>I'm gonna quickly run through the getting started

00:04:10.750 --> 00:04:13.070
<v Speaker 0>guide from the cluster API book.

00:04:13.230 --> 00:04:14.670
<v Speaker 0>If you haven't checked out the book, I

00:04:14.670 --> 00:04:16.910
<v Speaker 0>recommend doing so as soon as possible. It

00:04:16.910 --> 00:04:18.910
<v Speaker 0>has everything you need to know about getting

00:04:18.910 --> 00:04:20.350
<v Speaker 0>started with the cluster API.

00:04:24.885 --> 00:04:26.885
<v Speaker 0>So what we have here is a very

00:04:26.885 --> 00:04:28.165
<v Speaker 0>simple Just file.

00:04:28.325 --> 00:04:30.565
<v Speaker 0>Just file is like a Makefile, but better.

00:04:31.205 --> 00:04:34.245
<v Speaker 0>It has two different targets. The first, init.

00:04:34.405 --> 00:04:37.125
<v Speaker 0>This will prepare our management cluster for creating

00:04:37.125 --> 00:04:38.325
<v Speaker 0>new Kubernetes

00:04:38.325 --> 00:04:38.725
<v Speaker 0>clusters.

00:04:39.700 --> 00:04:41.700
<v Speaker 0>Next, there's a create cluster target.

00:04:42.020 --> 00:04:43.780
<v Speaker 0>This one's a little bit more for both,

00:04:44.020 --> 00:04:46.100
<v Speaker 0>but this will generate the YAML required for

00:04:46.100 --> 00:04:48.500
<v Speaker 0>us to apply to our management cluster in

00:04:48.500 --> 00:04:50.500
<v Speaker 0>order to allow the controllers to create our

00:04:50.500 --> 00:04:51.780
<v Speaker 0>new workload

00:04:51.780 --> 00:04:54.375
<v Speaker 0>cluster. We specify the Kubernetes version that we

00:04:54.375 --> 00:04:56.935
<v Speaker 0>want, how many control plane nodes we want,

00:04:57.254 --> 00:04:59.574
<v Speaker 0>and how many worker nodes we want.

00:05:00.534 --> 00:05:02.615
<v Speaker 0>You don't have to worry about having a

00:05:02.615 --> 00:05:05.495
<v Speaker 0>single control plane node or a highly available

00:05:05.900 --> 00:05:08.060
<v Speaker 0>control plane node. Cluster API will take care

00:05:08.060 --> 00:05:09.500
<v Speaker 0>of that for you.

00:05:10.380 --> 00:05:12.220
<v Speaker 0>And in order for these just fail targets

00:05:12.220 --> 00:05:14.140
<v Speaker 0>to work, we just need a little bit

00:05:14.140 --> 00:05:16.700
<v Speaker 0>of environment information to configure it along the

00:05:16.700 --> 00:05:17.180
<v Speaker 0>way.

00:05:18.220 --> 00:05:19.980
<v Speaker 0>Of course, we need to provide an API

00:05:19.980 --> 00:05:21.500
<v Speaker 0>key for the cloud provider of choice.

00:05:22.745 --> 00:05:24.664
<v Speaker 0>Because I'm using Equinix Mineral, I also have

00:05:24.664 --> 00:05:26.745
<v Speaker 0>to provide which project to create the devices

00:05:26.745 --> 00:05:27.305
<v Speaker 0>in,

00:05:28.425 --> 00:05:30.025
<v Speaker 0>and I also have to tell it which

00:05:30.025 --> 00:05:32.425
<v Speaker 0>operating system to use for each of the

00:05:32.425 --> 00:05:35.064
<v Speaker 0>nodes as well as the facility to launch

00:05:35.064 --> 00:05:35.465
<v Speaker 0>them in.

00:05:36.690 --> 00:05:38.930
<v Speaker 0>We can configure the pod CIDR and service

00:05:38.930 --> 00:05:40.370
<v Speaker 0>CIDR for our cluster,

00:05:41.250 --> 00:05:43.330
<v Speaker 0>and we can tell it which instant types

00:05:43.330 --> 00:05:44.130
<v Speaker 0>to use

00:05:44.449 --> 00:05:46.930
<v Speaker 0>individually for the control plane node and for

00:05:46.930 --> 00:05:48.449
<v Speaker 0>any worker node pools that we have.

00:05:50.495 --> 00:05:53.535
<v Speaker 0>To get started, I can run just init.

00:05:55.134 --> 00:05:56.255
<v Speaker 0>This will

00:05:56.414 --> 00:05:58.574
<v Speaker 0>speak to my management cluster, which is Docker

00:05:58.574 --> 00:05:59.294
<v Speaker 0>for Mac.

00:05:59.775 --> 00:06:01.694
<v Speaker 0>It will install all of the custom resources

00:06:01.694 --> 00:06:04.414
<v Speaker 0>to that cluster, get the controllers running,

00:06:05.110 --> 00:06:08.069
<v Speaker 0>and pass in the packet API keys I

00:06:08.069 --> 00:06:11.750
<v Speaker 0>need for deploying new clusters on Equinix Metal.

00:06:12.470 --> 00:06:15.110
<v Speaker 0>It's called packet just because packet renamed to

00:06:15.110 --> 00:06:16.949
<v Speaker 0>Equinix Metal last year and the provider is

00:06:16.949 --> 00:06:17.750
<v Speaker 0>a little bit behind.

00:06:23.095 --> 00:06:24.775
<v Speaker 0>It's not the quickest, but it is pulling

00:06:24.775 --> 00:06:27.015
<v Speaker 0>a number of images to the management cluster.

00:06:27.415 --> 00:06:30.135
<v Speaker 0>However, that is now available for me to

00:06:30.135 --> 00:06:32.055
<v Speaker 0>generate my target cluster.

00:06:39.220 --> 00:06:41.539
<v Speaker 0>Cluster control uses templates that are baked into

00:06:41.539 --> 00:06:43.220
<v Speaker 0>each provider's repository

00:06:43.379 --> 00:06:46.180
<v Speaker 0>to try and guess what you need for

00:06:46.180 --> 00:06:47.300
<v Speaker 0>your target cluster.

00:06:47.965 --> 00:06:49.405
<v Speaker 0>And in fact, we can pop this open

00:06:49.405 --> 00:06:51.005
<v Speaker 0>in Versus Code and take a look.

00:06:54.125 --> 00:06:56.445
<v Speaker 0>Now inside of our cluster YAML, you will

00:06:56.445 --> 00:06:57.005
<v Speaker 0>see

00:06:57.805 --> 00:06:59.085
<v Speaker 0>a kubeadm control.

00:06:59.580 --> 00:07:01.979
<v Speaker 0>This is a custom resource that tells cluster

00:07:01.979 --> 00:07:02.780
<v Speaker 0>API

00:07:02.860 --> 00:07:04.860
<v Speaker 0>how to get a control plane node on

00:07:04.860 --> 00:07:06.139
<v Speaker 0>your provider of choice.

00:07:06.860 --> 00:07:08.379
<v Speaker 0>Here, we see a whole bunch of shell

00:07:08.379 --> 00:07:10.780
<v Speaker 0>commands that are required to configure the host

00:07:11.180 --> 00:07:13.419
<v Speaker 0>and install all of the Kubernetes component.

00:07:14.545 --> 00:07:16.305
<v Speaker 0>We then have a machine template

00:07:16.385 --> 00:07:19.905
<v Speaker 0>that tells us what our control plane nodes

00:07:19.905 --> 00:07:20.785
<v Speaker 0>look like.

00:07:22.465 --> 00:07:24.544
<v Speaker 0>We then have a cluster CRD that contains

00:07:24.544 --> 00:07:26.705
<v Speaker 0>each of the pod CIDR, service CIDR, and

00:07:26.705 --> 00:07:28.544
<v Speaker 0>other infrastructure parts that we need,

00:07:29.100 --> 00:07:32.460
<v Speaker 0>followed by a provider specific cluster that just

00:07:32.460 --> 00:07:34.780
<v Speaker 0>tells it the facility and project IDs.

00:07:35.660 --> 00:07:37.340
<v Speaker 0>We then have machine deployments,

00:07:38.300 --> 00:07:39.660
<v Speaker 0>more machine templates,

00:07:39.900 --> 00:07:41.420
<v Speaker 0>more QEDM configs,

00:07:42.555 --> 00:07:44.794
<v Speaker 0>and there we are. 206

00:07:44.794 --> 00:07:47.915
<v Speaker 0>lines of wonderful, beautiful YAML.

00:07:50.715 --> 00:07:52.475
<v Speaker 0>Okay. Let's get it started.

00:07:53.514 --> 00:07:56.155
<v Speaker 0>What's the problem? Seems simple enough. Right?

00:07:58.640 --> 00:07:59.600
<v Speaker 0>Unfortunately,

00:08:00.720 --> 00:08:03.840
<v Speaker 0>YAML is not the best programming language

00:08:04.240 --> 00:08:05.680
<v Speaker 0>for complex logic.

00:08:07.680 --> 00:08:08.320
<v Speaker 0>And

00:08:08.480 --> 00:08:10.640
<v Speaker 0>we seem to have got ourselves into a

00:08:10.640 --> 00:08:12.640
<v Speaker 0>bit of a pickle in the cloud native

00:08:12.640 --> 00:08:13.520
<v Speaker 0>ecosystem

00:08:13.895 --> 00:08:15.655
<v Speaker 0>when it comes to YAML. In fact, there

00:08:15.655 --> 00:08:18.135
<v Speaker 0>are memes all over the Internet

00:08:18.295 --> 00:08:20.295
<v Speaker 0>about how, you know, to be a DevOps

00:08:20.295 --> 00:08:22.295
<v Speaker 0>engineer, to be a platform engineer, to be

00:08:22.295 --> 00:08:23.815
<v Speaker 0>a Kubernetes developer

00:08:24.135 --> 00:08:26.215
<v Speaker 0>is to be a YAML developer.

00:08:27.200 --> 00:08:30.080
<v Speaker 0>And while they're funny, sometimes incorrect, and a

00:08:30.080 --> 00:08:31.200
<v Speaker 0>whole bunch of other things,

00:08:32.480 --> 00:08:36.000
<v Speaker 0>let's identify real problem that we have, that

00:08:36.000 --> 00:08:38.960
<v Speaker 0>we've gotten ourselves into. We've got Helm. We've

00:08:38.960 --> 00:08:41.760
<v Speaker 0>got Carvel. We've got Capitan. We have Customize

00:08:42.105 --> 00:08:43.225
<v Speaker 0>to help us

00:08:43.704 --> 00:08:46.185
<v Speaker 0>try and wrangle this YAML into something that

00:08:46.185 --> 00:08:48.185
<v Speaker 0>is much more fluent

00:08:48.264 --> 00:08:50.505
<v Speaker 0>to work with, that allows us to handle

00:08:50.505 --> 00:08:53.225
<v Speaker 0>complex logic and loops and

00:08:53.225 --> 00:08:53.785
<v Speaker 0>templating.

00:08:56.420 --> 00:08:59.380
<v Speaker 0>And I think it's safe to say, if

00:08:59.380 --> 00:09:00.180
<v Speaker 0>you

00:09:00.500 --> 00:09:03.220
<v Speaker 0>maintain any Helm charts, I certainly do,

00:09:03.779 --> 00:09:05.940
<v Speaker 0>it can be overwhelming

00:09:06.820 --> 00:09:09.154
<v Speaker 0>because those Helm charts which are trying to

00:09:09.154 --> 00:09:11.555
<v Speaker 0>set out a predefined way or a best

00:09:11.555 --> 00:09:13.714
<v Speaker 0>practice way for deploying a piece of software

00:09:14.355 --> 00:09:16.595
<v Speaker 0>doesn't fit everyone's use case.

00:09:17.154 --> 00:09:17.875
<v Speaker 0>People

00:09:18.115 --> 00:09:19.635
<v Speaker 0>wanna do their own thing,

00:09:20.115 --> 00:09:22.595
<v Speaker 0>and we layer and layer on more loops,

00:09:22.560 --> 00:09:25.600
<v Speaker 0>more conditionals, more loops, and more conditionals,

00:09:26.160 --> 00:09:28.640
<v Speaker 0>trying to provide enough flexibility for the end

00:09:28.640 --> 00:09:29.360
<v Speaker 0>user

00:09:29.600 --> 00:09:31.040
<v Speaker 0>while saving them time,

00:09:31.360 --> 00:09:34.000
<v Speaker 0>but at the expense of everyone's

00:09:34.080 --> 00:09:34.800
<v Speaker 0>time.

00:09:35.440 --> 00:09:36.880
<v Speaker 0>And there has to be a better way.

00:09:39.715 --> 00:09:42.755
<v Speaker 0>So I reached out to my colleague, Jason

00:09:42.755 --> 00:09:43.875
<v Speaker 0>Deceberis,

00:09:44.355 --> 00:09:47.715
<v Speaker 0>who just happens to be a contributor and

00:09:47.715 --> 00:09:50.515
<v Speaker 0>maintainer of various cluster API projects.

00:09:51.650 --> 00:09:52.290
<v Speaker 0>And

00:09:52.610 --> 00:09:54.290
<v Speaker 0>I wouldn't read

00:09:54.690 --> 00:09:56.370
<v Speaker 0>his words verbatim.

00:09:56.610 --> 00:09:59.010
<v Speaker 0>Feel free to pause and and do that

00:09:59.010 --> 00:10:00.210
<v Speaker 0>on your own accord.

00:10:00.930 --> 00:10:03.330
<v Speaker 0>But I think the message from Jason is

00:10:03.330 --> 00:10:03.650
<v Speaker 0>clear.

00:10:05.384 --> 00:10:07.545
<v Speaker 0>The cluster API's responsibility

00:10:09.065 --> 00:10:11.065
<v Speaker 0>is the reconciliation,

00:10:11.065 --> 00:10:13.065
<v Speaker 0>creation, provision, and operability

00:10:13.384 --> 00:10:15.225
<v Speaker 0>of the target clusters.

00:10:16.505 --> 00:10:17.945
<v Speaker 0>The cluster API's

00:10:17.945 --> 00:10:19.945
<v Speaker 0>responsibility is not

00:10:20.340 --> 00:10:21.300
<v Speaker 0>to provide,

00:10:21.540 --> 00:10:24.660
<v Speaker 0>you know, ergonomic tooling to generate the YAML

00:10:24.660 --> 00:10:26.260
<v Speaker 0>to describe those clusters.

00:10:26.980 --> 00:10:29.220
<v Speaker 0>And as we've seen through the Quickstart,

00:10:29.460 --> 00:10:32.260
<v Speaker 0>well, it does offer some simple mechanics to

00:10:32.260 --> 00:10:34.100
<v Speaker 0>generate that getting started

00:10:34.900 --> 00:10:35.460
<v Speaker 0>YAML.

00:10:36.165 --> 00:10:37.765
<v Speaker 0>The minute you need to be able to

00:10:37.765 --> 00:10:39.685
<v Speaker 0>make your own tweaks, things get a little

00:10:39.685 --> 00:10:41.285
<v Speaker 0>bit complicated.

00:10:41.285 --> 00:10:42.964
<v Speaker 0>You have to start copying and pasting your

00:10:42.964 --> 00:10:44.964
<v Speaker 0>own YAML to get the kind of cluster

00:10:44.964 --> 00:10:47.525
<v Speaker 0>topology that you would want or expect.

00:10:47.925 --> 00:10:49.925
<v Speaker 0>Yeah. Fine. It gives you a control plane

00:10:49.925 --> 00:10:51.810
<v Speaker 0>cluster, highly available,

00:10:53.010 --> 00:10:56.370
<v Speaker 0>but it only generates one single worker pool.

00:10:57.170 --> 00:10:59.810
<v Speaker 0>And for most production clusters, you're probably gonna

00:10:59.810 --> 00:11:01.089
<v Speaker 0>want more,

00:11:01.250 --> 00:11:04.610
<v Speaker 0>potentially within different availability zones within a single

00:11:04.610 --> 00:11:05.089
<v Speaker 0>region

00:11:05.505 --> 00:11:08.625
<v Speaker 0>with a variety of instance types, some disk

00:11:08.625 --> 00:11:11.265
<v Speaker 0>heavy, some memory heavy, some CPU heavy,

00:11:11.585 --> 00:11:13.985
<v Speaker 0>that really are tailored to your workload.

00:11:14.465 --> 00:11:17.665
<v Speaker 0>We're seeing the same confusion and complexity that

00:11:17.665 --> 00:11:19.025
<v Speaker 0>we see across broader

00:11:19.350 --> 00:11:23.430
<v Speaker 0>Kubernetes ecosystem for deployments and templating now starting

00:11:23.430 --> 00:11:25.029
<v Speaker 0>to come to the cluster API.

00:11:25.750 --> 00:11:27.350
<v Speaker 0>It is that not all clusters are the

00:11:27.350 --> 00:11:29.589
<v Speaker 0>same. And as an end user, I wanna

00:11:29.589 --> 00:11:31.269
<v Speaker 0>describe a cluster that works for me.

00:11:32.535 --> 00:11:34.855
<v Speaker 0>And for that, we need to look beyond

00:11:35.175 --> 00:11:36.455
<v Speaker 0>the cluster API

00:11:36.695 --> 00:11:37.895
<v Speaker 0>to other tools.

00:11:38.935 --> 00:11:39.575
<v Speaker 0>Okay.

00:11:39.975 --> 00:11:41.815
<v Speaker 0>Let's talk about solutions.

00:11:43.975 --> 00:11:45.495
<v Speaker 0>If we have to look beyond the cluster

00:11:45.495 --> 00:11:48.130
<v Speaker 0>API for tooling to allow us to define

00:11:48.130 --> 00:11:49.810
<v Speaker 0>the clusters that we need and we want

00:11:49.810 --> 00:11:51.810
<v Speaker 0>for our day to day lives to be

00:11:51.810 --> 00:11:52.450
<v Speaker 0>better,

00:11:53.170 --> 00:11:54.930
<v Speaker 0>then we have to look at other tooling.

00:11:55.970 --> 00:11:57.970
<v Speaker 0>Then we have to pick the right tooling,

00:11:58.290 --> 00:12:01.250
<v Speaker 0>and I am a firm believer in infrastructure

00:12:01.935 --> 00:12:03.055
<v Speaker 0>That's code.

00:12:03.535 --> 00:12:04.735
<v Speaker 0>Not as YAML.

00:12:05.695 --> 00:12:06.575
<v Speaker 0>That's code.

00:12:06.975 --> 00:12:08.415
<v Speaker 0>We're using real,

00:12:08.575 --> 00:12:10.575
<v Speaker 0>high level languages that allow us to pervade

00:12:10.575 --> 00:12:12.175
<v Speaker 0>the abstractions that we need

00:12:13.135 --> 00:12:15.295
<v Speaker 0>to make our jobs almost enjoyable.

00:12:18.810 --> 00:12:20.490
<v Speaker 0>And that means that I want

00:12:20.970 --> 00:12:23.370
<v Speaker 0>something that is flexible.

00:12:23.770 --> 00:12:25.930
<v Speaker 0>I wanna be able to define a cluster

00:12:26.810 --> 00:12:28.970
<v Speaker 0>that is the size I want, that uses

00:12:28.970 --> 00:12:31.210
<v Speaker 0>the node pools I want, uses the instant

00:12:31.210 --> 00:12:34.214
<v Speaker 0>types I want, has the operating system that

00:12:34.214 --> 00:12:36.694
<v Speaker 0>I want to use because maybe there's other

00:12:36.694 --> 00:12:37.815
<v Speaker 0>things on there that I want to take

00:12:37.815 --> 00:12:38.615
<v Speaker 0>advantage of.

00:12:39.975 --> 00:12:42.375
<v Speaker 0>I think, more importantly, it also has to

00:12:42.375 --> 00:12:43.574
<v Speaker 0>be composable.

00:12:43.815 --> 00:12:45.334
<v Speaker 0>I think that we are in a stage

00:12:45.334 --> 00:12:48.720
<v Speaker 0>of Kubernetes awareness and adoption where we know

00:12:48.720 --> 00:12:52.240
<v Speaker 0>that having one giant monolithic Kubernetes cluster is

00:12:52.240 --> 00:12:53.120
<v Speaker 0>not the answer.

00:12:53.680 --> 00:12:57.440
<v Speaker 0>We actually want lots of smaller Kubernetes clusters,

00:12:57.520 --> 00:12:59.840
<v Speaker 0>and our tooling has to evolve to help

00:12:59.840 --> 00:13:01.520
<v Speaker 0>us provide that and describe that.

00:13:02.575 --> 00:13:04.575
<v Speaker 0>So when I say composable, it's like I

00:13:04.575 --> 00:13:06.175
<v Speaker 0>wanna be able to define what a node

00:13:06.175 --> 00:13:08.894
<v Speaker 0>pool looks like for machine learning workloads and

00:13:08.894 --> 00:13:11.214
<v Speaker 0>reuse that over and over again. I wanna

00:13:11.214 --> 00:13:12.495
<v Speaker 0>be able to find what a node pool

00:13:12.495 --> 00:13:13.214
<v Speaker 0>looks like

00:13:13.695 --> 00:13:15.535
<v Speaker 0>for databases, for stateful workloads,

00:13:16.020 --> 00:13:18.740
<v Speaker 0>for disk IOPS are critical

00:13:19.940 --> 00:13:22.100
<v Speaker 0>and security across the board.

00:13:23.940 --> 00:13:26.100
<v Speaker 0>And it has to be ergonomic.

00:13:26.820 --> 00:13:28.740
<v Speaker 0>I have to enjoy

00:13:29.220 --> 00:13:29.860
<v Speaker 0>using it.

00:13:30.975 --> 00:13:32.975
<v Speaker 0>Coding doesn't have to be a chore.

00:13:33.375 --> 00:13:35.615
<v Speaker 0>We provide abstractions and libraries to make our

00:13:35.615 --> 00:13:36.495
<v Speaker 0>lives easier.

00:13:36.895 --> 00:13:40.015
<v Speaker 0>I wanna make future me life easier,

00:13:41.055 --> 00:13:42.175
<v Speaker 0>and there is a way.

00:13:44.255 --> 00:13:44.654
<v Speaker 0>So,

00:13:45.800 --> 00:13:47.800
<v Speaker 0>the solution I'm gonna show today is based

00:13:47.800 --> 00:13:50.040
<v Speaker 0>on a project called Pulumi, which hopefully you're

00:13:50.040 --> 00:13:52.040
<v Speaker 0>aware of. It is an infrastructure as code

00:13:52.040 --> 00:13:52.680
<v Speaker 0>tool.

00:13:53.160 --> 00:13:54.760
<v Speaker 0>It allows you, the developer, to make your

00:13:54.760 --> 00:13:55.560
<v Speaker 0>own choices.

00:13:56.120 --> 00:13:58.680
<v Speaker 0>You wanna write your infrastructure as code in

00:13:58.680 --> 00:13:59.080
<v Speaker 0>Python,

00:14:00.455 --> 00:14:01.255
<v Speaker 0>Go,

00:14:02.295 --> 00:14:03.975
<v Speaker 0>JavaScript, TypeScript,

00:14:05.015 --> 00:14:05.895
<v Speaker 0>.net.

00:14:07.255 --> 00:14:08.695
<v Speaker 0>These are all choices you do get to

00:14:08.695 --> 00:14:09.175
<v Speaker 0>make.

00:14:10.855 --> 00:14:12.215
<v Speaker 0>Pulumi allows you

00:14:12.620 --> 00:14:14.459
<v Speaker 0>and provides an SDK

00:14:14.940 --> 00:14:16.380
<v Speaker 0>to work with a language that you're more

00:14:16.380 --> 00:14:17.260
<v Speaker 0>comfortable with.

00:14:18.380 --> 00:14:20.300
<v Speaker 0>And what we have here is an example

00:14:20.300 --> 00:14:22.860
<v Speaker 0>of using the TypeScript SDK for Azure

00:14:24.060 --> 00:14:25.420
<v Speaker 0>to spin up an app service,

00:14:26.894 --> 00:14:29.295
<v Speaker 0>which has a handler, an anonymous function, my

00:14:29.295 --> 00:14:30.895
<v Speaker 0>business logic can go there,

00:14:31.135 --> 00:14:32.975
<v Speaker 0>and then just four lines of code to

00:14:32.975 --> 00:14:34.894
<v Speaker 0>describe how to deploy that to the Azure

00:14:34.894 --> 00:14:35.775
<v Speaker 0>ecosystem.

00:14:37.375 --> 00:14:39.855
<v Speaker 0>These are the ergonomics that we're talking about.

00:14:41.750 --> 00:14:44.149
<v Speaker 0>Less than 10 lines of code, easy to

00:14:44.149 --> 00:14:47.430
<v Speaker 0>read, easy to reason, easy to change.

00:14:48.230 --> 00:14:50.870
<v Speaker 0>It's very explicit and does only what I

00:14:50.870 --> 00:14:51.110
<v Speaker 0>need.

00:14:56.875 --> 00:14:59.595
<v Speaker 0>There's another project from the Pulumi Corporation

00:15:00.555 --> 00:15:03.355
<v Speaker 0>that allows us to generate

00:15:03.675 --> 00:15:04.875
<v Speaker 0>these types

00:15:05.915 --> 00:15:08.315
<v Speaker 0>from the custom resource definitions that are widely

00:15:08.315 --> 00:15:10.075
<v Speaker 0>available in the Kubernetes ecosystem.

00:15:11.390 --> 00:15:12.910
<v Speaker 0>By not confined

00:15:13.310 --> 00:15:16.030
<v Speaker 0>to v one or apps v one,

00:15:16.350 --> 00:15:18.590
<v Speaker 0>they're already broadly known and understood,

00:15:19.070 --> 00:15:21.230
<v Speaker 0>but to any custom resource that is online

00:15:21.230 --> 00:15:23.790
<v Speaker 0>that has an open API specification as part

00:15:23.790 --> 00:15:24.430
<v Speaker 0>of its resource.

00:15:25.615 --> 00:15:27.935
<v Speaker 0>Pulumi can generate the types and allow us

00:15:27.935 --> 00:15:30.895
<v Speaker 0>to consume them using the same ergonomics that

00:15:30.895 --> 00:15:32.415
<v Speaker 0>we're becoming accustomed to.

00:15:35.535 --> 00:15:38.095
<v Speaker 0>As I said, Pulumi supports the languages you're

00:15:38.095 --> 00:15:40.620
<v Speaker 0>already familiar with. I'm a big fan of

00:15:40.620 --> 00:15:42.379
<v Speaker 0>using TypeScript. I think it works really well

00:15:42.379 --> 00:15:44.620
<v Speaker 0>for infrastructure as code with a strongly typed

00:15:44.620 --> 00:15:45.980
<v Speaker 0>but dynamic nature.

00:15:46.620 --> 00:15:49.420
<v Speaker 0>However, this is cloud native. Go is an

00:15:49.420 --> 00:15:51.100
<v Speaker 0>option as long as you don't mind checking

00:15:51.100 --> 00:15:52.699
<v Speaker 0>for errors every thirteen seconds.

00:15:53.705 --> 00:15:56.105
<v Speaker 0>Python and .net are also available, and more

00:15:56.105 --> 00:15:58.505
<v Speaker 0>languages I've heard are coming soon.

00:16:00.265 --> 00:16:02.825
<v Speaker 0>And there's one secret thing that launched very

00:16:02.825 --> 00:16:04.425
<v Speaker 0>recently from the Pulumi Corporation,

00:16:05.820 --> 00:16:09.180
<v Speaker 0>And it's that they have enabled cross language

00:16:09.180 --> 00:16:11.420
<v Speaker 0>SDK runtime capability.

00:16:12.220 --> 00:16:12.860
<v Speaker 0>Meaning,

00:16:14.220 --> 00:16:15.580
<v Speaker 0>I like TypeScript.

00:16:15.740 --> 00:16:17.580
<v Speaker 0>I publish libraries in TypeScript.

00:16:18.655 --> 00:16:20.815
<v Speaker 0>You let go. You want to write your

00:16:20.815 --> 00:16:22.975
<v Speaker 0>infrastructure's code in Go.

00:16:23.615 --> 00:16:26.015
<v Speaker 0>You can now consume TypeScript libraries from Go

00:16:26.015 --> 00:16:28.175
<v Speaker 0>as I can consume the type the Go

00:16:28.175 --> 00:16:28.975
<v Speaker 0>library

00:16:29.055 --> 00:16:29.855
<v Speaker 0>from TypeScript.

00:16:31.330 --> 00:16:32.130
<v Speaker 0>Wow.

00:16:37.650 --> 00:16:39.330
<v Speaker 0>So for the rest of this talk, we're

00:16:39.330 --> 00:16:41.010
<v Speaker 0>gonna be moving into the live demo where

00:16:41.010 --> 00:16:42.370
<v Speaker 0>I will show you the library that I've

00:16:42.370 --> 00:16:43.970
<v Speaker 0>built and how it allows you to define

00:16:43.970 --> 00:16:47.795
<v Speaker 0>Kubernetes clusters with great ergonomics, composability,

00:16:47.795 --> 00:16:49.155
<v Speaker 0>and extremely flexible.

00:16:50.435 --> 00:16:52.195
<v Speaker 0>Okay. Let's take a look.

00:16:52.915 --> 00:16:54.755
<v Speaker 0>So what I have here is a brand

00:16:54.755 --> 00:16:58.675
<v Speaker 0>new Pulumi project inside of my KubeCon directory.

00:16:59.860 --> 00:17:02.579
<v Speaker 0>It's configured for Kubernetes and TypeScript,

00:17:02.579 --> 00:17:04.260
<v Speaker 0>which means that it comes with the Pulumi

00:17:04.260 --> 00:17:07.859
<v Speaker 0>SDK, Kubernetes SDK, and some Kubernetes helpers.

00:17:09.460 --> 00:17:11.700
<v Speaker 0>In my own namespace, I have access to

00:17:11.700 --> 00:17:13.700
<v Speaker 0>all of the cluster API resources that have

00:17:13.700 --> 00:17:15.484
<v Speaker 0>already generated and published.

00:17:15.885 --> 00:17:17.405
<v Speaker 0>First thing I'm gonna do is just pull

00:17:17.405 --> 00:17:20.045
<v Speaker 0>in the cluster API generic package.

00:17:21.645 --> 00:17:23.485
<v Speaker 0>From here, we can open our index dot

00:17:23.485 --> 00:17:24.285
<v Speaker 0>TypeScript,

00:17:24.765 --> 00:17:26.204
<v Speaker 0>and we wanna import

00:17:26.845 --> 00:17:28.925
<v Speaker 0>star as copy

00:17:30.550 --> 00:17:31.110
<v Speaker 0>from

00:17:32.070 --> 00:17:33.350
<v Speaker 0>our new library.

00:17:35.110 --> 00:17:36.470
<v Speaker 0>Now one of the more

00:17:36.790 --> 00:17:39.190
<v Speaker 0>difficult things to automate with the cluster API

00:17:39.190 --> 00:17:41.110
<v Speaker 0>is that initial infrastructure

00:17:41.110 --> 00:17:41.670
<v Speaker 0>provision,

00:17:42.715 --> 00:17:44.315
<v Speaker 0>because the only way to do it is

00:17:44.315 --> 00:17:46.394
<v Speaker 0>through a cluster control in it dash dash

00:17:46.394 --> 00:17:47.034
<v Speaker 0>infrastructure

00:17:48.794 --> 00:17:49.834
<v Speaker 0>packet.

00:17:50.235 --> 00:17:52.955
<v Speaker 0>It then requires a secret to exist in

00:17:52.955 --> 00:17:53.914
<v Speaker 0>the environment

00:17:53.995 --> 00:17:56.394
<v Speaker 0>that tells the controllers how to speak to

00:17:56.394 --> 00:17:57.115
<v Speaker 0>the cloud provider.

00:17:58.330 --> 00:18:00.650
<v Speaker 0>Cluster control does not provide a way

00:18:01.290 --> 00:18:03.610
<v Speaker 0>to generate the YAML and store that for

00:18:03.610 --> 00:18:04.890
<v Speaker 0>a GitOps fashion.

00:18:05.770 --> 00:18:07.610
<v Speaker 0>However, the library I provided

00:18:07.850 --> 00:18:11.690
<v Speaker 0>does ship with helpers to initialize your provider

00:18:11.885 --> 00:18:13.965
<v Speaker 0>in your management cluster.

00:18:14.685 --> 00:18:16.125
<v Speaker 0>So the first thing we wanna do is

00:18:16.125 --> 00:18:18.125
<v Speaker 0>initialize the cluster API.

00:18:21.405 --> 00:18:23.725
<v Speaker 0>And we can do we can do that

00:18:23.805 --> 00:18:24.525
<v Speaker 0>through

00:18:24.605 --> 00:18:26.285
<v Speaker 0>a call to edit.

00:18:27.430 --> 00:18:28.070
<v Speaker 0>Now

00:18:28.310 --> 00:18:30.070
<v Speaker 0>one of the really nice things about working

00:18:30.070 --> 00:18:31.110
<v Speaker 0>with TypeScript

00:18:31.350 --> 00:18:33.430
<v Speaker 0>is that you don't need to know the

00:18:33.430 --> 00:18:35.030
<v Speaker 0>SDKs upfront

00:18:35.350 --> 00:18:38.470
<v Speaker 0>because the language server protocols are all really,

00:18:38.470 --> 00:18:39.429
<v Speaker 0>really good.

00:18:39.670 --> 00:18:41.350
<v Speaker 0>And in fact, I can just type copy

00:18:41.350 --> 00:18:41.750
<v Speaker 0>dot,

00:18:42.195 --> 00:18:44.274
<v Speaker 0>and already I can see the API space

00:18:44.274 --> 00:18:46.114
<v Speaker 0>that is available for me to use.

00:18:46.835 --> 00:18:48.755
<v Speaker 0>Now I'm not quite ready to create a

00:18:48.755 --> 00:18:49.394
<v Speaker 0>cluster.

00:18:49.715 --> 00:18:51.634
<v Speaker 0>I'm just gonna do init,

00:18:52.115 --> 00:18:54.595
<v Speaker 0>and I don't know what parameters this function

00:18:54.595 --> 00:18:55.315
<v Speaker 0>takes.

00:18:55.715 --> 00:18:57.394
<v Speaker 0>But I open my parameters, and I can

00:18:57.394 --> 00:18:58.809
<v Speaker 0>see, oh,

00:18:59.450 --> 00:19:02.330
<v Speaker 0>the inner function takes a cluster API

00:19:02.330 --> 00:19:03.370
<v Speaker 0>config.

00:19:04.330 --> 00:19:05.290
<v Speaker 0>Do

00:19:06.010 --> 00:19:08.170
<v Speaker 0>we know what a cluster API config is?

00:19:08.170 --> 00:19:08.730
<v Speaker 0>Well,

00:19:08.970 --> 00:19:09.530
<v Speaker 0>not yet.

00:19:10.875 --> 00:19:13.914
<v Speaker 0>But we can expand that, use our autocomplete,

00:19:13.915 --> 00:19:16.235
<v Speaker 0>and we can see, oh, it wants to

00:19:16.235 --> 00:19:18.634
<v Speaker 0>know whether we should install cert manager,

00:19:18.795 --> 00:19:20.715
<v Speaker 0>and if so, which version.

00:19:21.835 --> 00:19:23.755
<v Speaker 0>It also wants to know whether we want

00:19:23.755 --> 00:19:25.035
<v Speaker 0>to enable any of the feature.

00:19:27.389 --> 00:19:30.349
<v Speaker 0>And finally, it needs a Kubernetes provider.

00:19:31.149 --> 00:19:33.149
<v Speaker 0>So let's just quickly run through this one

00:19:33.149 --> 00:19:33.950
<v Speaker 0>by one.

00:19:35.309 --> 00:19:37.230
<v Speaker 0>When we did the cluster control in it

00:19:37.230 --> 00:19:39.549
<v Speaker 0>earlier, we did see that it installed cert

00:19:39.549 --> 00:19:41.465
<v Speaker 0>manager. In fact, it's required.

00:19:41.545 --> 00:19:42.105
<v Speaker 0>So

00:19:42.985 --> 00:19:46.345
<v Speaker 0>I'm just gonna say true. Yeah. Why not

00:19:46.345 --> 00:19:47.785
<v Speaker 0>install cert manager?

00:19:48.425 --> 00:19:49.545
<v Speaker 0>What version?

00:19:49.545 --> 00:19:50.105
<v Speaker 0>Well,

00:19:50.425 --> 00:19:52.105
<v Speaker 0>I already know that one one zero is

00:19:52.105 --> 00:19:53.785
<v Speaker 0>available, so I'm just gonna drop that straight

00:19:53.785 --> 00:19:55.880
<v Speaker 0>in. But you could find that from the

00:19:55.880 --> 00:19:58.759
<v Speaker 0>cost from the SERP manager GitHub repository.

00:19:59.800 --> 00:20:00.360
<v Speaker 0>Next.

00:20:00.760 --> 00:20:02.919
<v Speaker 0>Oh, feature case. Well,

00:20:03.320 --> 00:20:05.880
<v Speaker 0>we can hover over, and we know that

00:20:05.880 --> 00:20:08.040
<v Speaker 0>it expects a list of something called a

00:20:08.040 --> 00:20:10.674
<v Speaker 0>feature gate. So let's just pop open our

00:20:10.674 --> 00:20:11.554
<v Speaker 0>list and

00:20:12.034 --> 00:20:14.355
<v Speaker 0>click on feature gate, and we can see

00:20:14.355 --> 00:20:16.914
<v Speaker 0>there's two features available for us to enable.

00:20:17.554 --> 00:20:19.075
<v Speaker 0>We don't need to know what our machine

00:20:19.075 --> 00:20:20.595
<v Speaker 0>pool is yet, but I am gonna enable

00:20:20.595 --> 00:20:21.554
<v Speaker 0>cluster resource set.

00:20:22.230 --> 00:20:24.470
<v Speaker 0>Cluster resource sets are a way for you

00:20:24.470 --> 00:20:26.230
<v Speaker 0>to define manifest

00:20:26.230 --> 00:20:29.270
<v Speaker 0>to deploy to your new target clusters or

00:20:29.270 --> 00:20:31.350
<v Speaker 0>workload clusters when they become available.

00:20:32.150 --> 00:20:33.510
<v Speaker 0>It kinda like GitOps.

00:20:35.865 --> 00:20:38.585
<v Speaker 0>And finally, we need a Kubernetes

00:20:38.585 --> 00:20:39.385
<v Speaker 0>provider.

00:20:39.865 --> 00:20:42.185
<v Speaker 0>I'm gonna leave this blank for just a

00:20:42.185 --> 00:20:42.745
<v Speaker 0>moment.

00:20:43.145 --> 00:20:44.025
<v Speaker 0>And that's it.

00:20:44.905 --> 00:20:47.945
<v Speaker 0>That will enable the cluster API controllers on

00:20:47.945 --> 00:20:49.304
<v Speaker 0>my management cluster.

00:20:49.625 --> 00:20:50.105
<v Speaker 0>However,

00:20:50.880 --> 00:20:54.080
<v Speaker 0>I've not provided the dash dash infrastructure provider

00:20:54.080 --> 00:20:54.720
<v Speaker 0>yet.

00:20:54.880 --> 00:20:56.159
<v Speaker 0>Let's do that next.

00:20:57.280 --> 00:20:59.040
<v Speaker 0>So we're going to pull in one more

00:20:59.040 --> 00:20:59.440
<v Speaker 0>import.

00:21:05.825 --> 00:21:07.345
<v Speaker 0>We have to go to our package dot

00:21:07.345 --> 00:21:07.984
<v Speaker 0>JSON

00:21:09.265 --> 00:21:12.065
<v Speaker 0>and add one more package.

00:21:14.865 --> 00:21:18.304
<v Speaker 0>This time, I'm gonna add the packet

00:21:17.680 --> 00:21:18.640
<v Speaker 0>provider.

00:21:19.440 --> 00:21:21.360
<v Speaker 0>We can run a yarn install,

00:21:21.600 --> 00:21:23.520
<v Speaker 0>and that'll just take a moment.

00:21:28.400 --> 00:21:30.960
<v Speaker 0>Okay. Now we can come back and complete

00:21:30.960 --> 00:21:31.360
<v Speaker 0>this.

00:21:33.684 --> 00:21:36.084
<v Speaker 0>We're gonna pull in the packet provider.

00:21:36.725 --> 00:21:39.044
<v Speaker 0>Again, we don't know the API upfront,

00:21:39.605 --> 00:21:42.164
<v Speaker 0>but we can say packet copy equals

00:21:42.164 --> 00:21:43.284
<v Speaker 0>cap dot.

00:21:43.924 --> 00:21:45.924
<v Speaker 0>And again, we have the ability to create

00:21:45.924 --> 00:21:49.340
<v Speaker 0>a control plane or initialize the management cluster.

00:21:50.140 --> 00:21:52.619
<v Speaker 0>Just like before, it needs a config.

00:21:53.980 --> 00:21:55.820
<v Speaker 0>Okay. So let's take care of that API

00:21:55.820 --> 00:21:56.619
<v Speaker 0>key first.

00:21:56.940 --> 00:21:58.700
<v Speaker 0>One of the really great things about using

00:21:58.700 --> 00:22:01.175
<v Speaker 0>Pulumi for infrastructure as code is in built

00:22:01.175 --> 00:22:02.375
<v Speaker 0>secret management.

00:22:03.015 --> 00:22:05.175
<v Speaker 0>That means I can just see blank strength

00:22:05.175 --> 00:22:07.095
<v Speaker 0>for now, jump up to the top of

00:22:07.095 --> 00:22:08.855
<v Speaker 0>my file and import

00:22:09.495 --> 00:22:10.695
<v Speaker 0>the Pulumi

00:22:10.855 --> 00:22:11.495
<v Speaker 0>library.

00:22:13.039 --> 00:22:13.840
<v Speaker 0>From here,

00:22:14.399 --> 00:22:16.480
<v Speaker 0>I can create a new config object. I'm

00:22:16.480 --> 00:22:18.239
<v Speaker 0>gonna call this the config metal,

00:22:18.399 --> 00:22:20.159
<v Speaker 0>which is a new Pulumi

00:22:20.159 --> 00:22:21.119
<v Speaker 0>config

00:22:21.440 --> 00:22:23.600
<v Speaker 0>with a prefix of Equinix

00:22:23.600 --> 00:22:23.919
<v Speaker 0>metal.

00:22:25.455 --> 00:22:28.894
<v Speaker 0>I can then say here, config metal

00:22:28.894 --> 00:22:30.174
<v Speaker 0>dot require

00:22:30.654 --> 00:22:31.455
<v Speaker 0>secret

00:22:33.215 --> 00:22:34.014
<v Speaker 0>auth

00:22:35.135 --> 00:22:35.854
<v Speaker 0>token.

00:22:36.735 --> 00:22:37.294
<v Speaker 0>And that's it.

00:22:38.760 --> 00:22:41.480
<v Speaker 0>What's actually happening here is that our Pulumi

00:22:41.480 --> 00:22:44.120
<v Speaker 0>stack is configured with a secret provider.

00:22:44.520 --> 00:22:46.920
<v Speaker 0>That can be a cloud KMS from AWS,

00:22:46.920 --> 00:22:48.520
<v Speaker 0>GCP, or anywhere else,

00:22:49.080 --> 00:22:52.520
<v Speaker 0>or it can be a password protected local

00:22:52.520 --> 00:22:53.080
<v Speaker 0>provider.

00:22:54.425 --> 00:22:56.585
<v Speaker 0>I can open the Pulumi production environment, and

00:22:56.585 --> 00:22:59.065
<v Speaker 0>we see a prefix of Equinix metal, and

00:22:59.065 --> 00:23:01.144
<v Speaker 0>we see a key of off token.

00:23:01.385 --> 00:23:04.585
<v Speaker 0>And here, we have an encrypted version of

00:23:04.585 --> 00:23:05.865
<v Speaker 0>our API token,

00:23:06.345 --> 00:23:08.345
<v Speaker 0>which is all that has been consumed here.

00:23:11.820 --> 00:23:14.299
<v Speaker 0>Next, we need a cluster API.

00:23:14.780 --> 00:23:17.660
<v Speaker 0>What is that? Well, we can hover over

00:23:17.980 --> 00:23:20.220
<v Speaker 0>and see that it's just looking

00:23:20.620 --> 00:23:23.260
<v Speaker 0>for some providers that come from our CAPI

00:23:23.260 --> 00:23:25.835
<v Speaker 0>in it. Our copy in it actually returns

00:23:25.835 --> 00:23:27.354
<v Speaker 0>a set of manifest.

00:23:27.755 --> 00:23:30.955
<v Speaker 0>So from here, we can see cluster API

00:23:31.034 --> 00:23:32.634
<v Speaker 0>dot cluster API.

00:23:33.995 --> 00:23:36.075
<v Speaker 0>And finally, there is a Kubernetes

00:23:36.075 --> 00:23:36.635
<v Speaker 0>provider.

00:23:37.080 --> 00:23:39.159
<v Speaker 0>We ignored that above, but we're gonna take

00:23:39.159 --> 00:23:40.440
<v Speaker 0>care of it now.

00:23:41.240 --> 00:23:42.760
<v Speaker 1>So all we need to do is create

00:23:42.760 --> 00:23:44.039
<v Speaker 0>a new Kubernetes

00:23:44.039 --> 00:23:44.999
<v Speaker 0>provider.

00:23:46.440 --> 00:23:48.600
<v Speaker 0>For that, we import the Kubernetes

00:23:48.600 --> 00:23:49.159
<v Speaker 0>package,

00:23:54.165 --> 00:23:56.965
<v Speaker 0>And we can create a new, okay,

00:23:57.285 --> 00:23:58.164
<v Speaker 0>dot

00:23:58.565 --> 00:23:59.284
<v Speaker 0>provider.

00:24:03.045 --> 00:24:04.404
<v Speaker 0>We can see here

00:24:04.645 --> 00:24:05.684
<v Speaker 0>that it needs a name.

00:24:07.750 --> 00:24:09.830
<v Speaker 0>We'll just call this local.

00:24:11.510 --> 00:24:13.910
<v Speaker 0>Now we can add our Kubernetes provider

00:24:14.310 --> 00:24:15.350
<v Speaker 0>to both

00:24:15.670 --> 00:24:17.110
<v Speaker 0>of our innits,

00:24:17.925 --> 00:24:19.125
<v Speaker 0>and that is it.

00:24:20.165 --> 00:24:22.885
<v Speaker 0>Now we can run this Pulumi program

00:24:23.365 --> 00:24:25.925
<v Speaker 0>to provision cluster API controllers

00:24:26.245 --> 00:24:27.845
<v Speaker 0>to a Kubernetes cluster.

00:24:31.080 --> 00:24:33.160
<v Speaker 0>So, of course, I won't make you take

00:24:33.160 --> 00:24:34.279
<v Speaker 0>my word for it.

00:24:34.679 --> 00:24:36.119
<v Speaker 0>Let's actually run this.

00:24:36.679 --> 00:24:38.039
<v Speaker 0>We'll pop over here,

00:24:38.520 --> 00:24:41.320
<v Speaker 0>jump to the terminal, and we're gonna run

00:24:41.320 --> 00:24:42.279
<v Speaker 0>Lumi

00:24:42.760 --> 00:24:43.000
<v Speaker 0>app.

00:24:44.925 --> 00:24:47.085
<v Speaker 0>It's gonna work out from those functions that

00:24:47.085 --> 00:24:49.005
<v Speaker 0>we provided, which resource have to be created

00:24:49.005 --> 00:24:51.485
<v Speaker 0>within the management cluster. You can see there's

00:24:51.485 --> 00:24:52.285
<v Speaker 0>a fair few.

00:24:53.565 --> 00:24:54.845
<v Speaker 0>We can hit yes

00:24:55.325 --> 00:24:57.485
<v Speaker 0>and give it just a few moments,

00:24:57.725 --> 00:24:59.485
<v Speaker 0>and it will begin applying these

00:24:59.910 --> 00:25:01.110
<v Speaker 0>to the cluster.

00:25:02.470 --> 00:25:03.110
<v Speaker 0>Now

00:25:03.990 --> 00:25:06.549
<v Speaker 0>one of the things that Pulumi does is

00:25:07.190 --> 00:25:09.430
<v Speaker 0>try to ensure that what we apply will

00:25:09.430 --> 00:25:10.790
<v Speaker 0>actually become healthy.

00:25:11.110 --> 00:25:13.365
<v Speaker 0>That means that it's probably gonna sit there

00:25:13.365 --> 00:25:15.365
<v Speaker 0>for quite a while while it waits to

00:25:15.365 --> 00:25:17.525
<v Speaker 0>make sure that the deployments and the images

00:25:17.525 --> 00:25:19.765
<v Speaker 0>are pulled, the pods are passing all the

00:25:19.765 --> 00:25:22.325
<v Speaker 0>probes, the services have endpoints,

00:25:22.325 --> 00:25:23.925
<v Speaker 0>all of those little bits and pieces that

00:25:23.925 --> 00:25:26.405
<v Speaker 0>normally we just allow the Kubernetes reconciliation loop

00:25:26.405 --> 00:25:27.045
<v Speaker 0>to take care of.

00:25:28.280 --> 00:25:30.440
<v Speaker 0>So I'm just gonna click control c

00:25:32.200 --> 00:25:33.399
<v Speaker 0>couple of times.

00:25:34.840 --> 00:25:37.000
<v Speaker 0>And I'm gonna run get pods all.

00:25:40.455 --> 00:25:41.815
<v Speaker 0>Maybe. There we go.

00:25:42.775 --> 00:25:44.695
<v Speaker 0>We'll see we have cert manager,

00:25:44.775 --> 00:25:46.935
<v Speaker 0>and we have our CAPI controllers, and we

00:25:46.935 --> 00:25:50.135
<v Speaker 0>even have the packet controller manager.

00:25:50.775 --> 00:25:52.055
<v Speaker 0>Not quite ready yet,

00:25:53.200 --> 00:25:54.320
<v Speaker 0>but getting there.

00:25:55.360 --> 00:25:56.880
<v Speaker 0>And I control c that because I've not

00:25:56.880 --> 00:25:58.480
<v Speaker 0>fussed about it at a finish. I wanna

00:25:58.480 --> 00:26:01.440
<v Speaker 0>show you an alternative approach that may better

00:26:01.440 --> 00:26:02.880
<v Speaker 0>fit your workflow.

00:26:04.480 --> 00:26:06.640
<v Speaker 0>Okay. So let's jump back into our code.

00:26:07.695 --> 00:26:10.254
<v Speaker 0>And where we created our Kubernetes provider,

00:26:10.255 --> 00:26:12.254
<v Speaker 0>we're gonna make a few small tweaks.

00:26:13.054 --> 00:26:15.134
<v Speaker 0>We're gonna open up the arguments,

00:26:15.855 --> 00:26:17.615
<v Speaker 0>and we're gonna see that we have a

00:26:17.615 --> 00:26:19.135
<v Speaker 0>bunch of things that we can tweak with

00:26:19.135 --> 00:26:20.335
<v Speaker 0>a Kubernetes provider.

00:26:21.340 --> 00:26:24.059
<v Speaker 0>For one, it doesn't have to use whichever

00:26:24.059 --> 00:26:26.859
<v Speaker 0>context is available to me in the environment.

00:26:27.019 --> 00:26:29.179
<v Speaker 0>I can provide my own KubeConfig.

00:26:29.500 --> 00:26:31.740
<v Speaker 0>I can specify a namespace that I wanna

00:26:31.740 --> 00:26:32.699
<v Speaker 0>deploy to,

00:26:33.340 --> 00:26:34.299
<v Speaker 0>or

00:26:36.075 --> 00:26:37.514
<v Speaker 0>I can render YAML.

00:26:39.515 --> 00:26:40.634
<v Speaker 0>We can see

00:26:40.875 --> 00:26:42.554
<v Speaker 0>rendered YAML.

00:26:43.355 --> 00:26:45.914
<v Speaker 0>Now we can come to the command lane

00:26:48.235 --> 00:26:49.595
<v Speaker 0>and run Pulumi up.

00:26:50.940 --> 00:26:53.019
<v Speaker 0>And instead of reaching out to that cluster,

00:26:53.019 --> 00:26:54.620
<v Speaker 0>checking which resources exist,

00:26:54.620 --> 00:26:56.860
<v Speaker 0>waiting for health checks and services and add

00:26:56.860 --> 00:26:59.179
<v Speaker 0>endpoints and liveness probes to pass,

00:26:59.820 --> 00:27:02.539
<v Speaker 0>we can just click yes and allow Pulumi

00:27:02.539 --> 00:27:03.899
<v Speaker 0>to write a bunch of YAML

00:27:04.235 --> 00:27:05.434
<v Speaker 0>to a directory

00:27:05.595 --> 00:27:08.075
<v Speaker 0>that we can apply whenever we want.

00:27:08.955 --> 00:27:10.155
<v Speaker 0>Just that simple.

00:27:15.115 --> 00:27:16.155
<v Speaker 0>And that's it.

00:27:16.955 --> 00:27:19.200
<v Speaker 0>We can pop open Versus Code. We'll see

00:27:19.200 --> 00:27:21.759
<v Speaker 0>this brand new render YAML directory.

00:27:22.080 --> 00:27:23.679
<v Speaker 0>We can see the CRDs that need to

00:27:23.679 --> 00:27:25.039
<v Speaker 0>be applied to the cluster,

00:27:25.280 --> 00:27:27.440
<v Speaker 0>as well as all of the manifests with

00:27:27.440 --> 00:27:28.639
<v Speaker 0>all of the resources

00:27:28.720 --> 00:27:29.679
<v Speaker 0>that have to exist.

00:27:31.174 --> 00:27:33.414
<v Speaker 0>And that's not all. It was just the

00:27:33.414 --> 00:27:34.054
<v Speaker 0>beginning.

00:27:35.174 --> 00:27:36.934
<v Speaker 0>As well as installing

00:27:37.015 --> 00:27:39.815
<v Speaker 0>cluster API as the providers to our cluster,

00:27:40.294 --> 00:27:43.495
<v Speaker 0>we can add and layer on more abstractions

00:27:43.495 --> 00:27:45.590
<v Speaker 0>to make our lives easier. You can see

00:27:45.590 --> 00:27:48.710
<v Speaker 0>that there's already the ability to create a

00:27:48.710 --> 00:27:49.910
<v Speaker 0>control plane

00:27:50.470 --> 00:27:52.309
<v Speaker 0>on an Equinix Mineral cluster

00:27:53.030 --> 00:27:55.990
<v Speaker 0>that has the configuration options that an Equinix

00:27:55.990 --> 00:27:57.830
<v Speaker 0>Mineral customer would come to expect.

00:27:58.445 --> 00:28:01.005
<v Speaker 0>The project ID, the number of replicas, the

00:28:01.005 --> 00:28:03.565
<v Speaker 0>machine types, the facility, and the image.

00:28:04.525 --> 00:28:07.325
<v Speaker 0>And, of course, it's not Equinix Mineral specific.

00:28:07.325 --> 00:28:08.845
<v Speaker 0>And in fact, we can take a look

00:28:08.845 --> 00:28:09.725
<v Speaker 0>at CAPD,

00:28:09.965 --> 00:28:13.040
<v Speaker 0>which is the Digital Ocean provider. Again, using

00:28:13.040 --> 00:28:14.880
<v Speaker 0>just a simple edit command

00:28:15.040 --> 00:28:16.320
<v Speaker 0>and a config,

00:28:16.640 --> 00:28:18.960
<v Speaker 0>we can provide the access token, the cluster

00:28:18.960 --> 00:28:21.680
<v Speaker 0>API manifest, and the Kubernetes provider just like

00:28:21.680 --> 00:28:22.720
<v Speaker 0>we did earlier

00:28:23.200 --> 00:28:26.320
<v Speaker 0>to make Digital Ocean Kubernetes clusters available to

00:28:26.320 --> 00:28:27.520
<v Speaker 0>us on our management cluster.

00:28:28.535 --> 00:28:30.855
<v Speaker 0>There's no reason we can't support AWS,

00:28:30.855 --> 00:28:31.654
<v Speaker 0>GCP,

00:28:31.655 --> 00:28:33.735
<v Speaker 0>and all the other major cloud providers.

00:28:33.895 --> 00:28:35.975
<v Speaker 0>It just requires a little bit of effort

00:28:35.975 --> 00:28:37.975
<v Speaker 0>to put together these abstractions.

00:28:38.775 --> 00:28:39.095
<v Speaker 0>Okay.

00:28:39.910 --> 00:28:41.190
<v Speaker 0>Let's head back to the slides.

00:28:56.335 --> 00:28:57.054
<v Speaker 0>Okay.

00:28:58.015 --> 00:28:59.455
<v Speaker 0>So what's coming next?

00:29:00.975 --> 00:29:01.695
<v Speaker 0>Well,

00:29:02.015 --> 00:29:04.975
<v Speaker 0>the CDK8s is a really, really cool project.

00:29:05.054 --> 00:29:06.495
<v Speaker 0>It's it's very similar

00:29:06.880 --> 00:29:10.400
<v Speaker 0>to Pulumi in that it exposes a multi

00:29:10.400 --> 00:29:14.320
<v Speaker 0>language or runtime for defining and creating Kubernetes

00:29:14.320 --> 00:29:15.200
<v Speaker 0>resources.

00:29:16.400 --> 00:29:18.640
<v Speaker 0>Generating the types is actually a lot easier

00:29:18.640 --> 00:29:20.640
<v Speaker 0>with CDK's than it is in Pulumi. It

00:29:20.640 --> 00:29:22.240
<v Speaker 0>doesn't require an external command,

00:29:23.095 --> 00:29:25.335
<v Speaker 0>but there are some trade offs from both

00:29:25.335 --> 00:29:26.214
<v Speaker 0>approaches.

00:29:26.774 --> 00:29:28.695
<v Speaker 0>As we've seen with Pulumi, we can use

00:29:28.695 --> 00:29:32.054
<v Speaker 0>Pulumi's runtime to speak to the Kubernetes cluster

00:29:32.054 --> 00:29:33.494
<v Speaker 0>and do the apply.

00:29:34.054 --> 00:29:36.615
<v Speaker 0>This allows us to take advantage of Pulumi's

00:29:36.615 --> 00:29:38.215
<v Speaker 0>inbuilt secrets management.

00:29:39.090 --> 00:29:40.450
<v Speaker 0>This protects

00:29:40.770 --> 00:29:43.809
<v Speaker 0>our access tokens and API keys from being

00:29:43.809 --> 00:29:47.090
<v Speaker 0>rendered to YAML and available even ephemerally

00:29:47.090 --> 00:29:48.289
<v Speaker 0>in some location.

00:29:48.929 --> 00:29:50.450
<v Speaker 0>And c d case doesn't have that, just

00:29:50.450 --> 00:29:52.049
<v Speaker 0>as Pulumi doesn't have it when we render

00:29:52.049 --> 00:29:52.770
<v Speaker 0>to YAML too.

00:29:53.495 --> 00:29:55.175
<v Speaker 0>So it could be a good idea to

00:29:55.175 --> 00:29:56.855
<v Speaker 0>install and edit

00:29:57.095 --> 00:30:00.615
<v Speaker 0>the cluster API and the providers via Pulumi,

00:30:01.495 --> 00:30:04.055
<v Speaker 0>but then use c d kits and Pulumi's

00:30:04.055 --> 00:30:06.455
<v Speaker 0>abstractions to generate the YAML to define each

00:30:06.455 --> 00:30:07.415
<v Speaker 0>unique cluster.

00:30:08.520 --> 00:30:09.640
<v Speaker 0>That's up to you.

00:30:14.040 --> 00:30:16.680
<v Speaker 0>And I'd like to see more use of

00:30:16.680 --> 00:30:18.760
<v Speaker 0>Open Policy Agent for testing

00:30:18.920 --> 00:30:20.520
<v Speaker 0>the clusters that we are creating.

00:30:22.375 --> 00:30:24.855
<v Speaker 0>The Pulumi SDK that I provided

00:30:24.935 --> 00:30:27.815
<v Speaker 0>applies some basic tests to ensure

00:30:28.055 --> 00:30:30.055
<v Speaker 0>that all of the feature gates are interpolated

00:30:30.055 --> 00:30:32.215
<v Speaker 0>before they hit your management cluster.

00:30:32.375 --> 00:30:33.655
<v Speaker 0>But there's a lot more that we can

00:30:33.655 --> 00:30:34.215
<v Speaker 0>do there too.

00:30:35.740 --> 00:30:37.980
<v Speaker 0>And I'd like to see more providers. I'd

00:30:37.980 --> 00:30:40.139
<v Speaker 0>like types generated for AWS

00:30:40.299 --> 00:30:41.580
<v Speaker 0>and for GCP

00:30:41.580 --> 00:30:44.299
<v Speaker 0>and maybe even Oracle Cloud. Who knows?

00:30:47.419 --> 00:30:49.900
<v Speaker 0>And I think what we really need

00:30:50.485 --> 00:30:52.164
<v Speaker 0>is more abstractions,

00:30:53.284 --> 00:30:55.524
<v Speaker 0>more helper functions to create

00:30:55.764 --> 00:30:56.565
<v Speaker 0>unique

00:30:57.365 --> 00:30:58.884
<v Speaker 0>cluster configurations

00:30:59.044 --> 00:31:01.924
<v Speaker 0>for machine learning, for computer intensive workloads, for

00:31:01.924 --> 00:31:02.885
<v Speaker 0>stateful workloads,

00:31:03.570 --> 00:31:06.289
<v Speaker 0>more abstractions and higher level functions that can

00:31:06.289 --> 00:31:08.129
<v Speaker 0>make all of our lives easier.

00:31:10.529 --> 00:31:12.289
<v Speaker 0>One of the really cool things about cluster

00:31:12.289 --> 00:31:14.049
<v Speaker 0>API is cluster resources.

00:31:14.610 --> 00:31:16.929
<v Speaker 0>The ability in the management cluster to see

00:31:16.929 --> 00:31:19.914
<v Speaker 0>when we have a new healthy cluster created,

00:31:20.235 --> 00:31:21.514
<v Speaker 0>we should go and apply a set of

00:31:21.514 --> 00:31:22.234
<v Speaker 0>resources.

00:31:23.195 --> 00:31:25.594
<v Speaker 0>These are a little finicky to work with

00:31:25.754 --> 00:31:28.634
<v Speaker 0>because you have to actually encapsulate

00:31:28.794 --> 00:31:31.914
<v Speaker 0>the deployments, services, the conflict maps, the secrets

00:31:31.914 --> 00:31:34.840
<v Speaker 0>for those individual workloads into a config map

00:31:34.840 --> 00:31:35.639
<v Speaker 0>itself.

00:31:36.679 --> 00:31:39.799
<v Speaker 0>And this is exactly where abstractions like this

00:31:39.799 --> 00:31:41.239
<v Speaker 0>can make our lives easier.

00:31:44.120 --> 00:31:45.320
<v Speaker 0>So that's my talk.

00:31:45.880 --> 00:31:47.559
<v Speaker 0>I hope I've given you some food for

00:31:47.559 --> 00:31:47.799
<v Speaker 0>thought.

00:31:48.925 --> 00:31:51.565
<v Speaker 0>Not only does the tooling that I've shown

00:31:51.565 --> 00:31:53.085
<v Speaker 0>today for cluster API

00:31:54.045 --> 00:31:56.044
<v Speaker 0>exist and can better our lives,

00:31:56.205 --> 00:31:59.005
<v Speaker 0>but it's not confined to cluster API either.

00:31:59.165 --> 00:32:01.885
<v Speaker 0>There's no reason we can't use CDK and

00:32:01.885 --> 00:32:05.710
<v Speaker 0>Pulumi across our entire deployment surface for Kubernetes.

00:32:06.190 --> 00:32:07.950
<v Speaker 0>But there's still a lot to be done,

00:32:09.310 --> 00:32:10.990
<v Speaker 0>a lot of challenges to solve,

00:32:11.390 --> 00:32:12.910
<v Speaker 0>and a lot of things we can make

00:32:12.910 --> 00:32:13.630
<v Speaker 0>simpler.

00:32:14.990 --> 00:32:16.510
<v Speaker 0>I can't wait to see what you do

00:32:16.510 --> 00:32:16.910
<v Speaker 0>with it.

00:32:18.345 --> 00:32:19.945
<v Speaker 0>Best of luck. Have a great day.
