WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: a06ecc19-69dc-49bb-9f06-d86ffbf7f680
Created: 2025-04-29T14:45:46.480Z
Duration: 944.94257
Channels: 1

00:00:06.080 --> 00:00:06.800
<v Speaker 0>Hello,

00:00:07.120 --> 00:00:09.679
<v Speaker 0>and welcome back to the Rawkode Academy. My

00:00:09.679 --> 00:00:11.679
<v Speaker 0>name is David Flanagan, although you probably know

00:00:11.679 --> 00:00:12.719
<v Speaker 0>me as Rawkode.

00:00:13.805 --> 00:00:16.204
<v Speaker 0>And today, we're kicking off our new course,

00:00:16.204 --> 00:00:18.685
<v Speaker 0>the complete guide to Fermion Spin.

00:00:19.404 --> 00:00:22.125
<v Speaker 0>If you're not familiar, Spin is a framework

00:00:22.125 --> 00:00:23.884
<v Speaker 0>from the team at Fermion,

00:00:24.525 --> 00:00:26.925
<v Speaker 0>which allows you to write micro service applications

00:00:27.950 --> 00:00:29.630
<v Speaker 0>with a compilation target

00:00:29.630 --> 00:00:30.910
<v Speaker 0>of WebAssembly.

00:00:32.030 --> 00:00:34.750
<v Speaker 0>Now before we dive in to the different

00:00:34.750 --> 00:00:37.070
<v Speaker 0>SDKs and languages that you can write and

00:00:37.070 --> 00:00:38.990
<v Speaker 0>compile to WebAssembly web,

00:00:39.870 --> 00:00:41.405
<v Speaker 0>we're gonna spend a little bit of time

00:00:41.405 --> 00:00:43.405
<v Speaker 0>today understanding the why

00:00:43.565 --> 00:00:44.844
<v Speaker 0>of WebAssembly.

00:00:46.045 --> 00:00:48.524
<v Speaker 0>Why if you are a Rust developer,

00:00:48.605 --> 00:00:52.125
<v Speaker 0>TypeScript developer, Go developer, or any other developer,

00:00:52.940 --> 00:00:55.420
<v Speaker 0>should you care about using WebAssembly as a

00:00:55.420 --> 00:00:56.860
<v Speaker 0>target for your application?

00:00:57.980 --> 00:01:00.140
<v Speaker 0>And there are a few reasons.

00:01:00.620 --> 00:01:02.780
<v Speaker 0>And I hope that today's small demo

00:01:03.020 --> 00:01:05.180
<v Speaker 0>will set off a small chain reaction in

00:01:05.180 --> 00:01:05.980
<v Speaker 0>your mind

00:01:06.140 --> 00:01:08.300
<v Speaker 0>with an explosion of ideas

00:01:08.205 --> 00:01:10.605
<v Speaker 0>for your use case on WebAssembly.

00:01:12.605 --> 00:01:15.325
<v Speaker 0>So without further ado, let's dive in and

00:01:15.325 --> 00:01:17.805
<v Speaker 0>take a look at today's small code example

00:01:18.045 --> 00:01:21.165
<v Speaker 0>and why you should start looking at WebAssembly.

00:01:21.805 --> 00:01:22.685
<v Speaker 0>Let's dive right in.

00:01:23.810 --> 00:01:25.570
<v Speaker 0>So in order to show you why I

00:01:25.570 --> 00:01:27.650
<v Speaker 0>think WebAssembly is so important,

00:01:28.210 --> 00:01:30.930
<v Speaker 0>I have put together a small sample application.

00:01:31.890 --> 00:01:33.650
<v Speaker 0>Now the first thing to note is this

00:01:33.650 --> 00:01:35.330
<v Speaker 0>is not a life changing application.

00:01:36.035 --> 00:01:38.515
<v Speaker 0>This is not a production application.

00:01:38.915 --> 00:01:41.315
<v Speaker 0>This is a contrived example

00:01:41.635 --> 00:01:44.515
<v Speaker 0>that wants to show you how to consume

00:01:44.515 --> 00:01:46.035
<v Speaker 0>WebAssembly modules

00:01:46.995 --> 00:01:48.755
<v Speaker 0>across disparate systems.

00:01:50.200 --> 00:01:52.600
<v Speaker 0>Because the true value in WebAssembly comes from

00:01:52.600 --> 00:01:54.840
<v Speaker 0>the fact that we can choose to use

00:01:54.840 --> 00:01:56.680
<v Speaker 0>Rust for one part of our system,

00:01:57.080 --> 00:01:58.280
<v Speaker 0>Go in another,

00:01:58.600 --> 00:02:00.200
<v Speaker 0>JavaScript or TypeScript,

00:02:00.280 --> 00:02:01.000
<v Speaker 0>and so forth.

00:02:02.325 --> 00:02:05.125
<v Speaker 0>Now assuming you compile those to a WebAssembly

00:02:05.125 --> 00:02:05.845
<v Speaker 0>module,

00:02:06.244 --> 00:02:07.685
<v Speaker 0>they can be consumed

00:02:08.164 --> 00:02:11.125
<v Speaker 0>by a WebAssembly runtime or by other languages

00:02:11.125 --> 00:02:12.645
<v Speaker 0>that understand WebAssembly.

00:02:14.100 --> 00:02:17.140
<v Speaker 0>This means you get the ability to explore

00:02:17.140 --> 00:02:18.740
<v Speaker 0>and test new languages.

00:02:19.380 --> 00:02:21.940
<v Speaker 0>Use the correct language for the correct job.

00:02:23.220 --> 00:02:25.460
<v Speaker 0>Maybe the Rust is the right 190% of

00:02:25.460 --> 00:02:27.380
<v Speaker 0>the time, but there's still 10% where you

00:02:27.380 --> 00:02:29.300
<v Speaker 0>wanna fall back on JavaScript or Tensor.

00:02:30.475 --> 00:02:31.995
<v Speaker 0>There are times you want to use a

00:02:31.995 --> 00:02:34.715
<v Speaker 0>strongly typed language on the front end, like

00:02:34.715 --> 00:02:35.435
<v Speaker 0>Rust.

00:02:35.835 --> 00:02:37.995
<v Speaker 0>And these are all possible via the power

00:02:37.995 --> 00:02:39.035
<v Speaker 0>of WebAssembly.

00:02:40.395 --> 00:02:42.155
<v Speaker 0>In fact, Solomon Hicks,

00:02:42.939 --> 00:02:44.780
<v Speaker 0>the founder of Docker,

00:02:45.180 --> 00:02:48.300
<v Speaker 0>once said that if WebAssembly had existed,

00:02:49.019 --> 00:02:50.460
<v Speaker 0>Docker wouldn't.

00:02:51.579 --> 00:02:53.980
<v Speaker 0>He's saying that if WebAssembly

00:02:53.980 --> 00:02:56.299
<v Speaker 0>was a compilation target for applications,

00:02:56.735 --> 00:02:58.735
<v Speaker 0>we wouldn't need containers.

00:02:59.535 --> 00:03:01.535
<v Speaker 0>And that's a very powerful statement.

00:03:02.175 --> 00:03:05.455
<v Speaker 0>So let's dive into the contrived example

00:03:05.775 --> 00:03:07.375
<v Speaker 0>and see what I put together.

00:03:08.095 --> 00:03:08.415
<v Speaker 0>Okay.

00:03:09.159 --> 00:03:11.640
<v Speaker 0>First, we have the domain folder.

00:03:11.879 --> 00:03:13.879
<v Speaker 0>This is where we store the domain logic

00:03:13.879 --> 00:03:15.000
<v Speaker 0>for our application.

00:03:15.480 --> 00:03:18.040
<v Speaker 0>This is really common across most software teams

00:03:18.040 --> 00:03:20.840
<v Speaker 0>these days. Domain driven design has gathered a

00:03:20.840 --> 00:03:21.799
<v Speaker 0>lot of adoption

00:03:22.125 --> 00:03:24.364
<v Speaker 0>along with the various architectures which have spun

00:03:24.364 --> 00:03:25.485
<v Speaker 0>out of the movement.

00:03:26.845 --> 00:03:29.724
<v Speaker 0>It teaches us to build reusable components across

00:03:29.724 --> 00:03:31.805
<v Speaker 0>our domain using our domain language

00:03:32.125 --> 00:03:34.525
<v Speaker 0>and hopefully ensuring that you don't reimplement the

00:03:34.525 --> 00:03:35.165
<v Speaker 0>same thing twice.

00:03:36.849 --> 00:03:38.769
<v Speaker 0>This is often a challenge for companies that

00:03:38.769 --> 00:03:40.370
<v Speaker 0>want to have polyglot teams

00:03:40.530 --> 00:03:42.129
<v Speaker 0>because if you write your domain logic in

00:03:42.129 --> 00:03:43.890
<v Speaker 0>one language, how do you share it and

00:03:43.890 --> 00:03:45.010
<v Speaker 0>consume it in another?

00:03:45.489 --> 00:03:47.810
<v Speaker 0>This often leads to rather special test cases

00:03:47.810 --> 00:03:49.570
<v Speaker 0>to ensure that we have compliance

00:03:49.730 --> 00:03:51.250
<v Speaker 0>across multiple run times.

00:03:53.385 --> 00:03:54.745
<v Speaker 0>But with WebAssembly,

00:03:54.745 --> 00:03:56.265
<v Speaker 0>that concern disappears.

00:03:57.305 --> 00:03:58.825
<v Speaker 0>And I'm taking the domain that is hopefully

00:03:58.825 --> 00:04:00.825
<v Speaker 0>familiar to everybody watching this video.

00:04:01.545 --> 00:04:03.305
<v Speaker 0>Password validation.

00:04:04.185 --> 00:04:06.425
<v Speaker 0>Is the password that your customer or user

00:04:06.425 --> 00:04:07.225
<v Speaker 0>using

00:04:07.849 --> 00:04:10.730
<v Speaker 0>pass the constraints provided by your security team

00:04:11.209 --> 00:04:13.050
<v Speaker 0>across all of your applications?

00:04:15.049 --> 00:04:17.130
<v Speaker 0>So I've chosen to write this in Rust.

00:04:19.209 --> 00:04:21.289
<v Speaker 0>We have a constant defining the minimum length

00:04:21.289 --> 00:04:23.665
<v Speaker 0>for a password with 16 characters.

00:04:24.865 --> 00:04:27.505
<v Speaker 0>We have two error messages, password too short

00:04:27.505 --> 00:04:29.825
<v Speaker 0>and password no space, which give us the

00:04:29.825 --> 00:04:31.825
<v Speaker 0>error message if the password is too short

00:04:31.825 --> 00:04:33.105
<v Speaker 0>or has no space.

00:04:35.380 --> 00:04:37.860
<v Speaker 0>We then have a validate password function. Now

00:04:37.860 --> 00:04:39.940
<v Speaker 0>I kept this really small and simple for

00:04:39.940 --> 00:04:40.980
<v Speaker 0>today's demo,

00:04:41.620 --> 00:04:43.300
<v Speaker 0>but you may have more rules in your

00:04:43.300 --> 00:04:44.180
<v Speaker 0>production systems.

00:04:47.335 --> 00:04:48.935
<v Speaker 0>We receive the password,

00:04:49.255 --> 00:04:51.095
<v Speaker 0>and we return a result

00:04:52.935 --> 00:04:54.615
<v Speaker 0>or an error message.

00:04:56.695 --> 00:04:58.375
<v Speaker 0>If the length of the password is less

00:04:58.375 --> 00:05:00.710
<v Speaker 0>than password min length, we return an error

00:05:00.710 --> 00:05:01.350
<v Speaker 0>message.

00:05:02.230 --> 00:05:03.990
<v Speaker 0>And if it doesn't contain a space, we

00:05:03.990 --> 00:05:05.510
<v Speaker 0>return an error message.

00:05:06.310 --> 00:05:08.790
<v Speaker 0>Assuming both our constraints pass, we return our

00:05:08.790 --> 00:05:10.150
<v Speaker 0>okay response.

00:05:12.790 --> 00:05:15.004
<v Speaker 0>If we scroll down, you'll see we have

00:05:15.004 --> 00:05:16.044
<v Speaker 0>a test case.

00:05:16.444 --> 00:05:18.365
<v Speaker 0>I'm not gonna go through it, but it's

00:05:18.365 --> 00:05:21.165
<v Speaker 0>just making a few assertions against our function.

00:05:23.245 --> 00:05:26.365
<v Speaker 0>What's important here is that there is nothing

00:05:26.525 --> 00:05:28.764
<v Speaker 0>to tell you this is going to be

00:05:28.764 --> 00:05:29.564
<v Speaker 0>used on WebAssembly.

00:05:30.790 --> 00:05:33.510
<v Speaker 0>This is a Rust function using Rust types

00:05:33.510 --> 00:05:35.430
<v Speaker 0>and Rust paradigms.

00:05:37.830 --> 00:05:39.830
<v Speaker 0>This is the perfect example

00:05:41.510 --> 00:05:43.270
<v Speaker 0>of writing your domain logic

00:05:43.935 --> 00:05:46.414
<v Speaker 0>without truly understanding where it's going to end

00:05:46.414 --> 00:05:48.014
<v Speaker 0>up or be used.

00:05:49.055 --> 00:05:51.695
<v Speaker 0>Next, we have the Wasm crate.

00:05:52.175 --> 00:05:55.215
<v Speaker 0>This is our glue. This is what consumes

00:05:55.215 --> 00:05:56.895
<v Speaker 0>our domain logic

00:05:57.700 --> 00:05:59.540
<v Speaker 0>with a little bit of binding

00:05:59.700 --> 00:06:01.700
<v Speaker 0>to the WebAssembly module.

00:06:02.980 --> 00:06:05.940
<v Speaker 0>Now this first function is entirely optional,

00:06:06.020 --> 00:06:08.020
<v Speaker 0>but I wanna use it to show you

00:06:08.020 --> 00:06:10.900
<v Speaker 0>the interrupt between client side browser

00:06:11.060 --> 00:06:11.780
<v Speaker 0>and Rust.

00:06:14.605 --> 00:06:16.925
<v Speaker 0>Here, we're defining a function called main,

00:06:17.805 --> 00:06:20.125
<v Speaker 0>and we bind it using wasm bindgen to

00:06:20.125 --> 00:06:22.125
<v Speaker 0>run when our application has started.

00:06:24.150 --> 00:06:26.470
<v Speaker 0>We find the HTML DOM window,

00:06:26.870 --> 00:06:27.910
<v Speaker 0>the document,

00:06:28.310 --> 00:06:29.590
<v Speaker 0>and the body element.

00:06:29.910 --> 00:06:30.710
<v Speaker 0>From there,

00:06:31.030 --> 00:06:33.509
<v Speaker 0>we can actually write hello in your browser

00:06:33.509 --> 00:06:34.950
<v Speaker 0>and your browser.

00:06:35.669 --> 00:06:36.389
<v Speaker 0>Kinda neat.

00:06:38.025 --> 00:06:41.065
<v Speaker 0>Next, we want to expose our domain logic

00:06:41.065 --> 00:06:42.745
<v Speaker 0>via the Wasm bindings.

00:06:43.865 --> 00:06:45.785
<v Speaker 0>So we write a function

00:06:46.585 --> 00:06:48.104
<v Speaker 0>that calls our domain function.

00:06:49.220 --> 00:06:50.980
<v Speaker 0>Here we have wasm bindgen

00:06:51.140 --> 00:06:54.420
<v Speaker 0>validate password, which takes the string and returns

00:06:54.420 --> 00:06:55.460
<v Speaker 0>a result

00:06:56.660 --> 00:06:58.740
<v Speaker 0>or a JS value

00:06:58.740 --> 00:06:59.220
<v Speaker 0>error.

00:07:01.055 --> 00:07:03.775
<v Speaker 0>Next, we can just call our Rust function,

00:07:03.775 --> 00:07:07.695
<v Speaker 0>the validate password function, passing in our password.

00:07:08.574 --> 00:07:10.974
<v Speaker 0>Now because our domain logic returns a string

00:07:10.974 --> 00:07:11.775
<v Speaker 0>error,

00:07:11.775 --> 00:07:13.775
<v Speaker 0>we do need to map this to a

00:07:13.775 --> 00:07:14.574
<v Speaker 0>JS value.

00:07:15.730 --> 00:07:17.730
<v Speaker 0>And we do so like this.

00:07:18.290 --> 00:07:20.450
<v Speaker 0>Rust provides a map error function,

00:07:20.610 --> 00:07:22.690
<v Speaker 0>which takes the original value

00:07:22.850 --> 00:07:24.850
<v Speaker 0>and returns a different value.

00:07:25.970 --> 00:07:27.090
<v Speaker 0>Nice and simple.

00:07:28.755 --> 00:07:29.635
<v Speaker 0>From here,

00:07:31.074 --> 00:07:33.315
<v Speaker 0>we can compile our Wasm create,

00:07:34.354 --> 00:07:37.795
<v Speaker 0>and we have two pieces of reusable information.

00:07:38.995 --> 00:07:42.080
<v Speaker 0>Any other Rust service or application that we

00:07:42.080 --> 00:07:44.960
<v Speaker 0>build can consume our domain create just as

00:07:44.960 --> 00:07:46.960
<v Speaker 0>if it was another Rust create because it

00:07:46.960 --> 00:07:48.560
<v Speaker 0>is just another Rust create.

00:07:49.439 --> 00:07:52.960
<v Speaker 0>And any application that runs or supports WebAssembly

00:07:53.254 --> 00:07:55.574
<v Speaker 0>can pull in our WebAssembly module,

00:07:55.815 --> 00:07:58.055
<v Speaker 0>which just so happens to consume some of

00:07:58.055 --> 00:07:59.495
<v Speaker 0>our domain logic.

00:08:00.055 --> 00:08:02.215
<v Speaker 0>And you can expand on this as much

00:08:02.215 --> 00:08:04.215
<v Speaker 0>as you need and share as much of

00:08:04.215 --> 00:08:06.775
<v Speaker 0>that agnostic domain logic as you need across

00:08:06.775 --> 00:08:07.895
<v Speaker 0>all of your services.

00:08:09.810 --> 00:08:11.330
<v Speaker 0>So let's consume

00:08:12.129 --> 00:08:15.729
<v Speaker 0>our domain logic from a Fermion Spin application.

00:08:23.105 --> 00:08:24.945
<v Speaker 0>I've chosen to write this in Rust so

00:08:24.945 --> 00:08:26.385
<v Speaker 0>that we can see the Rust and Rust

00:08:26.385 --> 00:08:27.345
<v Speaker 0>interrupt.

00:08:27.665 --> 00:08:29.665
<v Speaker 0>Although, I should definitely point out that Fermion

00:08:29.665 --> 00:08:33.105
<v Speaker 0>Spin applications are compiled to a WebAssembly module.

00:08:33.665 --> 00:08:35.424
<v Speaker 0>Because of that and because our domain is

00:08:35.424 --> 00:08:37.505
<v Speaker 0>written in Rust, we don't need to consume

00:08:37.505 --> 00:08:39.820
<v Speaker 0>our domain logic as a WebAssembly module. We

00:08:39.820 --> 00:08:41.580
<v Speaker 0>can consume it as a Rust module, which

00:08:41.580 --> 00:08:43.580
<v Speaker 0>is still gonna be compiled to a WebAssembly

00:08:43.580 --> 00:08:44.300
<v Speaker 0>target.

00:08:45.020 --> 00:08:45.900
<v Speaker 0>Pretty cool.

00:08:48.220 --> 00:08:49.820
<v Speaker 0>Here we have

00:08:50.875 --> 00:08:53.194
<v Speaker 0>a macro that sets up our back end

00:08:53.194 --> 00:08:55.915
<v Speaker 0>function as an HTTP component on Fermion Spin

00:08:55.915 --> 00:08:56.875
<v Speaker 0>framework.

00:08:57.595 --> 00:08:59.435
<v Speaker 0>This just means that when request come in,

00:08:59.435 --> 00:09:01.194
<v Speaker 0>they can be routed to this back end

00:09:01.194 --> 00:09:01.915
<v Speaker 0>function.

00:09:02.555 --> 00:09:04.555
<v Speaker 0>And you'll see it takes a request input

00:09:04.555 --> 00:09:05.035
<v Speaker 0>parameter.

00:09:06.460 --> 00:09:09.020
<v Speaker 0>And all it expects is a result response.

00:09:10.460 --> 00:09:11.900
<v Speaker 0>Now we've got a little bit of tape

00:09:11.900 --> 00:09:13.740
<v Speaker 0>juggling to do to fetch the body from

00:09:13.740 --> 00:09:14.620
<v Speaker 0>this request,

00:09:15.180 --> 00:09:16.860
<v Speaker 0>but we can grab the base,

00:09:17.660 --> 00:09:18.940
<v Speaker 0>coerce it into a string,

00:09:20.275 --> 00:09:23.075
<v Speaker 0>and then call a validate password

00:09:23.075 --> 00:09:23.715
<v Speaker 0>function.

00:09:25.955 --> 00:09:28.115
<v Speaker 0>If we get an okay response, we return

00:09:28.115 --> 00:09:30.035
<v Speaker 0>a 200 okay. And if we get an

00:09:30.035 --> 00:09:32.195
<v Speaker 0>error message, we return a four zero one

00:09:32.195 --> 00:09:33.395
<v Speaker 0>with the error message.

00:09:34.450 --> 00:09:36.370
<v Speaker 0>Now let me click through to our validate

00:09:36.370 --> 00:09:37.089
<v Speaker 0>function.

00:09:37.250 --> 00:09:38.290
<v Speaker 0>This is

00:09:38.450 --> 00:09:40.210
<v Speaker 0>our nonspecific,

00:09:40.290 --> 00:09:41.970
<v Speaker 0>non WebAssembly knowledge,

00:09:42.690 --> 00:09:44.770
<v Speaker 0>straight up pure Rust

00:09:45.089 --> 00:09:45.490
<v Speaker 0>function.

00:09:47.725 --> 00:09:50.845
<v Speaker 0>So let's run our back end service.

00:09:52.125 --> 00:09:54.685
<v Speaker 0>So let's run spin build,

00:09:55.245 --> 00:09:56.765
<v Speaker 0>followed by spin up

00:09:57.645 --> 00:09:59.485
<v Speaker 0>and follow all to get the logs.

00:10:06.650 --> 00:10:09.450
<v Speaker 0>Now I provide a small HARL test suite,

00:10:09.450 --> 00:10:10.570
<v Speaker 0>which we can run

00:10:12.170 --> 00:10:12.810
<v Speaker 0>like so.

00:10:14.695 --> 00:10:16.535
<v Speaker 0>You'll see that two requests were made against

00:10:16.535 --> 00:10:17.815
<v Speaker 0>our back end API

00:10:18.214 --> 00:10:19.575
<v Speaker 0>and both succeeded.

00:10:19.894 --> 00:10:22.375
<v Speaker 0>What does our HARL test suite look like?

00:10:27.575 --> 00:10:29.890
<v Speaker 0>One, we send a post request to local

00:10:29.890 --> 00:10:31.170
<v Speaker 0>host 3,000

00:10:33.250 --> 00:10:35.490
<v Speaker 0>and the password is the full string and

00:10:35.490 --> 00:10:38.050
<v Speaker 0>the code block. Password space one two three

00:10:38.050 --> 00:10:39.810
<v Speaker 0>space password space one two three.

00:10:40.705 --> 00:10:43.105
<v Speaker 0>This will satisfy both our constraints.

00:10:43.265 --> 00:10:45.425
<v Speaker 0>One, that it's at least 16 characters and

00:10:45.425 --> 00:10:47.825
<v Speaker 0>two, that has at least one space.

00:10:50.785 --> 00:10:53.905
<v Speaker 0>Our second assertion is another post to localhost:one

00:10:53.905 --> 00:10:54.625
<v Speaker 0>3000

00:10:55.100 --> 00:10:57.820
<v Speaker 0>And this time the password is password space.

00:10:58.460 --> 00:11:00.460
<v Speaker 0>So we pass the space constraint,

00:11:00.620 --> 00:11:02.220
<v Speaker 0>but not the 16

00:11:02.220 --> 00:11:03.100
<v Speaker 0>characters.

00:11:03.740 --> 00:11:05.420
<v Speaker 0>And this should return

00:11:06.140 --> 00:11:07.020
<v Speaker 0>a photo one.

00:11:08.175 --> 00:11:10.654
<v Speaker 0>And we can confirm by running Hurl one

00:11:10.654 --> 00:11:11.375
<v Speaker 0>more time.

00:11:13.135 --> 00:11:15.375
<v Speaker 0>Remove the dash dash test, and we will

00:11:15.375 --> 00:11:17.135
<v Speaker 0>get the output from the function or the

00:11:17.135 --> 00:11:18.495
<v Speaker 0>assertion that fails.

00:11:18.735 --> 00:11:20.894
<v Speaker 0>And the error message is the password must

00:11:20.894 --> 00:11:22.815
<v Speaker 0>contain at least 16 characters.

00:11:24.390 --> 00:11:25.110
<v Speaker 0>Perfect.

00:11:26.310 --> 00:11:27.750
<v Speaker 0>And for the last demo,

00:11:27.990 --> 00:11:31.270
<v Speaker 0>I'm going to consume the wasm trait. This

00:11:31.270 --> 00:11:34.550
<v Speaker 0>is a domain logic compiled and exposed via

00:11:34.550 --> 00:11:35.270
<v Speaker 0>WebAssembly.

00:11:37.435 --> 00:11:40.155
<v Speaker 0>This time being consumed by a JavaScript function.

00:11:40.715 --> 00:11:41.355
<v Speaker 0>Here,

00:11:42.075 --> 00:11:44.155
<v Speaker 0>with the right webpack configuration,

00:11:46.555 --> 00:11:49.355
<v Speaker 0>you can just pull in a WASM package.

00:11:51.090 --> 00:11:53.970
<v Speaker 0>So here, we're importing a WASM package like

00:11:53.970 --> 00:11:56.370
<v Speaker 0>any other Node JS dependency.

00:11:56.850 --> 00:11:58.690
<v Speaker 0>We use a promise so that after the

00:11:58.690 --> 00:12:01.570
<v Speaker 0>module is loaded, we call the validate password

00:12:01.570 --> 00:12:04.050
<v Speaker 0>function, and we pass it a password. In

00:12:04.050 --> 00:12:04.850
<v Speaker 0>this case,

00:12:05.250 --> 00:12:05.730
<v Speaker 0>password.

00:12:07.625 --> 00:12:10.105
<v Speaker 0>So now we can run this front end

00:12:10.345 --> 00:12:11.065
<v Speaker 0>application

00:12:11.865 --> 00:12:13.144
<v Speaker 0>and see it work.

00:12:14.345 --> 00:12:15.865
<v Speaker 0>We can run NPM,

00:12:17.625 --> 00:12:18.345
<v Speaker 0>run build,

00:12:21.329 --> 00:12:22.769
<v Speaker 0>followed by NPM,

00:12:23.649 --> 00:12:24.610
<v Speaker 0>run start.

00:12:26.050 --> 00:12:28.450
<v Speaker 0>This runs the webpack dev server,

00:12:28.850 --> 00:12:31.250
<v Speaker 0>which we can browse to in our browser.

00:12:32.769 --> 00:12:33.970
<v Speaker 0>So let's pop open

00:12:34.769 --> 00:12:35.410
<v Speaker 0>80 80.

00:12:37.425 --> 00:12:40.464
<v Speaker 0>And first, we see the string from our

00:12:40.464 --> 00:12:41.185
<v Speaker 0>Rust

00:12:41.824 --> 00:12:43.985
<v Speaker 0>compiled WebAssembly application.

00:12:46.625 --> 00:12:48.944
<v Speaker 0>If we take a look at index.HTML,

00:12:52.840 --> 00:12:54.200
<v Speaker 0>We actually don't

00:12:54.360 --> 00:12:56.360
<v Speaker 0>print out anything in the body of our

00:12:56.360 --> 00:12:57.240
<v Speaker 0>HTML.

00:12:58.200 --> 00:13:00.040
<v Speaker 0>So only by browsing to this

00:13:01.000 --> 00:13:03.640
<v Speaker 0>is the hello in your browser injected.

00:13:04.280 --> 00:13:06.200
<v Speaker 0>So let's pop open our dev tools.

00:13:08.325 --> 00:13:10.165
<v Speaker 0>And if we go to the console, you'll

00:13:10.165 --> 00:13:10.805
<v Speaker 0>see

00:13:11.525 --> 00:13:13.685
<v Speaker 0>that the password must be at least 16

00:13:13.685 --> 00:13:14.405
<v Speaker 0>characters.

00:13:14.725 --> 00:13:17.205
<v Speaker 0>Now I am no front end web developer.

00:13:17.605 --> 00:13:19.285
<v Speaker 0>To me, a good UI is in the

00:13:19.285 --> 00:13:20.085
<v Speaker 0>CLI.

00:13:20.085 --> 00:13:22.720
<v Speaker 0>However, we wanna show a demo today.

00:13:23.200 --> 00:13:25.840
<v Speaker 0>So we're gonna go back to our application

00:13:26.480 --> 00:13:28.800
<v Speaker 0>and modify the JavaScript code.

00:13:30.000 --> 00:13:32.000
<v Speaker 0>And this time, I'll make sure the password

00:13:32.000 --> 00:13:32.960
<v Speaker 0>passes

00:13:33.120 --> 00:13:34.240
<v Speaker 0>the constraints

00:13:34.320 --> 00:13:35.120
<v Speaker 0>and hit save.

00:13:36.454 --> 00:13:38.774
<v Speaker 0>Now the webpack web dev server will have

00:13:38.774 --> 00:13:41.735
<v Speaker 0>reloaded our application in the background, which internal

00:13:41.735 --> 00:13:42.695
<v Speaker 0>have reloaded

00:13:42.935 --> 00:13:43.975
<v Speaker 0>our browser.

00:13:44.295 --> 00:13:46.055
<v Speaker 0>And already, we can see the error message

00:13:46.055 --> 00:13:47.894
<v Speaker 0>about our password constraints is gone.

00:13:49.260 --> 00:13:51.339
<v Speaker 0>And one more time, we'll make it fail,

00:13:51.500 --> 00:13:53.180
<v Speaker 0>hit save, and jump back,

00:13:53.420 --> 00:13:55.420
<v Speaker 0>and the reload we caught just in time.

00:13:56.380 --> 00:13:58.540
<v Speaker 0>So from our front end application

00:13:59.420 --> 00:14:01.019
<v Speaker 0>and pure JavaScript,

00:14:01.019 --> 00:14:03.885
<v Speaker 0>we're able to consume our domain logic written

00:14:03.885 --> 00:14:04.685
<v Speaker 0>in Rust,

00:14:04.925 --> 00:14:07.005
<v Speaker 0>which is compiled to WebAssembly.

00:14:07.805 --> 00:14:10.445
<v Speaker 0>And that is the power of WebAssembly.

00:14:11.405 --> 00:14:13.165
<v Speaker 0>And that's all we're gonna cover in this

00:14:13.165 --> 00:14:15.565
<v Speaker 0>first video. I hope this piques your interest

00:14:15.565 --> 00:14:17.405
<v Speaker 0>in WebAssembly and you want to learn more.

00:14:18.630 --> 00:14:20.630
<v Speaker 0>In future segments of this course, we'll be

00:14:20.630 --> 00:14:22.630
<v Speaker 0>taking a look at all the SDKs provided

00:14:22.630 --> 00:14:23.589
<v Speaker 0>by Spin.

00:14:24.149 --> 00:14:25.350
<v Speaker 0>That is Rust,

00:14:25.589 --> 00:14:27.029
<v Speaker 0>TypeScript and JavaScript,

00:14:27.510 --> 00:14:28.390
<v Speaker 0>and Go.

00:14:29.350 --> 00:14:31.510
<v Speaker 0>We may even get a sneak preview

00:14:31.510 --> 00:14:33.894
<v Speaker 0>of the new Python SDK.

00:14:34.375 --> 00:14:35.654
<v Speaker 0>I'm not even sure if I'm allowed to

00:14:35.654 --> 00:14:36.375
<v Speaker 0>say that.

00:14:38.295 --> 00:14:40.535
<v Speaker 0>After we have covered the SDKs, we're going

00:14:40.535 --> 00:14:43.415
<v Speaker 0>to build some real world applications using Fermion

00:14:43.415 --> 00:14:46.454
<v Speaker 0>Spin. One, a Google Analytics replacement.

00:14:47.380 --> 00:14:50.180
<v Speaker 0>Not completely, but enough to get analytics from

00:14:50.180 --> 00:14:52.339
<v Speaker 0>the front end application stored into a database

00:14:52.339 --> 00:14:53.380
<v Speaker 0>on the back end.

00:14:54.339 --> 00:14:56.100
<v Speaker 0>This should show us what a full three

00:14:56.100 --> 00:14:58.740
<v Speaker 0>tier application looks like in the real world.

00:14:59.555 --> 00:15:01.635
<v Speaker 0>And because we're deploying it as web assembly

00:15:01.635 --> 00:15:02.995
<v Speaker 0>on Fermion Cloud,

00:15:03.875 --> 00:15:06.275
<v Speaker 0>we get almost infinite scale

00:15:06.835 --> 00:15:09.955
<v Speaker 0>with sub millisecond startup times for was in

00:15:09.955 --> 00:15:10.755
<v Speaker 0>binaries.

00:15:11.075 --> 00:15:13.635
<v Speaker 0>And the second application we will build

00:15:14.240 --> 00:15:15.840
<v Speaker 0>is an uptime checker.

00:15:17.360 --> 00:15:18.800
<v Speaker 0>Using WebAssembly,

00:15:19.040 --> 00:15:21.839
<v Speaker 0>we can make HTTP requests to check the

00:15:21.839 --> 00:15:24.000
<v Speaker 0>status of our website. We can run this

00:15:24.000 --> 00:15:25.520
<v Speaker 0>on a regular cadence

00:15:25.520 --> 00:15:26.960
<v Speaker 0>and send notifications

00:15:26.960 --> 00:15:28.480
<v Speaker 0>if our website fails to check.

00:15:29.945 --> 00:15:31.705
<v Speaker 0>So I hope you'll join us for the

00:15:31.705 --> 00:15:34.025
<v Speaker 0>next parts of this complete guide to Fermion

00:15:34.025 --> 00:15:34.665
<v Speaker 0>Spin.

00:15:34.905 --> 00:15:37.145
<v Speaker 0>Until then, I'll see you next time.

00:15:37.465 --> 00:15:38.265
<v Speaker 0>Have a great day.
