WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 362d4afe-8427-471c-a050-0a8544b42fe3
Created: 2025-04-29T20:58:07.713Z
Duration: 4745.039
Channels: 1

00:01:07.480 --> 00:01:10.520
<v Speaker 0>Hello. Welcome to today's episode of Rawkode live.

00:01:10.545 --> 00:01:12.225
<v Speaker 0>I'm your host, Rawkode.

00:01:12.545 --> 00:01:14.784
<v Speaker 0>Today, we're gonna be taking a bit of

00:01:14.784 --> 00:01:17.104
<v Speaker 0>a look at the Rust programming language. We're

00:01:17.104 --> 00:01:19.265
<v Speaker 0>gonna be doing a few exercises and walking

00:01:19.265 --> 00:01:20.784
<v Speaker 0>through everything you need to know to start

00:01:20.784 --> 00:01:22.064
<v Speaker 0>writing Rust yourself.

00:01:22.545 --> 00:01:25.450
<v Speaker 0>Today, I am joined by Steve Klabik. He

00:01:25.450 --> 00:01:26.410
<v Speaker 0>is a

00:01:26.650 --> 00:01:29.130
<v Speaker 0>co author of the Rust programming language,

00:01:29.690 --> 00:01:31.770
<v Speaker 0>an engineer at Oxford Computers,

00:01:31.770 --> 00:01:33.530
<v Speaker 0>and a core team member of the Rust

00:01:33.530 --> 00:01:36.250
<v Speaker 0>project itself. Hey, Steve. How are you? Hey.

00:01:36.250 --> 00:01:38.854
<v Speaker 1>Doing well. How about yourself? Very well. Thank

00:01:38.854 --> 00:01:40.454
<v Speaker 0>you. It's almost at the end of my

00:01:40.454 --> 00:01:42.134
<v Speaker 0>day. I believe it's more towards the start

00:01:42.134 --> 00:01:44.375
<v Speaker 0>of your day. Spread at noon here. So

00:01:44.695 --> 00:01:46.534
<v Speaker 1>Right right smack in the middle. Awesome.

00:01:47.735 --> 00:01:49.414
<v Speaker 0>So do you wanna just give us the

00:01:49.414 --> 00:01:51.575
<v Speaker 0>quick thirty second version about who you are

00:01:51.575 --> 00:01:54.390
<v Speaker 0>and then we'll dive into today's session. Yeah.

00:01:54.390 --> 00:01:56.630
<v Speaker 1>Totally. So I've been I've been using Rust

00:01:56.630 --> 00:01:58.230
<v Speaker 1>for something like seven or eight years now,

00:01:58.230 --> 00:02:00.870
<v Speaker 1>pretty well before Rust one point o. And

00:02:00.870 --> 00:02:02.630
<v Speaker 1>I I really love the language, so I

00:02:02.630 --> 00:02:03.350
<v Speaker 1>ended up

00:02:03.750 --> 00:02:05.270
<v Speaker 1>being one of the first people to write

00:02:05.270 --> 00:02:06.549
<v Speaker 1>a tutorial from it

00:02:06.870 --> 00:02:08.229
<v Speaker 1>and

00:02:07.715 --> 00:02:09.715
<v Speaker 1>kinda just, like, went from there. And now

00:02:09.875 --> 00:02:11.875
<v Speaker 1>years later, it's, what I do all the

00:02:11.875 --> 00:02:13.474
<v Speaker 1>time. So it's been really cool to watch

00:02:13.474 --> 00:02:15.795
<v Speaker 1>a language go from, like, 30 people in

00:02:15.795 --> 00:02:17.475
<v Speaker 1>an IRC room to

00:02:17.635 --> 00:02:20.035
<v Speaker 1>literally being used by the largest technology companies

00:02:20.035 --> 00:02:21.235
<v Speaker 1>in the world to get all sorts of

00:02:21.235 --> 00:02:22.035
<v Speaker 1>stuff done.

00:02:22.515 --> 00:02:24.310
<v Speaker 1>And, yeah, my focus has traditionally been on,

00:02:24.310 --> 00:02:27.270
<v Speaker 1>like, documentation and teaching people and doing stuff

00:02:27.270 --> 00:02:29.110
<v Speaker 1>like that. So as you said, I coauthored

00:02:29.110 --> 00:02:30.870
<v Speaker 1>the the book, which is the Rust programming

00:02:30.870 --> 00:02:32.870
<v Speaker 1>language, which is kind of the the default

00:02:32.870 --> 00:02:35.030
<v Speaker 1>book for learning Rust, and I run the

00:02:35.030 --> 00:02:37.270
<v Speaker 1>beginner Rust training at Rust conf and do

00:02:37.270 --> 00:02:38.390
<v Speaker 1>all that kind of stuff. So

00:02:39.325 --> 00:02:40.285
<v Speaker 1>yeah. Totally.

00:02:40.445 --> 00:02:41.165
<v Speaker 1>Nice.

00:02:41.405 --> 00:02:43.565
<v Speaker 1>Oxide Computer Company is a place that I

00:02:43.565 --> 00:02:45.885
<v Speaker 1>work using Rust to do embedded stuff. We're

00:02:45.885 --> 00:02:46.925
<v Speaker 1>building some servers.

00:02:47.325 --> 00:02:47.805
<v Speaker 1>And

00:02:48.205 --> 00:02:49.805
<v Speaker 1>So that's what I'm doing, my my day

00:02:49.805 --> 00:02:50.285
<v Speaker 1>job now.

00:02:51.090 --> 00:02:52.850
<v Speaker 0>Nice. I like the t shirts. They're pretty

00:02:52.850 --> 00:02:54.130
<v Speaker 0>sweet. Yeah. Thanks. I

00:02:55.650 --> 00:02:56.210
<v Speaker 0>think

00:02:56.450 --> 00:02:58.290
<v Speaker 0>oh, I am so excited by this session

00:02:58.290 --> 00:03:00.290
<v Speaker 0>is that Rust just seems to be

00:03:00.690 --> 00:03:03.010
<v Speaker 0>everywhere now. Right? Like, I mean, I kept

00:03:03.010 --> 00:03:04.370
<v Speaker 0>an eye on it a few years ago,

00:03:04.370 --> 00:03:06.290
<v Speaker 0>and you could see it growing in popularity.

00:03:07.495 --> 00:03:09.975
<v Speaker 0>I I think everywhere I look though, there's

00:03:09.975 --> 00:03:11.815
<v Speaker 0>either people that are writing Rust or people

00:03:11.815 --> 00:03:13.575
<v Speaker 0>that just want to write Rust.

00:03:13.815 --> 00:03:16.695
<v Speaker 0>And I think it's just so available these

00:03:16.695 --> 00:03:17.895
<v Speaker 0>days. I see a lot of really cool

00:03:17.895 --> 00:03:18.935
<v Speaker 0>stuff with WebAssembly.

00:03:19.340 --> 00:03:20.780
<v Speaker 0>I see a lot of people doing embedded

00:03:20.780 --> 00:03:22.379
<v Speaker 0>systems, something that I think you're working on

00:03:22.379 --> 00:03:24.299
<v Speaker 0>now. And then even as far as actor

00:03:24.299 --> 00:03:26.540
<v Speaker 0>based systems and web based systems, Rust just

00:03:26.540 --> 00:03:27.660
<v Speaker 0>seems to be sweeping.

00:03:28.140 --> 00:03:29.340
<v Speaker 0>And it seems to be such a popular

00:03:29.340 --> 00:03:30.780
<v Speaker 0>choice no matter what the domain is.

00:03:32.424 --> 00:03:34.504
<v Speaker 0>Yeah. I I don't know. Can you explain

00:03:34.504 --> 00:03:38.425
<v Speaker 0>that? Like Totally. Why is Rust so popular?

00:03:38.745 --> 00:03:40.504
<v Speaker 1>I think there's a couple of different things.

00:03:40.504 --> 00:03:43.305
<v Speaker 1>So what initially drove me towards Rust was

00:03:43.305 --> 00:03:43.865
<v Speaker 1>that

00:03:44.105 --> 00:03:45.864
<v Speaker 1>I've I really like programming languages, and I

00:03:45.864 --> 00:03:48.720
<v Speaker 1>like learning ones. And I've, like, switched between

00:03:48.720 --> 00:03:50.960
<v Speaker 1>languages a lot historically.

00:03:51.840 --> 00:03:54.560
<v Speaker 1>And, actually, I primarily was doing Ruby before

00:03:54.560 --> 00:03:55.440
<v Speaker 1>I did Rust,

00:03:55.680 --> 00:03:57.600
<v Speaker 1>to which I joke that I only programming

00:03:57.600 --> 00:03:59.440
<v Speaker 1>languages starting with RU now.

00:04:00.515 --> 00:04:01.955
<v Speaker 1>Told that joke in Russia, and I was

00:04:01.955 --> 00:04:03.395
<v Speaker 1>like, have to learn Russian too because it's

00:04:03.395 --> 00:04:04.355
<v Speaker 1>also RU.

00:04:04.834 --> 00:04:05.475
<v Speaker 1>But

00:04:05.635 --> 00:04:07.155
<v Speaker 1>no. There's a there's a couple different reasons

00:04:07.155 --> 00:04:08.915
<v Speaker 1>why this happening. So so, originally,

00:04:09.315 --> 00:04:11.235
<v Speaker 1>Rust is kind of, like, really trying to

00:04:11.235 --> 00:04:12.595
<v Speaker 1>focus on the sort of c and c

00:04:12.595 --> 00:04:14.435
<v Speaker 1>plus plus use cases, and there hasn't been

00:04:14.435 --> 00:04:15.075
<v Speaker 1>a lot of

00:04:15.790 --> 00:04:18.430
<v Speaker 1>motion in that corner of the programming language

00:04:18.430 --> 00:04:20.589
<v Speaker 1>space. There's been a ton of new languages

00:04:20.589 --> 00:04:22.750
<v Speaker 1>appearing that are, like, great for higher level

00:04:22.750 --> 00:04:24.830
<v Speaker 1>things, but there hasn't really been anything that's

00:04:24.830 --> 00:04:26.990
<v Speaker 1>been, like, a serious competitor in the low

00:04:26.990 --> 00:04:29.230
<v Speaker 1>level space for a while. And so that's

00:04:29.230 --> 00:04:29.710
<v Speaker 1>why

00:04:30.134 --> 00:04:32.294
<v Speaker 1>Mozilla was interested in Rust and why they

00:04:32.294 --> 00:04:34.294
<v Speaker 1>sort of sponsored the initial development,

00:04:34.775 --> 00:04:37.895
<v Speaker 1>in the early days is because, Firefox's

00:04:37.895 --> 00:04:40.055
<v Speaker 1>millions of lines of c plus plus code,

00:04:40.055 --> 00:04:41.414
<v Speaker 1>and, you know, you don't wanna visit the

00:04:41.414 --> 00:04:43.495
<v Speaker 1>wrong web page and have some JavaScript, like,

00:04:43.639 --> 00:04:46.120
<v Speaker 1>own you. So web browsers need to be

00:04:46.120 --> 00:04:47.080
<v Speaker 1>super secure,

00:04:47.320 --> 00:04:48.760
<v Speaker 1>but you're sort of using these very sharp

00:04:48.760 --> 00:04:51.480
<v Speaker 1>and very dangerous tools. And so Mozilla folks

00:04:51.480 --> 00:04:53.320
<v Speaker 1>said, like, what if we could have a

00:04:53.320 --> 00:04:55.000
<v Speaker 1>a language that's just as powerful as c

00:04:55.000 --> 00:04:56.360
<v Speaker 1>and c plus plus, but doesn't have as

00:04:56.360 --> 00:04:58.440
<v Speaker 1>many of the significant drawbacks that they do?

00:04:59.015 --> 00:05:00.135
<v Speaker 1>And so that was kind of the original

00:05:00.135 --> 00:05:02.455
<v Speaker 1>Genesis from there. But as it turns out,

00:05:02.615 --> 00:05:04.215
<v Speaker 1>some of the ways in which we we

00:05:04.215 --> 00:05:06.855
<v Speaker 1>accomplished that task meant Rod was Rust was,

00:05:06.855 --> 00:05:08.855
<v Speaker 1>like, a little more broadly applicable.

00:05:08.855 --> 00:05:11.095
<v Speaker 1>And so it's it's sort of been funny,

00:05:11.095 --> 00:05:13.800
<v Speaker 1>like, over time, exactly as you said, we've

00:05:13.800 --> 00:05:15.400
<v Speaker 1>seen these other use cases kind of, like,

00:05:15.400 --> 00:05:17.720
<v Speaker 1>open up as time goes on. And, like,

00:05:17.720 --> 00:05:19.639
<v Speaker 1>if you had asked me, would I write

00:05:19.639 --> 00:05:22.360
<v Speaker 1>a web service in Rust eight years ago,

00:05:22.360 --> 00:05:24.039
<v Speaker 1>I would have said, absolutely not. That would

00:05:24.039 --> 00:05:24.520
<v Speaker 1>be ridiculous.

00:05:24.985 --> 00:05:26.745
<v Speaker 1>And now there's tons of people who are

00:05:26.745 --> 00:05:28.585
<v Speaker 1>doing that even in production, and it's, like,

00:05:28.585 --> 00:05:30.585
<v Speaker 1>actually a reasonable choice. So that's been kind

00:05:30.585 --> 00:05:31.625
<v Speaker 1>of a surprise to me.

00:05:32.105 --> 00:05:34.265
<v Speaker 1>It turns out also that there are other

00:05:34.265 --> 00:05:36.505
<v Speaker 1>places, like you mentioned, WebAssembly specifically.

00:05:36.665 --> 00:05:38.345
<v Speaker 1>It turns out WebAssembly has a lot more

00:05:38.345 --> 00:05:40.740
<v Speaker 1>in common with an embedded device than it

00:05:40.740 --> 00:05:43.380
<v Speaker 1>does with a web page in many ways.

00:05:43.460 --> 00:05:45.220
<v Speaker 1>And so languages that are really good for

00:05:45.220 --> 00:05:47.380
<v Speaker 1>this, like, small constrained environment

00:05:47.460 --> 00:05:50.020
<v Speaker 1>also operate really well in that small constrained

00:05:50.020 --> 00:05:52.100
<v Speaker 1>environment. So there's been some interesting, like, kinda

00:05:52.100 --> 00:05:53.780
<v Speaker 1>cross pollination because of those sort of things.

00:05:54.245 --> 00:05:56.324
<v Speaker 1>And then finally, I think another thing that's

00:05:56.324 --> 00:05:58.324
<v Speaker 1>sort of driven this kind of renaissance

00:05:58.324 --> 00:06:00.565
<v Speaker 1>in this area is as we've moved to

00:06:00.565 --> 00:06:01.365
<v Speaker 1>the cloud

00:06:01.685 --> 00:06:04.245
<v Speaker 1>and we're built on things like, you know,

00:06:04.245 --> 00:06:04.965
<v Speaker 1>CPU time,

00:06:06.000 --> 00:06:08.640
<v Speaker 1>languages that have more performance and use less

00:06:08.640 --> 00:06:11.440
<v Speaker 1>memory turns into direct,

00:06:11.520 --> 00:06:14.160
<v Speaker 1>you know, bottom line cost savings.

00:06:14.480 --> 00:06:16.400
<v Speaker 1>You know, back whenever we had our own

00:06:16.400 --> 00:06:19.280
<v Speaker 1>servers and we didn't didn't like Kara who's

00:06:18.435 --> 00:06:20.835
<v Speaker 1>super ton about, like, scale, when you had

00:06:20.835 --> 00:06:22.755
<v Speaker 1>one server and it was running your application,

00:06:22.915 --> 00:06:24.195
<v Speaker 1>you were just paying for that server and

00:06:24.195 --> 00:06:25.794
<v Speaker 1>that was it. You know, you could use

00:06:25.794 --> 00:06:27.155
<v Speaker 1>whatever you wanted as long as it fit

00:06:27.155 --> 00:06:29.235
<v Speaker 1>on that server. Now when people are spinning

00:06:29.235 --> 00:06:31.395
<v Speaker 1>up thousands of servers by just, you know,

00:06:31.395 --> 00:06:33.075
<v Speaker 1>running a small command on AWS,

00:06:33.360 --> 00:06:35.040
<v Speaker 1>If you can spin up 500 servers instead

00:06:35.040 --> 00:06:36.560
<v Speaker 1>of a thousand servers, you're gonna save yourself

00:06:36.560 --> 00:06:37.600
<v Speaker 1>a lot of money. And so there's been

00:06:37.600 --> 00:06:40.160
<v Speaker 1>kind of a a renewed interest in languages

00:06:40.160 --> 00:06:41.360
<v Speaker 1>that prioritize

00:06:41.440 --> 00:06:42.320
<v Speaker 1>efficiency,

00:06:42.880 --> 00:06:45.040
<v Speaker 1>because it directly saves you cash.

00:06:45.360 --> 00:06:48.155
<v Speaker 1>So that's also, I think, a reason why

00:06:48.155 --> 00:06:49.675
<v Speaker 1>people are looking at Rust where maybe that

00:06:49.675 --> 00:06:51.755
<v Speaker 1>wouldn't have made as much sense five or

00:06:51.755 --> 00:06:52.635
<v Speaker 1>ten years ago.

00:06:53.755 --> 00:06:55.275
<v Speaker 0>Yeah. Definitely.

00:06:55.515 --> 00:06:57.195
<v Speaker 0>Well, there's a lot of really good points

00:06:57.195 --> 00:06:58.635
<v Speaker 0>there. I think that's the best answer I've

00:06:58.635 --> 00:07:01.435
<v Speaker 0>ever had to an unplanned question. Like, actually,

00:07:01.595 --> 00:07:04.310
<v Speaker 0>quite in-depth. It's in in some ways, I'm

00:07:04.310 --> 00:07:06.310
<v Speaker 1>planning for these answers for, like, ten years.

00:07:06.310 --> 00:07:08.310
<v Speaker 1>It's not entirely unplanned, but you're definitely right.

00:07:08.310 --> 00:07:10.229
<v Speaker 1>They're, like, off the off the cuff. I

00:07:10.229 --> 00:07:11.909
<v Speaker 1>was gonna say the last thing is we

00:07:11.909 --> 00:07:13.990
<v Speaker 1>tried deliberately to build a really friendly and

00:07:13.990 --> 00:07:15.110
<v Speaker 1>welcoming community.

00:07:15.190 --> 00:07:16.870
<v Speaker 1>We're not always perfect at that, but, like,

00:07:16.870 --> 00:07:19.665
<v Speaker 1>you can get answers from Rust people. And

00:07:19.665 --> 00:07:22.305
<v Speaker 1>we've developed a culture where, like, no beginner

00:07:22.305 --> 00:07:24.385
<v Speaker 1>question is off limits. Like, we're super happy

00:07:24.385 --> 00:07:27.185
<v Speaker 1>to help people, and that's often uncommon in,

00:07:27.425 --> 00:07:30.465
<v Speaker 1>especially the lower level, spaces online. And so

00:07:30.465 --> 00:07:32.065
<v Speaker 1>we've also sort of developed a big following

00:07:32.065 --> 00:07:34.170
<v Speaker 1>because people know and trust that they can

00:07:34.170 --> 00:07:36.490
<v Speaker 1>get help with their problems without being, like,

00:07:36.490 --> 00:07:38.650
<v Speaker 1>told that they suck. And that's definitely super

00:07:38.650 --> 00:07:39.610
<v Speaker 1>useful as well.

00:07:40.410 --> 00:07:42.170
<v Speaker 0>I guess, I got something I noticed in

00:07:42.170 --> 00:07:44.410
<v Speaker 0>general with not just the Rust community, but

00:07:44.410 --> 00:07:45.784
<v Speaker 0>the the Rust tooling. There seems to be

00:07:45.784 --> 00:07:47.865
<v Speaker 0>a lot of effort on documentation and even

00:07:47.865 --> 00:07:50.985
<v Speaker 0>the compiler error messages and tutorials online. There's

00:07:50.985 --> 00:07:51.865
<v Speaker 0>just a lot

00:07:52.344 --> 00:07:53.865
<v Speaker 0>I guess because the community is going so

00:07:53.865 --> 00:07:55.384
<v Speaker 0>fast, there's a lot of new people and

00:07:55.384 --> 00:07:56.824
<v Speaker 0>those are those people are getting a lot

00:07:56.824 --> 00:07:58.550
<v Speaker 0>of help along the way, which helps everyone

00:07:58.550 --> 00:08:00.230
<v Speaker 0>across this path. Totally.

00:08:00.789 --> 00:08:03.270
<v Speaker 1>There's there's one guy specifically, Esteban Cooper, who

00:08:03.270 --> 00:08:04.550
<v Speaker 1>works on error messages,

00:08:04.789 --> 00:08:06.389
<v Speaker 1>and his kind of approach is that, like

00:08:06.470 --> 00:08:07.669
<v Speaker 1>and we'll see, I guess, how that goes

00:08:07.669 --> 00:08:09.830
<v Speaker 1>as we actually do this code. But his

00:08:09.830 --> 00:08:11.430
<v Speaker 1>idea is that, like, the compiler is, like,

00:08:11.430 --> 00:08:12.875
<v Speaker 1>a pair programmer, and it should be helping

00:08:12.875 --> 00:08:13.914
<v Speaker 1>you. So you shouldn't just get a message

00:08:13.914 --> 00:08:15.675
<v Speaker 1>saying your code is wrong. It should try

00:08:15.675 --> 00:08:17.195
<v Speaker 1>to help you actually figure out what you

00:08:17.195 --> 00:08:18.955
<v Speaker 1>need to do in response to it. Sometimes

00:08:18.955 --> 00:08:20.395
<v Speaker 1>it's very good at that. Sometimes it's not

00:08:20.395 --> 00:08:21.835
<v Speaker 1>very good at that. But, like, a concrete

00:08:21.835 --> 00:08:24.235
<v Speaker 1>example is Rust has a sync await, kinda

00:08:24.235 --> 00:08:25.914
<v Speaker 1>like JavaScript does, but we use a different

00:08:25.914 --> 00:08:28.710
<v Speaker 1>syntax than JavaScript does. So we actually changed

00:08:28.870 --> 00:08:30.790
<v Speaker 1>the Rust compiler knows how to parse the

00:08:30.790 --> 00:08:33.910
<v Speaker 1>JavaScript understanding of async await, specifically to give

00:08:33.910 --> 00:08:35.510
<v Speaker 1>you the error message saying, hey. I see

00:08:35.510 --> 00:08:37.270
<v Speaker 1>you're trying it like this. Turns out we

00:08:37.270 --> 00:08:38.630
<v Speaker 1>actually do it like that instead, so you

00:08:38.630 --> 00:08:39.910
<v Speaker 1>should change your code. So that's kind of

00:08:39.910 --> 00:08:41.590
<v Speaker 1>an idea about how this tooling can, like,

00:08:41.924 --> 00:08:44.485
<v Speaker 1>help people is, you know, by by not

00:08:44.485 --> 00:08:46.325
<v Speaker 1>just being like that's an error, but actually

00:08:46.325 --> 00:08:48.404
<v Speaker 1>being able to understand, hey. I think you're

00:08:48.404 --> 00:08:49.685
<v Speaker 1>trying to do this because you come from

00:08:49.685 --> 00:08:52.165
<v Speaker 1>a different language and that's really super cool.

00:08:53.365 --> 00:08:55.445
<v Speaker 0>Yeah. I mean, async await is one of

00:08:55.445 --> 00:08:57.020
<v Speaker 0>those things. Like, I've written a little bit

00:08:57.020 --> 00:08:58.780
<v Speaker 0>of Rust to be dangerous, but every time

00:08:58.780 --> 00:09:00.620
<v Speaker 0>I venture down the async path, I just

00:09:00.620 --> 00:09:02.220
<v Speaker 0>seem to, like, shoot myself in the foot

00:09:02.220 --> 00:09:04.060
<v Speaker 0>so many times. And I I don't think

00:09:04.060 --> 00:09:06.060
<v Speaker 0>that's so much the Rust async syntax with

00:09:06.060 --> 00:09:07.740
<v Speaker 0>the docs is that I keep trying to

00:09:07.740 --> 00:09:09.675
<v Speaker 0>do it with Actix, which doesn't have great

00:09:09.675 --> 00:09:13.274
<v Speaker 0>documentation anyway. So Gotcha. Yeah. It's definitely a

00:09:13.274 --> 00:09:15.595
<v Speaker 1>moving target in a complicated space for sure.

00:09:15.595 --> 00:09:18.475
<v Speaker 1>So Yeah. But it's good fun. So let's

00:09:18.475 --> 00:09:20.714
<v Speaker 0>get my screen share then. So we we

00:09:20.714 --> 00:09:22.590
<v Speaker 0>have I know we've not done anything in

00:09:22.590 --> 00:09:23.870
<v Speaker 0>advance. We've not even had that much of

00:09:23.870 --> 00:09:24.750
<v Speaker 0>a conversation.

00:09:25.230 --> 00:09:26.670
<v Speaker 0>As far as I know, of us have

00:09:26.670 --> 00:09:28.750
<v Speaker 0>looked at the Rustling's examples before, which is

00:09:28.750 --> 00:09:30.910
<v Speaker 0>what we're gonna be looking at today. Mhmm.

00:09:30.910 --> 00:09:32.750
<v Speaker 0>If people are curious and want to follow

00:09:32.750 --> 00:09:34.190
<v Speaker 0>along or do this in their own time,

00:09:34.190 --> 00:09:38.030
<v Speaker 0>it's just the Rustling's repository on the Rust

00:09:36.705 --> 00:09:37.585
<v Speaker 0>Lang

00:09:37.585 --> 00:09:39.025
<v Speaker 0>Gethub organization.

00:09:39.985 --> 00:09:42.545
<v Speaker 0>Now it seems to have now I know

00:09:42.545 --> 00:09:44.625
<v Speaker 0>the the bet on the rate is painful

00:09:44.625 --> 00:09:46.145
<v Speaker 0>to read and I guess I can do

00:09:46.145 --> 00:09:47.505
<v Speaker 0>my just know and then turn back out.

00:09:47.505 --> 00:09:49.420
<v Speaker 0>But it's got four quizzes and I figured

00:09:49.420 --> 00:09:51.500
<v Speaker 0>we try and work our way towards quiz

00:09:51.500 --> 00:09:52.700
<v Speaker 0>one. We'll see how we're doing for time

00:09:52.700 --> 00:09:54.060
<v Speaker 0>and maybe we'll try and get a few

00:09:54.060 --> 00:09:56.220
<v Speaker 0>more bits and pieces done after that. Totally.

00:09:56.220 --> 00:09:58.140
<v Speaker 0>What I would suggest to anyone watching, if

00:09:58.140 --> 00:09:59.580
<v Speaker 0>there's anything you want us to try and

00:09:59.580 --> 00:10:01.580
<v Speaker 0>answer questions on or cover or any sections

00:10:01.580 --> 00:10:02.940
<v Speaker 0>we should take a look at, feel free

00:10:02.940 --> 00:10:04.380
<v Speaker 0>to drop that in the comments and we'll

00:10:04.380 --> 00:10:06.195
<v Speaker 0>do our best to tackle that.

00:10:06.595 --> 00:10:07.715
<v Speaker 0>Now, quiz one.

00:10:08.915 --> 00:10:10.755
<v Speaker 0>One more. There we go.

00:10:11.715 --> 00:10:14.275
<v Speaker 0>Requires us to work with variables and functions,

00:10:14.275 --> 00:10:16.035
<v Speaker 0>which makes sense. Probably, it's two of the

00:10:16.035 --> 00:10:18.195
<v Speaker 0>most common things we wanna cover. So let's

00:10:18.195 --> 00:10:20.570
<v Speaker 0>grab variables first and see what we're dealing

00:10:20.570 --> 00:10:23.529
<v Speaker 0>with. So Yeah. To to briefly interject the

00:10:23.529 --> 00:10:25.130
<v Speaker 1>way that this Rust things kinda works is

00:10:25.130 --> 00:10:27.290
<v Speaker 1>that you you try to compile the examples

00:10:27.290 --> 00:10:28.810
<v Speaker 1>and they fail. So this is a not

00:10:28.810 --> 00:10:29.850
<v Speaker 1>working program.

00:10:30.089 --> 00:10:31.529
<v Speaker 1>And so we'll, like, run it and it'll

00:10:31.529 --> 00:10:32.730
<v Speaker 1>tell us, hey. This doesn't work and we

00:10:32.730 --> 00:10:33.930
<v Speaker 1>have to fix it to make it work.

00:10:34.655 --> 00:10:36.415
<v Speaker 1>So that's kind of the general structure of

00:10:36.415 --> 00:10:38.495
<v Speaker 1>this if you haven't heard of Rustlings before.

00:10:40.655 --> 00:10:41.455
<v Speaker 0>Nice.

00:10:41.775 --> 00:10:44.095
<v Speaker 0>So we run this Rustlings watch command.

00:10:45.135 --> 00:10:45.855
<v Speaker 0>My

00:10:46.175 --> 00:10:47.855
<v Speaker 0>terminal is acting a bit weird. You know,

00:10:47.855 --> 00:10:49.295
<v Speaker 0>I'm just gonna do that here.

00:10:50.130 --> 00:10:50.930
<v Speaker 1>Totally.

00:10:51.730 --> 00:10:53.410
<v Speaker 0>There we go. Okay. So, yeah, it's trying

00:10:53.410 --> 00:10:55.650
<v Speaker 0>to compare variables one and this town is

00:10:55.650 --> 00:10:57.890
<v Speaker 0>a variable cannot find value x in that

00:10:57.890 --> 00:10:59.170
<v Speaker 0>scope. So let's just take a look at

00:10:59.170 --> 00:11:00.290
<v Speaker 0>this. Yeah.

00:11:01.730 --> 00:11:04.274
<v Speaker 0>Now if we look at this code, we

00:11:04.274 --> 00:11:05.555
<v Speaker 0>can first of all, I mean, we should

00:11:05.555 --> 00:11:07.635
<v Speaker 0>cover the basic syntax for anyone that's completely

00:11:07.635 --> 00:11:09.315
<v Speaker 0>new to Rust. Totally.

00:11:09.714 --> 00:11:12.834
<v Speaker 0>F n, I'm assuming, is a function. Correct.

00:11:12.834 --> 00:11:14.355
<v Speaker 1>It's how you declare functions.

00:11:14.915 --> 00:11:17.519
<v Speaker 1>There's actually a fun trivia here. So it

00:11:17.519 --> 00:11:19.199
<v Speaker 1>used to be in the very old days

00:11:19.199 --> 00:11:21.040
<v Speaker 1>that Rust had a rule that no keyword

00:11:21.040 --> 00:11:23.040
<v Speaker 1>could be longer than five characters,

00:11:23.279 --> 00:11:25.839
<v Speaker 1>and that's because they tended to prefer brevity.

00:11:26.320 --> 00:11:28.240
<v Speaker 1>Over time, we relaxed that, but we sort

00:11:28.240 --> 00:11:31.040
<v Speaker 1>of kept it where extremely commonly used keynames

00:11:31.040 --> 00:11:33.855
<v Speaker 1>or keywords are very short and lesser used

00:11:33.855 --> 00:11:35.695
<v Speaker 1>ones are very long. So it turns out

00:11:35.695 --> 00:11:37.455
<v Speaker 1>that f n was one that you use

00:11:37.455 --> 00:11:39.375
<v Speaker 1>all the time. You define lots of functions,

00:11:39.615 --> 00:11:41.695
<v Speaker 1>and, you know, we we decided it's worth

00:11:41.695 --> 00:11:44.815
<v Speaker 1>keeping short. So, that's why it's it's, it's

00:11:44.815 --> 00:11:45.855
<v Speaker 1>so so short.

00:11:46.255 --> 00:11:49.019
<v Speaker 1>We thought about fun or funk, but in

00:11:49.019 --> 00:11:50.620
<v Speaker 1>the end, we decided that f n was

00:11:50.620 --> 00:11:51.980
<v Speaker 1>was good enough. Yeah.

00:11:53.019 --> 00:11:56.220
<v Speaker 0>Yeah. Definitely. Like, I mean, that's that's looks

00:11:56.220 --> 00:11:58.860
<v Speaker 0>like c style or c's are ever to

00:11:58.860 --> 00:12:00.540
<v Speaker 0>style code. I guess that most people should

00:12:00.540 --> 00:12:02.865
<v Speaker 0>find us relatively familiar to them even if

00:12:02.865 --> 00:12:04.385
<v Speaker 0>we just even if the keyword is slightly

00:12:04.385 --> 00:12:05.825
<v Speaker 0>different. And I guess this is very similar

00:12:05.825 --> 00:12:07.105
<v Speaker 0>to go as well, which is also a

00:12:07.105 --> 00:12:08.305
<v Speaker 0>c derivative. So

00:12:09.505 --> 00:12:11.505
<v Speaker 0>do you wanna explain the exclamation mark here

00:12:11.505 --> 00:12:13.345
<v Speaker 0>to people? Yeah. So,

00:12:13.665 --> 00:12:15.649
<v Speaker 1>basically, this is print l n, which is

00:12:15.649 --> 00:12:16.850
<v Speaker 1>like print line,

00:12:17.250 --> 00:12:19.730
<v Speaker 1>again, with a small abbreviation there. But the

00:12:19.810 --> 00:12:22.690
<v Speaker 1>exclamation point is because this is a macro.

00:12:22.690 --> 00:12:24.529
<v Speaker 1>So we're definitely not gonna get into writing

00:12:24.529 --> 00:12:25.330
<v Speaker 1>macros

00:12:25.810 --> 00:12:27.970
<v Speaker 1>in this because, honestly, I'm not even that

00:12:27.970 --> 00:12:29.410
<v Speaker 1>good at writing macros. But

00:12:30.254 --> 00:12:32.654
<v Speaker 1>the the trick is is that macros let

00:12:32.654 --> 00:12:35.214
<v Speaker 1>you write code inside of them that is

00:12:35.214 --> 00:12:37.694
<v Speaker 1>not normal Rust code, and so depending on

00:12:37.694 --> 00:12:39.774
<v Speaker 1>the macro, of course. And so the exclamation

00:12:39.774 --> 00:12:41.375
<v Speaker 1>point or sometimes you say bang

00:12:41.694 --> 00:12:44.360
<v Speaker 1>means that this is invoking a macro, and

00:12:44.360 --> 00:12:45.880
<v Speaker 1>so the stuff that's inside might be a

00:12:45.880 --> 00:12:48.040
<v Speaker 1>little weird. Now, specifically, you might say this

00:12:48.040 --> 00:12:49.880
<v Speaker 1>doesn't look weird, but it turns out that

00:12:49.880 --> 00:12:53.399
<v Speaker 1>Rust actually functions can don't have a variable

00:12:53.399 --> 00:12:54.520
<v Speaker 1>number of arguments.

00:12:54.839 --> 00:12:55.880
<v Speaker 1>So this,

00:12:56.360 --> 00:12:56.760
<v Speaker 1>like,

00:12:57.255 --> 00:12:59.015
<v Speaker 1>if we wanted to just do hello,

00:13:00.455 --> 00:13:01.015
<v Speaker 1>this,

00:13:01.735 --> 00:13:03.575
<v Speaker 1>this would not work in a regular Rust

00:13:03.575 --> 00:13:05.735
<v Speaker 1>function because the second version here has one

00:13:05.735 --> 00:13:07.735
<v Speaker 1>argument and this the the one on line

00:13:07.735 --> 00:13:10.210
<v Speaker 1>13 has two arguments. So we use a

00:13:10.210 --> 00:13:13.410
<v Speaker 1>macro. It's because, we want that extra flexibility,

00:13:13.970 --> 00:13:15.650
<v Speaker 1>because, as you might imagine,

00:13:16.050 --> 00:13:17.890
<v Speaker 1>this is going to print the value of

00:13:17.890 --> 00:13:19.570
<v Speaker 1>x by interpolating

00:13:19.570 --> 00:13:22.210
<v Speaker 1>the value of x into where the little

00:13:22.210 --> 00:13:23.090
<v Speaker 1>curly braces are.

00:13:24.445 --> 00:13:26.204
<v Speaker 1>And so we need to be able to,

00:13:26.204 --> 00:13:27.404
<v Speaker 1>like, know if you have if you have

00:13:27.404 --> 00:13:29.485
<v Speaker 1>three sets of curlies, you want three other

00:13:29.485 --> 00:13:31.404
<v Speaker 1>arguments as well as the string. And so

00:13:31.404 --> 00:13:33.485
<v Speaker 1>the the print l n macro does a

00:13:33.485 --> 00:13:35.245
<v Speaker 1>whole bunch of really fancy stuff to make

00:13:35.245 --> 00:13:36.524
<v Speaker 1>all that work and work nicely.

00:13:37.370 --> 00:13:39.450
<v Speaker 1>Yeah. Basically, the exclamation point is is used

00:13:39.450 --> 00:13:41.290
<v Speaker 1>when you're when you're doing macro stuff.

00:13:42.090 --> 00:13:45.130
<v Speaker 0>Very cool. Yeah. Mac metaprogramming or macros is

00:13:45.130 --> 00:13:46.810
<v Speaker 0>something that I always struggle with. Like, I've

00:13:46.810 --> 00:13:48.170
<v Speaker 0>written a fair amount of a lecture in

00:13:48.170 --> 00:13:49.450
<v Speaker 0>my time, and every time I go to

00:13:49.450 --> 00:13:51.529
<v Speaker 0>write a macro, I still fall over many,

00:13:51.529 --> 00:13:53.024
<v Speaker 0>many times before I get it right. So

00:13:53.185 --> 00:13:53.904
<v Speaker 1>Totally.

00:13:54.065 --> 00:13:57.425
<v Speaker 1>Luckily, Rust has a, like, culture of external

00:13:57.425 --> 00:13:59.584
<v Speaker 1>packages and letting people use them. So I

00:13:59.584 --> 00:14:01.584
<v Speaker 1>use macros other people have written all the

00:14:01.584 --> 00:14:03.745
<v Speaker 1>time constantly, but so many people have written

00:14:03.745 --> 00:14:05.264
<v Speaker 1>so many useful ones that I don't really

00:14:05.264 --> 00:14:06.785
<v Speaker 1>find it to be necessary to write my

00:14:06.785 --> 00:14:08.280
<v Speaker 1>own very often. So that's kind of like

00:14:08.280 --> 00:14:10.840
<v Speaker 1>a a fun interplay of that is that

00:14:10.840 --> 00:14:12.840
<v Speaker 1>there's definitely a lot of macros in Rust,

00:14:12.840 --> 00:14:14.520
<v Speaker 1>but you almost never need to write them.

00:14:14.520 --> 00:14:15.480
<v Speaker 1>You just need to be able to use

00:14:15.480 --> 00:14:15.880
<v Speaker 1>them.

00:14:16.840 --> 00:14:17.400
<v Speaker 0>Okay.

00:14:18.200 --> 00:14:20.360
<v Speaker 0>So let's break down this error message then.

00:14:20.360 --> 00:14:22.360
<v Speaker 0>It's telling us the x is not in

00:14:22.360 --> 00:14:23.400
<v Speaker 0>scope. Now

00:14:24.014 --> 00:14:26.014
<v Speaker 0>it kinda looks like this. This is this

00:14:26.014 --> 00:14:28.095
<v Speaker 0>is subtle. Right? I'm I'm not sure if

00:14:28.095 --> 00:14:30.415
<v Speaker 0>I understand this, but I'm assuming that this

00:14:30.415 --> 00:14:33.774
<v Speaker 0>just maybe wants a let here. Correct. So

00:14:33.935 --> 00:14:35.855
<v Speaker 1>to introduce a new variable, you need to

00:14:35.855 --> 00:14:37.709
<v Speaker 1>use the let keyword. And that's what this

00:14:37.709 --> 00:14:39.149
<v Speaker 1>example is trying to teach you. You can't

00:14:39.149 --> 00:14:41.470
<v Speaker 1>just use the name itself. You specifically say

00:14:41.470 --> 00:14:43.149
<v Speaker 1>let and then the name of the variable

00:14:43.149 --> 00:14:44.910
<v Speaker 1>and then an equals and then the value

00:14:44.910 --> 00:14:46.510
<v Speaker 1>of what goes into that variable.

00:14:48.029 --> 00:14:50.350
<v Speaker 1>So yeah. Okay. So by adding the let,

00:14:50.350 --> 00:14:51.310
<v Speaker 0>if I pop over here,

00:14:52.665 --> 00:14:55.225
<v Speaker 0>it compiles and we passed variables one.

00:14:55.545 --> 00:14:57.225
<v Speaker 1>Yep. And you can see x has a

00:14:57.225 --> 00:14:58.985
<v Speaker 1>value five because it put the five in

00:14:58.985 --> 00:15:01.144
<v Speaker 1>where the curly braces were and that's the

00:15:01.144 --> 00:15:03.225
<v Speaker 1>the bit that it printed out. So yeah.

00:15:03.625 --> 00:15:05.545
<v Speaker 0>Okay. Can we tackle one more thing on

00:15:05.545 --> 00:15:07.065
<v Speaker 0>this example then before we move on to

00:15:07.065 --> 00:15:08.105
<v Speaker 0>variables two? Absolutely.

00:15:08.710 --> 00:15:11.430
<v Speaker 1>We didn't define a type here when we

00:15:11.430 --> 00:15:13.030
<v Speaker 0>defined what x is.

00:15:13.750 --> 00:15:16.390
<v Speaker 0>Is this the compiler doing type inference and

00:15:16.390 --> 00:15:18.150
<v Speaker 0>and doing that for us? Or is there

00:15:18.150 --> 00:15:20.470
<v Speaker 0>something else happening here? It's it's specifically the

00:15:20.470 --> 00:15:23.030
<v Speaker 1>compiler infers the type of what

00:15:23.270 --> 00:15:23.750
<v Speaker 1>it should be.

00:15:24.555 --> 00:15:26.795
<v Speaker 1>And so Rust can feel like a dynamically

00:15:26.795 --> 00:15:28.075
<v Speaker 1>typed language often,

00:15:28.395 --> 00:15:30.715
<v Speaker 1>but is super super statically typed.

00:15:31.275 --> 00:15:32.795
<v Speaker 1>One interesting thing about this, and I was

00:15:32.795 --> 00:15:34.955
<v Speaker 1>gonna mention this too with the the function

00:15:34.955 --> 00:15:36.795
<v Speaker 1>main syntax. So first of all, main is

00:15:36.795 --> 00:15:39.115
<v Speaker 1>where Rust program start executing. So you're always

00:15:39.115 --> 00:15:40.930
<v Speaker 1>gonna have a main function somewhere, and that's,

00:15:40.930 --> 00:15:42.050
<v Speaker 1>like, where things begin.

00:15:42.290 --> 00:15:42.770
<v Speaker 1>But

00:15:43.330 --> 00:15:45.490
<v Speaker 1>we require you to put types in for

00:15:45.490 --> 00:15:47.649
<v Speaker 1>arguments to functions and return types. I'm sure

00:15:47.649 --> 00:15:48.769
<v Speaker 1>we're about to get into that in a

00:15:48.769 --> 00:15:50.930
<v Speaker 1>second. So the main function has no arguments

00:15:50.930 --> 00:15:53.410
<v Speaker 1>and no return. So, therefore, there's no types

00:15:53.410 --> 00:15:55.985
<v Speaker 1>written there, but you may see types in

00:15:55.985 --> 00:15:58.065
<v Speaker 1>function declarations. And I'm guessing given that that's

00:15:58.065 --> 00:15:59.745
<v Speaker 1>where we're going next, we're we're about to

00:15:59.745 --> 00:16:01.024
<v Speaker 1>segue into that. But

00:16:01.904 --> 00:16:02.785
<v Speaker 1>but yes.

00:16:03.264 --> 00:16:05.425
<v Speaker 0>Alright. Let's see. Let's just pop open variables

00:16:05.425 --> 00:16:07.024
<v Speaker 0>too then. I think it says so this

00:16:07.024 --> 00:16:09.024
<v Speaker 1>paragraph says about this I am done thing.

00:16:09.024 --> 00:16:10.625
<v Speaker 1>It's like you gotta remove

00:16:12.430 --> 00:16:14.430
<v Speaker 1>when you feel ready for the next exercise,

00:16:14.430 --> 00:16:16.030
<v Speaker 1>remove the I am done comment. So I

00:16:16.030 --> 00:16:16.990
<v Speaker 1>think that that's

00:16:17.230 --> 00:16:20.270
<v Speaker 1>yeah. Totally. We go. Awesome. Cool. Alright.

00:16:21.630 --> 00:16:23.550
<v Speaker 0>So I'm done. And then now we have

00:16:23.550 --> 00:16:24.510
<v Speaker 0>variables two.

00:16:25.045 --> 00:16:25.685
<v Speaker 0>So

00:16:26.005 --> 00:16:27.605
<v Speaker 0>our error message is

00:16:27.845 --> 00:16:29.765
<v Speaker 0>alright. Okay. So x doesn't have

00:16:30.245 --> 00:16:31.205
<v Speaker 0>a type.

00:16:31.605 --> 00:16:32.245
<v Speaker 1>Yeah.

00:16:32.405 --> 00:16:34.725
<v Speaker 1>So this one is, like, a a little

00:16:34.725 --> 00:16:35.685
<v Speaker 1>bit trickier.

00:16:36.325 --> 00:16:36.885
<v Speaker 1>So

00:16:37.460 --> 00:16:40.100
<v Speaker 1>when it comes to numbers specifically,

00:16:40.260 --> 00:16:42.100
<v Speaker 1>there's a lot of different kinds of numbers

00:16:42.100 --> 00:16:44.340
<v Speaker 1>in Rust. So we have both signed and

00:16:44.340 --> 00:16:46.660
<v Speaker 1>unsigned numbers, which basically means, like, is there

00:16:46.660 --> 00:16:49.460
<v Speaker 1>a negative sign? So unsigned numbers can go

00:16:49.460 --> 00:16:51.815
<v Speaker 1>from zero to some big number, and signed

00:16:51.815 --> 00:16:53.895
<v Speaker 1>numbers go from negative some number to positive

00:16:53.895 --> 00:16:54.695
<v Speaker 1>some number.

00:16:55.095 --> 00:16:56.615
<v Speaker 1>And so there's there's a lot of them.

00:16:56.615 --> 00:16:57.575
<v Speaker 1>I think there's,

00:16:57.815 --> 00:17:00.055
<v Speaker 1>like, something like 16 different types or something

00:17:00.055 --> 00:17:03.175
<v Speaker 1>like that. Forget. Eight is let's I'll I'll

00:17:03.175 --> 00:17:04.855
<v Speaker 1>write them out real quick. We got

00:17:05.575 --> 00:17:08.690
<v Speaker 1>U 8, u 6 Oh, can't type.

00:17:09.170 --> 00:17:09.890
<v Speaker 1>16,

00:17:10.290 --> 00:17:11.490
<v Speaker 1>u 32,

00:17:12.450 --> 00:17:13.730
<v Speaker 1>u 64,

00:17:14.290 --> 00:17:16.050
<v Speaker 1>and 1 20 8.

00:17:16.290 --> 00:17:17.010
<v Speaker 1>And then

00:17:17.330 --> 00:17:19.330
<v Speaker 1>so those are the unsigned types. Those can

00:17:19.330 --> 00:17:21.785
<v Speaker 1>only be positive. And then there's I eight,

00:17:21.785 --> 00:17:24.024
<v Speaker 1>I 16, I 64,

00:17:25.065 --> 00:17:27.305
<v Speaker 1>and I one twenty eight. There's also a

00:17:27.305 --> 00:17:28.105
<v Speaker 1>couple other

00:17:28.425 --> 00:17:30.185
<v Speaker 1>these are only the integer types. So right

00:17:30.185 --> 00:17:31.865
<v Speaker 1>there, you can see one, two, three, four,

00:17:31.865 --> 00:17:33.545
<v Speaker 1>five. So we got 10 types right there.

00:17:34.110 --> 00:17:36.590
<v Speaker 1>There's also floating point numbers and

00:17:36.990 --> 00:17:39.870
<v Speaker 1>some other related types. So what's happening here

00:17:39.870 --> 00:17:40.429
<v Speaker 1>is

00:17:41.550 --> 00:17:42.990
<v Speaker 1>in the earlier example,

00:17:43.150 --> 00:17:44.990
<v Speaker 1>we didn't have to write a type because

00:17:45.070 --> 00:17:46.990
<v Speaker 1>you weren't doing anything with that variable, and

00:17:46.990 --> 00:17:48.830
<v Speaker 1>so Rust just picked the default, which is

00:17:48.830 --> 00:17:49.550
<v Speaker 1>u 32.

00:17:50.615 --> 00:17:53.174
<v Speaker 1>But here, it's confused because we have this

00:17:53.174 --> 00:17:55.414
<v Speaker 1>number 10 and we have this x, and

00:17:55.414 --> 00:17:56.855
<v Speaker 1>it's like it's really,

00:17:57.254 --> 00:17:59.894
<v Speaker 1>it's really, like, not it's not understanding what's

00:17:59.894 --> 00:18:01.894
<v Speaker 1>going on. Now the reason it's not able

00:18:01.894 --> 00:18:03.575
<v Speaker 1>to understand I'm gonna delete all these type

00:18:03.575 --> 00:18:04.855
<v Speaker 1>names so this actually works.

00:18:05.570 --> 00:18:07.330
<v Speaker 1>If you think about this, we never set

00:18:07.330 --> 00:18:09.330
<v Speaker 1>a value to x in the first place.

00:18:09.650 --> 00:18:10.450
<v Speaker 1>And so

00:18:10.690 --> 00:18:13.250
<v Speaker 1>what trying to say, like, they're they're basically,

00:18:13.250 --> 00:18:14.850
<v Speaker 1>like, Rust does not have the idea of

00:18:14.850 --> 00:18:15.409
<v Speaker 1>null.

00:18:15.970 --> 00:18:18.130
<v Speaker 1>So in many languages, if you did something

00:18:18.130 --> 00:18:19.490
<v Speaker 1>like this, you make a new variable and

00:18:19.490 --> 00:18:21.365
<v Speaker 1>you don't get the value, its value would

00:18:21.365 --> 00:18:22.084
<v Speaker 1>be null.

00:18:22.245 --> 00:18:22.804
<v Speaker 1>But

00:18:23.125 --> 00:18:23.924
<v Speaker 1>here,

00:18:24.085 --> 00:18:26.324
<v Speaker 1>we never gave it a value at all.

00:18:26.325 --> 00:18:28.404
<v Speaker 1>And so Rust effectively has no idea what

00:18:28.404 --> 00:18:30.164
<v Speaker 1>this type is. So it says, hey. I'm

00:18:30.164 --> 00:18:31.684
<v Speaker 1>gonna compare this thing. I don't know what

00:18:31.684 --> 00:18:33.605
<v Speaker 1>it is to 10. Is that valid? I

00:18:33.605 --> 00:18:34.884
<v Speaker 1>have no idea because I don't even know

00:18:34.884 --> 00:18:35.924
<v Speaker 1>what x is in the first place.

00:18:37.300 --> 00:18:38.820
<v Speaker 1>So that's kinda like what this is complaining

00:18:38.820 --> 00:18:41.780
<v Speaker 1>about. Does that make sense? It does. So

00:18:42.260 --> 00:18:44.260
<v Speaker 0>based on my naive knowledge then, there's two

00:18:44.260 --> 00:18:45.700
<v Speaker 0>ways that I think we can fix this,

00:18:45.700 --> 00:18:47.220
<v Speaker 0>and I'm gonna see if you can correct

00:18:47.220 --> 00:18:49.460
<v Speaker 0>me on this. No. I don't know. But

00:18:49.460 --> 00:18:51.540
<v Speaker 0>if I set this to be an unseen,

00:18:51.885 --> 00:18:54.605
<v Speaker 0>and let's just say we do an eight,

00:18:54.685 --> 00:18:56.685
<v Speaker 0>does that have a default value that then

00:18:56.685 --> 00:18:58.925
<v Speaker 0>that x will become? It does not have

00:18:58.925 --> 00:19:00.685
<v Speaker 1>a default value. Let's see what the compiler

00:19:00.685 --> 00:19:02.525
<v Speaker 1>says whenever you you do this because I'm

00:19:02.525 --> 00:19:04.765
<v Speaker 1>I'm interested in the exact error message, actually.

00:19:05.565 --> 00:19:06.285
<v Speaker 1>Yeah. So

00:19:06.910 --> 00:19:09.870
<v Speaker 1>use a possibly uninitialized variable x. And so

00:19:09.870 --> 00:19:11.550
<v Speaker 1>it's saying, hey. You may have never given

00:19:11.550 --> 00:19:13.470
<v Speaker 1>this a value. It can figure it out

00:19:13.470 --> 00:19:15.150
<v Speaker 1>most of the time, but it says possibly

00:19:15.150 --> 00:19:16.910
<v Speaker 1>because it's it's like, you might have do

00:19:16.910 --> 00:19:18.270
<v Speaker 1>it. I just might be I just might

00:19:18.270 --> 00:19:21.435
<v Speaker 1>not know. There's some complicated details there. But

00:19:21.435 --> 00:19:22.875
<v Speaker 1>the point is is that it's like, hey.

00:19:22.875 --> 00:19:24.875
<v Speaker 1>You haven't actually initialized this to a value,

00:19:24.875 --> 00:19:26.155
<v Speaker 1>so I'm gonna give you an error.

00:19:27.195 --> 00:19:28.315
<v Speaker 1>Now there is

00:19:28.635 --> 00:19:30.715
<v Speaker 1>a way that you can opt in to

00:19:30.715 --> 00:19:31.915
<v Speaker 1>giving a default value,

00:19:32.600 --> 00:19:34.760
<v Speaker 1>And so some types do have a default.

00:19:34.760 --> 00:19:36.680
<v Speaker 1>So I'll I'll let me show you that

00:19:36.680 --> 00:19:38.440
<v Speaker 1>real fast. Well, actually, let's talk about the

00:19:38.440 --> 00:19:40.120
<v Speaker 1>other way first because they're gonna converge

00:19:40.440 --> 00:19:42.760
<v Speaker 1>to to one thing, I guess. Okay. So

00:19:42.760 --> 00:19:44.520
<v Speaker 0>I'm assuming I mean, I can leave that

00:19:44.520 --> 00:19:46.405
<v Speaker 0>type definition there, but I could also just

00:19:46.405 --> 00:19:48.085
<v Speaker 0>set it to zero and I could remove

00:19:48.085 --> 00:19:49.285
<v Speaker 0>that and that would Right. That would be

00:19:49.285 --> 00:19:51.365
<v Speaker 0>okay. Right? Yes. It should be. Let's see

00:19:51.365 --> 00:19:52.565
<v Speaker 1>what the compiler says.

00:19:55.445 --> 00:19:56.245
<v Speaker 1>It works. Yeah.

00:19:57.500 --> 00:19:57.980
<v Speaker 1>So,

00:19:58.300 --> 00:19:59.980
<v Speaker 1>so yeah. So now it's, like, looks at

00:19:59.980 --> 00:20:01.020
<v Speaker 1>it and says, oh, I have a number

00:20:01.020 --> 00:20:02.780
<v Speaker 1>and a number. Neither of them have types,

00:20:02.780 --> 00:20:04.140
<v Speaker 1>so they're both U 30 2. So everything

00:20:04.140 --> 00:20:05.980
<v Speaker 1>is great. And that totally works. And if

00:20:05.980 --> 00:20:07.340
<v Speaker 1>you were to put back the u eight

00:20:07.340 --> 00:20:09.100
<v Speaker 1>thing, it would go, oh, then I have

00:20:09.100 --> 00:20:10.380
<v Speaker 1>a u eight and something I don't know

00:20:10.380 --> 00:20:11.500
<v Speaker 1>what type it is. They must both be

00:20:11.500 --> 00:20:12.940
<v Speaker 1>U eights, and that's fine. And it just,

00:20:12.940 --> 00:20:14.315
<v Speaker 1>like, figures it out, basically.

00:20:15.355 --> 00:20:15.915
<v Speaker 1>The

00:20:16.315 --> 00:20:18.155
<v Speaker 1>there so you can opt into the default

00:20:18.155 --> 00:20:19.674
<v Speaker 1>value by doing this.

00:20:23.035 --> 00:20:25.195
<v Speaker 1>This is maybe slightly more I'm interested to

00:20:25.195 --> 00:20:26.955
<v Speaker 1>see if this compiles or not, actually. Let's

00:20:26.955 --> 00:20:28.635
<v Speaker 1>let's run this real fast and just check.

00:20:30.600 --> 00:20:32.600
<v Speaker 0>It did. It did. So,

00:20:32.840 --> 00:20:35.160
<v Speaker 1>yeah. So some types have a default value,

00:20:35.160 --> 00:20:36.760
<v Speaker 1>but you have to explicitly ask for them.

00:20:36.760 --> 00:20:39.000
<v Speaker 1>So this is saying, there's a thing called

00:20:39.000 --> 00:20:40.440
<v Speaker 1>a trait in Rust, which I don't think

00:20:40.440 --> 00:20:41.560
<v Speaker 1>we're gonna get to, but they're sort of,

00:20:41.560 --> 00:20:43.880
<v Speaker 1>like, interfaces if you've used Go or Java.

00:20:44.875 --> 00:20:46.395
<v Speaker 1>Similar kind of idea. And so you can

00:20:46.395 --> 00:20:49.275
<v Speaker 1>say, like, please give me the default value

00:20:49.275 --> 00:20:51.755
<v Speaker 1>of the default interface for this type. And

00:20:51.755 --> 00:20:53.595
<v Speaker 1>so Rust is able to say, oh, u

00:20:53.595 --> 00:20:55.835
<v Speaker 1>eight has a default value, which in this

00:20:55.835 --> 00:20:56.475
<v Speaker 1>case is zero,

00:20:56.970 --> 00:20:58.890
<v Speaker 1>and we'll actually give you that sort of

00:20:58.890 --> 00:21:00.490
<v Speaker 1>default. But it's an opt in thing rather

00:21:00.490 --> 00:21:02.169
<v Speaker 1>than an opt out thing. And you'll see

00:21:02.169 --> 00:21:03.610
<v Speaker 1>this happen a lot with Rust, which is

00:21:03.610 --> 00:21:04.730
<v Speaker 1>one of the reasons I think it's a

00:21:04.730 --> 00:21:06.970
<v Speaker 1>great question that you asked. It's basically, like,

00:21:07.130 --> 00:21:09.210
<v Speaker 1>there's many things where in other languages, something

00:21:09.210 --> 00:21:11.049
<v Speaker 1>is the default, and in Rust, it's like,

00:21:11.049 --> 00:21:12.905
<v Speaker 1>oh, that's not there. But if you want

00:21:12.905 --> 00:21:14.905
<v Speaker 1>it, you can make it happen. And so

00:21:14.905 --> 00:21:15.784
<v Speaker 1>in this case,

00:21:16.184 --> 00:21:18.184
<v Speaker 1>you have to you have to expressly say,

00:21:18.184 --> 00:21:19.865
<v Speaker 1>please give me the default value if you

00:21:19.865 --> 00:21:20.585
<v Speaker 1>want one.

00:21:21.865 --> 00:21:22.665
<v Speaker 0>I'm

00:21:22.665 --> 00:21:24.905
<v Speaker 0>assuming that's just zero. Right? I think I'm

00:21:24.905 --> 00:21:27.059
<v Speaker 1>99% sure it's zero, but I don't use

00:21:27.059 --> 00:21:29.220
<v Speaker 1>it very often. So who knows? We'll find

00:21:29.220 --> 00:21:30.019
<v Speaker 1>out though.

00:21:32.899 --> 00:21:35.220
<v Speaker 1>Yeah. Okay. There we go. 0. That would

00:21:35.220 --> 00:21:36.659
<v Speaker 1>make sense. I I was gonna be sad

00:21:36.659 --> 00:21:37.779
<v Speaker 1>if it wasn't zero.

00:21:39.860 --> 00:21:42.019
<v Speaker 0>Okay. Alright. Let's remove our I am done.

00:21:43.195 --> 00:21:45.035
<v Speaker 0>And we'll see what we get next. So

00:21:45.035 --> 00:21:47.195
<v Speaker 0>variable three with an error.

00:21:48.075 --> 00:21:49.675
<v Speaker 0>Oh, no immutability.

00:21:49.675 --> 00:21:50.955
<v Speaker 0>Nice. Okay. Yeah.

00:21:52.795 --> 00:21:55.035
<v Speaker 0>Oh, let's see if I can articulate the

00:21:55.035 --> 00:21:57.995
<v Speaker 0>problem here. So we define access three.

00:21:59.170 --> 00:22:00.289
<v Speaker 0>We are

00:22:02.130 --> 00:22:05.010
<v Speaker 0>I'm thinking oh, and then trying to reassign

00:22:05.010 --> 00:22:07.170
<v Speaker 0>it and that is failing. Mhmm. So

00:22:09.410 --> 00:22:10.049
<v Speaker 0>no.

00:22:10.450 --> 00:22:11.890
<v Speaker 0>I've written by default

00:22:12.045 --> 00:22:14.445
<v Speaker 0>is immutable in Rust. Is that correct, Simon?

00:22:14.445 --> 00:22:15.325
<v Speaker 0>Alright. Yes.

00:22:15.885 --> 00:22:18.445
<v Speaker 0>So this exercise is what as to introduce

00:22:18.445 --> 00:22:20.365
<v Speaker 0>the mute keyword.

00:22:20.365 --> 00:22:20.845
<v Speaker 1>Totally.

00:22:24.890 --> 00:22:25.610
<v Speaker 1>That

00:22:25.930 --> 00:22:26.570
<v Speaker 1>works.

00:22:27.370 --> 00:22:29.210
<v Speaker 1>One fun thing, if you remove the mute

00:22:29.210 --> 00:22:30.410
<v Speaker 1>and go back to the error that you

00:22:30.410 --> 00:22:31.370
<v Speaker 1>got previously

00:22:33.770 --> 00:22:35.290
<v Speaker 1>so when I was talking before about how

00:22:35.290 --> 00:22:37.225
<v Speaker 1>the compiler tries to help you, you can

00:22:37.225 --> 00:22:38.904
<v Speaker 1>see that there, it's got this arrow pointing

00:22:38.904 --> 00:22:40.345
<v Speaker 1>to x and it says, hey. Make this

00:22:40.345 --> 00:22:42.424
<v Speaker 1>mutable by changing it to mute x. And

00:22:42.424 --> 00:22:44.184
<v Speaker 1>so Rust is actually able to say, like,

00:22:44.184 --> 00:22:46.345
<v Speaker 1>this may be what you want. And there's

00:22:46.345 --> 00:22:48.424
<v Speaker 1>actually a tool called Rust fix that can

00:22:48.424 --> 00:22:50.264
<v Speaker 1>take these suggestions and apply them to your

00:22:50.264 --> 00:22:52.710
<v Speaker 1>code automatically if you trust the compiler that

00:22:52.710 --> 00:22:54.550
<v Speaker 1>much. Every once in a while, it gets

00:22:54.550 --> 00:22:55.910
<v Speaker 1>it wrong, but most of the time, it's

00:22:55.910 --> 00:22:58.549
<v Speaker 1>pretty good about understanding what's what's going on.

00:22:59.030 --> 00:22:59.990
<v Speaker 1>Yeah. So

00:23:00.230 --> 00:23:01.350
<v Speaker 1>that's also a thing.

00:23:02.150 --> 00:23:04.630
<v Speaker 0>Alright. Let's stick our mute back in then.

00:23:05.030 --> 00:23:06.630
<v Speaker 0>Let let say yes,

00:23:07.294 --> 00:23:08.174
<v Speaker 0>and then

00:23:08.575 --> 00:23:09.934
<v Speaker 0>remove where I am done.

00:23:12.975 --> 00:23:13.934
<v Speaker 1>Variables four.

00:23:19.559 --> 00:23:21.720
<v Speaker 1>So this one is actually very similar to

00:23:21.720 --> 00:23:24.200
<v Speaker 1>number two. So I'm sort of surprised that

00:23:24.200 --> 00:23:25.479
<v Speaker 1>they're so similar,

00:23:25.799 --> 00:23:27.559
<v Speaker 1>but it's the same. It it is. Right?

00:23:27.559 --> 00:23:29.320
<v Speaker 0>It's just a no no value. Right? Yeah.

00:23:29.320 --> 00:23:31.240
<v Speaker 1>It's like well, it doesn't have one because

00:23:31.240 --> 00:23:32.760
<v Speaker 1>it's like, yeah, there's no there's no no

00:23:32.760 --> 00:23:33.720
<v Speaker 1>value. So

00:23:34.325 --> 00:23:36.085
<v Speaker 1>it's complaining about I don't know what that

00:23:36.085 --> 00:23:36.565
<v Speaker 1>is.

00:23:37.125 --> 00:23:39.205
<v Speaker 0>Let's just assume that passes.

00:23:39.525 --> 00:23:40.085
<v Speaker 1>Yeah.

00:23:43.205 --> 00:23:44.965
<v Speaker 1>Great. So that's the right one. Okay.

00:23:45.365 --> 00:23:46.805
<v Speaker 0>So let hold on. I'll read my error

00:23:46.805 --> 00:23:49.445
<v Speaker 0>messages first. So expected

00:23:49.050 --> 00:23:50.650
<v Speaker 0>string found

00:23:50.650 --> 00:23:51.690
<v Speaker 0>integer.

00:23:52.330 --> 00:23:52.970
<v Speaker 0>Yes.

00:23:53.210 --> 00:23:55.770
<v Speaker 0>Okay. So we define a variable called number.

00:23:56.010 --> 00:23:58.330
<v Speaker 0>We print it out, and then

00:24:00.090 --> 00:24:02.330
<v Speaker 0>it's trying to be reassigned

00:24:02.330 --> 00:24:04.490
<v Speaker 0>and then manipulate it in the next print.

00:24:04.865 --> 00:24:06.865
<v Speaker 0>Mhmm. Quite a lot going on there then.

00:24:07.105 --> 00:24:07.665
<v Speaker 1>Yeah.

00:24:08.225 --> 00:24:09.905
<v Speaker 1>So yes. This is kind of showing you

00:24:09.905 --> 00:24:13.025
<v Speaker 1>how once you give a variable some sort

00:24:13.025 --> 00:24:15.105
<v Speaker 1>of value, you can't change its type later.

00:24:15.105 --> 00:24:17.105
<v Speaker 1>So if this were Ruby or Python or

00:24:17.105 --> 00:24:19.025
<v Speaker 1>JavaScript, you know, it's totally fine to have

00:24:19.025 --> 00:24:20.890
<v Speaker 1>something be a string and later change it

00:24:20.890 --> 00:24:22.170
<v Speaker 1>to a number, and that's, like, not a

00:24:22.170 --> 00:24:24.970
<v Speaker 1>big deal. But in Rust, variables have, like,

00:24:24.970 --> 00:24:27.130
<v Speaker 1>a type whenever you, you know, make them,

00:24:27.130 --> 00:24:28.970
<v Speaker 1>and a type can't change even if the

00:24:28.970 --> 00:24:31.130
<v Speaker 1>value can change to something within that similar

00:24:31.130 --> 00:24:32.650
<v Speaker 1>type. So yeah.

00:24:36.125 --> 00:24:38.365
<v Speaker 0>K. So the fix here is just

00:24:41.325 --> 00:24:43.644
<v Speaker 1>Yeah. It I I find it's interesting. I'm

00:24:43.644 --> 00:24:45.164
<v Speaker 1>not sure what the fix is they want

00:24:45.164 --> 00:24:47.164
<v Speaker 1>you to do here, but

00:24:47.325 --> 00:24:49.404
<v Speaker 1>I can show you an interesting fix,

00:24:50.340 --> 00:24:52.659
<v Speaker 1>which is to do this. So

00:24:55.300 --> 00:24:55.940
<v Speaker 1>so

00:24:57.460 --> 00:24:59.620
<v Speaker 1>this will actually work. And this may be

00:24:59.620 --> 00:25:00.980
<v Speaker 1>what they're talking about, but I'm not a

00:25:00.980 --> 00:25:01.620
<v Speaker 1>% sure.

00:25:02.715 --> 00:25:04.554
<v Speaker 1>So what this is actually doing is this

00:25:04.554 --> 00:25:07.595
<v Speaker 1>is introducing another variable with the same name.

00:25:09.355 --> 00:25:09.914
<v Speaker 1>And

00:25:10.715 --> 00:25:13.514
<v Speaker 1>so this is not mutating the original

00:25:13.595 --> 00:25:15.755
<v Speaker 1>number three that's a string. This is creating

00:25:15.755 --> 00:25:18.075
<v Speaker 1>a new variable with the same name, which

00:25:17.570 --> 00:25:19.650
<v Speaker 1>means the old one is no longer accessible,

00:25:19.650 --> 00:25:21.570
<v Speaker 1>and so this actually does work.

00:25:22.130 --> 00:25:23.570
<v Speaker 1>And this is like a thing that's either

00:25:23.570 --> 00:25:25.330
<v Speaker 1>really normal to you or really weird to

00:25:25.330 --> 00:25:27.809
<v Speaker 1>you depending on which programming languages you've used

00:25:27.809 --> 00:25:28.690
<v Speaker 1>in the past,

00:25:29.330 --> 00:25:29.730
<v Speaker 1>frankly.

00:25:31.935 --> 00:25:34.175
<v Speaker 0>I'm gonna go with weird. But Yeah.

00:25:35.295 --> 00:25:37.135
<v Speaker 0>Yeah. And okay. So that just means we

00:25:37.135 --> 00:25:39.775
<v Speaker 0>we remove all references to the former variable

00:25:39.775 --> 00:25:41.775
<v Speaker 0>known as number, like, that's Check check it

00:25:41.775 --> 00:25:43.135
<v Speaker 1>out like this. Maybe this will help make

00:25:43.135 --> 00:25:44.255
<v Speaker 1>it make sense. So

00:25:45.760 --> 00:25:47.600
<v Speaker 1>imagine we have a new scope

00:25:48.880 --> 00:25:51.360
<v Speaker 1>here. So we have curly braces. Right? So

00:25:51.360 --> 00:25:51.999
<v Speaker 1>now

00:25:52.160 --> 00:25:54.480
<v Speaker 1>this declares the new variable three, but then

00:25:54.480 --> 00:25:55.840
<v Speaker 1>it's gonna go out of scope on this

00:25:55.840 --> 00:25:58.559
<v Speaker 1>line. So now here, the old one still

00:25:58.559 --> 00:26:00.000
<v Speaker 1>exists. You can kinda think of this like

00:26:00.000 --> 00:26:01.355
<v Speaker 1>you have a deck of cards. So you

00:26:01.355 --> 00:26:02.875
<v Speaker 1>have, like, the five of clubs, and you

00:26:02.875 --> 00:26:04.555
<v Speaker 1>put a new card on top, and it's

00:26:04.555 --> 00:26:06.315
<v Speaker 1>like the two of hearts. And then later,

00:26:06.315 --> 00:26:07.515
<v Speaker 1>you pull the two of hearts off, and

00:26:07.515 --> 00:26:09.275
<v Speaker 1>the five of clubs is still, like, underneath

00:26:09.275 --> 00:26:09.755
<v Speaker 1>there.

00:26:10.955 --> 00:26:13.115
<v Speaker 1>This would print, like, t h r e

00:26:13.115 --> 00:26:15.880
<v Speaker 1>e and then five and then t h

00:26:15.880 --> 00:26:17.960
<v Speaker 1>r e e again because it's kinda like

00:26:17.960 --> 00:26:20.120
<v Speaker 1>you have this, like, you know, deck of

00:26:20.120 --> 00:26:22.120
<v Speaker 1>variables. And then I didn't save it, so

00:26:22.120 --> 00:26:23.880
<v Speaker 1>it's like Awesome. I forgot the new thing.

00:26:23.880 --> 00:26:24.360
<v Speaker 1>Yeah. Sorry.

00:26:26.054 --> 00:26:27.815
<v Speaker 0>There we go. Okay. Yeah. So so now

00:26:27.815 --> 00:26:28.774
<v Speaker 1>you can see how it kinda, like, goes

00:26:28.774 --> 00:26:29.815
<v Speaker 1>in a scope and then goes out of

00:26:29.815 --> 00:26:31.654
<v Speaker 1>scope, and the original value is still there.

00:26:31.654 --> 00:26:33.335
<v Speaker 1>It's just the name is, like, no longer

00:26:33.335 --> 00:26:34.294
<v Speaker 1>accessible.

00:26:35.414 --> 00:26:38.135
<v Speaker 1>Yeah. And it's kinda, like, not super you

00:26:38.135 --> 00:26:40.294
<v Speaker 1>know, there's certain situations in which this is

00:26:40.294 --> 00:26:42.270
<v Speaker 1>very useful, and it kind of makes the

00:26:42.270 --> 00:26:44.590
<v Speaker 1>rest of the world less complicated.

00:26:44.910 --> 00:26:46.510
<v Speaker 1>But it can feel weird

00:26:46.590 --> 00:26:48.270
<v Speaker 1>if you're not used to it for sure.

00:26:48.270 --> 00:26:50.590
<v Speaker 1>It's kind of a semi controversial choice.

00:26:52.510 --> 00:26:54.110
<v Speaker 0>Oh, no. Let me remove the I am

00:26:54.110 --> 00:26:55.390
<v Speaker 0>done. We'll keep Rust things happening.

00:26:56.845 --> 00:26:59.085
<v Speaker 0>K. And then we'll pop open number six.

00:26:59.085 --> 00:27:00.125
<v Speaker 0>So here

00:27:00.285 --> 00:27:01.805
<v Speaker 0>oh, it's trying to define

00:27:02.285 --> 00:27:03.485
<v Speaker 0>a constant,

00:27:03.965 --> 00:27:04.525
<v Speaker 0>which

00:27:05.805 --> 00:27:07.725
<v Speaker 0>is telling us that we have to provide

00:27:07.725 --> 00:27:08.445
<v Speaker 0>a

00:27:08.765 --> 00:27:11.245
<v Speaker 1>Type. Type. Yes. And it's actually telling us,

00:27:11.245 --> 00:27:13.460
<v Speaker 0>hey. You might wanna make this a 32

00:27:13.460 --> 00:27:15.380
<v Speaker 1>digit. Which is the default.

00:27:15.860 --> 00:27:17.299
<v Speaker 1>So yeah. So so

00:27:17.460 --> 00:27:19.940
<v Speaker 1>similar to how we define variables with let,

00:27:20.020 --> 00:27:22.020
<v Speaker 1>we can define constants with const.

00:27:22.180 --> 00:27:24.340
<v Speaker 1>The difference is is that we don't infer

00:27:24.340 --> 00:27:26.580
<v Speaker 1>the type of constants. We make you put

00:27:26.580 --> 00:27:27.140
<v Speaker 1>the type out.

00:27:28.205 --> 00:27:30.045
<v Speaker 1>And there's a couple different reasons for this,

00:27:30.045 --> 00:27:32.205
<v Speaker 1>but, basically, a lot of it boils down

00:27:32.205 --> 00:27:32.764
<v Speaker 1>to

00:27:33.485 --> 00:27:36.125
<v Speaker 1>it is local variables. You're usually using them

00:27:36.125 --> 00:27:37.965
<v Speaker 1>in one place pretty soon, and so it's,

00:27:37.965 --> 00:27:39.245
<v Speaker 1>like, easy to figure out what the type

00:27:39.245 --> 00:27:41.565
<v Speaker 1>should be. But constants are used globally in

00:27:41.565 --> 00:27:43.245
<v Speaker 1>a lot of places, and they, like, often

00:27:43.245 --> 00:27:45.780
<v Speaker 1>become sort of external API. And so you're

00:27:45.780 --> 00:27:48.179
<v Speaker 1>required to write the type down on constants

00:27:48.179 --> 00:27:51.380
<v Speaker 1>even if you're not on on regular variables.

00:27:51.380 --> 00:27:52.820
<v Speaker 1>And constants,

00:27:52.900 --> 00:27:54.580
<v Speaker 1>they're not just constant, but they're also kinda,

00:27:54.580 --> 00:27:56.179
<v Speaker 1>like, global. So you can see how it's

00:27:56.179 --> 00:27:58.260
<v Speaker 1>defined outside of the function. We could use

00:27:58.260 --> 00:28:00.874
<v Speaker 1>this number in any of our functions anywhere

00:28:01.115 --> 00:28:02.875
<v Speaker 1>as opposed to just in the body of

00:28:02.875 --> 00:28:03.914
<v Speaker 1>the function itself.

00:28:04.715 --> 00:28:05.514
<v Speaker 0>Alright.

00:28:06.075 --> 00:28:08.235
<v Speaker 0>It's always good to understand why these decisions

00:28:08.235 --> 00:28:09.995
<v Speaker 0>are made. It makes things a lot a

00:28:09.995 --> 00:28:11.274
<v Speaker 0>lot easier to understand.

00:28:11.514 --> 00:28:13.769
<v Speaker 1>Totally. I I have often found that when

00:28:13.769 --> 00:28:15.529
<v Speaker 1>I get mad about something in programming,

00:28:15.690 --> 00:28:17.610
<v Speaker 1>if I learn about why the decision was

00:28:17.610 --> 00:28:19.370
<v Speaker 1>made to make it that way, I'm like,

00:28:19.370 --> 00:28:21.049
<v Speaker 1>you know, I can see why that choice

00:28:21.049 --> 00:28:22.490
<v Speaker 1>was made. And so even though it's annoying

00:28:22.490 --> 00:28:23.850
<v Speaker 1>to me, like, I get it and I

00:28:23.850 --> 00:28:25.130
<v Speaker 1>get less mad about it. So,

00:28:25.835 --> 00:28:27.675
<v Speaker 1>yeah. Well, you're doing a lot of embedded

00:28:27.675 --> 00:28:29.675
<v Speaker 0>systems work now. Right? So you're working directly

00:28:29.675 --> 00:28:31.115
<v Speaker 0>with Linux syscalls?

00:28:31.355 --> 00:28:33.435
<v Speaker 1>But not even with Linux syscalls. Like, we

00:28:33.435 --> 00:28:35.275
<v Speaker 1>are writing an operating system. Like, I'm the

00:28:35.275 --> 00:28:37.435
<v Speaker 1>one Oh. Building the syscalls.

00:28:37.435 --> 00:28:38.155
<v Speaker 1>So yes.

00:28:39.130 --> 00:28:40.250
<v Speaker 1>So I have to deal with the hardware

00:28:40.250 --> 00:28:42.170
<v Speaker 1>and the decisions the hardware people made and,

00:28:42.170 --> 00:28:44.010
<v Speaker 1>like, why does this require, you know, doing

00:28:44.010 --> 00:28:45.450
<v Speaker 1>this this way and that kind of thing.

00:28:45.450 --> 00:28:47.370
<v Speaker 1>So the same thing, just one level down

00:28:47.690 --> 00:28:48.649
<v Speaker 1>like anything.

00:28:48.890 --> 00:28:50.250
<v Speaker 0>I hope you kept the e in your

00:28:50.250 --> 00:28:52.090
<v Speaker 0>create SIS call though. Yeah.

00:28:53.290 --> 00:28:53.690
<v Speaker 1>Totally.

00:28:54.725 --> 00:28:55.845
<v Speaker 0>Okay. So

00:28:56.165 --> 00:28:58.965
<v Speaker 0>this never onto the functions elements. It's like,

00:28:58.965 --> 00:29:00.965
<v Speaker 0>okay. We're gonna understand how Rust functions work.

00:29:00.965 --> 00:29:02.325
<v Speaker 0>We can see we've got our main function,

00:29:02.325 --> 00:29:03.845
<v Speaker 0>which we're not familiar with, and it's trying

00:29:03.845 --> 00:29:05.445
<v Speaker 0>to call a function that hasn't been defined

00:29:05.445 --> 00:29:08.085
<v Speaker 0>yet. Mhmm. But I'm assuming we can just

00:29:08.085 --> 00:29:09.445
<v Speaker 0>define our new function.

00:29:11.960 --> 00:29:13.880
<v Speaker 0>Is is that enough for that to pass?

00:29:13.880 --> 00:29:15.720
<v Speaker 1>That should be enough. Let's let's give it

00:29:15.720 --> 00:29:16.359
<v Speaker 1>a run.

00:29:16.760 --> 00:29:17.479
<v Speaker 1>Done.

00:29:18.760 --> 00:29:21.559
<v Speaker 0>So if we can when we don't provide

00:29:21.559 --> 00:29:24.679
<v Speaker 0>a return type or even any code within

00:29:24.679 --> 00:29:25.320
<v Speaker 0>a function,

00:29:26.425 --> 00:29:28.345
<v Speaker 0>what happens there? Is that just a void

00:29:28.345 --> 00:29:29.865
<v Speaker 0>type? Or So

00:29:29.945 --> 00:29:32.425
<v Speaker 1>sorta kinda. Let's see what happens with functions

00:29:32.425 --> 00:29:34.185
<v Speaker 1>two and three, and it'll be a little

00:29:34.185 --> 00:29:36.025
<v Speaker 1>easier. I don't wanna, like, get too far

00:29:36.025 --> 00:29:37.065
<v Speaker 1>ahead of ourselves,

00:29:37.545 --> 00:29:39.145
<v Speaker 1>and I'm assuming that one of these next

00:29:39.145 --> 00:29:41.385
<v Speaker 1>examples will sorta get into the details.

00:29:42.000 --> 00:29:42.720
<v Speaker 1>Yeah.

00:29:43.040 --> 00:29:44.799
<v Speaker 1>This will be a little a little

00:29:45.440 --> 00:29:48.960
<v Speaker 1>more helpful. So the the error message let's

00:29:48.960 --> 00:29:50.080
<v Speaker 1>let's take a look at the actual error

00:29:50.080 --> 00:29:51.039
<v Speaker 1>message. So

00:29:52.240 --> 00:29:53.600
<v Speaker 1>there's a couple things going on.

00:29:54.475 --> 00:29:57.594
<v Speaker 1>As it says, anonymous parameters oh, interesting.

00:29:57.995 --> 00:29:59.195
<v Speaker 1>That's a funny,

00:29:59.515 --> 00:30:01.354
<v Speaker 1>not super ideal error message.

00:30:01.595 --> 00:30:02.154
<v Speaker 1>But,

00:30:03.595 --> 00:30:04.234
<v Speaker 1>basically,

00:30:05.274 --> 00:30:08.075
<v Speaker 1>what it's saying here is that numb

00:30:07.890 --> 00:30:10.130
<v Speaker 1>is a a parameter, but you haven't given

00:30:10.130 --> 00:30:13.010
<v Speaker 1>it a type. So, it's expecting you to

00:30:13.010 --> 00:30:14.610
<v Speaker 1>say what the type of numb is. So

00:30:14.610 --> 00:30:16.770
<v Speaker 1>I mentioned this before, variables get type inference,

00:30:16.770 --> 00:30:18.690
<v Speaker 1>but the arguments to functions don't.

00:30:18.850 --> 00:30:20.434
<v Speaker 1>And part of the reason for that is

00:30:20.434 --> 00:30:22.755
<v Speaker 1>that there's a couple different things, but the

00:30:22.755 --> 00:30:24.915
<v Speaker 1>primary one is that sort of, like, Rust

00:30:24.915 --> 00:30:26.915
<v Speaker 1>thinks about the function signature as being, like,

00:30:26.915 --> 00:30:29.075
<v Speaker 1>the contract. And so you declare the contract

00:30:29.075 --> 00:30:30.755
<v Speaker 1>upfront, and then it checks that the body

00:30:30.755 --> 00:30:31.955
<v Speaker 1>fits. So I kind of like to think

00:30:31.955 --> 00:30:33.955
<v Speaker 1>about it as, like, the first unit test.

00:30:34.035 --> 00:30:35.554
<v Speaker 1>You say, like, I expect there to be

00:30:35.554 --> 00:30:37.210
<v Speaker 1>this type. And so if it inferred the

00:30:37.210 --> 00:30:38.570
<v Speaker 1>type, you could make a change in the

00:30:38.570 --> 00:30:39.850
<v Speaker 1>body and that would change the type of

00:30:39.850 --> 00:30:41.130
<v Speaker 1>the function, and then you get, like, weird

00:30:41.130 --> 00:30:43.610
<v Speaker 1>bad error messages. And so Rust's attitude with

00:30:43.610 --> 00:30:45.529
<v Speaker 1>this is put the types in the function

00:30:45.529 --> 00:30:46.330
<v Speaker 1>signatures,

00:30:46.490 --> 00:30:48.570
<v Speaker 1>and then you will get nice errors only

00:30:48.570 --> 00:30:50.890
<v Speaker 1>in the body of your functions instead of

00:30:50.970 --> 00:30:52.445
<v Speaker 1>if can imagine, like, we go back to

00:30:52.445 --> 00:30:53.085
<v Speaker 1>the code.

00:30:53.645 --> 00:30:54.285
<v Speaker 1>If

00:30:54.445 --> 00:30:55.885
<v Speaker 1>if we change the type of the body

00:30:55.885 --> 00:30:57.885
<v Speaker 1>here and then this there was, like, a

00:30:57.885 --> 00:31:00.125
<v Speaker 1>problem, like, up here on line seven, you

00:31:00.125 --> 00:31:01.725
<v Speaker 1>would get an error message about line seven

00:31:01.725 --> 00:31:03.725
<v Speaker 1>being wrong when your actual error message would

00:31:03.725 --> 00:31:05.405
<v Speaker 1>be, like, you know, your app your problem

00:31:05.405 --> 00:31:06.445
<v Speaker 1>would be down here or whatever.

00:31:07.640 --> 00:31:09.320
<v Speaker 0>But I said that's the string. We'll see

00:31:09.320 --> 00:31:10.999
<v Speaker 0>some sort of message that just says

00:31:11.799 --> 00:31:13.879
<v Speaker 1>Yeah. Let's let's see what happens. It's complaining.

00:31:13.880 --> 00:31:16.039
<v Speaker 1>Maybe. Yeah. So it expected a string and

00:31:16.039 --> 00:31:18.360
<v Speaker 1>found an integer because we're passing an integer

00:31:18.360 --> 00:31:18.520
<v Speaker 1>in.

00:31:19.705 --> 00:31:21.705
<v Speaker 0>We tell it to expect an integer.

00:31:21.945 --> 00:31:23.625
<v Speaker 0>It's happy. Yep.

00:31:24.105 --> 00:31:26.345
<v Speaker 1>So this is how you pass arguments, and

00:31:26.345 --> 00:31:28.185
<v Speaker 1>it's sort of the same as the

00:31:28.505 --> 00:31:30.505
<v Speaker 1>variable syntax except for there's no let. Right?

00:31:30.505 --> 00:31:31.705
<v Speaker 1>So you have the name, the colon, and

00:31:31.705 --> 00:31:33.545
<v Speaker 1>the type just like we had in variables.

00:31:33.545 --> 00:31:34.745
<v Speaker 1>So ends up being the same thing.

00:31:35.540 --> 00:31:38.419
<v Speaker 0>Okay. So I'm curious. Like, whenever it's, like,

00:31:38.419 --> 00:31:39.780
<v Speaker 0>best and we were getting the error message

00:31:40.020 --> 00:31:42.179
<v Speaker 1>Yeah. It told us that we could also

00:31:42.179 --> 00:31:44.580
<v Speaker 0>if not using the colon, use at or

00:31:44.580 --> 00:31:46.660
<v Speaker 0>the pipe. Like, what would what would those

00:31:46.660 --> 00:31:47.460
<v Speaker 0>be? So

00:31:48.184 --> 00:31:50.345
<v Speaker 1>it turns out that the syntax is not

00:31:50.345 --> 00:31:51.065
<v Speaker 1>actually,

00:31:51.145 --> 00:31:52.105
<v Speaker 1>like, a

00:31:52.585 --> 00:31:54.424
<v Speaker 1>name colon type.

00:31:54.585 --> 00:31:57.784
<v Speaker 1>The syntax is actually pattern colon type.

00:31:58.025 --> 00:31:58.744
<v Speaker 1>And so

00:31:58.985 --> 00:32:01.705
<v Speaker 1>this gets into some more interesting and complicated

00:32:01.705 --> 00:32:04.920
<v Speaker 1>things. But, like, for example, Rust has two

00:32:04.920 --> 00:32:06.600
<v Speaker 1>pools. So you could say, like, this won't

00:32:06.600 --> 00:32:07.960
<v Speaker 1>work because I'm outside of function body, but

00:32:07.960 --> 00:32:09.160
<v Speaker 1>to give you an example of, like, the

00:32:09.160 --> 00:32:12.600
<v Speaker 1>syntax. So x equals one two oh, I

00:32:12.600 --> 00:32:14.120
<v Speaker 1>hit escape, which is bad.

00:32:15.284 --> 00:32:17.445
<v Speaker 1>So here now x would be a two

00:32:17.445 --> 00:32:19.284
<v Speaker 1>ball where you have a first element one

00:32:19.284 --> 00:32:21.124
<v Speaker 1>and a second element two. Right?

00:32:22.164 --> 00:32:24.004
<v Speaker 1>But because this is a pattern,

00:32:24.164 --> 00:32:26.245
<v Speaker 1>you can actually do fancier things. So I

00:32:26.245 --> 00:32:29.150
<v Speaker 1>could actually say, let x comma y equals

00:32:29.150 --> 00:32:31.150
<v Speaker 1>one comma two, and this would assign one

00:32:31.150 --> 00:32:32.990
<v Speaker 1>to x and two to y.

00:32:33.790 --> 00:32:34.429
<v Speaker 1>So,

00:32:34.830 --> 00:32:36.590
<v Speaker 1>so that's like a thing that's there. So

00:32:36.590 --> 00:32:38.670
<v Speaker 1>there's actually a whole bunch of fancy things

00:32:38.670 --> 00:32:40.535
<v Speaker 1>that you can do in here. And so,

00:32:41.255 --> 00:32:43.255
<v Speaker 1>what actually this lets you do is there's

00:32:43.255 --> 00:32:45.575
<v Speaker 1>there's some more complicated syntax where you can

00:32:45.575 --> 00:32:47.415
<v Speaker 1>put an at and then some more stuff

00:32:47.415 --> 00:32:49.655
<v Speaker 1>here or an or and then more stuff

00:32:49.655 --> 00:32:51.655
<v Speaker 1>here. And so the error message is, like,

00:32:51.655 --> 00:32:54.054
<v Speaker 1>saying, like, you either need the the type

00:32:54.240 --> 00:32:55.520
<v Speaker 1>or you need to be doing one of

00:32:55.520 --> 00:32:58.240
<v Speaker 1>those fancier things. So you almost never want

00:32:58.240 --> 00:33:00.080
<v Speaker 1>to be doing those things, so that's why

00:33:00.080 --> 00:33:01.919
<v Speaker 1>the error is, like, slightly misleading.

00:33:02.000 --> 00:33:03.840
<v Speaker 1>But it is technically the case that you

00:33:03.840 --> 00:33:05.120
<v Speaker 1>could do that if you wanted.

00:33:05.679 --> 00:33:06.399
<v Speaker 0>Alright.

00:33:06.640 --> 00:33:07.519
<v Speaker 0>Good to know.

00:33:08.400 --> 00:33:09.039
<v Speaker 0>So

00:33:09.784 --> 00:33:12.105
<v Speaker 0>oh, why It's the next example. You removed

00:33:12.904 --> 00:33:13.945
<v Speaker 0>Yeah. That's

00:33:14.025 --> 00:33:17.384
<v Speaker 0>silly me. Alright. Okay. Functions functions three.

00:33:17.705 --> 00:33:19.304
<v Speaker 0>We have an error message that tells us

00:33:19.304 --> 00:33:21.625
<v Speaker 0>expected one argument. This should be nice and

00:33:21.625 --> 00:33:23.784
<v Speaker 0>trivial. I'm assuming it just wants us to

00:33:23.784 --> 00:33:26.129
<v Speaker 0>to fix that. There we go. Okay.

00:33:27.970 --> 00:33:29.809
<v Speaker 0>On functions four.

00:33:30.450 --> 00:33:31.889
<v Speaker 0>K. We've got a little bit more code

00:33:31.889 --> 00:33:33.729
<v Speaker 0>here. So we got a main function,

00:33:34.769 --> 00:33:36.289
<v Speaker 0>setting some integer,

00:33:36.529 --> 00:33:39.565
<v Speaker 0>and then trying to calculate It's still price.

00:33:39.565 --> 00:33:41.884
<v Speaker 1>So you can actually see the right by

00:33:41.884 --> 00:33:43.884
<v Speaker 1>your cursor, there's a little squiggly a little

00:33:43.884 --> 00:33:46.125
<v Speaker 1>red squiggly right after the arrow. And so

00:33:46.125 --> 00:33:47.484
<v Speaker 1>I think that it actually

00:33:47.804 --> 00:33:49.325
<v Speaker 1>it it gives you the error right in

00:33:49.325 --> 00:33:51.485
<v Speaker 1>line. So Visual Studio Code has really great

00:33:51.485 --> 00:33:51.884
<v Speaker 1>integration

00:33:52.450 --> 00:33:54.850
<v Speaker 1>If you install the the Rust Analyzer plug

00:33:54.850 --> 00:33:56.530
<v Speaker 1>in like you have, you don't even have

00:33:56.530 --> 00:33:58.530
<v Speaker 1>to run them necessarily. It will figure out,

00:33:58.530 --> 00:34:00.450
<v Speaker 1>hey. This is I expected a type here.

00:34:00.450 --> 00:34:01.890
<v Speaker 1>So that's I wanted to point that out

00:34:01.890 --> 00:34:03.970
<v Speaker 1>too before you, you know, went back over.

00:34:03.970 --> 00:34:05.250
<v Speaker 1>We could see what the full error is

00:34:05.250 --> 00:34:07.250
<v Speaker 1>by looking at the terminal or whatever, but

00:34:07.250 --> 00:34:08.565
<v Speaker 1>you can also get those errors in your

00:34:08.565 --> 00:34:10.725
<v Speaker 1>thing. Pretty much the same error message. Basically,

00:34:10.725 --> 00:34:12.565
<v Speaker 1>the same thing. So yeah. So the way

00:34:12.565 --> 00:34:13.925
<v Speaker 1>that you do return types, you have a

00:34:13.925 --> 00:34:15.605
<v Speaker 1>little arrow, and then that gives you the

00:34:15.605 --> 00:34:17.284
<v Speaker 1>type of whatever you're returning. So in this

00:34:17.284 --> 00:34:19.205
<v Speaker 1>case, we wanna take in a price and

00:34:19.205 --> 00:34:21.260
<v Speaker 1>then return the discounted price. So we need

00:34:21.260 --> 00:34:22.859
<v Speaker 1>to take in an I 32, but also

00:34:22.859 --> 00:34:24.300
<v Speaker 1>return an I 32.

00:34:25.820 --> 00:34:28.460
<v Speaker 0>Okay. That's it. Right? Yep. There we go.

00:34:30.540 --> 00:34:32.300
<v Speaker 0>Finally, we have functions five.

00:34:35.095 --> 00:34:36.855
<v Speaker 1>So this is another fun

00:34:36.935 --> 00:34:37.735
<v Speaker 1>one. So

00:34:47.079 --> 00:34:50.359
<v Speaker 0>it's saying that expected an end oh, okay.

00:34:50.359 --> 00:34:51.960
<v Speaker 0>Is this because we don't have a return

00:34:51.960 --> 00:34:52.760
<v Speaker 0>keyword?

00:34:52.839 --> 00:34:54.760
<v Speaker 1>Yes. So there's two ways to solve this.

00:34:54.760 --> 00:34:55.880
<v Speaker 1>There's the, like,

00:34:57.319 --> 00:34:59.720
<v Speaker 1>idiomatic and the unidiomatic way. It turns out

00:34:59.720 --> 00:35:02.495
<v Speaker 1>that many languages do the what is unidiomatic

00:35:02.495 --> 00:35:04.255
<v Speaker 1>in Rust, but you're totally right. Because we

00:35:04.255 --> 00:35:05.775
<v Speaker 1>don't have a return keyword,

00:35:06.015 --> 00:35:08.255
<v Speaker 1>this is going to multiply two numbers and

00:35:08.255 --> 00:35:10.895
<v Speaker 1>then not give you the the value back.

00:35:10.975 --> 00:35:12.255
<v Speaker 1>So it's, like, kind of like a no

00:35:12.255 --> 00:35:14.300
<v Speaker 1>op. Like, it doesn't do anything. So if

00:35:14.300 --> 00:35:16.700
<v Speaker 1>you add return right before the numb asterisk

00:35:16.700 --> 00:35:19.180
<v Speaker 1>numb, this should work and everything is great.

00:35:20.940 --> 00:35:22.780
<v Speaker 1>So this works. However,

00:35:22.940 --> 00:35:25.340
<v Speaker 1>Rust is what's called an expression oriented language,

00:35:25.755 --> 00:35:28.394
<v Speaker 1>which means that almost everything evaluates

00:35:28.394 --> 00:35:31.355
<v Speaker 1>to some other value. So you can actually

00:35:31.355 --> 00:35:34.075
<v Speaker 1>drop the semicolon and the return.

00:35:34.474 --> 00:35:36.474
<v Speaker 1>And now we have just num times num

00:35:36.474 --> 00:35:39.194
<v Speaker 1>on its own. The the semicolon basically says,

00:35:39.194 --> 00:35:41.030
<v Speaker 1>like, hey. I don't care about the return

00:35:41.030 --> 00:35:42.710
<v Speaker 1>value of this. I wanna just, like, ignore

00:35:42.710 --> 00:35:45.190
<v Speaker 1>it. So, and that's why it's at the

00:35:45.190 --> 00:35:47.190
<v Speaker 1>end of almost every line is because, like,

00:35:47.190 --> 00:35:48.710
<v Speaker 1>that's kinda, like, how the structure of the

00:35:48.710 --> 00:35:50.710
<v Speaker 1>grammar works. So if you do it like

00:35:50.710 --> 00:35:52.550
<v Speaker 1>this, which is num times none with no

00:35:52.550 --> 00:35:55.145
<v Speaker 1>return, that will evaluate to nine as well

00:35:55.145 --> 00:35:57.145
<v Speaker 1>and give you the return value back. And

00:35:57.145 --> 00:35:58.825
<v Speaker 1>this is very common in some languages like

00:35:58.825 --> 00:36:01.625
<v Speaker 1>Ruby, for example, and totally foreign

00:36:01.625 --> 00:36:03.865
<v Speaker 1>if you do see your JavaScript or whatever.

00:36:03.865 --> 00:36:05.225
<v Speaker 1>This is another example of where Rust has

00:36:05.225 --> 00:36:07.065
<v Speaker 1>taken an influence from a certain style of

00:36:07.065 --> 00:36:09.250
<v Speaker 1>programming language that can maybe feel a little

00:36:09.250 --> 00:36:10.690
<v Speaker 1>bit awkward if you haven't worked in it.

00:36:10.690 --> 00:36:12.690
<v Speaker 1>And this is probably the number one thing

00:36:12.690 --> 00:36:14.369
<v Speaker 1>that people who are new to Rust kinda

00:36:14.369 --> 00:36:15.650
<v Speaker 1>complain about. So

00:36:16.289 --> 00:36:18.290
<v Speaker 1>and part of the reason why is that

00:36:19.569 --> 00:36:21.809
<v Speaker 1>when you start getting into things like closures,

00:36:22.914 --> 00:36:25.714
<v Speaker 1>this syntax becomes much more normal and regular

00:36:25.714 --> 00:36:26.675
<v Speaker 1>and smaller,

00:36:26.835 --> 00:36:28.355
<v Speaker 1>and so it ends up being a lot

00:36:28.355 --> 00:36:29.075
<v Speaker 1>easier.

00:36:29.394 --> 00:36:31.394
<v Speaker 1>But that's kinda jumping ahead, I guess, a

00:36:31.394 --> 00:36:31.954
<v Speaker 1>little bit.

00:36:32.835 --> 00:36:35.075
<v Speaker 0>So as the the golden rule there that

00:36:35.075 --> 00:36:36.755
<v Speaker 0>if you met a semicolon,

00:36:36.755 --> 00:36:39.420
<v Speaker 0>it's always an expression, which means it's, like,

00:36:39.420 --> 00:36:40.859
<v Speaker 1>kind of always an expression. You can kinda

00:36:40.859 --> 00:36:42.860
<v Speaker 1>think of it as, like, expression

00:36:43.900 --> 00:36:45.660
<v Speaker 1>exists. And if you put a semicolon on

00:36:45.660 --> 00:36:47.180
<v Speaker 1>it, then you don't get the value. You

00:36:47.180 --> 00:36:49.740
<v Speaker 1>get an empty tuple, which is these double

00:36:49.740 --> 00:36:52.060
<v Speaker 1>parentheses because, nothing in inside. It's like we

00:36:52.060 --> 00:36:53.180
<v Speaker 1>had the one and two before.

00:36:54.045 --> 00:36:56.125
<v Speaker 1>Just an empty tuple. So

00:36:57.165 --> 00:36:58.605
<v Speaker 1>It's kind of a little weird, kind of

00:36:58.605 --> 00:37:00.205
<v Speaker 1>a little in the weeds, a little technical.

00:37:00.285 --> 00:37:02.125
<v Speaker 1>Honestly, the compiler will tell you when you

00:37:02.125 --> 00:37:03.244
<v Speaker 1>get it wrong and you just fix it

00:37:03.244 --> 00:37:05.085
<v Speaker 1>one or the other ways. And eventually, you

00:37:05.085 --> 00:37:07.325
<v Speaker 1>kinda develop an intuition and you stop worrying

00:37:07.325 --> 00:37:07.965
<v Speaker 1>about it.

00:37:08.444 --> 00:37:09.165
<v Speaker 1>But yeah.

00:37:09.830 --> 00:37:10.710
<v Speaker 0>Alright.

00:37:11.430 --> 00:37:13.590
<v Speaker 0>But I think we have now covered everything

00:37:13.590 --> 00:37:16.150
<v Speaker 0>for quiz one. Thanks, sir. We could do

00:37:16.150 --> 00:37:18.070
<v Speaker 0>quiz one, which I guess would just

00:37:19.110 --> 00:37:21.670
<v Speaker 0>confirm that we've learned stuff live. It's basically

00:37:21.670 --> 00:37:23.430
<v Speaker 1>just writing the syntax that we've learned in

00:37:23.430 --> 00:37:24.950
<v Speaker 1>the previous examples.

00:37:24.950 --> 00:37:25.190
<v Speaker 1>Yeah.

00:37:26.605 --> 00:37:27.965
<v Speaker 0>Okay. So it's telling me I'm not allowed

00:37:27.965 --> 00:37:29.885
<v Speaker 0>to modify. Okay. I have to write the

00:37:29.885 --> 00:37:32.365
<v Speaker 0>calculate apple price function. Yep.

00:37:35.165 --> 00:37:35.965
<v Speaker 0>Alright.

00:37:37.565 --> 00:37:39.485
<v Speaker 0>Take some

00:37:41.110 --> 00:37:41.990
<v Speaker 0>price.

00:37:44.230 --> 00:37:45.990
<v Speaker 0>Another return value.

00:37:46.230 --> 00:37:47.030
<v Speaker 0>Mhmm.

00:37:47.990 --> 00:37:48.870
<v Speaker 0>And

00:37:49.190 --> 00:37:50.790
<v Speaker 0>I should probably redo what it's supposed to

00:37:50.790 --> 00:37:50.950
<v Speaker 0>do.

00:37:53.835 --> 00:37:55.835
<v Speaker 0>Oh, it's how many apples I'm buying.

00:37:58.315 --> 00:38:00.635
<v Speaker 1>So it's if you have more than 40,

00:38:00.635 --> 00:38:02.795
<v Speaker 1>you it only costs 1. Basically, it costs

00:38:02.795 --> 00:38:04.555
<v Speaker 1>2 unless you're doing more than 40 in

00:38:04.555 --> 00:38:06.155
<v Speaker 1>which it costs 1. So there's, like, a

00:38:06.155 --> 00:38:07.115
<v Speaker 1>very small

00:38:07.355 --> 00:38:08.155
<v Speaker 1>calculation

00:38:08.155 --> 00:38:08.395
<v Speaker 1>there.

00:38:10.070 --> 00:38:12.710
<v Speaker 0>Alright. Well, number of apples.

00:38:14.550 --> 00:38:17.590
<v Speaker 0>And snake case is the idiomatic Rust approach.

00:38:17.590 --> 00:38:19.750
<v Speaker 0>Is that right? In so it's snake case

00:38:19.750 --> 00:38:22.230
<v Speaker 1>for variables and function names, and it's camel

00:38:22.230 --> 00:38:23.110
<v Speaker 1>case for types.

00:38:23.955 --> 00:38:26.995
<v Speaker 1>So you'll see, like, capital s string or

00:38:26.995 --> 00:38:28.435
<v Speaker 1>capital v vec.

00:38:28.595 --> 00:38:30.035
<v Speaker 1>And that way, can kinda tell at a

00:38:30.035 --> 00:38:31.955
<v Speaker 1>glance if it's something is a function or

00:38:31.955 --> 00:38:32.915
<v Speaker 1>variable or a type.

00:38:40.080 --> 00:38:42.640
<v Speaker 0>And then we return the number of apples

00:38:42.960 --> 00:38:45.760
<v Speaker 0>times one or the number of apples.

00:38:46.400 --> 00:38:46.960
<v Speaker 0>So

00:38:49.805 --> 00:38:51.484
<v Speaker 1>You're close. So

00:38:54.125 --> 00:38:56.045
<v Speaker 1>because of the way that you've written this,

00:38:56.045 --> 00:38:58.765
<v Speaker 1>the if statement would return into that number

00:38:58.765 --> 00:39:00.204
<v Speaker 1>of apples, but it's not gonna, like, return

00:39:00.204 --> 00:39:01.964
<v Speaker 1>it from the function entirely. So you have

00:39:01.964 --> 00:39:02.845
<v Speaker 1>two

00:39:02.770 --> 00:39:04.210
<v Speaker 1>have two ways of doing this. You can

00:39:04.210 --> 00:39:06.690
<v Speaker 1>either make the whole body one if expression.

00:39:06.850 --> 00:39:08.290
<v Speaker 1>You have two expressions here. Right? You have

00:39:08.290 --> 00:39:09.410
<v Speaker 1>the if and then you have the second

00:39:09.410 --> 00:39:11.090
<v Speaker 1>thing. So you're gonna do an if else.

00:39:11.090 --> 00:39:13.890
<v Speaker 1>That way, the whole body is one if

00:39:13.890 --> 00:39:14.530
<v Speaker 1>statement,

00:39:14.770 --> 00:39:17.170
<v Speaker 1>or you can use return to return early

00:39:17.585 --> 00:39:18.145
<v Speaker 1>and,

00:39:18.785 --> 00:39:19.345
<v Speaker 1>yeah,

00:39:19.825 --> 00:39:22.625
<v Speaker 1>that that actually will technically work. I think

00:39:22.625 --> 00:39:24.305
<v Speaker 1>most people would write it inside the body

00:39:24.305 --> 00:39:26.944
<v Speaker 1>of the if instead. So, like, online 27.

00:39:26.944 --> 00:39:27.505
<v Speaker 1>Yeah.

00:39:29.025 --> 00:39:30.545
<v Speaker 1>So this should work, I think.

00:39:32.830 --> 00:39:35.310
<v Speaker 1>Yay. You did it. And the alternative approach

00:39:35.310 --> 00:39:36.510
<v Speaker 0>you said there was

00:39:37.470 --> 00:39:39.710
<v Speaker 0>to to else here so that I only

00:39:39.710 --> 00:39:41.869
<v Speaker 0>have one expression and then Yeah. And then

00:39:41.869 --> 00:39:43.070
<v Speaker 1>now both

00:39:43.745 --> 00:39:46.065
<v Speaker 1>arms of the if evaluate to a value,

00:39:46.065 --> 00:39:47.505
<v Speaker 1>and then the whole thing gets returned. And

00:39:47.505 --> 00:39:49.105
<v Speaker 1>so that ends up being the same thing.

00:39:49.105 --> 00:39:50.865
<v Speaker 1>Yeah. So this is now one expression in

00:39:50.865 --> 00:39:52.385
<v Speaker 1>the body instead of two expressions.

00:39:53.905 --> 00:39:54.465
<v Speaker 0>Nice.

00:39:54.785 --> 00:39:56.705
<v Speaker 0>Alright. Let's see. What does quiz two want

00:39:56.705 --> 00:39:58.960
<v Speaker 0>from us? So this is the

00:39:59.280 --> 00:40:00.400
<v Speaker 1>strings. Yeah.

00:40:01.120 --> 00:40:03.440
<v Speaker 0>This is definitely one of the things that

00:40:03.440 --> 00:40:05.200
<v Speaker 0>always trips me up when I'm

00:40:05.600 --> 00:40:07.600
<v Speaker 0>attempting to write Rust, I should say. Totally.

00:40:07.600 --> 00:40:09.520
<v Speaker 0>Is that should I mean, what is the

00:40:09.520 --> 00:40:11.040
<v Speaker 0>idiomatic way? Should I be using

00:40:11.635 --> 00:40:14.195
<v Speaker 0>string, or should I be using string types?

00:40:14.195 --> 00:40:15.555
<v Speaker 0>Like, is there a one I should choose

00:40:15.555 --> 00:40:17.795
<v Speaker 0>by default? Are there any rules? And that

00:40:17.955 --> 00:40:19.395
<v Speaker 0>maybe we could just start by saying what

00:40:19.395 --> 00:40:21.395
<v Speaker 0>are the differences between Totally. So for the

00:40:21.395 --> 00:40:22.915
<v Speaker 1>background, Rust has sort of

00:40:23.770 --> 00:40:25.450
<v Speaker 1>depending on how you answer this question, Rust

00:40:25.450 --> 00:40:28.170
<v Speaker 1>either has one or, like, seven string types.

00:40:28.970 --> 00:40:31.050
<v Speaker 1>Part of that is because in many languages

00:40:31.050 --> 00:40:33.290
<v Speaker 1>with, like, garbage collection and stuff like that,

00:40:33.450 --> 00:40:35.290
<v Speaker 1>strings are a little easier. But it turns

00:40:35.290 --> 00:40:36.890
<v Speaker 1>out that any sort of variable

00:40:36.970 --> 00:40:40.315
<v Speaker 1>width structure is really difficult whenever you're, whenever

00:40:40.315 --> 00:40:41.595
<v Speaker 1>you don't have a GC and some other

00:40:41.595 --> 00:40:42.635
<v Speaker 1>things. And so,

00:40:43.275 --> 00:40:45.115
<v Speaker 1>this is kind of like strings are sort

00:40:45.115 --> 00:40:46.714
<v Speaker 1>of the entry point into

00:40:46.875 --> 00:40:48.714
<v Speaker 1>going from the absolute beginning. So we've sort

00:40:48.714 --> 00:40:50.075
<v Speaker 1>of done stuff that looks the same in

00:40:50.075 --> 00:40:52.470
<v Speaker 1>Rust as in basically any language. Strings are

00:40:52.470 --> 00:40:54.710
<v Speaker 1>kind of like the usual point where people

00:40:54.710 --> 00:40:57.110
<v Speaker 1>start learning a little more about the details

00:40:57.110 --> 00:40:59.830
<v Speaker 1>of things. And, honestly, it's so common that

00:40:59.830 --> 00:41:01.190
<v Speaker 1>we actually reoriented

00:41:01.190 --> 00:41:03.910
<v Speaker 1>the table of contents of the book around

00:41:03.910 --> 00:41:05.585
<v Speaker 1>the question of what do you need to

00:41:05.585 --> 00:41:07.984
<v Speaker 1>get to to understand strings and then how

00:41:07.984 --> 00:41:10.224
<v Speaker 1>to explain strings as early as possible. So

00:41:10.224 --> 00:41:11.825
<v Speaker 1>the first three chapters of the book are

00:41:11.825 --> 00:41:13.424
<v Speaker 1>kind of all the generic sort of syntax

00:41:13.424 --> 00:41:15.265
<v Speaker 1>that we've talked about so far. And then

00:41:15.265 --> 00:41:16.865
<v Speaker 1>chapter four is, like, let's get into it

00:41:16.865 --> 00:41:17.744
<v Speaker 1>with strings. So

00:41:19.110 --> 00:41:20.470
<v Speaker 1>the way you can think about these, these

00:41:20.470 --> 00:41:23.430
<v Speaker 1>are the two most core types about strings

00:41:23.430 --> 00:41:24.390
<v Speaker 1>in Rust.

00:41:24.630 --> 00:41:26.390
<v Speaker 1>The first one, the ampersand str,

00:41:26.790 --> 00:41:28.630
<v Speaker 1>if you've done some c or c plus

00:41:28.630 --> 00:41:30.310
<v Speaker 1>plus languages like that, you may recognize the

00:41:30.310 --> 00:41:31.670
<v Speaker 1>ampersand means it's like a reference.

00:41:32.505 --> 00:41:34.424
<v Speaker 1>And the capital s string is sort of

00:41:34.424 --> 00:41:36.505
<v Speaker 1>a what we call an own string type.

00:41:36.505 --> 00:41:38.345
<v Speaker 1>So sort of the difference is is that

00:41:38.424 --> 00:41:40.984
<v Speaker 1>the ampersand str is kind of like a

00:41:41.065 --> 00:41:42.825
<v Speaker 1>you're looking at some other string that exists

00:41:42.825 --> 00:41:45.145
<v Speaker 1>somewhere, so it's immutable. You can't change anything

00:41:45.145 --> 00:41:47.750
<v Speaker 1>about it. The capitalist string means that you

00:41:47.750 --> 00:41:49.110
<v Speaker 1>are the one who's in control of the

00:41:49.110 --> 00:41:50.390
<v Speaker 1>data of the string, and so that means

00:41:50.390 --> 00:41:51.990
<v Speaker 1>you can change it, you can modify it,

00:41:51.990 --> 00:41:52.870
<v Speaker 1>you can grow,

00:41:53.350 --> 00:41:56.310
<v Speaker 1>and and modify things. And so, that's that's

00:41:56.310 --> 00:41:58.230
<v Speaker 1>kinda like when you would use each one

00:41:58.230 --> 00:41:59.190
<v Speaker 1>depends on

00:42:00.015 --> 00:42:01.454
<v Speaker 1>what, you know, what you're trying to do.

00:42:01.454 --> 00:42:03.295
<v Speaker 1>If you wanna change the string itself and

00:42:03.295 --> 00:42:04.895
<v Speaker 1>modify it some way, you'd be using capital

00:42:04.895 --> 00:42:05.775
<v Speaker 1>s string.

00:42:05.934 --> 00:42:07.454
<v Speaker 1>If you just wanna read the value and

00:42:07.454 --> 00:42:09.214
<v Speaker 1>you don't care about doing modifications, you would

00:42:09.214 --> 00:42:11.055
<v Speaker 1>use you'll use ampersand string.

00:42:11.214 --> 00:42:13.800
<v Speaker 1>And one interesting thing that that kinda, like,

00:42:13.800 --> 00:42:15.160
<v Speaker 1>comes out of that is it means that

00:42:15.160 --> 00:42:18.120
<v Speaker 1>you often see ampersand string as arguments to

00:42:18.120 --> 00:42:20.120
<v Speaker 1>a function, and you often see capital s

00:42:20.120 --> 00:42:22.040
<v Speaker 1>string as a return type of a function.

00:42:22.040 --> 00:42:23.320
<v Speaker 1>So if you think about it, usually, you

00:42:23.320 --> 00:42:24.920
<v Speaker 1>take an argument, you don't change it, you

00:42:24.920 --> 00:42:26.475
<v Speaker 1>just look at it and do whatever. But

00:42:26.475 --> 00:42:28.475
<v Speaker 1>if you're returning something, that often means that

00:42:28.475 --> 00:42:30.555
<v Speaker 1>you wanna, like the person who's getting that

00:42:30.555 --> 00:42:32.235
<v Speaker 1>back is gonna change it or modify it

00:42:32.235 --> 00:42:33.675
<v Speaker 1>in some way or do something like that.

00:42:33.835 --> 00:42:35.195
<v Speaker 1>So you can see this exactly on line

00:42:35.195 --> 00:42:37.835
<v Speaker 1>12 here. We're returning a capital s string,

00:42:38.075 --> 00:42:40.475
<v Speaker 1>but, it turns out the string literals are

00:42:40.475 --> 00:42:43.450
<v Speaker 1>ampersand string, and so it's gonna complain that

00:42:43.450 --> 00:42:45.450
<v Speaker 1>the types don't make sense. If you if

00:42:45.450 --> 00:42:47.850
<v Speaker 1>you run the the compiler,

00:42:47.850 --> 00:42:48.330
<v Speaker 1>it should

00:42:49.290 --> 00:42:50.970
<v Speaker 0>Oh, I didn't remove my

00:42:51.690 --> 00:42:53.610
<v Speaker 1>Oh, yeah. Think it didn't get saved on

00:42:54.335 --> 00:42:56.654
<v Speaker 1>variable three dot r s. Oh, yeah. Line

00:42:56.654 --> 00:42:59.055
<v Speaker 1>four is I'm not done. Although, it's

00:42:59.375 --> 00:43:01.775
<v Speaker 0>a nice coincidence that I had to open

00:43:01.775 --> 00:43:03.855
<v Speaker 0>this again, I guess, actually, because we had

00:43:03.855 --> 00:43:06.095
<v Speaker 0>a question from someone Oh, cool. I missed

00:43:06.095 --> 00:43:08.220
<v Speaker 0>it. For a quiz one. And I think

00:43:08.300 --> 00:43:10.140
<v Speaker 0>because this is slightly out of context, I'm

00:43:10.140 --> 00:43:11.740
<v Speaker 0>gonna try and guess what they ask.

00:43:12.060 --> 00:43:13.980
<v Speaker 0>But does it work with the parenthesis? And

00:43:13.980 --> 00:43:16.620
<v Speaker 0>I'm assuming what they're suggesting was

00:43:16.700 --> 00:43:17.980
<v Speaker 0>this approach,

00:43:18.700 --> 00:43:20.220
<v Speaker 0>but removing these

00:43:21.615 --> 00:43:23.855
<v Speaker 1>So those that might be a question. I

00:43:23.855 --> 00:43:25.455
<v Speaker 1>don't think that's what they asked, but this

00:43:25.455 --> 00:43:26.735
<v Speaker 1>does not work. It's true.

00:43:27.135 --> 00:43:30.175
<v Speaker 1>Those are curly braces, not parentheses. The parentheses

00:43:30.175 --> 00:43:32.415
<v Speaker 1>are the around number of apples greater than

00:43:32.415 --> 00:43:34.575
<v Speaker 1>equal to 40, the the rounded ones on

00:43:34.575 --> 00:43:35.215
<v Speaker 1>line 26.

00:43:35.850 --> 00:43:36.410
<v Speaker 1>So

00:43:36.650 --> 00:43:38.810
<v Speaker 1>yes. And, actually, the compiler will warn you

00:43:38.810 --> 00:43:40.570
<v Speaker 1>if you put those parentheses in there because

00:43:40.570 --> 00:43:42.970
<v Speaker 1>they are actually not needed in Rust.

00:43:43.290 --> 00:43:44.650
<v Speaker 1>And so you can put them if you

00:43:44.650 --> 00:43:45.130
<v Speaker 1>want,

00:43:45.450 --> 00:43:47.850
<v Speaker 1>but usually people drop them off. So

00:43:48.330 --> 00:43:48.890
<v Speaker 1>That's

00:43:49.135 --> 00:43:51.295
<v Speaker 1>both both versions of if whichever way they

00:43:51.295 --> 00:43:52.815
<v Speaker 1>meant, those are the two answers to those

00:43:52.815 --> 00:43:54.095
<v Speaker 1>two questions totally.

00:43:54.335 --> 00:43:55.535
<v Speaker 0>Oh, you're right. I don't know why I

00:43:55.535 --> 00:43:57.215
<v Speaker 0>thought those were print, but we're good. That

00:43:57.215 --> 00:43:59.455
<v Speaker 0>was good to know anyway. Yeah. Yeah. I'm

00:43:59.455 --> 00:44:01.310
<v Speaker 0>so used to this in Go that I

00:44:01.310 --> 00:44:03.390
<v Speaker 0>now accidentally type or try to do that

00:44:03.390 --> 00:44:05.230
<v Speaker 0>in other languages and then always end up

00:44:05.230 --> 00:44:06.830
<v Speaker 0>getting frustrated. So it's good that that works.

00:44:06.830 --> 00:44:10.030
<v Speaker 1>Yeah. There's actually really interesting history there about

00:44:10.030 --> 00:44:12.190
<v Speaker 1>programming languages and grammar and stuff, but we're

00:44:12.190 --> 00:44:14.350
<v Speaker 1>getting too far off topic probably, so I

00:44:14.350 --> 00:44:15.515
<v Speaker 1>won't get into it. But just the point

00:44:15.515 --> 00:44:17.435
<v Speaker 1>is new languages have dropped it because they

00:44:17.435 --> 00:44:19.595
<v Speaker 1>require the curly braces. If you don't require

00:44:19.595 --> 00:44:21.835
<v Speaker 1>the curly braces, then you need the parentheses

00:44:21.835 --> 00:44:23.515
<v Speaker 1>more than if you don't. And so that's

00:44:23.915 --> 00:44:25.515
<v Speaker 1>there's there's a whole bunch going on there.

00:44:25.515 --> 00:44:27.115
<v Speaker 1>It's actually a pretty interesting question if you're

00:44:27.115 --> 00:44:28.075
<v Speaker 1>into languages.

00:44:29.515 --> 00:44:29.915
<v Speaker 1>So yeah.

00:44:31.500 --> 00:44:33.420
<v Speaker 0>Okay. So this why is that one on

00:44:33.420 --> 00:44:35.820
<v Speaker 0>just primitive types? Why did it go to

00:44:35.820 --> 00:44:37.900
<v Speaker 1>primitive types? Yeah. Maybe that's because that's the

00:44:37.900 --> 00:44:40.700
<v Speaker 1>next one instead of this one. But quest

00:44:40.700 --> 00:44:42.060
<v Speaker 0>two said strings,

00:44:42.060 --> 00:44:42.140
<v Speaker 0>though.

00:44:42.984 --> 00:44:44.665
<v Speaker 0>Oh, that's guess okay. Maybe this is not

00:44:44.665 --> 00:44:46.825
<v Speaker 0>a quiz on primitive types. So that's okay.

00:44:46.825 --> 00:44:48.025
<v Speaker 0>Maybe that's what it is. Yeah. It's a

00:44:48.025 --> 00:44:50.185
<v Speaker 1>quiz. We'll we'll just walk through strings one

00:44:50.185 --> 00:44:51.464
<v Speaker 0>and two and then we can double back.

00:44:51.464 --> 00:44:53.385
<v Speaker 0>So it looks like we have two options

00:44:53.385 --> 00:44:56.025
<v Speaker 0>here then is that and someone has suggested

00:44:56.025 --> 00:44:58.425
<v Speaker 0>this in the comment. So SDS says, we

00:44:58.425 --> 00:45:00.080
<v Speaker 0>could just can we change the return type

00:45:00.080 --> 00:45:02.000
<v Speaker 0>to just be an ampersand string instead of

00:45:02.000 --> 00:45:05.040
<v Speaker 0>an uppercase string? Yes. So the answer is

00:45:05.040 --> 00:45:07.360
<v Speaker 1>yes, but there's also a small caveat. So

00:45:07.360 --> 00:45:08.960
<v Speaker 1>if you try to compile this, it will

00:45:08.960 --> 00:45:10.080
<v Speaker 1>actually complain.

00:45:15.515 --> 00:45:18.395
<v Speaker 0>Maybe it's not what to run. Right? Maybe.

00:45:18.395 --> 00:45:20.395
<v Speaker 1>Yeah. There you go. Right. So it says

00:45:20.395 --> 00:45:23.595
<v Speaker 1>expected named lifetime parameter. And so this helps

00:45:23.595 --> 00:45:25.435
<v Speaker 1>as if the return type is borrowed, but

00:45:25.435 --> 00:45:26.955
<v Speaker 1>there's no value for it to borrow from,

00:45:26.955 --> 00:45:29.240
<v Speaker 1>you wanna use the tick static lifetime. This

00:45:29.240 --> 00:45:31.400
<v Speaker 1>is very jargon heavy, but the point is,

00:45:31.400 --> 00:45:31.880
<v Speaker 1>basically,

00:45:32.520 --> 00:45:35.480
<v Speaker 1>you can return the type. But if, if

00:45:35.480 --> 00:45:36.680
<v Speaker 1>we go back to the code, I can

00:45:36.680 --> 00:45:38.359
<v Speaker 1>sort of, like, show you. So since we're,

00:45:38.359 --> 00:45:41.240
<v Speaker 1>like, referencing a string that lives somewhere else,

00:45:41.559 --> 00:45:43.944
<v Speaker 1>normally, what would happen is if you have

00:45:43.944 --> 00:45:45.785
<v Speaker 1>some sort of, like, say that this took

00:45:48.025 --> 00:45:50.265
<v Speaker 1>this took an a string as an argument

00:45:50.265 --> 00:45:50.985
<v Speaker 1>too,

00:45:51.065 --> 00:45:52.665
<v Speaker 1>then I would say, oh, you wanna return

00:45:52.665 --> 00:45:55.145
<v Speaker 1>something that's borrowing from the argument, and so

00:45:55.145 --> 00:45:57.480
<v Speaker 1>this would, like, be more normal, but we're

00:45:57.480 --> 00:45:59.320
<v Speaker 1>not we have no argument here. And so

00:45:59.320 --> 00:46:01.720
<v Speaker 1>Rust needs to know, hey. You're referring to

00:46:01.720 --> 00:46:03.880
<v Speaker 1>a string, but I don't know where you're

00:46:03.880 --> 00:46:05.880
<v Speaker 1>referring to or what what is going on.

00:46:05.960 --> 00:46:08.360
<v Speaker 1>And so there's a special syntax called lifetimes

00:46:08.664 --> 00:46:11.144
<v Speaker 1>that, and there's a special lifetime called static.

00:46:11.144 --> 00:46:13.224
<v Speaker 1>So the full name of string literals is

00:46:13.224 --> 00:46:16.744
<v Speaker 1>actually this, which is ampersand tick static str.

00:46:16.904 --> 00:46:18.585
<v Speaker 1>And what that means is that tick static

00:46:18.585 --> 00:46:20.664
<v Speaker 1>means that this lives forever,

00:46:20.664 --> 00:46:22.184
<v Speaker 1>basically. And so since you have a literal

00:46:22.184 --> 00:46:24.610
<v Speaker 1>string, it's never going to, like, be deallocated

00:46:24.610 --> 00:46:25.970
<v Speaker 1>from memory or whatever.

00:46:26.370 --> 00:46:28.530
<v Speaker 1>Sort of there's a lot of complicatedness

00:46:28.530 --> 00:46:29.970
<v Speaker 1>we can get into in theory in there,

00:46:29.970 --> 00:46:32.050
<v Speaker 1>but just the point is that Rust will

00:46:32.050 --> 00:46:33.730
<v Speaker 1>complain slightly and make you put this. So

00:46:33.730 --> 00:46:35.490
<v Speaker 1>this is a valid solution to this problem.

00:46:36.605 --> 00:46:37.724
<v Speaker 1>I don't think it's the one that they

00:46:37.724 --> 00:46:39.085
<v Speaker 1>wanted to give you because it's a lot

00:46:39.085 --> 00:46:41.805
<v Speaker 1>of syntax for a very little reason, honestly.

00:46:42.684 --> 00:46:44.365
<v Speaker 1>But it does work in this case.

00:46:45.085 --> 00:46:46.445
<v Speaker 0>So just to confirm,

00:46:46.925 --> 00:46:49.085
<v Speaker 0>this applying a static live thing to the

00:46:49.085 --> 00:46:51.565
<v Speaker 0>string means that for however long our program

00:46:51.565 --> 00:46:53.620
<v Speaker 0>runs, the string blue will always be stored

00:46:53.620 --> 00:46:56.340
<v Speaker 0>in memory. Right. And that's because it literally

00:46:56.340 --> 00:46:59.140
<v Speaker 1>puts the words blue into the binary of

00:46:59.140 --> 00:47:01.620
<v Speaker 1>your program, and so it's valid forever because

00:47:01.620 --> 00:47:03.940
<v Speaker 1>it's, like, actually part of the, like, literal

00:47:03.940 --> 00:47:05.380
<v Speaker 1>text of the thing that is on your

00:47:05.380 --> 00:47:06.180
<v Speaker 1>computer that's running.

00:47:07.565 --> 00:47:09.325
<v Speaker 0>And if we want you to use the

00:47:09.325 --> 00:47:12.444
<v Speaker 0>uppercase string, then I'm assuming it wants us

00:47:12.444 --> 00:47:13.165
<v Speaker 0>to do

00:47:13.645 --> 00:47:16.045
<v Speaker 0>an actualized access over there.

00:47:16.765 --> 00:47:18.444
<v Speaker 1>That should also work just fine.

00:47:19.839 --> 00:47:21.520
<v Speaker 1>It turns out that strings implement a lot

00:47:21.520 --> 00:47:23.920
<v Speaker 1>of different interfaces. So there's actually, like, six

00:47:23.920 --> 00:47:25.599
<v Speaker 1>different ways to write the body of this

00:47:25.599 --> 00:47:27.599
<v Speaker 1>function that will all work. This is the

00:47:27.599 --> 00:47:29.839
<v Speaker 1>way that I personally prefer to write it.

00:47:29.839 --> 00:47:31.280
<v Speaker 1>And so this is what I would write

00:47:31.280 --> 00:47:32.400
<v Speaker 1>if I was writing this code.

00:47:32.955 --> 00:47:34.395
<v Speaker 0>Okay. Good to know.

00:47:35.435 --> 00:47:37.355
<v Speaker 0>And I think there was something important you

00:47:37.355 --> 00:47:38.795
<v Speaker 0>were saying you know, when you were explaining

00:47:38.795 --> 00:47:40.635
<v Speaker 0>it to different types of thing is that

00:47:40.955 --> 00:47:42.955
<v Speaker 0>if you're returning a string from a function,

00:47:42.955 --> 00:47:44.635
<v Speaker 0>you probably always wanna use an upper string,

00:47:44.840 --> 00:47:47.000
<v Speaker 0>uppercase string that allows it to be modified,

00:47:47.000 --> 00:47:48.360
<v Speaker 0>a hard coded string that you can do

00:47:48.360 --> 00:47:50.120
<v Speaker 0>and they get away with using an ampersand.

00:47:50.120 --> 00:47:52.120
<v Speaker 0>Is that roughly what Toy examples like this,

00:47:52.120 --> 00:47:54.040
<v Speaker 1>you often have hard coded strings, but, like,

00:47:54.040 --> 00:47:56.280
<v Speaker 1>imagine this is not current favorite color, but

00:47:56.280 --> 00:47:59.000
<v Speaker 1>this is, like, load color from config file.

00:47:59.545 --> 00:48:01.465
<v Speaker 1>The value in the config file would not

00:48:01.465 --> 00:48:03.705
<v Speaker 1>be a literal string. It would be something

00:48:03.705 --> 00:48:05.545
<v Speaker 1>we'd be reading from the file and returning.

00:48:05.545 --> 00:48:07.385
<v Speaker 1>And so we would want to return the,

00:48:07.385 --> 00:48:09.865
<v Speaker 1>like, capital s string where it's, you know,

00:48:09.865 --> 00:48:11.145
<v Speaker 1>you may look at it or inspect it

00:48:11.145 --> 00:48:14.250
<v Speaker 1>or do whatever later. And so that's usually

00:48:14.250 --> 00:48:15.770
<v Speaker 1>you'll want the capital s string when you're

00:48:15.770 --> 00:48:16.570
<v Speaker 1>returning things.

00:48:16.890 --> 00:48:17.610
<v Speaker 0>Nice.

00:48:17.770 --> 00:48:18.490
<v Speaker 0>Okay.

00:48:18.650 --> 00:48:20.810
<v Speaker 0>Strings two. Let's see what we got here.

00:48:20.810 --> 00:48:22.330
<v Speaker 0>So we're not allowed to change or at

00:48:22.330 --> 00:48:24.570
<v Speaker 0>least we're not supposed to be changing definition

00:48:24.570 --> 00:48:25.770
<v Speaker 0>of a word. Mhmm.

00:48:26.705 --> 00:48:27.825
<v Speaker 0>We are doing an

00:48:28.305 --> 00:48:29.905
<v Speaker 0>it's color words.

00:48:29.985 --> 00:48:31.425
<v Speaker 0>Okay. So this is

00:48:32.225 --> 00:48:34.305
<v Speaker 0>at the wrong type here.

00:48:34.625 --> 00:48:35.265
<v Speaker 1>Right.

00:48:36.225 --> 00:48:36.945
<v Speaker 0>And

00:48:37.985 --> 00:48:40.065
<v Speaker 0>and it's just returning a

00:48:40.590 --> 00:48:43.230
<v Speaker 0>billing based on this expression. Okay.

00:48:44.990 --> 00:48:46.190
<v Speaker 0>I mean, is that

00:48:46.670 --> 00:48:49.310
<v Speaker 0>just that? You could you could do this.

00:48:49.310 --> 00:48:50.590
<v Speaker 1>Yes. I don't think this is what you

00:48:50.590 --> 00:48:51.870
<v Speaker 1>want they want you to do, but you

00:48:51.870 --> 00:48:53.390
<v Speaker 1>can definitely do it. So try run it

00:48:53.390 --> 00:48:54.910
<v Speaker 1>and see if this works. I am, like,

00:48:54.910 --> 00:48:57.695
<v Speaker 1>99% sure this will be fine. Yeah. Totally.

00:48:57.695 --> 00:48:59.215
<v Speaker 1>So that's cool. So we can totally do

00:48:59.215 --> 00:48:59.615
<v Speaker 1>this.

00:49:00.655 --> 00:49:02.415
<v Speaker 1>However, I think what they wanna do, there's

00:49:02.415 --> 00:49:04.095
<v Speaker 1>kind of this joke in in Rust, which

00:49:04.095 --> 00:49:05.695
<v Speaker 1>is, like, you put an ampersand on it

00:49:05.695 --> 00:49:07.935
<v Speaker 1>is the default, if the compiler yells at

00:49:07.935 --> 00:49:10.530
<v Speaker 1>you. So you can convert. So in the

00:49:10.530 --> 00:49:12.370
<v Speaker 1>same way, what I'm I said the ampersand

00:49:12.370 --> 00:49:14.530
<v Speaker 1>string is like a view into a string

00:49:14.530 --> 00:49:16.530
<v Speaker 1>that lives somewhere else. So what you can

00:49:16.530 --> 00:49:17.970
<v Speaker 1>do is there on line nine where you're

00:49:17.970 --> 00:49:19.410
<v Speaker 1>at, if you make an ampersand word.

00:49:20.845 --> 00:49:22.205
<v Speaker 1>So it's similar to how they have the

00:49:22.205 --> 00:49:23.245
<v Speaker 1>ampersand stir.

00:49:23.485 --> 00:49:25.645
<v Speaker 1>This will kind of this will make an

00:49:25.645 --> 00:49:28.445
<v Speaker 1>ampersand stir that refers to the capital s

00:49:28.445 --> 00:49:30.365
<v Speaker 1>string, and so this will also work. And

00:49:30.365 --> 00:49:31.885
<v Speaker 1>so this is the code that I expect

00:49:31.885 --> 00:49:33.165
<v Speaker 1>they would want you to write and what

00:49:33.165 --> 00:49:33.565
<v Speaker 1>is more

00:49:34.390 --> 00:49:37.030
<v Speaker 1>likely. So this this encapsulates a really common

00:49:37.030 --> 00:49:39.030
<v Speaker 1>pattern in Rust, which is where you have

00:49:39.030 --> 00:49:41.030
<v Speaker 1>this capitalist string because you've loaded it from

00:49:41.030 --> 00:49:43.030
<v Speaker 1>somewhere, but you wanna operate on it in

00:49:43.030 --> 00:49:44.070
<v Speaker 1>a way that's,

00:49:44.150 --> 00:49:45.990
<v Speaker 1>you know, like, you're just reading the value.

00:49:45.990 --> 00:49:46.869
<v Speaker 1>And so this is what I was saying

00:49:46.869 --> 00:49:49.750
<v Speaker 1>earlier about how parameters are often ampersand stir.

00:49:50.045 --> 00:49:51.725
<v Speaker 1>So all you need to do to convert

00:49:51.725 --> 00:49:53.485
<v Speaker 1>the capitalist or string

00:49:53.645 --> 00:49:56.365
<v Speaker 1>into a temporary ampersand stir is you just

00:49:56.365 --> 00:49:58.125
<v Speaker 1>throw an ampersand on the front of it,

00:49:58.125 --> 00:50:00.365
<v Speaker 1>and then that will coerce it appropriately.

00:50:01.325 --> 00:50:03.485
<v Speaker 0>Okay. And the reason we wanted that approach

00:50:03.485 --> 00:50:05.485
<v Speaker 0>instead of best approach is, I guess, because

00:50:06.490 --> 00:50:09.210
<v Speaker 0>of the move semantics as well? Yes. Totally.

00:50:09.210 --> 00:50:10.810
<v Speaker 1>So if if I were to print word

00:50:10.810 --> 00:50:12.730
<v Speaker 1>down here, this will

00:50:15.450 --> 00:50:16.090
<v Speaker 1>yeah.

00:50:16.890 --> 00:50:18.890
<v Speaker 1>This would fail to compile because,

00:50:19.995 --> 00:50:22.155
<v Speaker 1>as it says, you've you've moved it into

00:50:22.155 --> 00:50:23.915
<v Speaker 1>the function. So when you when you pass

00:50:23.915 --> 00:50:25.755
<v Speaker 1>a capital s string, you're saying, like, hey.

00:50:25.755 --> 00:50:27.595
<v Speaker 1>Here's a color word. This is your string

00:50:27.595 --> 00:50:28.875
<v Speaker 1>now. Feel free to do what you want

00:50:28.875 --> 00:50:29.515
<v Speaker 1>with it.

00:50:29.995 --> 00:50:32.075
<v Speaker 1>And, at the end of the function body,

00:50:32.235 --> 00:50:34.450
<v Speaker 1>it will deallocate that string. And so it

00:50:34.450 --> 00:50:36.290
<v Speaker 1>will just, like, totally throw away all its

00:50:36.290 --> 00:50:36.930
<v Speaker 1>contents.

00:50:37.570 --> 00:50:38.290
<v Speaker 1>Whereas

00:50:38.690 --> 00:50:40.930
<v Speaker 1>if you use the ampersand version, you're just

00:50:40.930 --> 00:50:43.010
<v Speaker 1>passing in a temporary view into that string

00:50:43.010 --> 00:50:43.730
<v Speaker 1>instead.

00:50:43.890 --> 00:50:44.610
<v Speaker 1>And so,

00:50:44.850 --> 00:50:46.850
<v Speaker 1>you know, everything will be peachy keen

00:50:47.090 --> 00:50:47.570
<v Speaker 1>afterwards.

00:50:48.565 --> 00:50:50.165
<v Speaker 0>Yes. I guess I mean, one of the

00:50:50.165 --> 00:50:51.685
<v Speaker 0>nasty habits I seem to have got when

00:50:51.685 --> 00:50:53.125
<v Speaker 0>I write some Rust now is to throw

00:50:53.125 --> 00:50:54.325
<v Speaker 0>in dot clones.

00:50:54.885 --> 00:50:57.285
<v Speaker 1>Yeah. This would also technically work.

00:50:57.605 --> 00:50:59.285
<v Speaker 1>What this would just do is copy the

00:50:59.285 --> 00:51:01.685
<v Speaker 1>memory, and so this will basically just be

00:51:02.220 --> 00:51:05.020
<v Speaker 1>very, I mean, it's five letters. Right? So

00:51:05.020 --> 00:51:07.420
<v Speaker 1>it's going to be extremely

00:51:07.420 --> 00:51:09.980
<v Speaker 1>slower and use a tiny bit more memory,

00:51:09.980 --> 00:51:12.780
<v Speaker 1>like an imperceptible amount. So it's definitely not

00:51:12.780 --> 00:51:14.060
<v Speaker 1>a big deal. And if you get your

00:51:14.060 --> 00:51:16.285
<v Speaker 1>code to work with the clones, totally super

00:51:16.285 --> 00:51:18.525
<v Speaker 1>fine, especially when you're starting out. The important

00:51:18.525 --> 00:51:20.125
<v Speaker 1>part is to get your program working.

00:51:20.205 --> 00:51:21.805
<v Speaker 1>It does not matter if it's the fastest

00:51:21.805 --> 00:51:24.605
<v Speaker 1>possible thing. Like, one kinda interesting pattern is

00:51:24.605 --> 00:51:26.045
<v Speaker 1>that a lot of people who are new

00:51:26.045 --> 00:51:28.525
<v Speaker 1>to Rust make things harder on themselves than

00:51:28.525 --> 00:51:30.510
<v Speaker 1>they have to be. Because once you're given

00:51:30.510 --> 00:51:32.590
<v Speaker 1>the power of, like, making it so fast

00:51:32.590 --> 00:51:33.950
<v Speaker 1>and small and tiny,

00:51:34.110 --> 00:51:35.630
<v Speaker 1>you will, like, want to make it the

00:51:35.630 --> 00:51:37.150
<v Speaker 1>case that it is that fast and small

00:51:37.150 --> 00:51:38.510
<v Speaker 1>and tiny. And so people will go to

00:51:38.510 --> 00:51:41.310
<v Speaker 1>great lengths to avoid typing out a clone

00:51:41.310 --> 00:51:42.990
<v Speaker 1>when, like, they could just have their program

00:51:42.990 --> 00:51:44.765
<v Speaker 1>working. And, like, this will still be faster

00:51:44.765 --> 00:51:46.285
<v Speaker 1>than your Ruby or Python and still use

00:51:46.285 --> 00:51:47.965
<v Speaker 1>less memory even though you're making an extra

00:51:47.965 --> 00:51:50.445
<v Speaker 1>copy. So, like, don't sweat it when you're

00:51:50.445 --> 00:51:52.365
<v Speaker 1>starting. Just, like, throw a clone around. It's,

00:51:52.365 --> 00:51:54.365
<v Speaker 1>like, it's totally fine. Not a big deal.

00:51:54.685 --> 00:51:56.605
<v Speaker 0>Alright. Well, we'll leave that like that for

00:51:56.605 --> 00:51:58.125
<v Speaker 0>now. Well, I don't know if we'll make

00:51:58.125 --> 00:51:59.780
<v Speaker 0>it to move semantics, but we'll definitely have

00:51:59.780 --> 00:52:02.020
<v Speaker 0>a look anyway. So we got two comments

00:52:02.020 --> 00:52:04.579
<v Speaker 0>on this example. So SD is back and

00:52:04.579 --> 00:52:05.220
<v Speaker 0>saying,

00:52:05.619 --> 00:52:07.220
<v Speaker 0>when we use string from,

00:52:07.619 --> 00:52:09.220
<v Speaker 0>is this resource from the heap?

00:52:09.540 --> 00:52:11.300
<v Speaker 1>Yeah. So what happens is is the string

00:52:11.300 --> 00:52:13.619
<v Speaker 1>will will allocate some memory on the heap,

00:52:13.835 --> 00:52:16.315
<v Speaker 1>and then it will copy the green into

00:52:16.315 --> 00:52:18.234
<v Speaker 1>the heap afterwards. Yeah. It doesn't it doesn't

00:52:18.234 --> 00:52:19.835
<v Speaker 1>necessarily take it from the heap. It puts

00:52:19.835 --> 00:52:21.194
<v Speaker 1>it on the heap, but I think that

00:52:21.194 --> 00:52:23.515
<v Speaker 1>that's what you were trying to ask. Yes.

00:52:24.394 --> 00:52:26.154
<v Speaker 0>And Sev is asking, and this could because

00:52:26.154 --> 00:52:27.510
<v Speaker 0>I actually had to stop too. Is there

00:52:27.510 --> 00:52:29.830
<v Speaker 0>some magic between the ampersand on the string

00:52:29.830 --> 00:52:32.630
<v Speaker 0>that casts that to Yeah. Yeah. This is

00:52:32.630 --> 00:52:34.230
<v Speaker 1>a great question because I I was I

00:52:34.230 --> 00:52:35.670
<v Speaker 1>was trying to see if no one would

00:52:35.670 --> 00:52:37.830
<v Speaker 1>notice. So you've got some sharp viewers.

00:52:38.150 --> 00:52:39.270
<v Speaker 1>So technically,

00:52:39.270 --> 00:52:41.065
<v Speaker 1>yeah, what what you may notice, if you

00:52:41.065 --> 00:52:43.305
<v Speaker 1>think about it in terms of, like, forget

00:52:43.305 --> 00:52:45.625
<v Speaker 1>that. Yeah. It does go down. So, if

00:52:45.625 --> 00:52:47.065
<v Speaker 1>you think about this, like,

00:52:47.465 --> 00:52:49.065
<v Speaker 1>you know, okay. I have a string,

00:52:50.345 --> 00:52:52.105
<v Speaker 1>and then I'm gonna close the little terminal

00:52:52.105 --> 00:52:53.385
<v Speaker 1>I have because I can't see this well.

00:52:53.460 --> 00:52:54.740
<v Speaker 1>And then I put an ampersand on the

00:52:54.740 --> 00:52:57.540
<v Speaker 1>front. That makes it a capital ampersand string.

00:52:57.540 --> 00:52:59.940
<v Speaker 1>So how do we get a stir out

00:52:59.940 --> 00:53:00.580
<v Speaker 1>of this?

00:53:01.140 --> 00:53:02.980
<v Speaker 1>And the answer is is that in Rust,

00:53:02.980 --> 00:53:05.300
<v Speaker 1>there's an interface called dRef.

00:53:05.380 --> 00:53:06.580
<v Speaker 1>And what that means is

00:53:06.820 --> 00:53:07.700
<v Speaker 1>dRef.

00:53:07.780 --> 00:53:08.660
<v Speaker 1>And so

00:53:08.985 --> 00:53:11.385
<v Speaker 1>there's a special way that you can implement

00:53:11.545 --> 00:53:12.505
<v Speaker 1>deref

00:53:12.505 --> 00:53:14.345
<v Speaker 1>to do coercions. Rust,

00:53:14.505 --> 00:53:18.265
<v Speaker 1>generally speaking, does very few coercions implicitly on

00:53:18.265 --> 00:53:20.345
<v Speaker 1>its own. This is one of the only

00:53:20.345 --> 00:53:22.665
<v Speaker 1>cases in which it will enable a coercion.

00:53:22.980 --> 00:53:25.540
<v Speaker 1>And so, basically, what ends up happening here

00:53:25.780 --> 00:53:26.660
<v Speaker 1>is that

00:53:28.340 --> 00:53:30.500
<v Speaker 1>the the implementation

00:53:32.260 --> 00:53:33.859
<v Speaker 1>there's gonna be a lot of syntax here.

00:53:33.859 --> 00:53:35.540
<v Speaker 1>So I'm just gonna, like, show you, and

00:53:35.540 --> 00:53:38.245
<v Speaker 1>then we'll, we'll, like, not worry about it

00:53:38.245 --> 00:53:40.165
<v Speaker 1>because, like, there's gonna be a bunch. But

00:53:40.165 --> 00:53:42.165
<v Speaker 1>in the standard library somewhere,

00:53:42.245 --> 00:53:44.245
<v Speaker 1>there's some code that looks like this.

00:53:46.485 --> 00:53:48.645
<v Speaker 1>I changed. I copied and pasted some some

00:53:48.645 --> 00:53:49.445
<v Speaker 1>lines. So

00:53:55.900 --> 00:53:57.420
<v Speaker 1>I think it looks like this. I totally

00:53:57.420 --> 00:53:59.420
<v Speaker 1>forget. Anyway, this is a whole bunch giant

00:53:59.420 --> 00:54:01.339
<v Speaker 1>pile of garbage. The point is is that

00:54:01.339 --> 00:54:03.180
<v Speaker 1>it says, like, if you have a string,

00:54:03.180 --> 00:54:04.700
<v Speaker 1>you implement d rep for it, and the

00:54:04.700 --> 00:54:07.135
<v Speaker 1>type that comes out is this stir. The

00:54:07.135 --> 00:54:09.055
<v Speaker 1>reason there's no ampersand there is complicated and

00:54:09.055 --> 00:54:10.815
<v Speaker 1>far too advanced right now. It doesn't matter.

00:54:10.815 --> 00:54:12.654
<v Speaker 1>But the point is is that, like, there's

00:54:12.654 --> 00:54:14.494
<v Speaker 1>this there's this implementation. You can go look

00:54:14.494 --> 00:54:15.694
<v Speaker 1>it up if you really wanna know how

00:54:15.694 --> 00:54:16.335
<v Speaker 1>it works.

00:54:16.734 --> 00:54:17.775
<v Speaker 1>But whenever you have

00:54:18.560 --> 00:54:20.720
<v Speaker 1>string d refs to the target of ampersand

00:54:20.720 --> 00:54:23.200
<v Speaker 1>stir, that means an ampersand string can turn

00:54:23.200 --> 00:54:25.360
<v Speaker 1>into an ampersand stir. And so,

00:54:25.840 --> 00:54:28.400
<v Speaker 1>this is just one of those magic coercions,

00:54:28.400 --> 00:54:28.880
<v Speaker 1>and

00:54:29.360 --> 00:54:31.464
<v Speaker 1>that that, it's like it's like one of

00:54:31.464 --> 00:54:32.744
<v Speaker 1>those things where and this is why throwing

00:54:32.744 --> 00:54:34.825
<v Speaker 1>ampersand on it is, like, often the solution

00:54:34.825 --> 00:54:37.545
<v Speaker 1>to things in Rust because, like, many things

00:54:37.545 --> 00:54:40.105
<v Speaker 1>will have this this pattern of, like, there's

00:54:40.105 --> 00:54:41.945
<v Speaker 1>the type that is owned and mutable.

00:54:42.105 --> 00:54:44.430
<v Speaker 1>There's the type that's viewable and, like, not

00:54:44.430 --> 00:54:46.590
<v Speaker 1>changeable, and you implement d rep between them

00:54:46.590 --> 00:54:48.190
<v Speaker 1>so you get this nice coercion.

00:54:48.350 --> 00:54:50.350
<v Speaker 1>So that's the that's the high level version

00:54:50.350 --> 00:54:51.790
<v Speaker 1>of that answer. And you could you could

00:54:51.790 --> 00:54:53.150
<v Speaker 1>fill up a whole podcast with just the

00:54:53.150 --> 00:54:56.030
<v Speaker 1>details on on specifically how all that works

00:54:56.030 --> 00:54:57.954
<v Speaker 1>and, like, a bunch of things. But, yeah,

00:54:57.954 --> 00:54:59.714
<v Speaker 1>that's basically basically what it is is Rust

00:54:59.714 --> 00:55:01.315
<v Speaker 1>will coerce it, and there's an interface you

00:55:01.315 --> 00:55:02.515
<v Speaker 1>can use on your own types if you

00:55:02.515 --> 00:55:03.875
<v Speaker 1>wanna implement that coercion.

00:55:04.355 --> 00:55:06.115
<v Speaker 0>That's pretty cool. It's it's nice that it's

00:55:06.115 --> 00:55:08.755
<v Speaker 0>just using, you know, the different tree implementations,

00:55:08.755 --> 00:55:10.915
<v Speaker 0>and there's not just some hardcore compiler magic

00:55:10.915 --> 00:55:12.839
<v Speaker 0>that knows kinda what to do there. Like

00:55:12.920 --> 00:55:14.200
<v Speaker 1>Yeah. There's a lot of things like this

00:55:14.200 --> 00:55:16.279
<v Speaker 1>in Rust where the thing that is like

00:55:16.279 --> 00:55:19.000
<v Speaker 1>would normally be compiler magic is hooked into

00:55:19.000 --> 00:55:20.520
<v Speaker 1>via some sort of trait. And so you

00:55:20.520 --> 00:55:21.960
<v Speaker 1>could implement the trait on your type and

00:55:21.960 --> 00:55:24.039
<v Speaker 1>have access to the exact same same magic.

00:55:24.039 --> 00:55:25.720
<v Speaker 1>It's very common in a lot of places.

00:55:27.415 --> 00:55:30.935
<v Speaker 0>Alright. Let's move on then from there. So

00:55:31.255 --> 00:55:33.255
<v Speaker 0>was gonna move us on to primitive

00:55:33.255 --> 00:55:34.055
<v Speaker 0>types.

00:55:34.055 --> 00:55:35.415
<v Speaker 0>Let's pop that open.

00:55:35.974 --> 00:55:39.440
<v Speaker 0>So now we're looking at, oh, billions. Okay.

00:55:39.520 --> 00:55:41.200
<v Speaker 1>Yeah. This is very similar to the stuff

00:55:41.200 --> 00:55:43.760
<v Speaker 1>we've done before. Sometimes Rustling goes very slow

00:55:43.760 --> 00:55:46.079
<v Speaker 1>because it's designed for being a single person

00:55:46.079 --> 00:55:48.400
<v Speaker 1>with no help on their own. So it

00:55:48.400 --> 00:55:50.079
<v Speaker 1>does a very good job of taking very

00:55:50.079 --> 00:55:51.885
<v Speaker 1>small steps. But, you know

00:55:52.765 --> 00:55:54.605
<v Speaker 1>so we've we've kind of already covered this,

00:55:54.605 --> 00:55:56.045
<v Speaker 1>which would be great practice if, you know,

00:55:56.045 --> 00:55:57.725
<v Speaker 1>I wasn't here. But I I think we've

00:55:57.725 --> 00:55:58.845
<v Speaker 1>talked about this a bunch, so this should

00:55:58.845 --> 00:55:59.965
<v Speaker 1>be pretty easy for you.

00:56:00.605 --> 00:56:01.965
<v Speaker 0>Well, why don't we just pick something a

00:56:01.965 --> 00:56:03.885
<v Speaker 0>little bit more interesting? Yeah. Sure. We we've

00:56:03.885 --> 00:56:04.205
<v Speaker 0>got about,

00:56:05.150 --> 00:56:07.790
<v Speaker 0>say, twenty minutes left based Cool. Roughly. So

00:56:07.790 --> 00:56:09.470
<v Speaker 0>let's see. What have we got? Let's close

00:56:09.470 --> 00:56:11.390
<v Speaker 0>it down. Oh, exercises.

00:56:11.790 --> 00:56:13.550
<v Speaker 0>Is there anything that you think would be

00:56:13.550 --> 00:56:15.710
<v Speaker 0>fun to go through? I think maybe one

00:56:15.790 --> 00:56:18.115
<v Speaker 1>good example next, so we have twenty minutes,

00:56:18.115 --> 00:56:19.875
<v Speaker 1>is, like, in the intermediate part is sort

00:56:19.875 --> 00:56:21.155
<v Speaker 1>of, like, structs. Because I wanna show you

00:56:21.155 --> 00:56:23.235
<v Speaker 1>how you can define your own types in

00:56:23.235 --> 00:56:24.835
<v Speaker 1>Rust because that's also a useful sort of

00:56:24.835 --> 00:56:25.395
<v Speaker 1>thing.

00:56:27.475 --> 00:56:30.230
<v Speaker 1>This is Rust analyzers on my side. It's

00:56:30.230 --> 00:56:31.910
<v Speaker 1>got a lot of yeah. My my screen

00:56:31.910 --> 00:56:33.829
<v Speaker 1>looks very different than yours. It's kinda funny,

00:56:33.829 --> 00:56:36.470
<v Speaker 1>actually. Almost all of the little, like,

00:56:39.030 --> 00:56:41.349
<v Speaker 1>things where it says zero implementations on yours

00:56:41.445 --> 00:56:43.605
<v Speaker 1>Say, like, missing command on mine. So that's

00:56:43.605 --> 00:56:44.485
<v Speaker 1>kind of interesting.

00:56:44.645 --> 00:56:46.085
<v Speaker 1>I have to file a bug about the

00:56:46.085 --> 00:56:48.645
<v Speaker 1>live code share, etcetera. Yeah. Where's my Rust

00:56:48.645 --> 00:56:51.445
<v Speaker 0>Analyzer Revolts, Griggles? Yeah. Yeah. You've got it's

00:56:51.445 --> 00:56:52.645
<v Speaker 1>good. So

00:56:52.885 --> 00:56:54.325
<v Speaker 1>well, part of it's because

00:56:55.250 --> 00:56:56.290
<v Speaker 1>yeah. Anyway

00:56:56.450 --> 00:56:58.450
<v Speaker 1>okay. So, let's let's just get into it

00:56:58.450 --> 00:56:59.730
<v Speaker 1>rather than talking about bugs in the in

00:56:59.730 --> 00:57:00.850
<v Speaker 1>the IDE integration.

00:57:01.010 --> 00:57:03.250
<v Speaker 1>So, on line six here, have a struct.

00:57:03.250 --> 00:57:03.890
<v Speaker 1>And so

00:57:04.210 --> 00:57:06.530
<v Speaker 1>Rust doesn't have classes. It doesn't really do

00:57:06.530 --> 00:57:09.045
<v Speaker 1>object oriented programming exactly, but it can feel

00:57:09.045 --> 00:57:10.805
<v Speaker 1>like it's sort of you've seen methods already

00:57:10.805 --> 00:57:12.645
<v Speaker 1>and stuff like that. So the difference is

00:57:12.645 --> 00:57:14.645
<v Speaker 1>that Rust has structs. So, like

00:57:15.285 --> 00:57:15.845
<v Speaker 1>okay.

00:57:16.405 --> 00:57:18.724
<v Speaker 1>Classes in an object oriented programming have sort

00:57:18.724 --> 00:57:20.005
<v Speaker 1>of two things. Right? You have the data

00:57:20.005 --> 00:57:21.765
<v Speaker 1>and the behavior, and they go together in

00:57:21.765 --> 00:57:23.670
<v Speaker 1>a class. And so Rust kinda says those

00:57:23.670 --> 00:57:26.070
<v Speaker 1>are two separate things, so we should separate

00:57:26.070 --> 00:57:28.710
<v Speaker 1>them. So instead of instead of classes,

00:57:28.869 --> 00:57:29.910
<v Speaker 1>we have structs,

00:57:29.910 --> 00:57:31.750
<v Speaker 1>which are purely data, and then we have

00:57:31.750 --> 00:57:34.470
<v Speaker 1>functions and methods that are the behavior that

00:57:34.470 --> 00:57:36.070
<v Speaker 1>operates on the data. So there's a little

00:57:36.070 --> 00:57:36.710
<v Speaker 1>more separation

00:57:37.445 --> 00:57:38.965
<v Speaker 1>in Rust than there is in other languages.

00:57:38.965 --> 00:57:41.525
<v Speaker 1>So here, we have this struct, color classic

00:57:41.525 --> 00:57:42.245
<v Speaker 1>struct,

00:57:42.485 --> 00:57:45.445
<v Speaker 1>and there's no data inside of the body

00:57:45.445 --> 00:57:47.365
<v Speaker 1>of it. So it's not, like, super useful

00:57:47.445 --> 00:57:49.365
<v Speaker 1>because there's there's nothing there. So if we

00:57:49.365 --> 00:57:50.805
<v Speaker 1>look at down at the

00:57:51.845 --> 00:57:52.725
<v Speaker 1>examples

00:57:53.420 --> 00:57:55.660
<v Speaker 1>and, like, what these tests are kinda doing,

00:57:55.820 --> 00:57:57.340
<v Speaker 1>we can sort of see what they want

00:57:57.340 --> 00:57:58.140
<v Speaker 1>us to do.

00:57:58.540 --> 00:57:59.100
<v Speaker 1>So

00:58:01.260 --> 00:58:02.780
<v Speaker 1>let's see. So

00:58:04.380 --> 00:58:05.900
<v Speaker 1>it's gonna complain about

00:58:06.220 --> 00:58:07.420
<v Speaker 1>green doesn't exist

00:58:08.715 --> 00:58:09.595
<v Speaker 1>and then

00:58:10.155 --> 00:58:11.755
<v Speaker 1>the name being this

00:58:13.435 --> 00:58:15.355
<v Speaker 1>classic struct thing. So

00:58:17.195 --> 00:58:19.995
<v Speaker 1>I look up here. Yeah. Color classic struct.

00:58:20.235 --> 00:58:20.715
<v Speaker 1>Interesting.

00:58:21.440 --> 00:58:23.120
<v Speaker 1>So I don't know why it's referring to

00:58:23.120 --> 00:58:25.360
<v Speaker 1>these as classic c structs. Maybe we'll figure

00:58:25.360 --> 00:58:27.440
<v Speaker 1>it out as we type stuff here. But

00:58:27.440 --> 00:58:29.600
<v Speaker 1>down here on line 22,

00:58:29.600 --> 00:58:32.400
<v Speaker 1>where it says let green equals. So the

00:58:32.400 --> 00:58:33.680
<v Speaker 1>thing it's saying is, like,

00:58:36.895 --> 00:58:39.295
<v Speaker 1>we have all this color classic struct, right,

00:58:39.695 --> 00:58:40.735
<v Speaker 1>from above.

00:58:41.215 --> 00:58:41.775
<v Speaker 1>And

00:58:42.255 --> 00:58:43.775
<v Speaker 1>so this would be how we would, like,

00:58:43.775 --> 00:58:45.135
<v Speaker 1>instantiate it as we said the name and

00:58:45.135 --> 00:58:46.335
<v Speaker 1>then the curly braces.

00:58:46.575 --> 00:58:48.495
<v Speaker 1>But it's gonna complain because we don't have

00:58:48.495 --> 00:58:50.920
<v Speaker 1>a name and we don't have a hex.

00:58:50.920 --> 00:58:52.200
<v Speaker 1>So you can see on line twenty six

00:58:52.200 --> 00:58:54.440
<v Speaker 1>and twenty seven, use green dot name and

00:58:54.440 --> 00:58:56.360
<v Speaker 1>green dot hex to get sort of these,

00:58:56.360 --> 00:58:57.480
<v Speaker 1>like, values.

00:58:58.760 --> 00:59:01.640
<v Speaker 1>So what we'd want to do here is

00:59:01.640 --> 00:59:03.240
<v Speaker 1>we would wanna say name

00:59:03.480 --> 00:59:04.840
<v Speaker 1>is

00:59:05.195 --> 00:59:05.995
<v Speaker 1>green

00:59:06.395 --> 00:59:07.755
<v Speaker 1>and hex

00:59:07.994 --> 00:59:08.715
<v Speaker 1>is

00:59:09.115 --> 00:59:10.875
<v Speaker 1>bound zero zero

00:59:11.435 --> 00:59:13.035
<v Speaker 1>f f zero zero.

00:59:14.075 --> 00:59:15.595
<v Speaker 1>And so this, like,

00:59:16.155 --> 00:59:18.235
<v Speaker 1>this would work from declaring the body of

00:59:18.235 --> 00:59:19.680
<v Speaker 1>it, but it's gonna give us an error

00:59:19.680 --> 00:59:21.760
<v Speaker 1>about defining the struct up above.

00:59:22.560 --> 00:59:23.600
<v Speaker 1>So let's,

00:59:24.480 --> 00:59:27.760
<v Speaker 1>let's briefly jump up there, and we'll also

00:59:27.840 --> 00:59:30.320
<v Speaker 1>check those out. So color classic struct up

00:59:30.320 --> 00:59:31.920
<v Speaker 1>here. We would have,

00:59:32.880 --> 00:59:35.905
<v Speaker 1>name is a static str,

00:59:37.585 --> 00:59:38.225
<v Speaker 1>and

00:59:38.385 --> 00:59:40.705
<v Speaker 1>hex is also a static str. So I

00:59:40.705 --> 00:59:42.465
<v Speaker 1>think that this text will now

00:59:43.425 --> 00:59:44.785
<v Speaker 1>test will now work.

00:59:45.025 --> 00:59:46.625
<v Speaker 1>Let's double check that's true before we talk

00:59:46.625 --> 00:59:47.984
<v Speaker 1>about what the syntax looks like.

00:59:52.560 --> 00:59:54.800
<v Speaker 1>So this is complaining about 38. So this

00:59:54.800 --> 00:59:57.200
<v Speaker 1>is the other test. So think we're good.

00:59:57.599 --> 00:59:58.320
<v Speaker 1>Cool.

00:59:58.400 --> 01:00:00.320
<v Speaker 1>So yeah. So with the struct, if we

01:00:00.320 --> 01:00:02.560
<v Speaker 1>look up here at line, eight and nine,

01:00:03.265 --> 01:00:05.505
<v Speaker 1>very just much like we had the name

01:00:05.505 --> 01:00:08.305
<v Speaker 1>colon type with variables and with function arguments

01:00:08.305 --> 01:00:09.825
<v Speaker 1>is the exact same thing in struct. So

01:00:09.825 --> 01:00:13.345
<v Speaker 1>here, this color classic struct ends up being,

01:00:13.984 --> 01:00:16.400
<v Speaker 1>as two sort of data types inside of

01:00:16.400 --> 01:00:18.400
<v Speaker 1>it. So one string with the name and

01:00:18.400 --> 01:00:21.040
<v Speaker 1>one string with the, hex decimal value of

01:00:21.040 --> 01:00:22.960
<v Speaker 1>what the color is. I'm guessing this is

01:00:22.960 --> 01:00:25.840
<v Speaker 1>kinda like CSS colors or RGB values in

01:00:25.840 --> 01:00:27.440
<v Speaker 1>general where it's got some sort of name

01:00:27.440 --> 01:00:29.840
<v Speaker 1>associated than the actual type. And so

01:00:30.385 --> 01:00:32.385
<v Speaker 1>that's how you declare it. It's like a

01:00:32.385 --> 01:00:33.985
<v Speaker 1>struct, name of the struct,

01:00:34.305 --> 01:00:35.105
<v Speaker 1>curlies,

01:00:35.345 --> 01:00:37.265
<v Speaker 1>and then the same name and value pairs.

01:00:37.265 --> 01:00:38.385
<v Speaker 1>One thing you'll notice

01:00:39.185 --> 01:00:41.105
<v Speaker 1>is that there's a trailing comma here on

01:00:41.105 --> 01:00:43.585
<v Speaker 1>line nine. So Rust has support for trailing

01:00:43.585 --> 01:00:46.150
<v Speaker 1>commas, and, so that's really, really nice. Every

01:00:46.150 --> 01:00:48.310
<v Speaker 1>time I go back to JavaScript or JSON

01:00:48.390 --> 01:00:49.910
<v Speaker 1>and I can't put a trailing comma, I

01:00:49.910 --> 01:00:50.870
<v Speaker 1>get a little sad.

01:00:51.270 --> 01:00:52.950
<v Speaker 1>But, you know, this is like a stylistic

01:00:52.950 --> 01:00:54.870
<v Speaker 1>preference. You don't have to put one there.

01:00:55.190 --> 01:00:57.110
<v Speaker 1>If you leave it off, that that will

01:00:57.110 --> 01:00:59.415
<v Speaker 1>work. But, it's usually people put them in

01:00:59.415 --> 01:01:01.495
<v Speaker 1>because that's the preferred style of things.

01:01:02.775 --> 01:01:03.975
<v Speaker 1>So in the same way that's how you

01:01:03.975 --> 01:01:07.255
<v Speaker 1>declare a struct, we when we instantiate one,

01:01:07.575 --> 01:01:09.495
<v Speaker 1>you can see on line 24 to 27,

01:01:09.495 --> 01:01:11.520
<v Speaker 1>it's almost the exact same thing as when

01:01:11.520 --> 01:01:13.760
<v Speaker 1>we, like, assign a variable to value

01:01:13.920 --> 01:01:16.960
<v Speaker 1>except where, you know, we're let green equals

01:01:16.960 --> 01:01:18.960
<v Speaker 1>and then struct. And then inside of it,

01:01:18.960 --> 01:01:20.000
<v Speaker 1>we have the name as green and the

01:01:20.000 --> 01:01:22.320
<v Speaker 1>hex is that value. And so the the

01:01:22.320 --> 01:01:25.040
<v Speaker 1>syntax mirrors the kind of declaration syntax in

01:01:25.040 --> 01:01:27.315
<v Speaker 1>the same way. Okay. Did you use a

01:01:27.315 --> 01:01:30.355
<v Speaker 0>a static livestream string because of these assertions,

01:01:30.355 --> 01:01:32.835
<v Speaker 0>or would that just be, like, common practice

01:01:32.835 --> 01:01:34.675
<v Speaker 0>to not use this I use it because

01:01:34.675 --> 01:01:35.795
<v Speaker 1>of the assertions.

01:01:35.795 --> 01:01:36.595
<v Speaker 1>Usually,

01:01:37.075 --> 01:01:38.435
<v Speaker 1>in the same way that, like, if you

01:01:38.435 --> 01:01:40.950
<v Speaker 1>return a value, you will often return a

01:01:40.950 --> 01:01:42.070
<v Speaker 1>capital s string.

01:01:42.310 --> 01:01:43.830
<v Speaker 1>Most of the time in a in a

01:01:43.830 --> 01:01:45.750
<v Speaker 1>real world, Chuck, like, imagine again, like, I

01:01:45.750 --> 01:01:47.270
<v Speaker 1>always go to the config file example because

01:01:47.270 --> 01:01:48.630
<v Speaker 1>I think that's very intuitive.

01:01:48.790 --> 01:01:49.350
<v Speaker 1>So

01:01:49.750 --> 01:01:51.670
<v Speaker 1>if we were gonna be loading this color

01:01:51.670 --> 01:01:53.510
<v Speaker 1>from a file, we wouldn't have a string

01:01:53.510 --> 01:01:54.790
<v Speaker 1>literal, and so I would use a capital

01:01:54.790 --> 01:01:55.430
<v Speaker 1>s string.

01:01:55.835 --> 01:01:57.515
<v Speaker 1>And so I I purely just did that

01:01:57.515 --> 01:01:59.515
<v Speaker 1>because there are string literals in this text.

01:01:59.515 --> 01:02:00.875
<v Speaker 1>But normally,

01:02:01.434 --> 01:02:03.434
<v Speaker 1>I would I would sort of default personally

01:02:03.434 --> 01:02:06.714
<v Speaker 1>to to making this a string and making

01:02:06.714 --> 01:02:07.355
<v Speaker 1>this a string.

01:02:08.180 --> 01:02:10.420
<v Speaker 1>And that will, like, work. It just means

01:02:10.420 --> 01:02:12.740
<v Speaker 1>that this is gonna get a little weirder.

01:02:12.740 --> 01:02:14.660
<v Speaker 1>We'd wanna do a string from

01:02:14.820 --> 01:02:17.780
<v Speaker 1>down here and then same thing here.

01:02:19.780 --> 01:02:22.385
<v Speaker 1>And then finally, I think this might this

01:02:22.385 --> 01:02:24.305
<v Speaker 1>might compare or might not. We may have

01:02:24.305 --> 01:02:25.984
<v Speaker 1>to toss the ampersand on it to get

01:02:25.984 --> 01:02:26.705
<v Speaker 1>it to work.

01:02:27.185 --> 01:02:28.704
<v Speaker 1>But, like, this would be what the string

01:02:28.704 --> 01:02:30.545
<v Speaker 1>from version would look like. This looks a

01:02:30.545 --> 01:02:32.385
<v Speaker 1>little grosser in the tests, but it's more

01:02:32.385 --> 01:02:33.505
<v Speaker 1>likely to reflect

01:02:33.744 --> 01:02:35.984
<v Speaker 1>what, like, actual real world code would look

01:02:35.984 --> 01:02:36.145
<v Speaker 1>like.

01:02:36.940 --> 01:02:39.340
<v Speaker 0>Is there a macro for creating a string

01:02:39.340 --> 01:02:41.740
<v Speaker 0>that simplifies the syntax? The thing is is

01:02:41.740 --> 01:02:43.820
<v Speaker 1>that, like, someone did release a crate, like,

01:02:43.820 --> 01:02:45.820
<v Speaker 1>a crates or packages in Rust. So somebody

01:02:45.820 --> 01:02:48.780
<v Speaker 1>did release something that would let you type

01:02:51.015 --> 01:02:52.295
<v Speaker 1>s bang.

01:02:52.295 --> 01:02:54.295
<v Speaker 1>But, like, is it really worth getting a

01:02:54.295 --> 01:02:57.095
<v Speaker 1>whole external package just to eliminate, like, five

01:02:57.095 --> 01:02:59.895
<v Speaker 1>or six characters here? Like, generally not.

01:03:00.775 --> 01:03:02.589
<v Speaker 1>It's just like it's like it's it's one

01:03:02.589 --> 01:03:03.710
<v Speaker 1>of those things that it's like, it is

01:03:03.710 --> 01:03:05.710
<v Speaker 1>slightly unfortunate that's a little long, but it's

01:03:05.710 --> 01:03:07.230
<v Speaker 1>also not long enough to be so much

01:03:07.230 --> 01:03:09.069
<v Speaker 1>of a pain that you, like, resort to

01:03:09.069 --> 01:03:10.510
<v Speaker 1>something like a macro to fix it.

01:03:11.230 --> 01:03:13.150
<v Speaker 1>There may be someday,

01:03:13.470 --> 01:03:16.285
<v Speaker 1>maybe string literals will just coerce into capital

01:03:16.285 --> 01:03:18.445
<v Speaker 1>s string automatically. There's definitely some people that

01:03:18.445 --> 01:03:20.685
<v Speaker 1>want that. There's some people also that because

01:03:20.685 --> 01:03:22.045
<v Speaker 1>of that heap allocation,

01:03:22.205 --> 01:03:24.125
<v Speaker 1>there would be upset that we'd be doing

01:03:24.125 --> 01:03:25.885
<v Speaker 1>heap allocation implicitly.

01:03:25.965 --> 01:03:26.845
<v Speaker 1>And so

01:03:27.005 --> 01:03:28.765
<v Speaker 1>there's kind of a a battle over whether

01:03:28.765 --> 01:03:29.725
<v Speaker 1>it's a good idea or not.

01:03:31.780 --> 01:03:32.420
<v Speaker 0>Okay.

01:03:33.460 --> 01:03:36.340
<v Speaker 0>Let's remove that. So there was a a

01:03:36.420 --> 01:03:38.180
<v Speaker 0>question. I was gonna keep the layer, but

01:03:38.180 --> 01:03:40.740
<v Speaker 0>because you're kinda talking about battles between what

01:03:40.740 --> 01:03:43.140
<v Speaker 0>people wanna see, maybe it kinda nicely

01:03:43.140 --> 01:03:45.540
<v Speaker 0>segues in. But we had a question that

01:03:45.540 --> 01:03:45.780
<v Speaker 0>said,

01:03:46.695 --> 01:03:48.695
<v Speaker 0>Rust is very readable and enjoyable.

01:03:49.095 --> 01:03:51.255
<v Speaker 0>Or what does the team take into mind

01:03:51.255 --> 01:03:53.495
<v Speaker 0>when it's trying to add new features and

01:03:53.495 --> 01:03:54.535
<v Speaker 0>it's referencing

01:03:54.535 --> 01:03:56.855
<v Speaker 0>things like c plus plus 20?

01:03:57.415 --> 01:03:58.535
<v Speaker 1>Yeah. So

01:03:59.660 --> 01:04:01.020
<v Speaker 1>I I think the interesting thing about the

01:04:01.020 --> 01:04:02.860
<v Speaker 1>wording of this specifically is, like, to make

01:04:02.860 --> 01:04:04.700
<v Speaker 1>it complicated and ugly, or are they trying

01:04:04.700 --> 01:04:06.780
<v Speaker 1>to say to not make it complicated? Yeah.

01:04:06.780 --> 01:04:09.500
<v Speaker 1>Okay. Cool. There we go. Yeah. Awesome. So

01:04:09.900 --> 01:04:12.860
<v Speaker 1>one kinda, like, interesting thing about Rust and

01:04:12.860 --> 01:04:15.385
<v Speaker 1>its syntax is a lot of people hate

01:04:15.385 --> 01:04:16.985
<v Speaker 1>it, and a lot of people don't understand

01:04:16.985 --> 01:04:18.665
<v Speaker 1>why other people hate it. And the reason

01:04:18.665 --> 01:04:21.065
<v Speaker 1>is is that Rust really draws inspiration

01:04:21.065 --> 01:04:22.985
<v Speaker 1>from a lot of other languages.

01:04:23.145 --> 01:04:25.705
<v Speaker 1>So almost nothing in Rust is actually new.

01:04:25.705 --> 01:04:27.865
<v Speaker 1>Many of the things the the name specifically

01:04:28.340 --> 01:04:30.500
<v Speaker 1>is, like, evoking the idea of a well

01:04:30.500 --> 01:04:32.740
<v Speaker 1>worn tool, like something that's been around for

01:04:32.740 --> 01:04:33.540
<v Speaker 1>a long time.

01:04:34.740 --> 01:04:35.540
<v Speaker 1>And so,

01:04:36.340 --> 01:04:36.980
<v Speaker 1>like,

01:04:37.380 --> 01:04:37.940
<v Speaker 1>the

01:04:38.260 --> 01:04:40.980
<v Speaker 1>a lot of the syntaxes are drawn from,

01:04:40.980 --> 01:04:42.580
<v Speaker 1>like, several disparate

01:04:42.580 --> 01:04:43.380
<v Speaker 1>sources.

01:04:43.540 --> 01:04:45.015
<v Speaker 1>So, like, you have some stuff that's a

01:04:45.015 --> 01:04:46.135
<v Speaker 1>little c inspired,

01:04:46.135 --> 01:04:47.974
<v Speaker 1>some stuff that's a little, like, ML or

01:04:47.974 --> 01:04:50.375
<v Speaker 1>OCaml inspired, some stuff that's a little Ruby

01:04:50.375 --> 01:04:52.855
<v Speaker 1>inspired, some stuff that's a little Python inspired.

01:04:53.015 --> 01:04:54.855
<v Speaker 1>And that means if you, like, if you

01:04:54.855 --> 01:04:57.270
<v Speaker 1>don't have the particular

01:04:57.990 --> 01:04:58.870
<v Speaker 1>background,

01:04:59.110 --> 01:05:01.430
<v Speaker 1>it can feel really, really strange.

01:05:01.590 --> 01:05:03.190
<v Speaker 1>But if you do, it feels really, really

01:05:03.190 --> 01:05:05.510
<v Speaker 1>normal. And that leads to a lot of

01:05:05.510 --> 01:05:07.590
<v Speaker 1>areas in which, like, people

01:05:07.830 --> 01:05:09.805
<v Speaker 1>will kinda be like, you know, why is

01:05:09.805 --> 01:05:11.645
<v Speaker 1>it written like this? Because, like, no language

01:05:11.645 --> 01:05:12.845
<v Speaker 1>is these are like this. And they're like,

01:05:12.845 --> 01:05:15.565
<v Speaker 1>well, if you've programmed an OCaml before, actually,

01:05:15.565 --> 01:05:17.165
<v Speaker 1>this is the exact same syntax.

01:05:17.245 --> 01:05:17.965
<v Speaker 1>And so,

01:05:18.205 --> 01:05:20.605
<v Speaker 1>you know, or whatever. And so there's there's

01:05:20.605 --> 01:05:22.285
<v Speaker 1>definitely sort of kinda, like, fruitful,

01:05:23.005 --> 01:05:23.885
<v Speaker 1>arguments to be had.

01:05:24.640 --> 01:05:26.320
<v Speaker 1>I think the thing is is that,

01:05:26.720 --> 01:05:29.040
<v Speaker 1>specifically, referring c plus plus one of the

01:05:29.040 --> 01:05:31.120
<v Speaker 1>things that's a challenge for c plus plus

01:05:31.200 --> 01:05:32.640
<v Speaker 1>is that it originally

01:05:32.800 --> 01:05:35.760
<v Speaker 1>was very much, like, an object oriented language

01:05:35.760 --> 01:05:37.440
<v Speaker 1>that was, like, very much designed in the

01:05:37.440 --> 01:05:39.200
<v Speaker 1>late nineties when it was first released.

01:05:39.625 --> 01:05:42.185
<v Speaker 1>And then over the last, like, fifteen years,

01:05:42.345 --> 01:05:44.105
<v Speaker 1>they've tried to morph it into sort of,

01:05:44.105 --> 01:05:45.705
<v Speaker 1>like, a more functional

01:05:45.705 --> 01:05:46.905
<v Speaker 1>ish language.

01:05:47.145 --> 01:05:48.745
<v Speaker 1>And so when you

01:05:48.985 --> 01:05:51.545
<v Speaker 1>it's kinda like trying to change the engine

01:05:51.545 --> 01:05:53.465
<v Speaker 1>on a car while you're driving down the

01:05:53.465 --> 01:05:55.890
<v Speaker 1>highway. Like, you can do it, but it's,

01:05:55.890 --> 01:05:57.569
<v Speaker 1>like, very complicated,

01:05:57.569 --> 01:05:59.250
<v Speaker 1>and there's a lot of constraints on the

01:05:59.250 --> 01:06:01.170
<v Speaker 1>problem and, like, you know, you've got all

01:06:01.170 --> 01:06:03.170
<v Speaker 1>these things going on. And so I would

01:06:03.170 --> 01:06:04.530
<v Speaker 1>say the number one thing that we have

01:06:04.530 --> 01:06:06.690
<v Speaker 1>in Rust to make it feel more simple

01:06:06.849 --> 01:06:09.170
<v Speaker 1>is purely that we started so much later,

01:06:09.635 --> 01:06:11.474
<v Speaker 1>and we haven't gone through that process of,

01:06:11.474 --> 01:06:13.715
<v Speaker 1>like, let's mutate it into something else entirely

01:06:13.795 --> 01:06:16.515
<v Speaker 1>means that there's a lot less weird corner

01:06:16.515 --> 01:06:18.755
<v Speaker 1>cases because we we haven't, like, done that

01:06:18.755 --> 01:06:20.515
<v Speaker 1>make of a drastic change. And so I

01:06:20.515 --> 01:06:21.714
<v Speaker 1>think the number one thing that we can

01:06:21.714 --> 01:06:23.234
<v Speaker 1>do to make sure that Rust does not

01:06:23.234 --> 01:06:25.650
<v Speaker 1>mutate into something like that is basically to

01:06:25.650 --> 01:06:26.210
<v Speaker 1>say

01:06:27.730 --> 01:06:30.290
<v Speaker 1>they're like, we're never gonna like, go ahead

01:06:30.290 --> 01:06:32.369
<v Speaker 1>and make a new language that replaces Rust

01:06:32.369 --> 01:06:35.010
<v Speaker 1>someday rather than trying to turn Rust into

01:06:35.010 --> 01:06:37.570
<v Speaker 1>a totally different language incrementally over time.

01:06:38.130 --> 01:06:39.010
<v Speaker 1>So that's kind of,

01:06:40.385 --> 01:06:41.984
<v Speaker 1>I think that's sort of, like, the key

01:06:41.984 --> 01:06:44.385
<v Speaker 1>to it. It's, like, making sure that the

01:06:44.385 --> 01:06:46.145
<v Speaker 1>bits stay orthogonal

01:06:46.224 --> 01:06:48.145
<v Speaker 1>and that we're not trying to, like, change

01:06:48.145 --> 01:06:50.224
<v Speaker 1>the core nature of what Rust is over

01:06:50.224 --> 01:06:50.705
<v Speaker 1>time.

01:06:51.025 --> 01:06:52.550
<v Speaker 1>There are good reasons why the c plus

01:06:52.550 --> 01:06:54.470
<v Speaker 1>folks are doing what they're doing, and and

01:06:54.470 --> 01:06:55.990
<v Speaker 1>kinda like that's one of the reasons why

01:06:55.990 --> 01:06:58.230
<v Speaker 1>it's still maintained its position of dominance for

01:06:58.230 --> 01:06:59.910
<v Speaker 1>so long. So I don't wanna say that

01:06:59.910 --> 01:07:01.990
<v Speaker 1>that approach is wrong either, but I think

01:07:01.990 --> 01:07:04.550
<v Speaker 1>that we're kind of more, like, in the

01:07:04.550 --> 01:07:05.910
<v Speaker 1>interest of, like, we're gonna keep the core

01:07:05.910 --> 01:07:08.295
<v Speaker 1>Rust the same way it is. And, like,

01:07:08.295 --> 01:07:10.295
<v Speaker 1>maybe another better language will come along someday,

01:07:10.295 --> 01:07:11.575
<v Speaker 1>and that's just kind of the natural way

01:07:11.575 --> 01:07:13.975
<v Speaker 1>of the world. So it'll it's fine if

01:07:13.975 --> 01:07:15.335
<v Speaker 1>we let that happen.

01:07:15.735 --> 01:07:16.935
<v Speaker 0>Nice. Cool.

01:07:17.735 --> 01:07:20.750
<v Speaker 0>Okay. So shall we I think the other

01:07:20.750 --> 01:07:22.510
<v Speaker 0>example in this file is to take a

01:07:22.510 --> 01:07:24.430
<v Speaker 0>look at a tuple based

01:07:24.510 --> 01:07:25.790
<v Speaker 0>struct. Mhmm.

01:07:26.990 --> 01:07:28.190
<v Speaker 0>Do you want to do that or will

01:07:28.190 --> 01:07:29.710
<v Speaker 0>we look at yeah. You can do that

01:07:29.710 --> 01:07:31.150
<v Speaker 1>real fast because it's not too long. So

01:07:31.150 --> 01:07:33.070
<v Speaker 1>in the same way that I talked briefly

01:07:33.070 --> 01:07:35.390
<v Speaker 1>about tuples before with, like, let x equals

01:07:35.565 --> 01:07:38.444
<v Speaker 1>one two. So this is, an anonymous tuple.

01:07:38.444 --> 01:07:41.165
<v Speaker 1>Like, there's no name. You can also declare,

01:07:41.165 --> 01:07:42.845
<v Speaker 1>like, a struct that looks like a tuple.

01:07:42.845 --> 01:07:45.565
<v Speaker 1>So what you put here is string string.

01:07:45.805 --> 01:07:46.685
<v Speaker 1>And so

01:07:46.845 --> 01:07:48.204
<v Speaker 1>you can kinda see how it looks sort

01:07:48.204 --> 01:07:49.805
<v Speaker 1>of similar, but it's just the type, no

01:07:49.805 --> 01:07:52.180
<v Speaker 1>name, and then the type. And so

01:07:53.220 --> 01:07:54.740
<v Speaker 1>that means that down here,

01:07:56.500 --> 01:07:59.060
<v Speaker 1>it would say, let green equals

01:08:00.340 --> 01:08:02.020
<v Speaker 1>color tuple struct,

01:08:02.180 --> 01:08:04.740
<v Speaker 1>and then that would be string from

01:08:04.980 --> 01:08:06.020
<v Speaker 1>green

01:08:06.645 --> 01:08:07.365
<v Speaker 1>and

01:08:07.605 --> 01:08:08.325
<v Speaker 1>string

01:08:08.645 --> 01:08:09.285
<v Speaker 1>from

01:08:10.325 --> 01:08:12.725
<v Speaker 1>pound o o f f o o.

01:08:13.445 --> 01:08:15.605
<v Speaker 1>And so this kinda looks more similar to

01:08:15.605 --> 01:08:17.764
<v Speaker 1>a tuple, but the name

01:08:18.245 --> 01:08:19.845
<v Speaker 1>it's got a name to it instead of

01:08:19.845 --> 01:08:21.949
<v Speaker 1>it being anonymous. And so the way that

01:08:21.949 --> 01:08:23.870
<v Speaker 1>you access we don't have names. You access

01:08:23.870 --> 01:08:25.870
<v Speaker 1>them by numbers. So dot zero and dot

01:08:25.870 --> 01:08:28.590
<v Speaker 1>one would give you green and zero f

01:08:28.670 --> 01:08:30.910
<v Speaker 1>zero zero because we haven't done the name.

01:08:30.910 --> 01:08:34.029
<v Speaker 1>And so, like, under the hood, this operates

01:08:34.029 --> 01:08:34.989
<v Speaker 1>the exact same way.

01:08:35.665 --> 01:08:37.825
<v Speaker 1>Just like sometimes one or the other feels

01:08:37.825 --> 01:08:39.745
<v Speaker 1>more natural in a given situation.

01:08:40.064 --> 01:08:41.585
<v Speaker 1>And so, you know, if you have something

01:08:41.585 --> 01:08:43.345
<v Speaker 1>that's very simple and small, like, if you

01:08:43.345 --> 01:08:45.104
<v Speaker 1>have a point, you know, maybe you don't

01:08:45.104 --> 01:08:46.945
<v Speaker 1>wanna go the whole x y z, maybe

01:08:46.945 --> 01:08:48.545
<v Speaker 1>just like zero one two is, like, good

01:08:48.545 --> 01:08:50.640
<v Speaker 1>enough or whatever. So tuples tend to be

01:08:50.640 --> 01:08:52.319
<v Speaker 1>good in very simple circumstances,

01:08:52.479 --> 01:08:54.319
<v Speaker 1>and giving things names tend to be useful

01:08:54.319 --> 01:08:55.439
<v Speaker 1>when you have something that's a little more

01:08:55.439 --> 01:08:56.159
<v Speaker 1>complicated.

01:08:57.680 --> 01:08:59.359
<v Speaker 0>Nice. Okay. And

01:08:59.520 --> 01:09:00.800
<v Speaker 0>are you do you know what the final

01:09:00.800 --> 01:09:02.160
<v Speaker 0>one is about? The unit The final one's

01:09:02.160 --> 01:09:04.345
<v Speaker 1>unit struct is you could have a a

01:09:04.345 --> 01:09:06.344
<v Speaker 1>a struct that has no data at all.

01:09:07.225 --> 01:09:09.064
<v Speaker 1>And so this is called a unit struct.

01:09:09.064 --> 01:09:10.345
<v Speaker 1>And so to do that, you just say

01:09:10.345 --> 01:09:11.864
<v Speaker 1>let unit struct

01:09:11.945 --> 01:09:13.705
<v Speaker 1>equals unit struct,

01:09:13.945 --> 01:09:14.185
<v Speaker 1>and

01:09:15.610 --> 01:09:18.010
<v Speaker 1>it just exists. There there are some reasons

01:09:18.010 --> 01:09:19.370
<v Speaker 1>why this is useful

01:09:19.530 --> 01:09:20.569
<v Speaker 1>if you want,

01:09:21.050 --> 01:09:23.290
<v Speaker 1>but we probably should since we have limited

01:09:23.290 --> 01:09:24.729
<v Speaker 1>time, I don't wanna get super into it.

01:09:24.729 --> 01:09:26.330
<v Speaker 1>But just like the point is is that,

01:09:26.330 --> 01:09:27.690
<v Speaker 1>you know, you can have any number of

01:09:27.690 --> 01:09:29.290
<v Speaker 1>things you want, including zero things.

01:09:30.465 --> 01:09:31.104
<v Speaker 1>So

01:09:31.505 --> 01:09:31.984
<v Speaker 1>yeah.

01:09:32.944 --> 01:09:34.864
<v Speaker 0>Alright. I'll I'll pretend I'll know what that

01:09:34.864 --> 01:09:36.784
<v Speaker 0>one's for then. Okay. Totally. It's fine.

01:09:37.744 --> 01:09:39.744
<v Speaker 0>Okay. So do wanna do struct two, or

01:09:39.744 --> 01:09:41.824
<v Speaker 0>do you wanna jump into something else? Let's

01:09:41.824 --> 01:09:43.104
<v Speaker 1>let's briefly

01:09:43.185 --> 01:09:45.670
<v Speaker 1>let's not do struct two because this is

01:09:45.670 --> 01:09:47.029
<v Speaker 1>going to some other things. Let's check out

01:09:47.029 --> 01:09:48.949
<v Speaker 1>struct three real fast because I wanna see

01:09:48.949 --> 01:09:49.429
<v Speaker 1>if

01:09:49.829 --> 01:09:52.149
<v Speaker 1>right. So this is gonna cover methods, which

01:09:52.149 --> 01:09:53.670
<v Speaker 1>is, I think, gonna be interesting. We can

01:09:53.670 --> 01:09:54.869
<v Speaker 1>just go over it really briefly. You don't

01:09:54.869 --> 01:09:56.790
<v Speaker 1>have to go into all the details. But

01:09:57.205 --> 01:09:58.405
<v Speaker 1>point is, like I said, we have this

01:09:58.405 --> 01:10:00.885
<v Speaker 1>separation between the data and the behavior. So

01:10:00.885 --> 01:10:02.645
<v Speaker 1>here we have our struck package, which has

01:10:02.645 --> 01:10:05.364
<v Speaker 1>a country, it's a string, and recipient country,

01:10:05.364 --> 01:10:06.885
<v Speaker 1>it's a string, and then a weight is

01:10:06.885 --> 01:10:08.005
<v Speaker 1>I 32.

01:10:08.165 --> 01:10:09.844
<v Speaker 1>So this is just purely the data. We

01:10:09.844 --> 01:10:12.405
<v Speaker 1>use the import keyword to declare an implementation

01:10:12.900 --> 01:10:15.300
<v Speaker 1>of package. So this is saying, like, this

01:10:15.300 --> 01:10:16.739
<v Speaker 1>is gonna be all the methods that are

01:10:16.739 --> 01:10:17.380
<v Speaker 1>involved.

01:10:18.580 --> 01:10:19.380
<v Speaker 1>And so,

01:10:19.940 --> 01:10:22.179
<v Speaker 1>here we have three methods. One is new,

01:10:22.179 --> 01:10:24.100
<v Speaker 1>one is is international, and one is get

01:10:24.100 --> 01:10:26.420
<v Speaker 1>fees. You can kinda see the, some of

01:10:26.420 --> 01:10:28.505
<v Speaker 1>the versions of this index here. So this

01:10:28.505 --> 01:10:29.945
<v Speaker 1>is what would be called a static method

01:10:29.945 --> 01:10:32.105
<v Speaker 1>in other languages. We just call it a

01:10:32.505 --> 01:10:33.385
<v Speaker 1>a associated

01:10:34.025 --> 01:10:35.304
<v Speaker 1>function in Rust.

01:10:35.625 --> 01:10:37.865
<v Speaker 1>Details don't really matter. The point is is

01:10:37.865 --> 01:10:40.025
<v Speaker 1>that this would take three arguments, the country,

01:10:40.025 --> 01:10:42.025
<v Speaker 1>the recipient country, the weight in grams, and

01:10:42.025 --> 01:10:44.130
<v Speaker 1>we'll return a package. And so you would,

01:10:44.130 --> 01:10:46.610
<v Speaker 1>like, you know, return the value by creating

01:10:46.610 --> 01:10:49.730
<v Speaker 1>this struct. So, this because it gets declared

01:10:49.730 --> 01:10:50.449
<v Speaker 1>down

01:10:51.090 --> 01:10:53.410
<v Speaker 1>here. So package colon colon new is how

01:10:53.410 --> 01:10:55.090
<v Speaker 1>you'd invoke it, and you'd be able to

01:10:55.090 --> 01:10:56.610
<v Speaker 1>pass in those three things, and you would

01:10:56.610 --> 01:10:57.410
<v Speaker 1>get a package back.

01:10:58.515 --> 01:11:00.275
<v Speaker 1>If you wanted a method that lets you

01:11:00.275 --> 01:11:02.915
<v Speaker 1>do, like, method syntax like foo dot bar,

01:11:04.115 --> 01:11:06.195
<v Speaker 1>here, you would take a the first argument

01:11:06.195 --> 01:11:08.435
<v Speaker 1>is this self argument.

01:11:08.515 --> 01:11:10.355
<v Speaker 1>So it's very similar to self and JavaScript

01:11:10.355 --> 01:11:13.200
<v Speaker 1>or Ruby or Python. We're explicit about it

01:11:13.200 --> 01:11:15.440
<v Speaker 1>like Python rather than implicit about it like

01:11:15.440 --> 01:11:18.080
<v Speaker 1>Ruby. So the the first argument being self

01:11:18.080 --> 01:11:19.600
<v Speaker 1>means that this would be a method. So

01:11:19.600 --> 01:11:21.840
<v Speaker 1>if we had, say, a package of some

01:11:21.840 --> 01:11:22.160
<v Speaker 1>kinds,

01:11:24.784 --> 01:11:27.664
<v Speaker 1>then we could say p dot is international,

01:11:27.744 --> 01:11:29.025
<v Speaker 1>and that gives you that method to call

01:11:29.025 --> 01:11:30.625
<v Speaker 1>to next. And so this gives you Rust

01:11:30.625 --> 01:11:32.145
<v Speaker 1>sort of like an o o kind of,

01:11:32.145 --> 01:11:34.465
<v Speaker 1>like, feel because you have these methods, but

01:11:34.465 --> 01:11:36.145
<v Speaker 1>it's a little cleaner and that your data

01:11:36.145 --> 01:11:38.385
<v Speaker 1>and your behavior are cleanly separated as opposed

01:11:38.385 --> 01:11:39.905
<v Speaker 1>to being declared in all of one thing.

01:11:40.390 --> 01:11:42.790
<v Speaker 1>And in this example, you might say, like,

01:11:42.790 --> 01:11:44.390
<v Speaker 1>that's not super useful because you just declare

01:11:44.390 --> 01:11:46.550
<v Speaker 1>both of them anyway. That's totally true. Part

01:11:46.550 --> 01:11:48.070
<v Speaker 1>of it is because sometimes you only have

01:11:48.070 --> 01:11:49.989
<v Speaker 1>data until you just have structs. And so

01:11:49.989 --> 01:11:52.070
<v Speaker 1>rather than having two separate concepts, a struct

01:11:52.070 --> 01:11:54.355
<v Speaker 1>and a class, you just have one. Everything

01:11:54.355 --> 01:11:56.275
<v Speaker 1>is a struct. Sometimes you have methods. Sometimes

01:11:56.275 --> 01:11:57.875
<v Speaker 1>you don't have methods, and that feels a

01:11:57.875 --> 01:11:58.675
<v Speaker 1>little cleaner.

01:11:59.635 --> 01:12:02.675
<v Speaker 1>Also, it's because you can declare methods on

01:12:02.675 --> 01:12:04.435
<v Speaker 1>other people's structs if you want.

01:12:05.330 --> 01:12:07.410
<v Speaker 1>And there's some interesting rules about those details

01:12:07.410 --> 01:12:09.330
<v Speaker 1>there, but by splitting them up into two

01:12:09.330 --> 01:12:11.410
<v Speaker 1>separate things, you get that control over, like,

01:12:11.410 --> 01:12:13.250
<v Speaker 1>sometimes you just have data, sometimes you have

01:12:13.250 --> 01:12:15.250
<v Speaker 1>both, sometimes you put your own methods on

01:12:15.250 --> 01:12:16.369
<v Speaker 1>someone else's data.

01:12:16.930 --> 01:12:17.730
<v Speaker 1>And so

01:12:17.970 --> 01:12:20.050
<v Speaker 1>that's kinda like how all that stuff sorta

01:12:20.050 --> 01:12:22.144
<v Speaker 1>works. So you kinda get this o o

01:12:22.144 --> 01:12:24.945
<v Speaker 1>ish feel without exactly being

01:12:25.184 --> 01:12:26.064
<v Speaker 1>o o,

01:12:27.664 --> 01:12:29.824
<v Speaker 1>if that'll make sense. Seems very familiar to

01:12:29.824 --> 01:12:31.744
<v Speaker 0>the way that the goal works as well

01:12:31.824 --> 01:12:34.144
<v Speaker 0>with Definitely. Go is very similar in this

01:12:34.144 --> 01:12:34.784
<v Speaker 1>regard for sure.

01:12:35.540 --> 01:12:36.420
<v Speaker 1>And,

01:12:37.220 --> 01:12:40.099
<v Speaker 1>traits are what we call interfaces in Go.

01:12:40.420 --> 01:12:42.980
<v Speaker 1>So that has a very similar syntax where

01:12:42.980 --> 01:12:44.099
<v Speaker 1>you say, emple

01:12:44.580 --> 01:12:47.300
<v Speaker 1>trait for package instead of just emple package,

01:12:47.505 --> 01:12:49.905
<v Speaker 1>and that's how you'd implement an interface. And

01:12:49.905 --> 01:12:52.145
<v Speaker 1>it feels very similar where you would take

01:12:52.145 --> 01:12:54.304
<v Speaker 1>interfaces as arguments and, you know, then you

01:12:54.304 --> 01:12:56.545
<v Speaker 1>can pass in any structure that implements the

01:12:56.545 --> 01:12:58.144
<v Speaker 1>interface and do all that kind of thing.

01:12:58.945 --> 01:12:59.905
<v Speaker 0>Nice. Okay.

01:13:01.370 --> 01:13:03.850
<v Speaker 0>I think we'll leave it there rather than

01:13:03.850 --> 01:13:05.530
<v Speaker 0>trying to rush through anything else in a

01:13:05.530 --> 01:13:06.650
<v Speaker 0>in a in a matter of a few

01:13:06.650 --> 01:13:08.170
<v Speaker 0>minutes. So

01:13:08.970 --> 01:13:11.370
<v Speaker 0>let's remove the screen. If anyone has any

01:13:11.370 --> 01:13:13.370
<v Speaker 0>questions, feel free. We'll give you a minute

01:13:13.370 --> 01:13:15.290
<v Speaker 0>to drop them into the chat, and we

01:13:15.370 --> 01:13:17.624
<v Speaker 0>can just quickly talk for a second. Yeah.

01:13:17.704 --> 01:13:18.264
<v Speaker 0>So,

01:13:18.744 --> 01:13:19.945
<v Speaker 0>you know, I think

01:13:20.824 --> 01:13:23.385
<v Speaker 0>Rust should hopefully feel familiar enough to people

01:13:23.385 --> 01:13:25.625
<v Speaker 0>that come from other sea based languages. You

01:13:25.625 --> 01:13:27.784
<v Speaker 0>know, there are a few quirks that have

01:13:27.784 --> 01:13:29.465
<v Speaker 0>to be learned as I'm sure with all

01:13:29.465 --> 01:13:32.760
<v Speaker 0>languages for sure. Yeah. And we've got an

01:13:32.760 --> 01:13:35.160
<v Speaker 0>example here of Rustlings, and obviously, you've got

01:13:35.160 --> 01:13:37.080
<v Speaker 0>your book, the Rust programming book. Are there

01:13:37.080 --> 01:13:39.560
<v Speaker 0>any other resources you would recommend for people

01:13:39.560 --> 01:13:41.880
<v Speaker 0>to check out? Definitely. So we have

01:13:42.680 --> 01:13:45.080
<v Speaker 1>there's multiple discords that you can join for

01:13:45.080 --> 01:13:47.595
<v Speaker 1>getting help in a live chat environment as

01:13:47.595 --> 01:13:49.915
<v Speaker 1>opposed to, you know, posting things. There's also

01:13:49.915 --> 01:13:52.395
<v Speaker 1>the user forum at users.rustlang.org

01:13:52.395 --> 01:13:53.675
<v Speaker 1>where you can ask questions,

01:13:54.075 --> 01:13:56.955
<v Speaker 1>if you prefer a forum to a Discord.

01:13:57.275 --> 01:13:59.035
<v Speaker 1>And those are both really great resources for

01:13:59.035 --> 01:14:00.820
<v Speaker 1>getting going. Other one I would say, and

01:14:00.820 --> 01:14:02.660
<v Speaker 1>this kind of an interesting trick is there's

01:14:02.660 --> 01:14:04.500
<v Speaker 1>been a lot of people who learn Rust

01:14:04.500 --> 01:14:06.820
<v Speaker 1>to try it once and get frustrated and

01:14:06.820 --> 01:14:08.180
<v Speaker 1>say, this doesn't make any sense to me.

01:14:08.180 --> 01:14:10.020
<v Speaker 1>And then they leave for six months, and

01:14:10.020 --> 01:14:11.460
<v Speaker 1>they come back and they try it again.

01:14:11.460 --> 01:14:13.380
<v Speaker 1>And they're like, this makes perfect sense. Why

01:14:13.380 --> 01:14:15.415
<v Speaker 1>did I get frustrated the first time? And

01:14:15.415 --> 01:14:15.974
<v Speaker 1>so,

01:14:16.295 --> 01:14:17.974
<v Speaker 1>you know, you should give Rust a try.

01:14:18.215 --> 01:14:20.135
<v Speaker 1>And if if it's not for you, that's

01:14:20.135 --> 01:14:22.535
<v Speaker 1>totally fine. Maybe it never will be. But

01:14:22.535 --> 01:14:24.295
<v Speaker 1>also, you know, just try giving it a

01:14:24.295 --> 01:14:25.574
<v Speaker 1>while and coming back. Sometimes

01:14:26.070 --> 01:14:27.510
<v Speaker 1>I haven't figured out, like, this is, like,

01:14:27.510 --> 01:14:28.790
<v Speaker 1>really if I could figure out what it

01:14:28.790 --> 01:14:30.550
<v Speaker 1>is that happens in those months and, like,

01:14:30.550 --> 01:14:32.870
<v Speaker 1>get people to understand it immediately, like, I

01:14:32.870 --> 01:14:34.390
<v Speaker 1>would do it. But sometimes you just need

01:14:34.390 --> 01:14:35.990
<v Speaker 1>to, like, take a step away. It's kinda

01:14:35.990 --> 01:14:37.670
<v Speaker 1>like that old programmer advice of, like, go

01:14:37.670 --> 01:14:39.030
<v Speaker 1>on a walk or take a shower or

01:14:39.030 --> 01:14:40.870
<v Speaker 1>do something else and, like, eventually the answer

01:14:40.870 --> 01:14:42.685
<v Speaker 1>kinda comes to you. We found that that

01:14:42.685 --> 01:14:44.765
<v Speaker 1>really happens with learning Rust a lot. Like,

01:14:44.765 --> 01:14:47.245
<v Speaker 1>people will try it, be like, this is

01:14:47.245 --> 01:14:49.085
<v Speaker 1>too hard. I don't understand anything. I'm gonna

01:14:49.085 --> 01:14:51.005
<v Speaker 1>quit. And then they come back and they're

01:14:51.005 --> 01:14:52.765
<v Speaker 1>like, this makes sense. And sometimes it takes

01:14:52.765 --> 01:14:54.605
<v Speaker 1>a couple tries. We've had people say, oh,

01:14:54.605 --> 01:14:55.645
<v Speaker 1>yeah. Had to give it three or four

01:14:55.645 --> 01:14:57.005
<v Speaker 1>tries before it made sense, but now it

01:14:57.005 --> 01:14:57.725
<v Speaker 1>makes perfect sense.

01:14:58.420 --> 01:15:00.099
<v Speaker 1>And so so yeah. I don't know. But

01:15:00.099 --> 01:15:01.460
<v Speaker 1>that's also the other bit of advice I

01:15:01.460 --> 01:15:02.980
<v Speaker 1>would give you is take advantage of the

01:15:02.980 --> 01:15:05.059
<v Speaker 1>fact that the community exists and loves answering

01:15:05.059 --> 01:15:05.699
<v Speaker 1>questions.

01:15:05.940 --> 01:15:07.699
<v Speaker 1>Please post questions and get help if you

01:15:07.699 --> 01:15:09.780
<v Speaker 1>want. And, you know, if you don't like

01:15:09.780 --> 01:15:11.905
<v Speaker 1>Rust, that's totally fine. Maybe someday you'll like

01:15:11.905 --> 01:15:13.745
<v Speaker 1>better. Maybe maybe not. Like, there's lots of

01:15:13.745 --> 01:15:15.824
<v Speaker 1>programming languages when they have so much time.

01:15:15.825 --> 01:15:17.745
<v Speaker 1>So, you know, it's it's cool.

01:15:18.145 --> 01:15:19.585
<v Speaker 0>Yeah. I think that's one of my problems

01:15:19.585 --> 01:15:21.185
<v Speaker 0>is that I'm too busy playing with random

01:15:21.185 --> 01:15:24.305
<v Speaker 0>esoteric languages instead of actually building anything useful

01:15:24.305 --> 01:15:26.740
<v Speaker 0>in one language. Totally. Yeah. Jump in between.

01:15:26.740 --> 01:15:28.020
<v Speaker 0>There's just too many good things out there.

01:15:28.020 --> 01:15:29.300
<v Speaker 0>Know, there's Rust that I wanna get better

01:15:29.300 --> 01:15:30.660
<v Speaker 0>at. There's pony that I wanna get better

01:15:30.660 --> 01:15:31.940
<v Speaker 0>at. There's zigs that I wanna get better

01:15:31.940 --> 01:15:32.980
<v Speaker 0>at. And I'm just like, I wanna play

01:15:32.980 --> 01:15:33.940
<v Speaker 0>with all these things.

01:15:34.740 --> 01:15:36.660
<v Speaker 1>It's definitely not enough time in the day.

01:15:36.740 --> 01:15:37.860
<v Speaker 0>No. No. Definitely not.

01:15:38.455 --> 01:15:39.975
<v Speaker 0>Alright. So we got a couple of things

01:15:39.975 --> 01:15:42.215
<v Speaker 0>here. SD said lovely session. Thank you very

01:15:42.135 --> 01:15:42.534
<v Speaker 0>Rod

01:15:43.815 --> 01:15:46.054
<v Speaker 0>asked a question which I'll rephrase slightly.

01:15:46.455 --> 01:15:49.015
<v Speaker 0>Yeah. Has the future of Rust secure with

01:15:49.015 --> 01:15:50.295
<v Speaker 0>the recently offset Mozilla?

01:15:50.890 --> 01:15:53.370
<v Speaker 1>Yeah. So there is about 200 people that

01:15:53.370 --> 01:15:55.450
<v Speaker 1>work on Rust in general. And at the

01:15:55.450 --> 01:15:57.450
<v Speaker 1>time of the Mozilla layoffs, like, before the

01:15:57.450 --> 01:15:59.930
<v Speaker 1>layoffs happened, only four or five of those

01:15:59.930 --> 01:16:01.929
<v Speaker 1>people were employed by Mozilla. So

01:16:02.730 --> 01:16:04.975
<v Speaker 1>I it's always tricky to answer this question

01:16:04.975 --> 01:16:07.855
<v Speaker 1>because those are my friends and former colleagues.

01:16:07.855 --> 01:16:09.375
<v Speaker 1>And so I don't wanna say they don't

01:16:09.375 --> 01:16:11.295
<v Speaker 1>matter because they do matter because they are

01:16:11.295 --> 01:16:12.735
<v Speaker 1>wonderful people and do a lot of work

01:16:12.735 --> 01:16:15.375
<v Speaker 1>in Rust. But at the same time, they're

01:16:15.375 --> 01:16:17.215
<v Speaker 1>a small number of a large group of

01:16:17.215 --> 01:16:18.495
<v Speaker 1>people, and so

01:16:18.840 --> 01:16:21.320
<v Speaker 1>the overall movement of Rust is not really

01:16:21.320 --> 01:16:23.560
<v Speaker 1>affected by the Mozilla layoffs. Additionally,

01:16:25.240 --> 01:16:26.920
<v Speaker 1>you'll have seen and you will see in

01:16:26.920 --> 01:16:29.080
<v Speaker 1>the future more and more companies

01:16:29.160 --> 01:16:31.480
<v Speaker 1>picking up, getting into Rust development. So the

01:16:31.480 --> 01:16:34.225
<v Speaker 1>big announcement in the last week is Amazon

01:16:34.225 --> 01:16:36.545
<v Speaker 1>is, like, explicitly hiring a bunch of people

01:16:36.545 --> 01:16:38.785
<v Speaker 1>to work on Rust itself. And so we're

01:16:38.785 --> 01:16:41.185
<v Speaker 1>seeing other companies pick up where Mozilla left

01:16:41.185 --> 01:16:43.825
<v Speaker 1>off even though, like, as I said before,

01:16:43.825 --> 01:16:45.825
<v Speaker 1>most of the Rust development was volunteer in

01:16:45.825 --> 01:16:47.425
<v Speaker 1>the first place. So

01:16:48.130 --> 01:16:49.890
<v Speaker 1>it it affects us in the sense that,

01:16:49.890 --> 01:16:51.489
<v Speaker 1>you know, some people have had to shift

01:16:51.489 --> 01:16:53.250
<v Speaker 1>around and some people still work on Rust,

01:16:53.250 --> 01:16:54.850
<v Speaker 1>but only in a spare time capacity instead

01:16:54.850 --> 01:16:56.130
<v Speaker 1>of a full time one like they used

01:16:56.130 --> 01:16:56.530
<v Speaker 1>to.

01:16:56.930 --> 01:16:58.530
<v Speaker 1>And some people have just found jobs other

01:16:58.530 --> 01:16:59.970
<v Speaker 1>places working on Rust. And so,

01:17:00.655 --> 01:17:02.975
<v Speaker 1>you know but definitely, like, the future is

01:17:02.975 --> 01:17:05.054
<v Speaker 1>bright and the situation with Mozilla is pretty

01:17:05.054 --> 01:17:07.054
<v Speaker 1>independent from the situation of Rust these days.

01:17:08.094 --> 01:17:08.655
<v Speaker 1>Yeah.

01:17:09.375 --> 01:17:11.054
<v Speaker 0>Yeah. I mean, I I can't add any

01:17:11.054 --> 01:17:12.495
<v Speaker 0>more flavor to that other than what you

01:17:12.495 --> 01:17:13.775
<v Speaker 0>have said. But I I can say from

01:17:13.775 --> 01:17:15.820
<v Speaker 0>the cloud native perspective, which is where my,

01:17:15.820 --> 01:17:17.660
<v Speaker 0>you know as the community I'm most involved

01:17:17.660 --> 01:17:19.739
<v Speaker 0>in, is all these companies are now adopting

01:17:19.739 --> 01:17:20.940
<v Speaker 0>Rust for all

01:17:21.340 --> 01:17:22.940
<v Speaker 0>sorts of crazy technology.

01:17:23.020 --> 01:17:24.780
<v Speaker 0>And I think there's definitely enough

01:17:25.100 --> 01:17:27.020
<v Speaker 0>enough people contribute in in that space that

01:17:27.020 --> 01:17:28.780
<v Speaker 0>Rust would definitely have a future regardless of

01:17:28.780 --> 01:17:30.355
<v Speaker 0>what happens in this area. And I also

01:17:31.235 --> 01:17:32.755
<v Speaker 1>foundation is maybe what you're about to say.

01:17:32.755 --> 01:17:33.955
<v Speaker 1>The other part I didn't say is we're

01:17:33.955 --> 01:17:35.795
<v Speaker 1>working on starting a Rust foundation,

01:17:35.955 --> 01:17:37.395
<v Speaker 1>and so you'll hear some news about that

01:17:37.395 --> 01:17:39.554
<v Speaker 1>in the coming months. And so that's also

01:17:39.554 --> 01:17:40.275
<v Speaker 1>kind of,

01:17:40.755 --> 01:17:42.355
<v Speaker 1>you know, a part of that future too.

01:17:42.890 --> 01:17:44.730
<v Speaker 0>Yeah. All sorts of things going on there.

01:17:44.730 --> 01:17:46.490
<v Speaker 0>And there was news last week about several

01:17:46.490 --> 01:17:48.490
<v Speaker 0>being handed over to the Linux Foundation, which

01:17:48.490 --> 01:17:50.570
<v Speaker 0>I'm sure are are probably a key component

01:17:50.570 --> 01:17:52.330
<v Speaker 0>of the Rust Foundation work too, hopefully. So

01:17:52.330 --> 01:17:53.050
<v Speaker 0>we'll see.

01:17:53.770 --> 01:17:54.730
<v Speaker 0>I wouldn't be worried.

01:17:55.335 --> 01:17:56.934
<v Speaker 0>So Rod said, thank you.

01:17:57.415 --> 01:18:00.055
<v Speaker 0>And finally, I'll finish with SD saying, hey,

01:18:00.055 --> 01:18:01.175
<v Speaker 0>Steve, you need to come back so we

01:18:01.175 --> 01:18:03.975
<v Speaker 0>can do intermediate Rust. Sure. Yeah. Sounds good.

01:18:03.975 --> 01:18:05.575
<v Speaker 0>I wouldn't make him commit on air. Don't

01:18:05.655 --> 01:18:07.335
<v Speaker 0>sorry. But we'll speak afterwards.

01:18:07.840 --> 01:18:10.240
<v Speaker 0>Regardless of Steve's availability, I do plan on

01:18:10.240 --> 01:18:12.080
<v Speaker 0>doing more Rust content and hopefully Steve can

01:18:12.080 --> 01:18:13.040
<v Speaker 0>be a part of that too.

01:18:13.520 --> 01:18:14.800
<v Speaker 0>Thank you very much for your time today.

01:18:14.800 --> 01:18:16.480
<v Speaker 0>That was that was awesome. I think, you

01:18:16.480 --> 01:18:18.480
<v Speaker 0>know, we man hopefully covered enough of the

01:18:18.480 --> 01:18:20.480
<v Speaker 0>basics that people can get started. If you've

01:18:20.480 --> 01:18:22.400
<v Speaker 0>tried it before, definitely give it another try.

01:18:22.845 --> 01:18:24.525
<v Speaker 0>As we said, you know, sometimes you just

01:18:24.525 --> 01:18:26.445
<v Speaker 0>have to try it twice like olives. Totally.

01:18:27.725 --> 01:18:29.405
<v Speaker 0>And I hope you have a great rest

01:18:29.405 --> 01:18:30.845
<v Speaker 0>of your day. Thank you again for joining

01:18:30.845 --> 01:18:32.205
<v Speaker 0>me and I'll speak to soon. Yeah. You

01:18:32.205 --> 01:18:33.565
<v Speaker 1>too. Thanks for having me. Yeah. Thanks a

01:18:33.565 --> 01:18:33.965
<v Speaker 0>lot. Bye.
