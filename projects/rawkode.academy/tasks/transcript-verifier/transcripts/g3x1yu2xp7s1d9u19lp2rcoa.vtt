WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 8f035755-e9db-48c6-9d88-aa128ce9c212
Created: 2025-04-29T18:13:57.258Z
Duration: 4372.951
Channels: 1

00:01:04.785 --> 00:01:07.905
<v Speaker 0>Hello, and welcome to today's episode of Rawkode

00:01:07.905 --> 00:01:09.745
<v Speaker 0>live. I'm your host, Rawkode.

00:01:09.985 --> 00:01:12.385
<v Speaker 0>Today, we're gonna be taking a look hands

00:01:12.385 --> 00:01:15.585
<v Speaker 0>on introduction to c plus plus Now before

00:01:15.585 --> 00:01:16.865
<v Speaker 0>we do that, there's just a little bit

00:01:16.865 --> 00:01:17.345
<v Speaker 0>of housekeeping.

00:01:18.119 --> 00:01:20.119
<v Speaker 0>First, if you're not subscribed to the YouTube

00:01:20.119 --> 00:01:21.640
<v Speaker 0>channel, I would encourage you to do so

00:01:21.640 --> 00:01:23.719
<v Speaker 0>now. Subscribe and click the bell, and you

00:01:23.719 --> 00:01:25.479
<v Speaker 0>will get alerts for all future episodes of

00:01:25.479 --> 00:01:28.200
<v Speaker 0>Rawkode Live as we explore and learn this

00:01:28.200 --> 00:01:29.960
<v Speaker 0>vast cloud native landscape together.

00:01:30.360 --> 00:01:31.975
<v Speaker 0>If you're not watching live and wanna come

00:01:31.975 --> 00:01:33.415
<v Speaker 0>join us in the chat, there is a

00:01:33.415 --> 00:01:36.295
<v Speaker 0>Discord server available at Rawkode.chat.

00:01:36.455 --> 00:01:37.895
<v Speaker 0>Come in there and say hello. We talk

00:01:37.895 --> 00:01:40.135
<v Speaker 0>about all things cloud native, Kubernetes, rock music,

00:01:40.135 --> 00:01:41.255
<v Speaker 0>and a whole bunch of other things in

00:01:41.255 --> 00:01:43.175
<v Speaker 0>between. So we look forward to welcoming you.

00:01:43.960 --> 00:01:45.399
<v Speaker 0>Now to guide us on our journey into

00:01:45.399 --> 00:01:47.079
<v Speaker 0>c plus plus today, I am joined by

00:01:47.079 --> 00:01:49.640
<v Speaker 0>a c plus plus developer advocate at Microsoft,

00:01:49.640 --> 00:01:50.600
<v Speaker 0>Cy Brandt.

00:01:50.680 --> 00:01:53.159
<v Speaker 0>Hi, Cy. How are you? Hey. Good. Thanks

00:01:53.159 --> 00:01:54.200
<v Speaker 1>very much for having me. How are you

00:01:54.200 --> 00:01:56.520
<v Speaker 1>doing? Very well. Thank you. And it's a

00:01:56.520 --> 00:01:58.520
<v Speaker 0>pleasure to have you here. I've seen a

00:01:58.520 --> 00:02:00.545
<v Speaker 0>few of your talks over there the last

00:02:00.545 --> 00:02:01.104
<v Speaker 0>year.

00:02:01.585 --> 00:02:04.065
<v Speaker 0>All very very interesting and exciting and

00:02:04.945 --> 00:02:07.825
<v Speaker 0>very low level at times. But I think

00:02:07.825 --> 00:02:10.384
<v Speaker 0>those are those primitives are really good way

00:02:10.384 --> 00:02:11.665
<v Speaker 0>to try to understand

00:02:11.960 --> 00:02:12.760
<v Speaker 0>really

00:02:12.760 --> 00:02:15.480
<v Speaker 0>complex topics as well. So I'm very,

00:02:15.480 --> 00:02:17.000
<v Speaker 0>very excited to have you here today.

00:02:17.640 --> 00:02:19.720
<v Speaker 0>Can you do us a favor? And just

00:02:19.720 --> 00:02:21.720
<v Speaker 0>for anyone who is not familiar, hasn't seen

00:02:21.720 --> 00:02:23.480
<v Speaker 0>our talks, doesn't follow you on Twitter, give

00:02:23.480 --> 00:02:24.840
<v Speaker 0>us the introduction to Sai.

00:02:25.625 --> 00:02:27.625
<v Speaker 1>Yeah. So my name is Cy Brand. I

00:02:27.625 --> 00:02:30.345
<v Speaker 1>work as Microsoft c plus plus developer advocate,

00:02:30.745 --> 00:02:32.584
<v Speaker 1>where I spend most of my time on

00:02:32.584 --> 00:02:35.385
<v Speaker 1>Twitter just, like, making nonsense.

00:02:36.025 --> 00:02:37.465
<v Speaker 1>My background is in,

00:02:37.784 --> 00:02:38.984
<v Speaker 1>compilers

00:02:38.750 --> 00:02:41.870
<v Speaker 1>and, debuggers, tool chains for for graphics cards.

00:02:41.870 --> 00:02:44.190
<v Speaker 1>I spent about five years writing,

00:02:44.750 --> 00:02:47.310
<v Speaker 1>like, GPU compilers and debuggers,

00:02:47.870 --> 00:02:49.630
<v Speaker 1>which is where I got, like, fascinated by

00:02:49.630 --> 00:02:50.110
<v Speaker 1>really

00:02:50.510 --> 00:02:51.790
<v Speaker 1>low level stuff.

00:02:52.030 --> 00:02:52.190
<v Speaker 1>And,

00:02:54.174 --> 00:02:55.855
<v Speaker 1>yeah, that's where my kind of love for

00:02:55.855 --> 00:02:58.095
<v Speaker 1>developer tools and things like that came from.

00:02:58.095 --> 00:02:59.855
<v Speaker 1>So then I've been at Microsoft for for

00:02:59.855 --> 00:03:01.775
<v Speaker 1>a couple of years now and,

00:03:02.015 --> 00:03:04.415
<v Speaker 1>still, like, giving talks about c plus plus,

00:03:04.974 --> 00:03:07.040
<v Speaker 1>getting involved in the

00:03:07.280 --> 00:03:08.800
<v Speaker 1>ISO standardization.

00:03:08.800 --> 00:03:10.160
<v Speaker 1>Like, I just got a

00:03:10.480 --> 00:03:13.280
<v Speaker 1>feature hopefully getting into c plus plus 23,

00:03:13.600 --> 00:03:14.960
<v Speaker 1>which just got approved a couple of days

00:03:14.960 --> 00:03:16.960
<v Speaker 1>ago. So I'm very excited about that.

00:03:17.520 --> 00:03:18.000
<v Speaker 0>Awesome.

00:03:19.475 --> 00:03:21.715
<v Speaker 0>Okay. Well, we got people saying hello in

00:03:21.715 --> 00:03:23.315
<v Speaker 0>the chat. Hello, everyone, and welcome to today's

00:03:23.315 --> 00:03:24.275
<v Speaker 0>session. Everyone.

00:03:24.915 --> 00:03:27.315
<v Speaker 0>You also like to explain low level concepts

00:03:27.315 --> 00:03:28.915
<v Speaker 0>for viewer cats, and you have your own

00:03:28.915 --> 00:03:31.235
<v Speaker 0>YouTube channel. I will include a link to

00:03:31.235 --> 00:03:32.835
<v Speaker 0>that in the description, but you wanna tell

00:03:32.835 --> 00:03:34.115
<v Speaker 0>us a little bit more about that if

00:03:34.115 --> 00:03:36.750
<v Speaker 0>you want? Yeah. Sure. That was basically

00:03:38.030 --> 00:03:41.230
<v Speaker 1>I I come from, like, a very traditional

00:03:42.030 --> 00:03:44.030
<v Speaker 1>background of computing. Like, I did a CS

00:03:44.030 --> 00:03:44.670
<v Speaker 1>degree.

00:03:45.150 --> 00:03:45.710
<v Speaker 1>I

00:03:46.270 --> 00:03:47.550
<v Speaker 1>have been programming

00:03:47.735 --> 00:03:50.375
<v Speaker 1>for since I was, like, 10 or something.

00:03:50.375 --> 00:03:52.375
<v Speaker 1>So I I, like, come from, like, the

00:03:52.375 --> 00:03:53.815
<v Speaker 1>traditional background.

00:03:53.815 --> 00:03:55.975
<v Speaker 1>But then when I went into the industry

00:03:55.975 --> 00:03:58.055
<v Speaker 1>and started working with people who come from

00:03:58.055 --> 00:04:00.775
<v Speaker 1>different backgrounds and saw how they saw things

00:04:00.775 --> 00:04:02.295
<v Speaker 1>and explained things differently,

00:04:03.950 --> 00:04:06.750
<v Speaker 1>And it was sometimes a lot more digestible,

00:04:06.750 --> 00:04:08.350
<v Speaker 1>a lot more understandable the way that they're

00:04:08.350 --> 00:04:10.990
<v Speaker 1>approaching things. I wanted to try and, like,

00:04:10.990 --> 00:04:14.270
<v Speaker 1>join those two things together, like, bring

00:04:14.590 --> 00:04:16.750
<v Speaker 1>all of the the knowledge and interest I

00:04:16.750 --> 00:04:19.105
<v Speaker 1>had from, like, low level concepts, from my

00:04:19.105 --> 00:04:20.385
<v Speaker 1>experience with compilers,

00:04:20.385 --> 00:04:22.145
<v Speaker 1>and from from my degree and things like

00:04:22.145 --> 00:04:22.625
<v Speaker 1>that,

00:04:22.945 --> 00:04:25.665
<v Speaker 1>and take different approaches to to trying to

00:04:25.665 --> 00:04:28.705
<v Speaker 1>explain these, like explaining with household objects and

00:04:28.705 --> 00:04:30.625
<v Speaker 1>my cats and whatever I happen to to

00:04:30.625 --> 00:04:32.870
<v Speaker 1>have around. So that's Yeah. The odd child

00:04:32.870 --> 00:04:34.390
<v Speaker 1>toy, I think, has popped up there and

00:04:34.390 --> 00:04:35.990
<v Speaker 0>again as well. Yeah. Yeah. Yeah. Yeah. I

00:04:35.990 --> 00:04:38.710
<v Speaker 1>explained hash tables with my my kid and

00:04:38.710 --> 00:04:40.550
<v Speaker 1>some teddies, and the the hash function is

00:04:40.550 --> 00:04:42.070
<v Speaker 1>how cute the teddies are.

00:04:43.590 --> 00:04:45.750
<v Speaker 0>Awesome. Which is a terrible hash function.

00:04:47.235 --> 00:04:49.795
<v Speaker 0>It makes it fun and entertaining. We'll learn

00:04:49.795 --> 00:04:51.395
<v Speaker 0>on these concepts. You know, I think you'll

00:04:51.395 --> 00:04:53.395
<v Speaker 0>do a lot of credit for producing this

00:04:53.395 --> 00:04:55.395
<v Speaker 0>content and material. It's a it's a joy

00:04:55.395 --> 00:04:56.115
<v Speaker 0>to watch.

00:04:57.235 --> 00:04:59.315
<v Speaker 0>Okay. Now you've got your biggest challenge of

00:04:59.315 --> 00:05:01.715
<v Speaker 0>all which is to introduce me to c

00:05:01.715 --> 00:05:03.950
<v Speaker 0>plus plus a language that I haven't played

00:05:03.950 --> 00:05:05.710
<v Speaker 0>with in in many many years.

00:05:06.190 --> 00:05:07.630
<v Speaker 0>But I wanna I'm gonna give a shout

00:05:07.630 --> 00:05:10.030
<v Speaker 0>out to one of my former colleagues, Stuart,

00:05:10.030 --> 00:05:12.270
<v Speaker 0>who works at Influx Data. He kept telling

00:05:12.270 --> 00:05:14.190
<v Speaker 0>me for years now, go and look back

00:05:14.190 --> 00:05:15.870
<v Speaker 0>at c plus plus because it's not the

00:05:15.870 --> 00:05:17.710
<v Speaker 0>c plus plus that I'll remember. Like,

00:05:18.565 --> 00:05:20.325
<v Speaker 0>he had many good things to say about

00:05:20.325 --> 00:05:22.085
<v Speaker 0>the evolution of the language. I think you

00:05:22.085 --> 00:05:23.765
<v Speaker 0>just mentioned that version

00:05:23.765 --> 00:05:25.605
<v Speaker 0>c plus plus 23 is now a thing.

00:05:25.605 --> 00:05:26.565
<v Speaker 0>So like,

00:05:27.045 --> 00:05:29.205
<v Speaker 0>I'm curious and excited to see some of

00:05:29.205 --> 00:05:30.885
<v Speaker 0>these new constructs in the language and and

00:05:30.885 --> 00:05:32.325
<v Speaker 0>how they're gonna

00:05:33.125 --> 00:05:33.925
<v Speaker 0>hopefully

00:05:34.460 --> 00:05:36.300
<v Speaker 0>improve it to me. I think my image

00:05:36.300 --> 00:05:37.980
<v Speaker 0>of c plus plus back, you know, and

00:05:37.980 --> 00:05:39.740
<v Speaker 0>let me clarify. This has come back at

00:05:39.740 --> 00:05:42.060
<v Speaker 0>least fifteen years, think. So to me, it

00:05:42.060 --> 00:05:44.140
<v Speaker 0>was the difficult language. Having only ever done

00:05:44.140 --> 00:05:45.340
<v Speaker 0>Perl and c at the time,

00:05:46.155 --> 00:05:48.315
<v Speaker 0>I think now, hopefully, with my experience, it's

00:05:48.315 --> 00:05:50.155
<v Speaker 0>gonna be a lot more familiar and easier.

00:05:50.395 --> 00:05:52.235
<v Speaker 0>But he's always had said really good things

00:05:52.235 --> 00:05:53.915
<v Speaker 0>about modern versions of it, so I'm excited

00:05:53.915 --> 00:05:54.955
<v Speaker 0>to learn that today.

00:05:56.395 --> 00:05:57.835
<v Speaker 0>Okay. Let's

00:05:57.995 --> 00:05:59.755
<v Speaker 0>jump over to my screen share.

00:06:01.010 --> 00:06:02.290
<v Speaker 0>We are using

00:06:02.450 --> 00:06:03.330
<v Speaker 0>Exorcism

00:06:03.330 --> 00:06:05.890
<v Speaker 0>today. Are you familiar with Exorcism at all?

00:06:06.050 --> 00:06:08.130
<v Speaker 1>No. I had, like, a brief look,

00:06:08.610 --> 00:06:10.210
<v Speaker 1>but, yeah, I've never used it before.

00:06:10.850 --> 00:06:13.730
<v Speaker 0>Yeah. It's a a really cool project that

00:06:13.730 --> 00:06:15.730
<v Speaker 0>has, like, language tracks. In fact, let me

00:06:15.730 --> 00:06:18.345
<v Speaker 0>just quickly do the thirty second pitch but

00:06:18.425 --> 00:06:20.505
<v Speaker 0>It has language tracks. A lot of tracks.

00:06:21.145 --> 00:06:23.224
<v Speaker 0>Yeah. It says here showing 50 and I'm

00:06:23.224 --> 00:06:24.185
<v Speaker 0>assuming there's maybe Yeah.

00:06:25.305 --> 00:06:27.465
<v Speaker 1>I love the x 64 assembly

00:06:25.784 --> 00:06:26.185
<v Speaker 0>I

00:06:28.264 --> 00:06:30.025
<v Speaker 1>kinda wanna do that one. I haven't done

00:06:30.139 --> 00:06:32.940
<v Speaker 0>that much x 64 in a while. That

00:06:32.940 --> 00:06:33.820
<v Speaker 0>would be cool.

00:06:34.300 --> 00:06:36.460
<v Speaker 0>Yeah. It's it's it's a nice website for

00:06:36.460 --> 00:06:38.139
<v Speaker 0>picking up on your language. It kinda guides

00:06:38.139 --> 00:06:40.540
<v Speaker 0>you through a bunch of different problems

00:06:41.180 --> 00:06:43.580
<v Speaker 0>that start with like really easy things like

00:06:43.580 --> 00:06:46.835
<v Speaker 0>hello world and simple challenges which normally involve

00:06:46.835 --> 00:06:48.995
<v Speaker 0>working out leap years, etcetera, but then they

00:06:48.995 --> 00:06:51.235
<v Speaker 0>go down to more difficult things. And that

00:06:51.235 --> 00:06:53.955
<v Speaker 0>kind of guide through the language would be

00:06:53.955 --> 00:06:55.315
<v Speaker 0>cool enough on its own.

00:06:55.635 --> 00:06:57.155
<v Speaker 0>But you'll see here it also says there's

00:06:57.155 --> 00:06:59.155
<v Speaker 0>mentors. And all that means is that when

00:06:59.155 --> 00:06:59.795
<v Speaker 0>you submit

00:07:00.230 --> 00:07:03.110
<v Speaker 0>your solutions to problems is that the mentors

00:07:03.110 --> 00:07:05.030
<v Speaker 0>generally review them and give you feedback on

00:07:05.030 --> 00:07:06.630
<v Speaker 0>how you can write more idiomatic code in

00:07:06.630 --> 00:07:08.950
<v Speaker 0>that language. So it's a really Yeah. Interactive

00:07:08.950 --> 00:07:10.230
<v Speaker 0>way of learning as well.

00:07:10.870 --> 00:07:13.030
<v Speaker 1>Yeah. I think that's really, like, valuable thing

00:07:13.030 --> 00:07:14.790
<v Speaker 1>as well because there's there's getting the right

00:07:14.790 --> 00:07:15.110
<v Speaker 1>answer,

00:07:15.655 --> 00:07:17.975
<v Speaker 1>and then there's having a solution which is,

00:07:17.975 --> 00:07:21.415
<v Speaker 1>like, actually edematic and maintainable and performant,

00:07:21.415 --> 00:07:24.935
<v Speaker 1>and those can look very different. So, yeah,

00:07:24.935 --> 00:07:26.775
<v Speaker 1>having that mentorship on top sounds like a

00:07:26.775 --> 00:07:27.255
<v Speaker 1>really good thing.

00:07:28.150 --> 00:07:29.030
<v Speaker 0>Awesome.

00:07:29.669 --> 00:07:32.630
<v Speaker 0>Well, I think we should start with hello

00:07:32.630 --> 00:07:34.229
<v Speaker 0>world. I think it would be rude not

00:07:34.229 --> 00:07:34.790
<v Speaker 0>to.

00:07:35.190 --> 00:07:38.310
<v Speaker 1>That's good. I have a local directory here

00:07:38.310 --> 00:07:41.350
<v Speaker 0>where I've already downloaded the hello world example.

00:07:41.830 --> 00:07:43.590
<v Speaker 0>I have my Versus code open,

00:07:44.275 --> 00:07:46.035
<v Speaker 0>and I've got the basic files here that

00:07:46.035 --> 00:07:47.395
<v Speaker 0>we need to get started.

00:07:48.595 --> 00:07:51.635
<v Speaker 0>So let's open the README. Probably a good

00:07:51.635 --> 00:07:52.515
<v Speaker 0>place to start.

00:07:53.635 --> 00:07:55.875
<v Speaker 0>So our objectives here, and I like that

00:07:55.875 --> 00:07:56.995
<v Speaker 0>it always kind of lays out what we

00:07:56.995 --> 00:07:59.350
<v Speaker 0>wanna do. The other nice thing about for

00:07:59.350 --> 00:08:00.710
<v Speaker 0>people that aren't familiar with it is they

00:08:00.710 --> 00:08:02.949
<v Speaker 0>provide tests for all of the examples. So

00:08:02.949 --> 00:08:04.310
<v Speaker 0>your goal is actually

00:08:04.470 --> 00:08:06.229
<v Speaker 0>to make the test pass, which means you

00:08:06.229 --> 00:08:08.150
<v Speaker 0>get introduced to testing in the language as

00:08:08.150 --> 00:08:09.990
<v Speaker 0>well as writing code, which I think is

00:08:09.990 --> 00:08:10.389
<v Speaker 0>really important.

00:08:12.045 --> 00:08:14.045
<v Speaker 0>If we pop open our test, I have

00:08:14.045 --> 00:08:15.725
<v Speaker 0>never seen a test in c plus plus

00:08:15.725 --> 00:08:17.405
<v Speaker 0>before, so this is exciting.

00:08:17.805 --> 00:08:21.085
<v Speaker 1>Okay. So this is using the catch two

00:08:21.085 --> 00:08:23.725
<v Speaker 1>testing framework, which is probably

00:08:24.445 --> 00:08:25.645
<v Speaker 1>the most popular

00:08:28.030 --> 00:08:30.590
<v Speaker 1>testing framework for for open source projects right

00:08:30.590 --> 00:08:32.669
<v Speaker 1>now, I would say. It was developed by

00:08:32.669 --> 00:08:33.630
<v Speaker 1>Phil Nash,

00:08:34.910 --> 00:08:36.429
<v Speaker 1>and it's

00:08:36.669 --> 00:08:38.590
<v Speaker 1>yeah. It lets you have these, like, quite

00:08:38.590 --> 00:08:40.190
<v Speaker 1>nice requires

00:08:40.455 --> 00:08:42.295
<v Speaker 1>statements where you just say, I require that

00:08:42.295 --> 00:08:44.775
<v Speaker 1>hello world hello is equal to to hello

00:08:44.775 --> 00:08:47.175
<v Speaker 1>world rather than, like, some other testing frameworks

00:08:47.175 --> 00:08:49.335
<v Speaker 1>where you'd have to say, like, require equals

00:08:49.335 --> 00:08:51.415
<v Speaker 1>or require true or things like that.

00:08:52.455 --> 00:08:53.575
<v Speaker 0>Okay. So

00:08:54.680 --> 00:08:56.280
<v Speaker 0>this makes sense to you then as a

00:08:56.280 --> 00:08:57.160
<v Speaker 0>test case.

00:08:57.400 --> 00:08:59.960
<v Speaker 0>Good. Good. That's good. And is this is

00:08:59.960 --> 00:09:01.560
<v Speaker 0>this the test framework you would use as

00:09:01.560 --> 00:09:03.240
<v Speaker 0>well in in your This is what I

00:09:03.240 --> 00:09:05.240
<v Speaker 1>use for my my open source projects as

00:09:05.240 --> 00:09:07.880
<v Speaker 1>well. Yeah. So that that test case in

00:09:07.880 --> 00:09:09.640
<v Speaker 1>in case is

00:09:10.895 --> 00:09:12.654
<v Speaker 1>this is a test case, and it's called

00:09:12.654 --> 00:09:13.695
<v Speaker 1>test hello.

00:09:14.095 --> 00:09:15.375
<v Speaker 1>In fact, one of the cool things about

00:09:15.375 --> 00:09:17.855
<v Speaker 1>catch is that you don't need to use,

00:09:17.855 --> 00:09:19.135
<v Speaker 1>like, c plus plus,

00:09:19.615 --> 00:09:20.495
<v Speaker 1>identifiers

00:09:20.495 --> 00:09:22.175
<v Speaker 1>for your test case names. You could call

00:09:22.175 --> 00:09:23.375
<v Speaker 1>that test hello as

00:09:23.960 --> 00:09:25.880
<v Speaker 1>as two words if you wanted. You could

00:09:25.880 --> 00:09:27.560
<v Speaker 1>use special characters in there. You can do

00:09:27.560 --> 00:09:29.480
<v Speaker 1>whatever you want. And then you can also

00:09:29.560 --> 00:09:31.640
<v Speaker 1>it also takes a a tag so you

00:09:31.640 --> 00:09:32.360
<v Speaker 1>can, like,

00:09:32.840 --> 00:09:35.320
<v Speaker 1>up your tests into different tags and and,

00:09:35.320 --> 00:09:37.720
<v Speaker 1>like, run large subsets of tests. So you

00:09:37.720 --> 00:09:40.415
<v Speaker 1>want to, like, run only the, like, command

00:09:40.415 --> 00:09:42.255
<v Speaker 1>line driver test or you want to only

00:09:42.255 --> 00:09:43.935
<v Speaker 1>test, like, some part of your application, then

00:09:43.935 --> 00:09:45.215
<v Speaker 1>you can do that with catch. So it's

00:09:45.215 --> 00:09:46.015
<v Speaker 1>it's quite nice.

00:09:46.495 --> 00:09:47.135
<v Speaker 0>Okay.

00:09:47.455 --> 00:09:48.975
<v Speaker 0>Well, I mean, there's one thing that's jumping

00:09:48.975 --> 00:09:50.335
<v Speaker 0>out to me right now that is that

00:09:50.335 --> 00:09:52.415
<v Speaker 0>is confusing me is that at first, I

00:09:52.415 --> 00:09:55.290
<v Speaker 0>thought these were function calls. But I noticed

00:09:55.290 --> 00:09:57.290
<v Speaker 0>that the test case here has then got

00:09:57.290 --> 00:09:59.130
<v Speaker 0>braces after it, which makes me think it's

00:09:59.130 --> 00:10:02.490
<v Speaker 0>maybe not a function call. Right. Exactly. So

00:10:02.890 --> 00:10:04.250
<v Speaker 1>these are macros.

00:10:05.850 --> 00:10:08.170
<v Speaker 1>Macros in c plus plus is

00:10:08.394 --> 00:10:10.475
<v Speaker 1>essentially the same as c macros, if you're

00:10:10.475 --> 00:10:12.154
<v Speaker 1>familiar with them. So they're

00:10:13.274 --> 00:10:15.515
<v Speaker 1>the and the the idiom is to use

00:10:15.675 --> 00:10:17.675
<v Speaker 1>all caps when you when you have a

00:10:17.675 --> 00:10:19.755
<v Speaker 1>macro because macros can do weird things,

00:10:21.149 --> 00:10:23.790
<v Speaker 1>which normal, like, c plus plus functions cannot

00:10:23.790 --> 00:10:26.110
<v Speaker 1>do. So bringing attention to the fact that,

00:10:26.110 --> 00:10:28.029
<v Speaker 1>hey. This is a macro. Pay attention. Something

00:10:28.029 --> 00:10:29.790
<v Speaker 1>weird might be going on is why we

00:10:29.790 --> 00:10:31.070
<v Speaker 1>use case.

00:10:31.470 --> 00:10:33.995
<v Speaker 1>It's like how how Rust uses the the

00:10:33.995 --> 00:10:35.995
<v Speaker 1>exclamation mark or the bang after the macro

00:10:35.995 --> 00:10:38.555
<v Speaker 1>name just to draw attention to, like, hey.

00:10:39.035 --> 00:10:40.555
<v Speaker 1>There may be dragons.

00:10:40.714 --> 00:10:41.355
<v Speaker 1>Yes.

00:10:42.394 --> 00:10:44.075
<v Speaker 0>Okay. That makes a lot of sense then.

00:10:44.075 --> 00:10:45.435
<v Speaker 0>Well, these are macros

00:10:45.595 --> 00:10:47.115
<v Speaker 0>making writing tests easier.

00:10:47.840 --> 00:10:50.160
<v Speaker 1>Yeah. Exactly. I've got one more question. This

00:10:50.160 --> 00:10:52.160
<v Speaker 0>is not really related to the test case

00:10:52.160 --> 00:10:52.800
<v Speaker 0>here, but

00:10:53.280 --> 00:10:55.360
<v Speaker 0>is there now, like, a de facto way

00:10:55.360 --> 00:10:58.080
<v Speaker 0>in c plus plus to pull in libraries?

00:10:58.080 --> 00:10:59.760
<v Speaker 0>Like, is this pulling in a cache library

00:10:59.760 --> 00:11:02.240
<v Speaker 0>through a package manager or something? Or

00:11:03.265 --> 00:11:06.305
<v Speaker 1>That's a very good question. So, basically, we

00:11:06.305 --> 00:11:06.945
<v Speaker 1>are

00:11:09.105 --> 00:11:11.665
<v Speaker 1>so c plus plus was originally standardized in

00:11:11.665 --> 00:11:13.025
<v Speaker 1>1998,

00:11:13.105 --> 00:11:15.024
<v Speaker 1>like, a very, very, very long time ago

00:11:15.024 --> 00:11:15.825
<v Speaker 1>when,

00:11:15.825 --> 00:11:17.584
<v Speaker 1>like, dependency management

00:11:18.740 --> 00:11:20.660
<v Speaker 1>was not a thing which, you know, all

00:11:20.660 --> 00:11:23.460
<v Speaker 1>languages just had, and they had great solutions

00:11:23.460 --> 00:11:26.020
<v Speaker 1>for handling your dependencies and saying what your

00:11:26.020 --> 00:11:28.020
<v Speaker 1>dependencies were and what versions they were and

00:11:28.020 --> 00:11:29.860
<v Speaker 1>things like that. But C plus plus is

00:11:29.860 --> 00:11:32.500
<v Speaker 1>having to to evolve. So there is no

00:11:33.075 --> 00:11:35.315
<v Speaker 1>standard dependency management

00:11:35.315 --> 00:11:35.955
<v Speaker 1>tool,

00:11:36.195 --> 00:11:37.155
<v Speaker 1>nor

00:11:37.315 --> 00:11:39.155
<v Speaker 1>de facto or DigiArray.

00:11:39.795 --> 00:11:41.315
<v Speaker 1>There are a few solutions.

00:11:41.635 --> 00:11:44.755
<v Speaker 1>The two major ones are Conan

00:11:44.835 --> 00:11:46.115
<v Speaker 1>and vcpackage.

00:11:46.115 --> 00:11:47.715
<v Speaker 1>Vcpackage is

00:11:48.590 --> 00:11:50.910
<v Speaker 1>is the the Microsoft one, so it's the

00:11:50.910 --> 00:11:53.310
<v Speaker 1>one that I'm most familiar with. Okay.

00:11:54.430 --> 00:11:55.390
<v Speaker 1>So this,

00:11:55.630 --> 00:11:57.950
<v Speaker 1>I can't tell what this is using

00:11:58.510 --> 00:11:59.310
<v Speaker 1>just

00:11:59.390 --> 00:12:02.625
<v Speaker 1>by okay. It looks like it's literally just

00:12:02.625 --> 00:12:04.705
<v Speaker 1>using the the header only

00:12:05.665 --> 00:12:07.585
<v Speaker 1>version of CAPS. So, yeah, when when you

00:12:07.585 --> 00:12:09.665
<v Speaker 1>when you cloned this directory,

00:12:09.745 --> 00:12:12.545
<v Speaker 1>it just has a copy of the CAPS

00:12:12.545 --> 00:12:14.305
<v Speaker 1>testing framework in it. So it's not using

00:12:14.305 --> 00:12:15.745
<v Speaker 1>any dependency management stuff.

00:12:17.270 --> 00:12:17.910
<v Speaker 0>Okay.

00:12:18.230 --> 00:12:19.750
<v Speaker 0>Well, that that's good to know.

00:12:20.149 --> 00:12:21.990
<v Speaker 0>That makes a lot of sense. But I'm

00:12:21.990 --> 00:12:24.390
<v Speaker 0>keen now that we jump into our hello

00:12:24.390 --> 00:12:26.070
<v Speaker 0>world. Like, we've got the test. I understand

00:12:26.070 --> 00:12:28.630
<v Speaker 0>this. Require is like an assertion and c

00:12:28.630 --> 00:12:30.550
<v Speaker 0>plus or at least in the catch framework.

00:12:31.115 --> 00:12:33.274
<v Speaker 0>We're calling our hello function, and we're expecting

00:12:33.274 --> 00:12:35.755
<v Speaker 0>to get the string hello world back.

00:12:36.315 --> 00:12:36.955
<v Speaker 1>Yep.

00:12:37.274 --> 00:12:38.795
<v Speaker 0>If we look at our code

00:12:39.675 --> 00:12:42.075
<v Speaker 0>okay. This looks a little bit different from

00:12:42.075 --> 00:12:42.954
<v Speaker 0>what I remember.

00:12:44.240 --> 00:12:45.760
<v Speaker 0>So the good thing is I remember they

00:12:45.760 --> 00:12:46.880
<v Speaker 0>include pragma.

00:12:48.079 --> 00:12:49.600
<v Speaker 0>I do not remember

00:12:50.320 --> 00:12:52.560
<v Speaker 0>namespaces or using keywords.

00:12:53.920 --> 00:12:55.920
<v Speaker 1>Cool. Well, I can walk through, I guess,

00:12:55.920 --> 00:12:58.000
<v Speaker 1>from from top to bottom kinda makes sense.

00:12:57.839 --> 00:12:59.865
<v Speaker 1>The very first thing at the top there

00:12:59.865 --> 00:13:02.905
<v Speaker 1>that hash include hello world, this is how

00:13:02.905 --> 00:13:04.025
<v Speaker 1>you bring

00:13:04.265 --> 00:13:06.025
<v Speaker 1>other functions

00:13:06.025 --> 00:13:09.385
<v Speaker 1>or names or or types from other files

00:13:09.385 --> 00:13:10.185
<v Speaker 1>into

00:13:10.345 --> 00:13:13.610
<v Speaker 1>your your current file, essentially. So c plus

00:13:13.610 --> 00:13:15.770
<v Speaker 1>plus, just like c, has,

00:13:16.410 --> 00:13:19.050
<v Speaker 1>things split up into implementation

00:13:19.050 --> 00:13:21.050
<v Speaker 1>files like this one, which is a a

00:13:21.050 --> 00:13:23.850
<v Speaker 1>dot cpp file, and header files, which are

00:13:23.850 --> 00:13:26.250
<v Speaker 1>dot h or sometimes dot h p p

00:13:26.250 --> 00:13:28.975
<v Speaker 1>as well. Different people use different things. But,

00:13:28.975 --> 00:13:32.175
<v Speaker 1>basically, the the header files are a description

00:13:32.415 --> 00:13:35.455
<v Speaker 1>of the types and functions which,

00:13:35.935 --> 00:13:38.655
<v Speaker 1>you can call and use, and then the

00:13:38.655 --> 00:13:40.175
<v Speaker 1>implementation files

00:13:40.415 --> 00:13:43.199
<v Speaker 1>are, you know, the actual implementation of those

00:13:43.199 --> 00:13:45.519
<v Speaker 1>things, what the the actual code does rather

00:13:45.519 --> 00:13:48.079
<v Speaker 1>than how you can use it. So the

00:13:48.240 --> 00:13:51.199
<v Speaker 1>this hash include just brings everything in that

00:13:51.199 --> 00:13:52.720
<v Speaker 1>helloworld.h

00:13:52.959 --> 00:13:55.440
<v Speaker 1>to to make it available in this file,

00:13:55.955 --> 00:13:59.715
<v Speaker 1>and it literally does do textual inclusion. So

00:13:59.715 --> 00:14:01.635
<v Speaker 1>when when you do a hash include, it,

00:14:01.635 --> 00:14:04.035
<v Speaker 1>like, literally takes the entire contents of that

00:14:04.035 --> 00:14:07.155
<v Speaker 1>header file and dumps them into into this

00:14:07.155 --> 00:14:07.795
<v Speaker 1>file.

00:14:09.235 --> 00:14:12.275
<v Speaker 1>There are in c plus plus 20, which

00:14:12.390 --> 00:14:14.149
<v Speaker 1>is the the most recent version of c

00:14:14.149 --> 00:14:16.390
<v Speaker 1>plus plus has a feature called modules,

00:14:16.470 --> 00:14:16.870
<v Speaker 1>which,

00:14:17.990 --> 00:14:19.910
<v Speaker 1>is a more like, if you're familiar with

00:14:19.910 --> 00:14:22.390
<v Speaker 1>modules from from other languages, it'll be a

00:14:22.390 --> 00:14:23.270
<v Speaker 1>little bit more

00:14:24.895 --> 00:14:27.615
<v Speaker 1>more reasonable. It doesn't just dump in entire

00:14:27.855 --> 00:14:30.495
<v Speaker 1>text files. It, like, actually looks at the

00:14:30.495 --> 00:14:33.055
<v Speaker 1>the symbols and names available and exports them

00:14:33.055 --> 00:14:36.015
<v Speaker 1>in in sensible manners. But this is this

00:14:36.015 --> 00:14:38.654
<v Speaker 1>is using the the old style, and I

00:14:38.010 --> 00:14:40.090
<v Speaker 1>I think the version of Clang you're using,

00:14:40.090 --> 00:14:42.490
<v Speaker 1>which is the the compiler, doesn't support modules

00:14:42.490 --> 00:14:44.650
<v Speaker 1>yet. So so we can't use modules. But,

00:14:44.650 --> 00:14:46.410
<v Speaker 1>anyway, modules will make this better.

00:14:46.970 --> 00:14:49.450
<v Speaker 1>Anyway and then the the using namespace std.

00:14:49.450 --> 00:14:52.345
<v Speaker 1>So std or std is the the namespace

00:14:52.345 --> 00:14:54.985
<v Speaker 1>where everything in the standard library lives.

00:14:54.985 --> 00:14:58.185
<v Speaker 1>So std string is the standard library string

00:14:58.185 --> 00:14:59.225
<v Speaker 1>implementation.

00:14:59.225 --> 00:15:01.705
<v Speaker 1>So when you say using namespace std,

00:15:01.945 --> 00:15:02.425
<v Speaker 1>that says,

00:15:03.670 --> 00:15:05.269
<v Speaker 1>okay. If I type

00:15:05.350 --> 00:15:06.070
<v Speaker 1>some,

00:15:06.709 --> 00:15:09.269
<v Speaker 1>unqualified name just like we do later on

00:15:09.269 --> 00:15:11.190
<v Speaker 1>where we say string and we don't say

00:15:11.190 --> 00:15:13.829
<v Speaker 1>std string, we don't say some other namespace

00:15:13.829 --> 00:15:14.470
<v Speaker 1>string,

00:15:15.670 --> 00:15:18.005
<v Speaker 1>if I just say string, then I want

00:15:18.005 --> 00:15:20.725
<v Speaker 1>you to look in the the STD namespace.

00:15:20.725 --> 00:15:23.605
<v Speaker 1>It's basically a way of stopping you having

00:15:23.605 --> 00:15:24.405
<v Speaker 1>to type

00:15:25.205 --> 00:15:26.325
<v Speaker 1>the namespace.

00:15:26.565 --> 00:15:28.325
<v Speaker 1>I will say that it's

00:15:29.605 --> 00:15:33.180
<v Speaker 1>probably not that idiomatic to using namespace std.

00:15:33.900 --> 00:15:35.580
<v Speaker 1>Some people do do it, but,

00:15:36.140 --> 00:15:38.060
<v Speaker 1>generally, I like to make it obvious when

00:15:38.060 --> 00:15:40.620
<v Speaker 1>I'm using something from the the standard library

00:15:41.180 --> 00:15:42.940
<v Speaker 0>Sorry. I guess it's to my own code.

00:15:43.340 --> 00:15:45.020
<v Speaker 0>Idiomatic to maybe just do this and not

00:15:45.020 --> 00:15:45.820
<v Speaker 0>pull in std?

00:15:46.485 --> 00:15:48.485
<v Speaker 1>Yeah. That's that's what I would prefer to

00:15:48.485 --> 00:15:50.805
<v Speaker 1>do, but it's you can do either. The

00:15:50.805 --> 00:15:53.045
<v Speaker 1>the main thing is to not write, like,

00:15:53.045 --> 00:15:55.845
<v Speaker 1>using namespaces in the header file because then

00:15:55.925 --> 00:15:58.565
<v Speaker 1>that will get copied into everyone else's files,

00:15:58.565 --> 00:15:59.845
<v Speaker 1>and now you're, like,

00:16:00.720 --> 00:16:02.959
<v Speaker 1>looking for standard library names when you maybe

00:16:02.959 --> 00:16:04.080
<v Speaker 1>didn't want to.

00:16:04.639 --> 00:16:06.399
<v Speaker 1>You know? In fact, I just noticed this

00:16:06.399 --> 00:16:08.240
<v Speaker 0>comment here, which is actually telling us that

00:16:08.240 --> 00:16:08.800
<v Speaker 0>we could Absolutely.

00:16:09.360 --> 00:16:10.800
<v Speaker 0>Yeah. Do that as well. Okay.

00:16:12.240 --> 00:16:14.595
<v Speaker 1>So that's when we say when we say

00:16:14.595 --> 00:16:14.995
<v Speaker 1>names

00:16:16.675 --> 00:16:18.675
<v Speaker 1>on line five now, when we say namespace

00:16:18.675 --> 00:16:21.715
<v Speaker 1>hello world, this is defining our own namespace.

00:16:21.715 --> 00:16:22.195
<v Speaker 1>So

00:16:23.235 --> 00:16:25.475
<v Speaker 1>everything in the standard library lives in the

00:16:25.475 --> 00:16:27.839
<v Speaker 1>std namespace. Now we are saying, okay. Everything

00:16:27.839 --> 00:16:30.399
<v Speaker 1>inside these braces is inside the hello world

00:16:30.399 --> 00:16:31.200
<v Speaker 1>namespace.

00:16:31.200 --> 00:16:32.800
<v Speaker 1>So this is just a way of, like,

00:16:33.440 --> 00:16:36.480
<v Speaker 1>qualifying names so that, you know, if I

00:16:36.480 --> 00:16:39.120
<v Speaker 1>have a function called hello and I include

00:16:39.120 --> 00:16:41.600
<v Speaker 1>some other library which has a hello function

00:16:41.600 --> 00:16:43.735
<v Speaker 1>that they don't conflict with each other.

00:16:45.574 --> 00:16:46.855
<v Speaker 0>Is that mandatory?

00:16:47.574 --> 00:16:49.894
<v Speaker 1>Nope. So you could just completely get rid

00:16:49.894 --> 00:16:52.535
<v Speaker 1>of namespace hello world and the,

00:16:53.175 --> 00:16:54.935
<v Speaker 1>the closing brace at the end, and you

00:16:54.935 --> 00:16:56.615
<v Speaker 1>would just have a an unqualified

00:16:57.899 --> 00:17:01.020
<v Speaker 1>hello function, which lives in the global namespace.

00:17:01.020 --> 00:17:01.580
<v Speaker 0>Oh, okay.

00:17:02.540 --> 00:17:04.300
<v Speaker 1>So you can do that, but you shouldn't

00:17:04.300 --> 00:17:06.859
<v Speaker 1>because then if someone else does that, then

00:17:07.020 --> 00:17:10.940
<v Speaker 1>everything goes horribly wrong. Plus our test does

00:17:10.174 --> 00:17:12.974
<v Speaker 0>seem to fully qualify it here. So Yeah.

00:17:12.974 --> 00:17:14.414
<v Speaker 0>I guess I should And the test could

00:17:15.294 --> 00:17:17.214
<v Speaker 1>just like we had earlier, the test could

00:17:17.214 --> 00:17:20.095
<v Speaker 1>say using namespace hello world, and that would

00:17:20.095 --> 00:17:21.694
<v Speaker 1>be a very, very reasonable thing to do

00:17:21.694 --> 00:17:24.335
<v Speaker 1>in your in your test suite. If you're

00:17:23.539 --> 00:17:25.140
<v Speaker 1>gonna be using all the names from your

00:17:25.140 --> 00:17:27.219
<v Speaker 1>own, library anyway, then,

00:17:27.859 --> 00:17:30.179
<v Speaker 1>then you could just write a names using

00:17:30.179 --> 00:17:31.539
<v Speaker 1>declaration like that.

00:17:32.899 --> 00:17:35.460
<v Speaker 0>Okay. Awesome. That's great context.

00:17:35.715 --> 00:17:37.875
<v Speaker 0>I'm gonna make a wild assumption right now

00:17:37.875 --> 00:17:39.635
<v Speaker 0>that just changing this to hello world is

00:17:39.635 --> 00:17:41.234
<v Speaker 0>probably gonna pass my test.

00:17:41.635 --> 00:17:43.875
<v Speaker 0>Yep. Can we walk through the process then

00:17:43.875 --> 00:17:45.715
<v Speaker 0>of confirming that? And then we do have

00:17:45.715 --> 00:17:47.075
<v Speaker 0>a couple of questions on the chat that

00:17:47.075 --> 00:17:48.674
<v Speaker 0>I'll get to in minute just a minute,

00:17:48.674 --> 00:17:49.874
<v Speaker 0>Daniel and Kai.

00:17:50.355 --> 00:17:51.154
<v Speaker 0>So Sure.

00:17:53.210 --> 00:17:56.009
<v Speaker 0>I've modified this. I think my test is

00:17:56.009 --> 00:17:57.850
<v Speaker 0>good. I'm assuming I jump to the command

00:17:57.850 --> 00:17:58.489
<v Speaker 0>line,

00:17:58.730 --> 00:18:00.169
<v Speaker 0>go into the directory,

00:18:00.649 --> 00:18:02.089
<v Speaker 0>I'm presented with

00:18:02.809 --> 00:18:05.049
<v Speaker 0>a CMIC list dot text, which I'm not

00:18:05.049 --> 00:18:07.075
<v Speaker 0>entirely sure what that is. I'm sure I

00:18:07.075 --> 00:18:08.915
<v Speaker 0>could read the read me, but do you

00:18:08.915 --> 00:18:10.835
<v Speaker 0>wanna just give us the TLDR on building

00:18:10.835 --> 00:18:11.635
<v Speaker 0>this thing?

00:18:12.035 --> 00:18:14.915
<v Speaker 1>Sure. So just like with

00:18:15.555 --> 00:18:18.515
<v Speaker 1>with dependency management, there is no standard build

00:18:18.515 --> 00:18:22.115
<v Speaker 1>system for c plus plus. However, CMake is

00:18:22.279 --> 00:18:24.200
<v Speaker 1>essentially the de facto

00:18:24.360 --> 00:18:26.200
<v Speaker 1>build system nowadays.

00:18:26.200 --> 00:18:28.360
<v Speaker 1>It's what most c plus plus projects use

00:18:28.360 --> 00:18:29.239
<v Speaker 1>for building.

00:18:30.200 --> 00:18:31.719
<v Speaker 1>So it's essentially a

00:18:31.880 --> 00:18:34.039
<v Speaker 1>it's its own language. So if you if

00:18:34.039 --> 00:18:36.360
<v Speaker 1>you, like, look at the CMakelists.TXT,

00:18:37.375 --> 00:18:39.775
<v Speaker 1>that's a description of how to build your

00:18:39.775 --> 00:18:41.855
<v Speaker 1>project, and it's written in

00:18:42.095 --> 00:18:43.855
<v Speaker 1>the CMake language.

00:18:44.095 --> 00:18:46.174
<v Speaker 1>So we have things like,

00:18:46.895 --> 00:18:49.375
<v Speaker 1>yeah, this add executable command

00:18:50.780 --> 00:18:51.820
<v Speaker 1>that is

00:18:52.140 --> 00:18:55.500
<v Speaker 1>saying how to build the the executable for

00:18:55.500 --> 00:18:56.539
<v Speaker 1>our project.

00:18:56.620 --> 00:18:58.540
<v Speaker 1>And you can see further down where it

00:18:58.540 --> 00:19:00.540
<v Speaker 1>says set target properties. That's saying, oh, we

00:19:00.540 --> 00:19:02.860
<v Speaker 1>want to use c plus plus 14 as

00:19:02.860 --> 00:19:03.260
<v Speaker 1>our

00:19:03.835 --> 00:19:05.835
<v Speaker 1>as our version of the standard, and we

00:19:05.835 --> 00:19:06.795
<v Speaker 1>don't want

00:19:07.195 --> 00:19:07.995
<v Speaker 1>any

00:19:08.395 --> 00:19:09.515
<v Speaker 1>extensions,

00:19:09.675 --> 00:19:10.155
<v Speaker 1>like,

00:19:10.555 --> 00:19:13.915
<v Speaker 1>we have compiler extensions from Clang or GCC

00:19:13.915 --> 00:19:17.195
<v Speaker 1>or whatever compiler you're using. So Is CXX

00:19:17.195 --> 00:19:19.380
<v Speaker 0>the way to that always mean c plus

00:19:19.380 --> 00:19:23.220
<v Speaker 0>plus rather than CPP? Yes. Alright. CXX is

00:19:23.620 --> 00:19:25.780
<v Speaker 1>the way that the it's the the the

00:19:25.780 --> 00:19:28.500
<v Speaker 1>term that that CMake uses, which is

00:19:29.860 --> 00:19:32.340
<v Speaker 1>what, like, Auto Tools used as well, if

00:19:32.340 --> 00:19:33.700
<v Speaker 1>you ever used Auto Tools

00:19:34.525 --> 00:19:35.965
<v Speaker 1>back in the dark ages.

00:19:37.085 --> 00:19:38.365
<v Speaker 0>It's quite a lot

00:19:39.165 --> 00:19:40.605
<v Speaker 0>to build Hello World.

00:19:41.485 --> 00:19:43.725
<v Speaker 1>Yeah. This is not, like, all

00:19:45.565 --> 00:19:47.325
<v Speaker 1>like, if you wanted to have an absolutely

00:19:47.325 --> 00:19:49.890
<v Speaker 1>minimal thing, all it would literally need is

00:19:49.890 --> 00:19:50.930
<v Speaker 1>a minimum

00:19:51.730 --> 00:19:52.850
<v Speaker 1>CMake version

00:19:53.090 --> 00:19:53.890
<v Speaker 1>and

00:19:55.330 --> 00:19:56.370
<v Speaker 1>and project

00:19:57.570 --> 00:19:59.970
<v Speaker 1>specifier and an add executable. Like, this whole

00:19:59.970 --> 00:20:02.414
<v Speaker 1>thing could be three lines if Alright. They

00:20:02.414 --> 00:20:03.934
<v Speaker 1>wanted it to be, but they're probably doing

00:20:03.934 --> 00:20:05.854
<v Speaker 1>other things. You know, like, they've got stuff

00:20:05.855 --> 00:20:07.855
<v Speaker 1>stuff to run the tests later on and

00:20:07.855 --> 00:20:10.255
<v Speaker 1>and whatnot. So Yeah. I I guess this

00:20:10.255 --> 00:20:11.615
<v Speaker 0>is just one of those things that as

00:20:11.615 --> 00:20:13.695
<v Speaker 0>you start to work with more c plus

00:20:13.695 --> 00:20:15.615
<v Speaker 0>plus and get more acquainted with the tooling

00:20:15.615 --> 00:20:17.520
<v Speaker 0>and stuff, it all becomes a lot familiar,

00:20:17.520 --> 00:20:19.280
<v Speaker 0>I guess, like any other language.

00:20:21.680 --> 00:20:23.840
<v Speaker 1>So So if we want to build this,

00:20:23.920 --> 00:20:25.680
<v Speaker 1>then the the usual thing you would do

00:20:25.680 --> 00:20:27.360
<v Speaker 1>is you'd make a directory called build,

00:20:30.385 --> 00:20:32.545
<v Speaker 1>and then change dir into there and then

00:20:32.545 --> 00:20:34.145
<v Speaker 1>run CMakespace.

00:20:34.145 --> 00:20:34.705
<v Speaker 1>Dot.

00:20:36.865 --> 00:20:39.425
<v Speaker 1>Yep. So CMake is a

00:20:39.825 --> 00:20:42.945
<v Speaker 1>it's not actually a build system. CMake is

00:20:42.590 --> 00:20:45.230
<v Speaker 1>a meta build system, which sounds kinda weird.

00:20:45.230 --> 00:20:47.790
<v Speaker 1>But, basically, it's a because there's so many

00:20:47.790 --> 00:20:50.269
<v Speaker 1>different ways to build code in,

00:20:50.830 --> 00:20:53.149
<v Speaker 1>you know, in Windows or in Linux or

00:20:53.150 --> 00:20:55.550
<v Speaker 1>Mac or BSD or whatever you're using,

00:20:57.125 --> 00:20:58.885
<v Speaker 1>CMake generates

00:21:00.565 --> 00:21:02.805
<v Speaker 1>a build system for you. So if you

00:21:02.805 --> 00:21:03.285
<v Speaker 1>use,

00:21:03.685 --> 00:21:06.485
<v Speaker 1>like, Visual Studio, then CMake could generate a

00:21:06.485 --> 00:21:08.325
<v Speaker 1>a Visual Studio solution. Here, you can see

00:21:08.325 --> 00:21:09.605
<v Speaker 1>it's generated a Makefile.

00:21:10.540 --> 00:21:11.419
<v Speaker 1>Nowadays,

00:21:11.420 --> 00:21:13.820
<v Speaker 1>most a lot of people use Ninja, which

00:21:13.820 --> 00:21:15.820
<v Speaker 1>is another build system.

00:21:17.900 --> 00:21:19.900
<v Speaker 1>So, yeah, this is the the Makefile which

00:21:19.900 --> 00:21:21.740
<v Speaker 1>is generated for you. So now if you

00:21:21.740 --> 00:21:23.820
<v Speaker 1>run Make, then it will build your project.

00:21:24.045 --> 00:21:26.365
<v Speaker 0>I know make. That's that's something.

00:21:26.845 --> 00:21:27.485
<v Speaker 1>Yeah.

00:21:27.885 --> 00:21:31.165
<v Speaker 0>Alright. And you can also run c make

00:21:31.405 --> 00:21:34.125
<v Speaker 1>dash dash build dot, which

00:21:34.925 --> 00:21:37.725
<v Speaker 1>will will do your build step regardless of

00:21:37.725 --> 00:21:38.925
<v Speaker 1>what generator

00:21:38.925 --> 00:21:39.565
<v Speaker 1>you're targeting.

00:21:40.140 --> 00:21:43.260
<v Speaker 1>We had a capital letter mismatch.

00:21:44.540 --> 00:21:46.780
<v Speaker 0>I broke my code already. Alright. So we

00:21:46.780 --> 00:21:48.059
<v Speaker 0>could change that back.

00:21:48.460 --> 00:21:50.140
<v Speaker 1>Well, we're changing the test instead of the

00:21:50.140 --> 00:21:52.060
<v Speaker 1>code. What did I? Yeah.

00:21:54.125 --> 00:21:55.965
<v Speaker 0>Is that not no. Of course not. Right.

00:21:55.965 --> 00:21:57.485
<v Speaker 0>Okay. That's

00:21:57.485 --> 00:21:58.765
<v Speaker 1>what I do if my code doesn't work.

00:21:58.765 --> 00:22:00.845
<v Speaker 1>I just change the test until it pass.

00:22:03.725 --> 00:22:06.605
<v Speaker 0>There we go. Yay. A testy hello world.

00:22:06.605 --> 00:22:07.725
<v Speaker 0>Heard you that

00:22:08.210 --> 00:22:10.290
<v Speaker 1>oh, no. That did run run the test

00:22:10.290 --> 00:22:12.529
<v Speaker 1>as well. Yeah. Because the the CMake lists,

00:22:14.850 --> 00:22:17.170
<v Speaker 1>yeah, had a a target which ran the

00:22:17.170 --> 00:22:19.490
<v Speaker 1>tests for you. So nice.

00:22:19.730 --> 00:22:21.970
<v Speaker 0>Yeah. So our default target here runs all.

00:22:24.055 --> 00:22:25.735
<v Speaker 1>Yeah. Generally, you don't wanna look at the

00:22:25.735 --> 00:22:26.935
<v Speaker 1>make file that

00:22:27.175 --> 00:22:28.695
<v Speaker 1>generated,

00:22:28.855 --> 00:22:30.855
<v Speaker 1>but you can if you want and it's

00:22:30.855 --> 00:22:32.535
<v Speaker 1>just it's it's not pretty.

00:22:33.335 --> 00:22:35.175
<v Speaker 0>I know. We let's not do that. I'm

00:22:35.175 --> 00:22:37.015
<v Speaker 0>more interested in the language itself,

00:22:37.580 --> 00:22:39.100
<v Speaker 0>and we'll touch on bits of the tooling

00:22:39.100 --> 00:22:41.500
<v Speaker 0>as as needed. But so far, so good.

00:22:41.500 --> 00:22:42.700
<v Speaker 0>It's

00:22:42.700 --> 00:22:44.380
<v Speaker 0>all starting to come together. It's probably a

00:22:44.380 --> 00:22:46.380
<v Speaker 0>good picture in my head. Hopefully, also for

00:22:46.380 --> 00:22:48.460
<v Speaker 0>the audience too. But I'm gonna So that's

00:22:48.460 --> 00:22:50.635
<v Speaker 1>how you'd use CMake list from the the

00:22:50.635 --> 00:22:51.835
<v Speaker 1>command line. Also,

00:22:52.315 --> 00:22:53.914
<v Speaker 1>Visual Studio Code has

00:22:54.235 --> 00:22:55.434
<v Speaker 1>CMake

00:22:55.835 --> 00:22:59.115
<v Speaker 1>extension as well, which makes it that you

00:22:59.115 --> 00:23:00.794
<v Speaker 1>can just build from from

00:23:01.195 --> 00:23:02.795
<v Speaker 1>from within Visual Studio Code.

00:23:03.360 --> 00:23:04.559
<v Speaker 0>Oh, cool.

00:23:06.240 --> 00:23:07.920
<v Speaker 0>Yeah. I I don't need to think that

00:23:07.920 --> 00:23:10.559
<v Speaker 0>right now. Let me read out these questions

00:23:10.559 --> 00:23:12.480
<v Speaker 0>for you. I'll let you tackle them in

00:23:12.480 --> 00:23:14.480
<v Speaker 0>whatever order you want, and then I'll get

00:23:14.480 --> 00:23:15.760
<v Speaker 0>the next exercise ready.

00:23:16.465 --> 00:23:19.424
<v Speaker 0>So Kai starts off with a, hopefully, a

00:23:19.424 --> 00:23:21.184
<v Speaker 0>nice simple one, but Kai is curious of

00:23:21.184 --> 00:23:23.424
<v Speaker 0>how do namespaces differ from classes.

00:23:24.384 --> 00:23:26.384
<v Speaker 1>Yeah. So Sorry. Oh, yeah. You go for

00:23:26.384 --> 00:23:27.345
<v Speaker 0>that, and then we'll come back to you,

00:23:27.264 --> 00:23:27.985
<v Speaker 1>Go for this one.

00:23:28.960 --> 00:23:32.880
<v Speaker 1>So a namespace is just a way to

00:23:35.600 --> 00:23:37.840
<v Speaker 1>split functions and classes

00:23:38.160 --> 00:23:39.120
<v Speaker 1>into

00:23:39.120 --> 00:23:40.000
<v Speaker 1>digestible

00:23:40.000 --> 00:23:42.720
<v Speaker 1>units in a way which they don't the

00:23:42.720 --> 00:23:44.794
<v Speaker 1>names do not conflict with each other. You

00:23:44.794 --> 00:23:45.835
<v Speaker 1>cannot have,

00:23:48.475 --> 00:23:51.434
<v Speaker 1>like, an object which represents a namespace. Like,

00:23:51.434 --> 00:23:52.554
<v Speaker 1>you can't create,

00:23:53.195 --> 00:23:56.075
<v Speaker 1>an instance of our hello world namespace. You

00:23:56.075 --> 00:23:58.235
<v Speaker 1>cannot pass them around or do anything like

00:23:58.235 --> 00:24:01.029
<v Speaker 1>that. It's just essentially a prefix

00:24:01.029 --> 00:24:01.589
<v Speaker 1>to,

00:24:02.309 --> 00:24:05.909
<v Speaker 1>any names which are inside those blocks. So

00:24:05.909 --> 00:24:07.669
<v Speaker 1>whereas classes, you can,

00:24:08.070 --> 00:24:09.830
<v Speaker 1>create an instance of one. You can pass

00:24:09.830 --> 00:24:11.909
<v Speaker 1>one around. You can give it

00:24:12.695 --> 00:24:14.855
<v Speaker 1>data members. You can give it

00:24:15.495 --> 00:24:17.415
<v Speaker 1>functions which you can call on instances of

00:24:17.415 --> 00:24:21.174
<v Speaker 1>that class. Namespaces are just named prefixes, essentially.

00:24:21.415 --> 00:24:23.255
<v Speaker 0>I guess if we were to correlate that

00:24:23.255 --> 00:24:25.095
<v Speaker 0>to Go, which I think Kai has a

00:24:25.095 --> 00:24:28.160
<v Speaker 0>a better familiarity with, then namespaces would be

00:24:28.160 --> 00:24:31.600
<v Speaker 0>like packages and classes would be like structs,

00:24:31.600 --> 00:24:33.680
<v Speaker 0>which also happen to have methods on them

00:24:33.680 --> 00:24:36.000
<v Speaker 0>as well. I think Sure. I don't really

00:24:36.000 --> 00:24:37.040
<v Speaker 1>know go, but that's interesting.

00:24:38.865 --> 00:24:41.265
<v Speaker 0>Alright. Daniel seems to be jumping straight into

00:24:41.265 --> 00:24:42.865
<v Speaker 0>the deep end, I'm afraid, with his first

00:24:42.865 --> 00:24:44.384
<v Speaker 0>question. But Mhmm.

00:24:44.625 --> 00:24:45.825
<v Speaker 0>He's saying a lot of folks in the

00:24:45.825 --> 00:24:47.985
<v Speaker 0>cloud native community are just a Go

00:24:48.465 --> 00:24:52.420
<v Speaker 0>Mhmm. Which, unless you're using GCC Go, pretty

00:24:52.420 --> 00:24:53.779
<v Speaker 0>much has one compiler.

00:24:54.100 --> 00:24:55.540
<v Speaker 0>Can you maybe talk about some of the

00:24:55.540 --> 00:24:57.140
<v Speaker 0>trade offs of the various c plus plus

00:24:57.140 --> 00:24:57.940
<v Speaker 0>compilers?

00:24:58.260 --> 00:24:59.059
<v Speaker 1>Absolutely.

00:24:59.140 --> 00:24:59.700
<v Speaker 1>So

00:25:00.020 --> 00:25:00.580
<v Speaker 1>the

00:25:01.140 --> 00:25:02.020
<v Speaker 1>main

00:25:02.020 --> 00:25:04.500
<v Speaker 1>compilers which are available for c plus plus

00:25:04.500 --> 00:25:05.380
<v Speaker 1>are

00:25:06.215 --> 00:25:07.015
<v Speaker 1>Clang,

00:25:07.015 --> 00:25:09.095
<v Speaker 1>which is the compiler which

00:25:09.255 --> 00:25:10.615
<v Speaker 1>OSX uses

00:25:11.655 --> 00:25:14.695
<v Speaker 1>and is also available on Linux and now

00:25:14.695 --> 00:25:15.414
<v Speaker 1>Windows.

00:25:15.655 --> 00:25:17.015
<v Speaker 1>GCC,

00:25:17.015 --> 00:25:18.615
<v Speaker 1>which is the

00:25:19.540 --> 00:25:22.420
<v Speaker 1>the good new c plus plus compiler. So

00:25:22.420 --> 00:25:24.500
<v Speaker 1>it's the the one which is kind of

00:25:24.500 --> 00:25:26.419
<v Speaker 1>the default on most Linux systems.

00:25:26.660 --> 00:25:28.100
<v Speaker 1>MSVC,

00:25:28.420 --> 00:25:29.220
<v Speaker 1>which is the

00:25:31.155 --> 00:25:34.435
<v Speaker 1>the Microsoft c plus plus compiler as that's

00:25:34.435 --> 00:25:36.195
<v Speaker 1>the the team that I'm on at Microsoft.

00:25:36.835 --> 00:25:38.275
<v Speaker 1>And there's also ICC,

00:25:38.275 --> 00:25:40.195
<v Speaker 1>which is the Intel c plus plus compiler,

00:25:40.195 --> 00:25:42.035
<v Speaker 1>but it's not quite as common.

00:25:43.750 --> 00:25:44.389
<v Speaker 1>So

00:25:44.710 --> 00:25:47.830
<v Speaker 1>as far as trade offs and differences between

00:25:47.830 --> 00:25:48.789
<v Speaker 1>them go,

00:25:49.190 --> 00:25:50.950
<v Speaker 1>they're

00:25:50.950 --> 00:25:53.270
<v Speaker 1>all good at different things,

00:25:56.014 --> 00:25:56.734
<v Speaker 1>And

00:25:57.615 --> 00:25:59.614
<v Speaker 1>which you target is

00:26:01.375 --> 00:26:03.534
<v Speaker 1>sometimes related to which platforms you will be

00:26:03.534 --> 00:26:06.495
<v Speaker 1>targeting, Windows, Linux. Quite a lot of projects

00:26:06.495 --> 00:26:08.095
<v Speaker 1>will target multiple compilers.

00:26:08.530 --> 00:26:09.730
<v Speaker 1>So, like, if you're

00:26:10.050 --> 00:26:12.930
<v Speaker 1>if you're building for Windows and Linux, then

00:26:12.930 --> 00:26:15.490
<v Speaker 1>maybe you're you're gonna target MSVC for Windows

00:26:15.490 --> 00:26:18.850
<v Speaker 1>and target GCC or Clang for for Linux.

00:26:18.850 --> 00:26:21.090
<v Speaker 1>If you're writing a generic library, then you

00:26:21.090 --> 00:26:23.684
<v Speaker 1>probably wanna make sure that your code will

00:26:23.684 --> 00:26:24.565
<v Speaker 1>compile

00:26:24.565 --> 00:26:26.404
<v Speaker 1>on all of those platforms.

00:26:27.525 --> 00:26:30.325
<v Speaker 1>If you are targeting just one specific compiler,

00:26:30.325 --> 00:26:31.764
<v Speaker 1>then you can do,

00:26:32.164 --> 00:26:34.085
<v Speaker 1>like, more aggressive optimizations.

00:26:34.085 --> 00:26:36.245
<v Speaker 1>Or even if you're targeting multiple compilers, you

00:26:36.245 --> 00:26:38.880
<v Speaker 1>can write code which will, you know, do

00:26:38.880 --> 00:26:41.840
<v Speaker 1>certain things on with some compilers and use

00:26:42.000 --> 00:26:44.000
<v Speaker 1>certain things on other ones. So there's there's

00:26:44.000 --> 00:26:45.760
<v Speaker 1>a lot of different things you can do.

00:26:47.360 --> 00:26:48.640
<v Speaker 0>Alright. Awesome.

00:26:50.080 --> 00:26:52.240
<v Speaker 0>I didn't realize there were so many compilers.

00:26:52.560 --> 00:26:52.880
<v Speaker 0>Yeah.

00:26:54.375 --> 00:26:55.175
<v Speaker 0>Okay.

00:26:55.175 --> 00:26:57.015
<v Speaker 0>Hopefully that answers your question,

00:26:57.575 --> 00:27:01.495
<v Speaker 0>Dan. Now we have cloned our second

00:27:02.935 --> 00:27:03.815
<v Speaker 0>exorcism

00:27:04.375 --> 00:27:06.375
<v Speaker 0>tutorial challenge. I'm not sure what we call

00:27:06.375 --> 00:27:08.740
<v Speaker 0>them. But it wants us to determine if

00:27:08.740 --> 00:27:11.299
<v Speaker 0>a word or a phrase is an isogram.

00:27:12.260 --> 00:27:14.420
<v Speaker 0>An isogram is a word or a phrase

00:27:14.420 --> 00:27:16.179
<v Speaker 0>without any repeating letter,

00:27:16.500 --> 00:27:18.340
<v Speaker 0>however spaces and hyphens are allowed to appear

00:27:18.340 --> 00:27:19.140
<v Speaker 0>multiple times.

00:27:20.174 --> 00:27:21.695
<v Speaker 0>I did not know what an isogram was

00:27:21.695 --> 00:27:23.934
<v Speaker 0>until three seconds ago. So there we go.

00:27:23.934 --> 00:27:24.494
<v Speaker 1>Yeah.

00:27:24.975 --> 00:27:28.095
<v Speaker 1>So is it wait. Is it adjacent characters

00:27:28.095 --> 00:27:28.975
<v Speaker 1>or is it just

00:27:31.710 --> 00:27:33.549
<v Speaker 1>okay. Now it's Yeah. Think it's Yeah.

00:27:34.429 --> 00:27:36.909
<v Speaker 1>If the the character appears twice

00:27:37.390 --> 00:27:38.429
<v Speaker 1>anywhere

00:27:38.429 --> 00:27:41.630
<v Speaker 1>in the string, then it's not an isogram.

00:27:41.630 --> 00:27:44.270
<v Speaker 0>Okay. Oh, yes. Okay. So, yeah, isograms

00:27:44.270 --> 00:27:45.070
<v Speaker 0>is

00:27:45.245 --> 00:27:47.085
<v Speaker 0>not an isogram because the s is on

00:27:47.085 --> 00:27:48.365
<v Speaker 0>it twice. Okay. So, yeah, we can't have

00:27:48.365 --> 00:27:50.845
<v Speaker 0>any any letter twice in our word or

00:27:50.845 --> 00:27:51.485
<v Speaker 0>phrase.

00:27:51.885 --> 00:27:52.525
<v Speaker 0>Yep.

00:27:52.845 --> 00:27:55.325
<v Speaker 0>So we already have I'm just gonna start

00:27:55.325 --> 00:27:57.565
<v Speaker 0>with the test cases here. We've got empty

00:27:57.565 --> 00:27:59.809
<v Speaker 0>string. That makes sense to start with. And

00:27:59.809 --> 00:28:01.970
<v Speaker 0>we're expecting to get a true value back

00:28:01.970 --> 00:28:03.890
<v Speaker 0>because spaces don't

00:28:03.890 --> 00:28:04.529
<v Speaker 0>count.

00:28:05.809 --> 00:28:07.009
<v Speaker 0>I find it curious

00:28:08.050 --> 00:28:10.610
<v Speaker 0>that they actually define and expect it as

00:28:10.610 --> 00:28:12.290
<v Speaker 0>a billion, and I'm not sure why it's

00:28:12.290 --> 00:28:14.985
<v Speaker 0>got braces for output and then have the

00:28:14.985 --> 00:28:17.145
<v Speaker 0>assertion. Is is that idiomatic?

00:28:17.785 --> 00:28:20.185
<v Speaker 1>No. No? I am kind of confused why

00:28:20.185 --> 00:28:21.465
<v Speaker 1>they did this as well.

00:28:22.665 --> 00:28:24.745
<v Speaker 1>So and and as far as that that

00:28:24.745 --> 00:28:26.830
<v Speaker 1>line 12 goes, that

00:28:26.990 --> 00:28:28.510
<v Speaker 1>so maybe we can talk a little bit

00:28:28.510 --> 00:28:30.990
<v Speaker 1>about about variable declarations

00:28:30.990 --> 00:28:32.190
<v Speaker 1>in general. Yeah.

00:28:32.990 --> 00:28:35.710
<v Speaker 1>So the the variable declarations here on line

00:28:35.710 --> 00:28:37.950
<v Speaker 1>ten and twelve, they both begin with const

00:28:37.950 --> 00:28:40.269
<v Speaker 1>bool. So bool is the boolean type.

00:28:41.015 --> 00:28:44.374
<v Speaker 1>Const says that this is an immutable

00:28:44.855 --> 00:28:49.094
<v Speaker 1>variable. So try changing this will not compile.

00:28:49.095 --> 00:28:51.654
<v Speaker 1>If you do some shenanigans in order to

00:28:51.654 --> 00:28:54.375
<v Speaker 1>get the compiler to accept you changing it,

00:28:54.375 --> 00:28:56.809
<v Speaker 1>then it's undefined behavior,

00:28:56.970 --> 00:28:59.050
<v Speaker 1>and your program may blow up.

00:29:00.330 --> 00:29:00.809
<v Speaker 1>So

00:29:01.370 --> 00:29:03.210
<v Speaker 1>right at the start, we have the type

00:29:03.210 --> 00:29:04.970
<v Speaker 1>of the variable, then we have the name

00:29:04.970 --> 00:29:05.930
<v Speaker 1>of the variable,

00:29:06.250 --> 00:29:08.490
<v Speaker 1>which is actual in case of line 10.

00:29:09.184 --> 00:29:10.304
<v Speaker 1>Then we have,

00:29:10.705 --> 00:29:13.585
<v Speaker 1>the equal sign and an initializer.

00:29:13.585 --> 00:29:14.144
<v Speaker 1>So

00:29:14.705 --> 00:29:18.225
<v Speaker 1>actual will be initialized to the value of,

00:29:19.105 --> 00:29:21.425
<v Speaker 1>returned by the function isogram is isogram.

00:29:22.950 --> 00:29:24.470
<v Speaker 1>Now on line 12,

00:29:24.950 --> 00:29:25.909
<v Speaker 1>this uses

00:29:26.309 --> 00:29:27.910
<v Speaker 1>slightly different syntax

00:29:27.910 --> 00:29:28.629
<v Speaker 1>for,

00:29:29.270 --> 00:29:30.230
<v Speaker 1>declaring

00:29:30.230 --> 00:29:31.269
<v Speaker 1>a variable.

00:29:31.510 --> 00:29:33.429
<v Speaker 1>So this is valid.

00:29:33.670 --> 00:29:36.309
<v Speaker 1>It's not really idiomatic.

00:29:36.745 --> 00:29:39.945
<v Speaker 1>Like, I would just use equals true there

00:29:39.945 --> 00:29:41.624
<v Speaker 1>if I was going to be.

00:29:42.585 --> 00:29:45.625
<v Speaker 1>Yeah. Yeah. Either having require true equals actual

00:29:45.625 --> 00:29:49.399
<v Speaker 1>or just having expected equals true. Yeah. Exactly.

00:29:49.400 --> 00:29:51.799
<v Speaker 1>I I see very, very little reason to

00:29:51.799 --> 00:29:55.320
<v Speaker 1>use braced initialization there. Braced initialization,

00:29:55.320 --> 00:29:57.640
<v Speaker 1>you mostly use if you're initializing,

00:29:57.640 --> 00:29:59.879
<v Speaker 1>like, a a container, like a

00:30:00.120 --> 00:30:02.165
<v Speaker 1>an array or a vector, and you want

00:30:02.165 --> 00:30:04.005
<v Speaker 1>to give it a set of initial values.

00:30:04.005 --> 00:30:05.285
<v Speaker 1>You know, like, you you want an an

00:30:05.285 --> 00:30:07.125
<v Speaker 1>array of zero one two three, then you

00:30:07.125 --> 00:30:08.885
<v Speaker 1>would use braces and write zero one two

00:30:08.885 --> 00:30:10.645
<v Speaker 1>three in those braces. There's no real reason

00:30:10.645 --> 00:30:12.085
<v Speaker 1>to use it in this case, I don't

00:30:12.085 --> 00:30:12.245
<v Speaker 1>think.

00:30:14.370 --> 00:30:16.210
<v Speaker 0>Okay. Well, I'm just gonna remove that one

00:30:16.210 --> 00:30:18.050
<v Speaker 0>because I I I don't understand it. In

00:30:18.050 --> 00:30:19.330
<v Speaker 0>fact, I don't even Sounds good to me.

00:30:19.410 --> 00:30:22.130
<v Speaker 0>This one. Like, that to me seems perfectly

00:30:22.130 --> 00:30:22.850
<v Speaker 0>acceptable.

00:30:23.010 --> 00:30:24.049
<v Speaker 1>Mhmm. Okay.

00:30:24.370 --> 00:30:26.050
<v Speaker 0>So let's see what code they have given

00:30:26.050 --> 00:30:26.770
<v Speaker 0>us to work with.

00:30:28.024 --> 00:30:29.384
<v Speaker 0>Matter. Not a lot.

00:30:30.664 --> 00:30:33.784
<v Speaker 0>Alright. So it's expecting an is isogram function

00:30:33.784 --> 00:30:35.784
<v Speaker 0>which takes a string.

00:30:37.144 --> 00:30:39.144
<v Speaker 0>We have a namespace already.

00:30:39.544 --> 00:30:40.985
<v Speaker 0>So I'm assuming

00:30:42.220 --> 00:30:44.619
<v Speaker 0>I've got maybe I should disable Copilot.

00:30:45.100 --> 00:30:46.539
<v Speaker 0>Is that is that cheating?

00:30:47.740 --> 00:30:49.820
<v Speaker 1>Alright. So we're we're gonna be returning a

00:30:49.820 --> 00:30:51.419
<v Speaker 1>boolean. Right? Because we're

00:30:53.655 --> 00:30:55.735
<v Speaker 1>okay. So now now we can maybe talk

00:30:55.735 --> 00:30:57.735
<v Speaker 1>about strings a little bit as well.

00:30:59.175 --> 00:31:01.175
<v Speaker 1>So there is a few different string types

00:31:01.175 --> 00:31:02.775
<v Speaker 1>in in c plus plus. If you go

00:31:02.775 --> 00:31:03.815
<v Speaker 1>back to the test

00:31:04.375 --> 00:31:04.695
<v Speaker 0>Yep.

00:31:06.409 --> 00:31:07.210
<v Speaker 1>So

00:31:07.610 --> 00:31:09.129
<v Speaker 1>anything enclosed

00:31:09.130 --> 00:31:09.769
<v Speaker 1>in

00:31:10.010 --> 00:31:10.729
<v Speaker 1>double

00:31:11.130 --> 00:31:14.169
<v Speaker 1>quotes, like that, is a string literal.

00:31:14.250 --> 00:31:14.889
<v Speaker 1>So

00:31:15.529 --> 00:31:17.850
<v Speaker 1>that's any string which is embedded into your

00:31:17.850 --> 00:31:20.970
<v Speaker 1>program. The type of a string literal is

00:31:20.970 --> 00:31:23.684
<v Speaker 1>a constant character array.

00:31:24.325 --> 00:31:27.365
<v Speaker 1>So this string literal will be a a

00:31:28.005 --> 00:31:31.285
<v Speaker 1>constant array of one character because they are,

00:31:31.925 --> 00:31:34.325
<v Speaker 1>they're null terminated. There's always a a null

00:31:34.325 --> 00:31:35.445
<v Speaker 1>character at the end.

00:31:37.670 --> 00:31:38.309
<v Speaker 1>But

00:31:39.670 --> 00:31:41.509
<v Speaker 1>string literals are

00:31:42.309 --> 00:31:45.429
<v Speaker 1>well, arrays in c style arrays in c

00:31:45.429 --> 00:31:46.950
<v Speaker 1>plus plus are a little bit weird because

00:31:46.950 --> 00:31:49.670
<v Speaker 1>they can change to pointers. We generally try

00:31:49.670 --> 00:31:51.845
<v Speaker 1>to shy away from them. So in c

00:31:51.845 --> 00:31:53.925
<v Speaker 1>plus plus, the main types we use for

00:31:53.925 --> 00:31:55.845
<v Speaker 1>strings are std::string,

00:31:56.005 --> 00:31:56.725
<v Speaker 1>which is

00:31:57.845 --> 00:32:00.005
<v Speaker 1>a string which owns its

00:32:00.485 --> 00:32:02.165
<v Speaker 1>own data. It has

00:32:02.965 --> 00:32:05.685
<v Speaker 1>buffer stored inside. It can be modified. It

00:32:05.685 --> 00:32:06.165
<v Speaker 1>can grow.

00:32:07.520 --> 00:32:10.239
<v Speaker 1>And the other type is std string view,

00:32:10.400 --> 00:32:11.039
<v Speaker 1>which is

00:32:12.960 --> 00:32:15.200
<v Speaker 1>actually, if this is using std string view

00:32:15.200 --> 00:32:16.960
<v Speaker 1>is a c plus plus 17 thing, so

00:32:16.960 --> 00:32:18.880
<v Speaker 1>it might not even allow us to use

00:32:18.880 --> 00:32:21.625
<v Speaker 1>string view. But string view is essentially a

00:32:21.625 --> 00:32:24.905
<v Speaker 1>a view into some existing string. So we

00:32:24.905 --> 00:32:27.945
<v Speaker 1>don't own the the memory. We're pointing at

00:32:27.945 --> 00:32:30.265
<v Speaker 1>some memory which is stored elsewhere, and that

00:32:30.265 --> 00:32:31.865
<v Speaker 1>could be a string literal or it could

00:32:31.865 --> 00:32:32.025
<v Speaker 1>be,

00:32:33.440 --> 00:32:34.799
<v Speaker 1>like, an existing

00:32:34.880 --> 00:32:35.919
<v Speaker 1>std string

00:32:36.080 --> 00:32:38.960
<v Speaker 1>stored somewhere else that we're just referencing into.

00:32:39.600 --> 00:32:41.760
<v Speaker 1>If you're familiar with Rust, then it's like

00:32:41.760 --> 00:32:42.320
<v Speaker 1>a

00:32:42.960 --> 00:32:44.960
<v Speaker 1>std string is the capital

00:32:45.200 --> 00:32:46.480
<v Speaker 1>s string,

00:32:46.559 --> 00:32:48.480
<v Speaker 1>and string view is like

00:32:48.640 --> 00:32:50.054
<v Speaker 1>a ref stir.

00:32:51.414 --> 00:32:53.335
<v Speaker 0>Okay. Yeah. That does make sense. The

00:32:54.455 --> 00:32:56.215
<v Speaker 0>the rush string stuff, I understand. I didn't

00:32:56.215 --> 00:32:57.495
<v Speaker 0>know it was so similar to the c

00:32:57.495 --> 00:32:59.414
<v Speaker 0>plus plus one, so that works really well.

00:32:59.575 --> 00:33:02.054
<v Speaker 0>Now Yeah. Is it string

00:33:02.135 --> 00:33:03.495
<v Speaker 0>view? Is that what you were seeing there?

00:33:03.660 --> 00:33:05.980
<v Speaker 0>Like so? Yeah. So that is what

00:33:06.620 --> 00:33:09.100
<v Speaker 1>would ideally be used here. I think

00:33:09.420 --> 00:33:10.860
<v Speaker 1>wait. I mean, we we can try it,

00:33:10.860 --> 00:33:12.380
<v Speaker 1>and if it doesn't compile

00:33:13.100 --> 00:33:15.180
<v Speaker 1>yeah. It's already saying that's oh, wait. We

00:33:15.260 --> 00:33:17.340
<v Speaker 1>we'd have to include the the header for

00:33:17.340 --> 00:33:19.935
<v Speaker 1>it. So, yeah, up there, we do hash

00:33:19.935 --> 00:33:20.735
<v Speaker 1>include.

00:33:21.935 --> 00:33:22.655
<v Speaker 1>And then

00:33:23.535 --> 00:33:26.095
<v Speaker 1>so there's there's two different syntaxes for hash

00:33:26.095 --> 00:33:28.335
<v Speaker 1>include. There's hash include yes. Exactly. That's what

00:33:28.335 --> 00:33:31.060
<v Speaker 1>we want. There's hash include double quotes, which

00:33:31.060 --> 00:33:33.780
<v Speaker 1>looks for the things in our own project,

00:33:33.780 --> 00:33:35.140
<v Speaker 1>and there's hash include

00:33:36.020 --> 00:33:39.860
<v Speaker 1>angle brackets, which looks for system include

00:33:39.940 --> 00:33:40.660
<v Speaker 1>headers.

00:33:41.540 --> 00:33:44.980
<v Speaker 1>So we would hash include string underscore view

00:33:44.655 --> 00:33:47.135
<v Speaker 1>just the same as string view, but without

00:33:47.135 --> 00:33:48.575
<v Speaker 1>the std. Yeah. Exactly.

00:33:50.015 --> 00:33:52.655
<v Speaker 0>Oh, it's happy. Okay. It's happy. We'll see

00:33:52.655 --> 00:33:54.495
<v Speaker 1>if we'll see if it builds.

00:33:55.695 --> 00:33:56.335
<v Speaker 1>Okay.

00:33:56.575 --> 00:33:58.895
<v Speaker 1>So what we wanna do is isogram.

00:33:59.290 --> 00:34:00.970
<v Speaker 0>Yeah. So our our first test case is

00:34:00.970 --> 00:34:03.130
<v Speaker 0>just empty string. So I'm assuming if we

00:34:03.130 --> 00:34:04.970
<v Speaker 0>have an empty string, we're just gonna return

00:34:05.370 --> 00:34:06.330
<v Speaker 0>true.

00:34:07.210 --> 00:34:10.330
<v Speaker 1>Yeah. So we could say if stir dot

00:34:10.330 --> 00:34:11.929
<v Speaker 1>empty. Oh, empty. Okay.

00:34:15.275 --> 00:34:15.995
<v Speaker 1>Yep.

00:34:16.155 --> 00:34:17.035
<v Speaker 1>Exactly.

00:34:17.755 --> 00:34:20.155
<v Speaker 0>Like so? Would that work? Yep. All good.

00:34:20.155 --> 00:34:20.795
<v Speaker 1>Mhmm.

00:34:21.675 --> 00:34:23.675
<v Speaker 0>And I guess we need a default case.

00:34:27.819 --> 00:34:29.420
<v Speaker 1>That's good to me. I just add don't

00:34:29.420 --> 00:34:31.340
<v Speaker 0>I don't see any red squiggles, so

00:34:32.139 --> 00:34:34.219
<v Speaker 0>that usually keeps me happy at the start.

00:34:34.219 --> 00:34:37.020
<v Speaker 0>Alright. So I would make a build directory.

00:34:37.579 --> 00:34:39.339
<v Speaker 0>I would run c make dot dot.

00:34:40.055 --> 00:34:41.975
<v Speaker 1>Mhmm. And then go.

00:34:42.935 --> 00:34:43.655
<v Speaker 0>Yep.

00:34:44.055 --> 00:34:46.135
<v Speaker 0>Okay. So I got something wrong.

00:34:46.375 --> 00:34:49.175
<v Speaker 0>November is isogram and namespace.

00:34:50.695 --> 00:34:51.335
<v Speaker 0>Isogram.

00:34:53.940 --> 00:34:56.340
<v Speaker 1>Did we, go into the header file?

00:34:57.139 --> 00:34:58.980
<v Speaker 1>So, yeah, we've got isogram dot c p

00:34:58.980 --> 00:35:00.820
<v Speaker 1>p. We also got isogram dot h, so

00:35:00.820 --> 00:35:02.180
<v Speaker 1>we need to declare

00:35:02.500 --> 00:35:03.220
<v Speaker 1>our,

00:35:03.619 --> 00:35:06.020
<v Speaker 1>our function here. So Would you just copy

00:35:06.020 --> 00:35:06.980
<v Speaker 0>and paste the sling?

00:35:07.805 --> 00:35:08.445
<v Speaker 1>Yes.

00:35:08.925 --> 00:35:10.925
<v Speaker 1>And end it with a semicolon.

00:35:12.685 --> 00:35:14.445
<v Speaker 1>So this is saying that

00:35:14.765 --> 00:35:15.645
<v Speaker 1>somewhere,

00:35:15.725 --> 00:35:18.845
<v Speaker 1>nebulously, there exists a function called isogram,

00:35:19.165 --> 00:35:20.845
<v Speaker 1>colon colon, isisogram,

00:35:21.085 --> 00:35:21.725
<v Speaker 1>and

00:35:23.369 --> 00:35:25.369
<v Speaker 1>this is the the header file which people

00:35:25.369 --> 00:35:28.089
<v Speaker 1>will include into their program in order to

00:35:28.089 --> 00:35:30.250
<v Speaker 1>know that there's something we can call call

00:35:30.250 --> 00:35:32.570
<v Speaker 1>this. And then when we compile the program,

00:35:32.650 --> 00:35:35.049
<v Speaker 1>then the linker is gonna, like, work out

00:35:35.049 --> 00:35:36.730
<v Speaker 1>where this function is actually defined.

00:35:37.215 --> 00:35:39.455
<v Speaker 0>So is it fair to make this

00:35:39.775 --> 00:35:41.775
<v Speaker 0>like, any function defined inside of a namespace

00:35:41.775 --> 00:35:44.015
<v Speaker 0>is essentially private until we add it to

00:35:44.015 --> 00:35:45.935
<v Speaker 0>the header file, and then we're making it

00:35:45.935 --> 00:35:48.175
<v Speaker 0>publicly available at that point in time? Alright.

00:35:48.175 --> 00:35:48.255
<v Speaker 0>Okay.

00:35:49.340 --> 00:35:51.020
<v Speaker 1>Yes. You can think of it that way.

00:35:51.020 --> 00:35:53.260
<v Speaker 1>It gets a little bit there's more details,

00:35:53.340 --> 00:35:55.740
<v Speaker 1>but, yeah, that that's a mental model which

00:35:55.900 --> 00:35:57.180
<v Speaker 1>checks out for

00:35:57.900 --> 00:35:59.660
<v Speaker 1>the the basic cases. Yeah.

00:36:00.620 --> 00:36:02.060
<v Speaker 0>So if we run make now,

00:36:03.185 --> 00:36:05.265
<v Speaker 0>then I'm getting under or so I didn't

00:36:05.265 --> 00:36:07.425
<v Speaker 0>use Okay. So in the in the header

00:36:07.425 --> 00:36:07.985
<v Speaker 1>file,

00:36:08.225 --> 00:36:09.745
<v Speaker 1>you need to also include

00:36:10.545 --> 00:36:11.585
<v Speaker 1>string view.

00:36:12.785 --> 00:36:13.905
<v Speaker 0>Alright. Okay.

00:36:14.945 --> 00:36:17.105
<v Speaker 1>Yeah. Because the header file needs to know

00:36:17.780 --> 00:36:19.460
<v Speaker 1>because it's taking a string view as a

00:36:19.460 --> 00:36:21.619
<v Speaker 1>parameter, it needs to know, like, what the

00:36:21.619 --> 00:36:24.260
<v Speaker 1>the size of that is and

00:36:24.500 --> 00:36:26.099
<v Speaker 1>how to pass one around and things like

00:36:26.099 --> 00:36:28.099
<v Speaker 1>that. Well, because this includes dot h, do

00:36:28.099 --> 00:36:30.180
<v Speaker 0>we still need the string view here? No.

00:36:30.180 --> 00:36:32.405
<v Speaker 1>You could get rid of that. Okay.

00:36:34.805 --> 00:36:37.125
<v Speaker 0>Alright. I was compiling a bit longer this

00:36:37.125 --> 00:36:38.485
<v Speaker 0>time. That's probably good.

00:36:39.205 --> 00:36:41.765
<v Speaker 1>K. They're still past. Okay. Awesome. Nice.

00:36:44.420 --> 00:36:46.820
<v Speaker 0>Let's see what our next test case is.

00:36:46.820 --> 00:36:48.420
<v Speaker 0>Now it looks like it's using

00:36:50.580 --> 00:36:52.580
<v Speaker 0>is this macros? Would you call them pragmas?

00:36:52.580 --> 00:36:54.660
<v Speaker 0>I'm not sure. Macros. Yeah. Macros.

00:36:55.805 --> 00:36:58.285
<v Speaker 0>I'm assuming I could just remove that, and

00:36:58.285 --> 00:36:59.885
<v Speaker 0>that would bring in this test case. Or

00:37:01.005 --> 00:37:02.685
<v Speaker 1>Yeah. I think there's

00:37:02.685 --> 00:37:04.765
<v Speaker 1>probably something defined in the CMake

00:37:05.725 --> 00:37:07.725
<v Speaker 1>which defines that, but, yeah, you can just

00:37:07.725 --> 00:37:09.170
<v Speaker 1>get rid of it as well, I'd say.

00:37:09.170 --> 00:37:11.170
<v Speaker 0>I'll just move it down. I'm assuming that

00:37:11.170 --> 00:37:13.090
<v Speaker 0>brings in one test that I I don't

00:37:13.090 --> 00:37:14.850
<v Speaker 0>know why it's still grayed out. Oh, there

00:37:14.850 --> 00:37:15.730
<v Speaker 0>we go. Okay.

00:37:18.050 --> 00:37:19.010
<v Speaker 0>So now

00:37:19.410 --> 00:37:21.785
<v Speaker 0>it really likes that brace syntax, I'm gonna

00:37:21.785 --> 00:37:22.745
<v Speaker 0>say. Yeah.

00:37:23.865 --> 00:37:26.265
<v Speaker 0>Now we wanna call isogram on isogram. Okay.

00:37:26.265 --> 00:37:27.465
<v Speaker 0>So now we're gonna actually have to do

00:37:27.465 --> 00:37:28.985
<v Speaker 0>our first bit of actual

00:37:29.305 --> 00:37:31.225
<v Speaker 0>code. So I think we're gonna need

00:37:31.785 --> 00:37:33.705
<v Speaker 0>to be able to loop over

00:37:33.705 --> 00:37:35.785
<v Speaker 0>each of our characters and just store them

00:37:35.785 --> 00:37:38.069
<v Speaker 0>in an array. So maybe we could talk

00:37:38.069 --> 00:37:39.829
<v Speaker 0>about first how do we define an array

00:37:39.829 --> 00:37:41.910
<v Speaker 0>to store scene characters.

00:37:42.869 --> 00:37:44.549
<v Speaker 1>Sure. So are we how are we gonna

00:37:44.549 --> 00:37:45.030
<v Speaker 1>be

00:37:46.950 --> 00:37:48.470
<v Speaker 1>doing this? Are we are we gonna be

00:37:48.470 --> 00:37:49.269
<v Speaker 1>only

00:37:49.430 --> 00:37:52.565
<v Speaker 1>assuming that our string is ASCII

00:37:52.645 --> 00:37:53.205
<v Speaker 1>and

00:37:56.005 --> 00:37:56.645
<v Speaker 1>then

00:37:56.964 --> 00:37:59.205
<v Speaker 1>counting if there's more than one

00:38:00.885 --> 00:38:03.125
<v Speaker 1>Yeah. I think each, or are we gonna

00:38:03.125 --> 00:38:04.805
<v Speaker 1>use a hash map? Or there's a few

00:38:04.805 --> 00:38:05.765
<v Speaker 1>different ways we could do it.

00:38:06.869 --> 00:38:07.990
<v Speaker 0>Yeah. So

00:38:08.390 --> 00:38:10.630
<v Speaker 0>let's do a hash map and then if

00:38:10.630 --> 00:38:13.190
<v Speaker 0>the key exists, we'll just immediately return false.

00:38:13.190 --> 00:38:15.109
<v Speaker 0>Otherwise, we'll continue to loop over and store

00:38:15.109 --> 00:38:17.269
<v Speaker 0>them. And, yes, we'll stick to ASCII. There's

00:38:17.269 --> 00:38:18.950
<v Speaker 0>already been a joke about UTFE

00:38:19.005 --> 00:38:21.085
<v Speaker 0>based on another series I do called clustered.

00:38:21.085 --> 00:38:22.445
<v Speaker 0>I'll talk about that later.

00:38:22.924 --> 00:38:24.125
<v Speaker 0>No UTFE.

00:38:24.605 --> 00:38:25.165
<v Speaker 0>Okay.

00:38:25.565 --> 00:38:27.724
<v Speaker 0>Yes. The UTFE story for c plus plus

00:38:27.724 --> 00:38:28.845
<v Speaker 1>is is a mess.

00:38:32.180 --> 00:38:33.859
<v Speaker 0>Yeah. Let's let's take the ask you then.

00:38:33.859 --> 00:38:35.380
<v Speaker 0>So first of all Yeah. Like, how do

00:38:35.380 --> 00:38:36.180
<v Speaker 0>I define

00:38:36.900 --> 00:38:38.339
<v Speaker 0>a hash map then to be able to

00:38:38.339 --> 00:38:40.339
<v Speaker 0>store the scene characters?

00:38:40.660 --> 00:38:42.980
<v Speaker 1>Yep. So the the default hash map

00:38:43.299 --> 00:38:45.539
<v Speaker 1>in c plus plus for reasons

00:38:45.984 --> 00:38:47.025
<v Speaker 1>is called

00:38:47.265 --> 00:38:48.625
<v Speaker 1>std unordered

00:38:48.625 --> 00:38:49.985
<v Speaker 1>underscore map.

00:38:52.385 --> 00:38:53.905
<v Speaker 0>Like so? Yeah. That's it.

00:38:54.625 --> 00:38:56.705
<v Speaker 1>So unordered map

00:38:56.785 --> 00:38:57.505
<v Speaker 1>is,

00:38:57.825 --> 00:38:59.585
<v Speaker 1>we'd have to include the the header for

00:38:59.585 --> 00:39:01.185
<v Speaker 1>unordered map as well, which is,

00:39:02.130 --> 00:39:04.130
<v Speaker 1>it's just called unordered map.

00:39:04.930 --> 00:39:07.810
<v Speaker 0>Okay. So we want to do an include

00:39:07.970 --> 00:39:10.450
<v Speaker 0>on our yep. There we go. I feel

00:39:10.450 --> 00:39:11.970
<v Speaker 0>like these ones should be above the string

00:39:11.970 --> 00:39:13.730
<v Speaker 0>ones. Is that something you would do? Or

00:39:13.569 --> 00:39:14.369
<v Speaker 0>Yeah. Okay.

00:39:15.555 --> 00:39:17.315
<v Speaker 0>I'm sure if it's like a whatever. It

00:39:17.315 --> 00:39:19.075
<v Speaker 0>doesn't matter. But Yeah.

00:39:19.395 --> 00:39:22.995
<v Speaker 1>So unordered map is a class template.

00:39:23.714 --> 00:39:26.115
<v Speaker 1>So templates in c plus plus are

00:39:26.355 --> 00:39:26.915
<v Speaker 1>the

00:39:27.395 --> 00:39:28.994
<v Speaker 1>the basic way to do generics.

00:39:29.910 --> 00:39:31.910
<v Speaker 1>So if you're familiar with, like, traits from

00:39:31.910 --> 00:39:34.390
<v Speaker 1>Rust or, like, Swift protocols

00:39:34.390 --> 00:39:35.110
<v Speaker 1>or,

00:39:35.750 --> 00:39:38.630
<v Speaker 1>Java generics or whatever anyone else calls them,

00:39:38.630 --> 00:39:40.630
<v Speaker 1>it's it's kind of a a similar thing.

00:39:40.630 --> 00:39:43.030
<v Speaker 1>So you can't just create an unordered map.

00:39:43.030 --> 00:39:45.265
<v Speaker 1>You have to create an unordered map with

00:39:45.265 --> 00:39:48.145
<v Speaker 1>some key type and some value type.

00:39:48.465 --> 00:39:51.745
<v Speaker 1>So in this case, our unordered map is

00:39:51.745 --> 00:39:53.745
<v Speaker 1>going to be a map from,

00:39:55.105 --> 00:39:55.985
<v Speaker 1>characters,

00:39:56.065 --> 00:39:58.970
<v Speaker 1>which are char, c h a r,

00:39:59.210 --> 00:39:59.850
<v Speaker 1>to,

00:40:01.450 --> 00:40:02.330
<v Speaker 1>I guess,

00:40:03.050 --> 00:40:03.610
<v Speaker 1>just

00:40:04.170 --> 00:40:06.090
<v Speaker 0>Yeah. If we're if

00:40:07.770 --> 00:40:10.090
<v Speaker 1>we're doing a char to to build like,

00:40:10.090 --> 00:40:11.530
<v Speaker 1>if if we're just checking if we've seen

00:40:11.530 --> 00:40:12.714
<v Speaker 1>it before, then we actually actually don't need

00:40:12.714 --> 00:40:13.994
<v Speaker 1>an unordered map. We could do it with

00:40:13.994 --> 00:40:15.195
<v Speaker 1>an unordered set.

00:40:17.194 --> 00:40:19.355
<v Speaker 0>Yeah. Because that's just

00:40:20.395 --> 00:40:22.555
<v Speaker 1>checking whether it exists yet or not.

00:40:23.355 --> 00:40:24.795
<v Speaker 1>Yep. Exactly the same.

00:40:25.410 --> 00:40:26.930
<v Speaker 1>So we would just have it on our

00:40:26.690 --> 00:40:27.650
<v Speaker 0>the template

00:40:27.890 --> 00:40:28.770
<v Speaker 0>syntax?

00:40:29.170 --> 00:40:30.930
<v Speaker 1>Yep. That's the template syntax.

00:40:31.010 --> 00:40:31.650
<v Speaker 1>So,

00:40:33.329 --> 00:40:35.410
<v Speaker 1>yeah, so for for our declaration,

00:40:35.970 --> 00:40:37.250
<v Speaker 1>we would need to say,

00:40:37.650 --> 00:40:39.010
<v Speaker 1>stood unorderedset

00:40:40.134 --> 00:40:42.134
<v Speaker 1>will be the first thing in our declaration

00:40:42.134 --> 00:40:44.055
<v Speaker 1>because that's the type. So we'd say std

00:40:44.055 --> 00:40:45.015
<v Speaker 1>unorderedset

00:40:45.494 --> 00:40:46.855
<v Speaker 1>char scene

00:40:48.855 --> 00:40:52.295
<v Speaker 1>semicolon. Yep. And that will construct an empty

00:40:52.454 --> 00:40:53.414
<v Speaker 1>unorderedset,

00:40:53.980 --> 00:40:54.700
<v Speaker 1>and

00:40:54.940 --> 00:40:56.780
<v Speaker 1>that will be our our scene

00:40:56.780 --> 00:40:57.420
<v Speaker 1>object.

00:40:58.780 --> 00:40:59.980
<v Speaker 0>Okay. Cool. So

00:41:00.380 --> 00:41:02.620
<v Speaker 0>the first thing popping into my head now

00:41:03.980 --> 00:41:06.700
<v Speaker 0>is when we call dot empty, which I

00:41:06.700 --> 00:41:08.620
<v Speaker 0>didn't know was possible on the string view,

00:41:09.405 --> 00:41:11.165
<v Speaker 0>I'm assuming we can get

00:41:11.885 --> 00:41:14.205
<v Speaker 0>the characters or an iterator or something we

00:41:14.205 --> 00:41:16.605
<v Speaker 0>can loop over as well through a function?

00:41:16.925 --> 00:41:18.045
<v Speaker 1>Yep. So

00:41:19.725 --> 00:41:22.540
<v Speaker 1>we could do that by by calling functions,

00:41:22.540 --> 00:41:23.100
<v Speaker 1>but

00:41:23.660 --> 00:41:26.220
<v Speaker 1>c plus plus has the the idea of

00:41:26.220 --> 00:41:27.980
<v Speaker 1>a range, which is

00:41:28.780 --> 00:41:29.660
<v Speaker 1>basically

00:41:31.020 --> 00:41:32.060
<v Speaker 1>the beginning

00:41:32.140 --> 00:41:35.445
<v Speaker 1>of some range and the end of a

00:41:35.445 --> 00:41:37.925
<v Speaker 1>range, and those two things are called iterators.

00:41:39.285 --> 00:41:43.685
<v Speaker 1>So anything which supplies a begin and end

00:41:43.685 --> 00:41:46.485
<v Speaker 1>function is a range in c plus plus,

00:41:46.485 --> 00:41:48.325
<v Speaker 1>and we can loop over things which are

00:41:48.325 --> 00:41:51.270
<v Speaker 1>ranges a lot easier than anything else. So

00:41:51.270 --> 00:41:53.030
<v Speaker 1>we can use what's called a range based

00:41:53.030 --> 00:41:54.470
<v Speaker 1>for loop, which is like a for each

00:41:54.470 --> 00:41:57.270
<v Speaker 1>loop or for in or whatever you might

00:41:57.270 --> 00:41:58.950
<v Speaker 1>know from from other languages.

00:41:59.110 --> 00:42:00.550
<v Speaker 1>And so the syntax for that is just

00:42:00.550 --> 00:42:01.270
<v Speaker 1>for

00:42:01.830 --> 00:42:03.270
<v Speaker 1>and then parenthesis.

00:42:05.325 --> 00:42:07.645
<v Speaker 1>And then we need to say what the

00:42:07.645 --> 00:42:10.685
<v Speaker 1>type of the thing we are looping over

00:42:10.685 --> 00:42:12.765
<v Speaker 1>is. In this case, it will be,

00:42:13.805 --> 00:42:14.605
<v Speaker 1>characters,

00:42:14.605 --> 00:42:16.125
<v Speaker 1>so just char.

00:42:16.125 --> 00:42:17.965
<v Speaker 1>We need to give it a name, so,

00:42:17.965 --> 00:42:19.005
<v Speaker 1>I guess, just c.

00:42:19.950 --> 00:42:20.830
<v Speaker 1>Yeah. Letter.

00:42:22.990 --> 00:42:24.270
<v Speaker 1>And then

00:42:24.750 --> 00:42:25.470
<v Speaker 1>colon.

00:42:27.869 --> 00:42:30.030
<v Speaker 1>And then what we're looping over, which is

00:42:30.030 --> 00:42:30.350
<v Speaker 1>str.

00:42:32.845 --> 00:42:35.245
<v Speaker 1>Yep. So this reads for

00:42:35.645 --> 00:42:37.485
<v Speaker 1>character c in

00:42:37.885 --> 00:42:38.685
<v Speaker 1>string,

00:42:39.005 --> 00:42:40.445
<v Speaker 1>do whatever

00:42:40.445 --> 00:42:41.165
<v Speaker 1>is,

00:42:42.045 --> 00:42:43.965
<v Speaker 1>is within these braces.

00:42:45.140 --> 00:42:47.700
<v Speaker 0>Okay. So I'm assuming we can do scene

00:42:48.180 --> 00:42:50.660
<v Speaker 0>hat? No. Contains?

00:42:51.140 --> 00:42:52.100
<v Speaker 1>.Contains,

00:42:52.180 --> 00:42:53.140
<v Speaker 1>I believe, is

00:42:54.740 --> 00:42:57.140
<v Speaker 1>I don't remember what the the interface for

00:42:58.105 --> 00:42:59.225
<v Speaker 1>We

00:42:59.225 --> 00:43:02.105
<v Speaker 0>have find. Maybe we should just find.

00:43:03.465 --> 00:43:06.105
<v Speaker 1>So find will will return

00:43:06.105 --> 00:43:07.465
<v Speaker 1>an iterator.

00:43:07.465 --> 00:43:09.705
<v Speaker 1>There is contains, but it says that's in

00:43:09.705 --> 00:43:11.145
<v Speaker 1>c plus plus 20.

00:43:11.385 --> 00:43:12.745
<v Speaker 1>We can use dot count.

00:43:15.850 --> 00:43:16.570
<v Speaker 1>So if you

00:43:17.690 --> 00:43:18.330
<v Speaker 1>yeah.

00:43:20.570 --> 00:43:22.730
<v Speaker 0>Would that not return the size?

00:43:23.610 --> 00:43:24.490
<v Speaker 1>Yes.

00:43:24.490 --> 00:43:27.370
<v Speaker 1>But current dot current will Oh, current. Sorry.

00:43:28.285 --> 00:43:30.445
<v Speaker 0>No? No. No. It's dot current. So we'd

00:43:30.445 --> 00:43:33.245
<v Speaker 1>see scene dot current and give it c

00:43:33.245 --> 00:43:34.125
<v Speaker 1>as the

00:43:34.445 --> 00:43:35.645
<v Speaker 1>as the argument.

00:43:37.565 --> 00:43:39.565
<v Speaker 1>Yeah. I've got two dots in there.

00:43:39.965 --> 00:43:40.365
<v Speaker 1>Yep.

00:43:42.050 --> 00:43:43.090
<v Speaker 1>Yeah. So this will

00:43:43.970 --> 00:43:45.010
<v Speaker 1>because it's

00:43:45.490 --> 00:43:48.130
<v Speaker 1>an unordered set, then current is gonna either

00:43:48.130 --> 00:43:51.170
<v Speaker 1>return zero or it's gonna return one.

00:43:51.810 --> 00:43:53.490
<v Speaker 0>So Right. Okay. Gotcha.

00:43:55.145 --> 00:43:56.905
<v Speaker 1>If in c plus plus

00:43:58.744 --> 00:44:01.225
<v Speaker 1>yeah. That that will that will be fine.

00:44:01.705 --> 00:44:04.505
<v Speaker 1>Yeah. So that that will check to ensure

00:44:04.505 --> 00:44:05.145
<v Speaker 1>that

00:44:05.305 --> 00:44:07.705
<v Speaker 1>c is not in scene. I'm just gonna

00:44:07.705 --> 00:44:09.705
<v Speaker 0>make this up now, but I'm assuming

00:44:10.960 --> 00:44:12.480
<v Speaker 0>we could do this.

00:44:13.760 --> 00:44:15.360
<v Speaker 0>I think this is gonna do an early

00:44:15.360 --> 00:44:17.120
<v Speaker 0>return, although I could be wrong. And I'm

00:44:17.120 --> 00:44:18.240
<v Speaker 0>assuming here,

00:44:19.040 --> 00:44:20.720
<v Speaker 0>could we continue?

00:44:24.185 --> 00:44:26.505
<v Speaker 1>Yeah. So you could do that. I generally

00:44:26.505 --> 00:44:28.505
<v Speaker 1>try to not use continue in loops because

00:44:28.505 --> 00:44:31.065
<v Speaker 1>it makes them very difficult to to read.

00:44:32.345 --> 00:44:33.385
<v Speaker 1>I would

00:44:33.465 --> 00:44:34.265
<v Speaker 1>instead

00:44:34.505 --> 00:44:35.305
<v Speaker 1>use

00:44:35.625 --> 00:44:39.305
<v Speaker 1>put an else clause after the the if

00:44:38.289 --> 00:44:39.010
<v Speaker 1>and

00:44:40.769 --> 00:44:43.329
<v Speaker 1>and do a return false in there.

00:44:44.049 --> 00:44:44.609
<v Speaker 1>Yeah.

00:44:47.250 --> 00:44:49.890
<v Speaker 0>Okay. Well, it looks like it's complaining about

00:44:49.890 --> 00:44:52.450
<v Speaker 0>my for loop. Let's fix that first then.

00:44:53.165 --> 00:44:54.205
<v Speaker 0>Did I get something?

00:44:56.525 --> 00:44:57.325
<v Speaker 1>Looks

00:44:57.645 --> 00:45:00.045
<v Speaker 1>fine. Maybe try and compile it, see what

00:45:00.045 --> 00:45:00.845
<v Speaker 1>the compiler says.

00:45:07.320 --> 00:45:09.880
<v Speaker 1>Okay. That compiled just the test. Yeah. Think

00:45:09.960 --> 00:45:11.560
<v Speaker 0>okay. Just my Versus code then.

00:45:11.800 --> 00:45:12.440
<v Speaker 1>Yeah.

00:45:13.480 --> 00:45:16.680
<v Speaker 0>Okay. So we are ranging over our string

00:45:16.680 --> 00:45:18.520
<v Speaker 0>and pulling out each character.

00:45:19.000 --> 00:45:21.240
<v Speaker 0>Mhmm. If the count for that character is

00:45:21.240 --> 00:45:23.960
<v Speaker 0>zero, we're going to insert it. If it's

00:45:23.295 --> 00:45:25.535
<v Speaker 0>not zero, that means we've seen it before.

00:45:25.694 --> 00:45:27.615
<v Speaker 0>It is no longer an isogram, and we

00:45:27.615 --> 00:45:28.815
<v Speaker 0>return false,

00:45:28.895 --> 00:45:30.494
<v Speaker 0>which now means if we get down to

00:45:30.494 --> 00:45:33.375
<v Speaker 0>here, we're actually return true. An isogram.

00:45:37.059 --> 00:45:38.980
<v Speaker 0>Look at that. There we go. Nice.

00:45:40.099 --> 00:45:42.340
<v Speaker 1>Then we can, I guess, uncomment the

00:45:42.980 --> 00:45:45.060
<v Speaker 1>other test because there was another one?

00:45:47.700 --> 00:45:49.780
<v Speaker 0>I don't think we may have a a

00:45:49.780 --> 00:45:51.460
<v Speaker 0>bunch. But Yes.

00:45:52.655 --> 00:45:54.975
<v Speaker 1>I think just get get rid of that

00:45:55.375 --> 00:45:56.175
<v Speaker 1>if

00:45:56.734 --> 00:45:57.935
<v Speaker 1>I think, and

00:45:58.335 --> 00:45:59.135
<v Speaker 1>there'll be

00:46:00.335 --> 00:46:02.095
<v Speaker 1>matching one right at the end.

00:46:02.734 --> 00:46:04.015
<v Speaker 1>Oh, there's a lot of tests. Yeah. Get

00:46:04.015 --> 00:46:05.855
<v Speaker 1>rid of that end of let's just see

00:46:05.855 --> 00:46:06.974
<v Speaker 1>if they all pass.

00:46:08.120 --> 00:46:09.560
<v Speaker 1>Alright. Failed.

00:46:09.800 --> 00:46:10.520
<v Speaker 1>Alright.

00:46:10.680 --> 00:46:13.320
<v Speaker 0>No. We don't handle there were some exceptions

00:46:13.320 --> 00:46:14.840
<v Speaker 0>here. So it said

00:46:14.920 --> 00:46:17.080
<v Speaker 0>hyphens and spaces are allowed. So I guess

00:46:17.080 --> 00:46:18.680
<v Speaker 0>if we just quickly add

00:46:19.795 --> 00:46:22.915
<v Speaker 0>Yeah. A condition to not look to skip

00:46:22.915 --> 00:46:23.715
<v Speaker 0>over them.

00:46:23.955 --> 00:46:25.235
<v Speaker 1>Yep. So

00:46:25.395 --> 00:46:27.555
<v Speaker 0>if c equals

00:46:27.955 --> 00:46:28.835
<v Speaker 0>this

00:46:30.275 --> 00:46:30.915
<v Speaker 1>So

00:46:32.319 --> 00:46:36.000
<v Speaker 1>character so things enclosed in double quotes are

00:46:36.319 --> 00:46:38.720
<v Speaker 1>are string literals. Things enclosed in single quotes

00:46:38.720 --> 00:46:41.119
<v Speaker 1>are characters. Yep. So we want we want

00:46:41.119 --> 00:46:42.000
<v Speaker 1>that. Yep.

00:46:43.359 --> 00:46:46.319
<v Speaker 1>We could say if if c equals hyphen

00:46:46.935 --> 00:46:48.455
<v Speaker 1>or c

00:46:48.615 --> 00:46:49.975
<v Speaker 1>equals space,

00:46:49.975 --> 00:46:51.735
<v Speaker 1>you could do it in the the same

00:46:52.535 --> 00:46:53.975
<v Speaker 1>I was just saying in the in the

00:46:53.975 --> 00:46:55.415
<v Speaker 1>same thing you had.

00:46:57.655 --> 00:46:59.175
<v Speaker 0>Oh, yeah. We don't want to insert this,

00:46:59.175 --> 00:47:02.080
<v Speaker 0>do we? Okay. No. Yeah. Just have another

00:47:02.240 --> 00:47:03.360
<v Speaker 1>yeah. Perfect.

00:47:04.640 --> 00:47:07.200
<v Speaker 1>Yeah. And then you've got a a trailing

00:47:07.840 --> 00:47:08.640
<v Speaker 0>Yep.

00:47:09.760 --> 00:47:12.320
<v Speaker 1>Yep. So in c plus plus, double bar

00:47:12.480 --> 00:47:12.960
<v Speaker 1>means

00:47:13.360 --> 00:47:14.000
<v Speaker 1>you can also

00:47:14.835 --> 00:47:16.915
<v Speaker 1>just write or. That works as well.

00:47:18.435 --> 00:47:19.395
<v Speaker 1>Nice.

00:47:20.035 --> 00:47:21.955
<v Speaker 0>I quite like it. A

00:47:22.115 --> 00:47:24.035
<v Speaker 0>lot of people don't because No. I think

00:47:24.035 --> 00:47:25.555
<v Speaker 0>it reads well. To the double bar. I

00:47:25.555 --> 00:47:26.915
<v Speaker 1>think it does as well. Yeah.

00:47:28.480 --> 00:47:29.120
<v Speaker 0>Okay.

00:47:29.280 --> 00:47:31.920
<v Speaker 0>Should I continue in here or should I

00:47:31.920 --> 00:47:32.560
<v Speaker 0>just

00:47:33.680 --> 00:47:35.520
<v Speaker 0>do nothing? Yeah. You can write a continue

00:47:35.520 --> 00:47:36.640
<v Speaker 1>in there. But

00:47:38.400 --> 00:47:40.080
<v Speaker 0>because we've got the change conditional, so we

00:47:40.080 --> 00:47:41.520
<v Speaker 0>should be okay just doing that, I think.

00:47:43.505 --> 00:47:44.145
<v Speaker 1>Yeah.

00:47:44.465 --> 00:47:46.625
<v Speaker 0>Maybe. We'll see. The test will tell us.

00:47:48.785 --> 00:47:51.105
<v Speaker 0>Oh, okay. So two edge cases.

00:47:51.985 --> 00:47:53.745
<v Speaker 0>It's not really given me

00:47:55.040 --> 00:47:56.080
<v Speaker 0>mixed case.

00:47:57.119 --> 00:47:58.880
<v Speaker 0>So we have to lower case it.

00:47:59.520 --> 00:48:00.320
<v Speaker 0>And

00:48:00.400 --> 00:48:01.600
<v Speaker 0>the last one

00:48:03.520 --> 00:48:05.600
<v Speaker 0>is also just the mixed case thing.

00:48:05.840 --> 00:48:06.240
<v Speaker 0>So.

00:48:07.015 --> 00:48:08.615
<v Speaker 1>Yeah. So we could use

00:48:10.295 --> 00:48:13.815
<v Speaker 1>std to lower or std to upper, just

00:48:13.815 --> 00:48:16.135
<v Speaker 1>a normal case. Part of the range, or

00:48:16.135 --> 00:48:17.175
<v Speaker 0>would you create a new variable?

00:48:18.910 --> 00:48:21.150
<v Speaker 1>Yeah. You probably wanna you could just you

00:48:21.150 --> 00:48:24.510
<v Speaker 1>do c equals to lower c.

00:48:26.110 --> 00:48:29.150
<v Speaker 1>That's all one word, to lower. It's a

00:48:30.750 --> 00:48:32.430
<v Speaker 1>can't remember which header it's in.

00:48:37.995 --> 00:48:39.275
<v Speaker 1>Split to lower

00:48:41.355 --> 00:48:43.915
<v Speaker 1>is in the c type

00:48:44.155 --> 00:48:44.555
<v Speaker 1>header.

00:48:48.510 --> 00:48:50.270
<v Speaker 0>Okay. How would you work that out? C

00:48:50.270 --> 00:48:51.150
<v Speaker 1>c type.

00:48:52.030 --> 00:48:54.110
<v Speaker 0>I'm sorry. Say that again, please? It's c

00:48:54.110 --> 00:48:56.590
<v Speaker 1>c type, two c's at the start. Yeah.

00:48:57.550 --> 00:48:59.630
<v Speaker 1>It's a that's an old c thing.

00:49:00.675 --> 00:49:02.435
<v Speaker 1>Yeah. You would generally work that out just

00:49:02.435 --> 00:49:05.155
<v Speaker 1>by going to CPP reference,

00:49:05.235 --> 00:49:05.955
<v Speaker 1>which is,

00:49:06.915 --> 00:49:08.915
<v Speaker 1>I'd say, the best online

00:49:08.915 --> 00:49:11.315
<v Speaker 1>c plus plus reference website

00:49:11.555 --> 00:49:13.950
<v Speaker 1>and just typing in the function if you

00:49:13.950 --> 00:49:16.350
<v Speaker 1>want, and that will tell you what what

00:49:16.350 --> 00:49:19.310
<v Speaker 1>header is. Yeah. Exactly. That's it. Okay.

00:49:20.190 --> 00:49:21.950
<v Speaker 0>Oh, I forgot my semicolon.

00:49:21.950 --> 00:49:23.550
<v Speaker 0>I have format it, which is just an

00:49:23.550 --> 00:49:25.390
<v Speaker 0>indicator that my code is maybe alright.

00:49:27.145 --> 00:49:28.985
<v Speaker 0>And all of our tests Yay.

00:49:30.745 --> 00:49:31.305
<v Speaker 0>Okay.

00:49:32.745 --> 00:49:33.945
<v Speaker 0>There's quite a lot

00:49:35.145 --> 00:49:36.905
<v Speaker 0>to kind of unpack here.

00:49:37.465 --> 00:49:38.105
<v Speaker 0>So

00:49:38.585 --> 00:49:40.025
<v Speaker 0>I like the unordered

00:49:40.025 --> 00:49:42.150
<v Speaker 0>set. You said we also had maps. So

00:49:42.150 --> 00:49:43.670
<v Speaker 0>there's all of these built in data structures

00:49:43.670 --> 00:49:45.349
<v Speaker 0>for handling, I guess, most of the common

00:49:45.349 --> 00:49:46.310
<v Speaker 0>use cases.

00:49:46.710 --> 00:49:48.390
<v Speaker 0>We got the range

00:49:48.470 --> 00:49:49.109
<v Speaker 0>for

00:49:49.670 --> 00:49:51.910
<v Speaker 1>Mhmm. Which was cool. Like, does c plus

00:49:51.910 --> 00:49:52.710
<v Speaker 0>plus have

00:49:53.750 --> 00:49:55.829
<v Speaker 0>functional primitives for doing this? Like, you know,

00:49:55.829 --> 00:49:58.045
<v Speaker 0>the ability to maybe map, filter,

00:49:58.125 --> 00:49:58.765
<v Speaker 0>etcetera?

00:49:59.565 --> 00:50:00.525
<v Speaker 1>Right. So

00:50:01.165 --> 00:50:03.325
<v Speaker 1>prior to c plus plus 20, there there

00:50:03.325 --> 00:50:05.165
<v Speaker 1>are these things called algorithms,

00:50:06.285 --> 00:50:07.965
<v Speaker 1>which are in the algorithms header.

00:50:08.685 --> 00:50:09.485
<v Speaker 1>And

00:50:09.565 --> 00:50:10.765
<v Speaker 1>those are

00:50:12.250 --> 00:50:14.330
<v Speaker 1>kind of what you're looking for. We have

00:50:14.330 --> 00:50:15.610
<v Speaker 1>things like transform,

00:50:15.610 --> 00:50:16.970
<v Speaker 1>which is basically a map,

00:50:17.130 --> 00:50:19.770
<v Speaker 1>lets you run some function over all of

00:50:19.770 --> 00:50:22.010
<v Speaker 1>the elements in some range. We've got, like,

00:50:22.010 --> 00:50:23.450
<v Speaker 1>remove f. We've got,

00:50:24.924 --> 00:50:25.645
<v Speaker 1>like,

00:50:26.605 --> 00:50:26.924
<v Speaker 1>couple

00:50:27.484 --> 00:50:28.765
<v Speaker 1>two or three dozen

00:50:29.964 --> 00:50:30.845
<v Speaker 1>algorithms

00:50:30.845 --> 00:50:33.805
<v Speaker 1>in that header. Yeah. The problem with those

00:50:33.805 --> 00:50:36.204
<v Speaker 1>is that they don't compose very nicely. You

00:50:36.204 --> 00:50:39.980
<v Speaker 1>have to essentially have, like, intermediate data structures.

00:50:39.980 --> 00:50:41.260
<v Speaker 1>So, like, if you wanted to do a

00:50:41.260 --> 00:50:43.740
<v Speaker 1>transform followed by something else, then you would,

00:50:43.740 --> 00:50:44.860
<v Speaker 1>like, transform

00:50:44.940 --> 00:50:48.460
<v Speaker 1>your string into some other string and then

00:50:48.540 --> 00:50:51.565
<v Speaker 1>operate on that. C plus plus 20 has

00:50:52.605 --> 00:50:54.525
<v Speaker 1>ranges which compose.

00:50:54.525 --> 00:50:56.925
<v Speaker 1>So you could, like, build up a pipeline

00:50:56.925 --> 00:50:59.805
<v Speaker 1>of operations and say, like, okay. We've got

00:50:59.805 --> 00:51:02.125
<v Speaker 1>my string. I wanna transform it. I then

00:51:02.125 --> 00:51:03.885
<v Speaker 1>I want to filter it. Then I wanna

00:51:03.885 --> 00:51:05.720
<v Speaker 1>drop the first three, then I wanna do

00:51:05.720 --> 00:51:07.160
<v Speaker 1>this, then I wanna do that. And those

00:51:07.160 --> 00:51:10.200
<v Speaker 1>would all only they would happen lazily. So

00:51:10.200 --> 00:51:12.200
<v Speaker 1>only when you ask for an element do

00:51:12.200 --> 00:51:14.360
<v Speaker 1>all of those operations actually occur.

00:51:16.040 --> 00:51:18.359
<v Speaker 1>But the the version of the compiler you're

00:51:18.359 --> 00:51:20.119
<v Speaker 1>using does not implement those yet.

00:51:21.075 --> 00:51:22.275
<v Speaker 0>Okay. Awesome.

00:51:22.515 --> 00:51:24.675
<v Speaker 0>Alright. I'll throw one more question out because

00:51:24.675 --> 00:51:25.235
<v Speaker 0>this

00:51:26.675 --> 00:51:28.995
<v Speaker 0>just something I've been curious about. Like, my

00:51:29.155 --> 00:51:31.395
<v Speaker 0>very old knowledge of working with c and

00:51:31.395 --> 00:51:33.795
<v Speaker 0>c plus plus required a lot of mallocs

00:51:33.795 --> 00:51:35.235
<v Speaker 0>and the allocation.

00:51:35.619 --> 00:51:37.540
<v Speaker 0>We haven't had to do any memory management

00:51:37.540 --> 00:51:39.060
<v Speaker 0>yet. Now is that just because our types

00:51:39.060 --> 00:51:41.300
<v Speaker 0>are mostly primitives or just because c plus

00:51:41.300 --> 00:51:43.460
<v Speaker 0>plus handles some of this for me?

00:51:44.020 --> 00:51:44.580
<v Speaker 1>So,

00:51:44.900 --> 00:51:46.260
<v Speaker 1>basically, if you're

00:51:46.740 --> 00:51:48.260
<v Speaker 1>so in in c plus plus

00:51:48.935 --> 00:51:50.695
<v Speaker 1>like, see, we have malloc. C plus plus

00:51:50.695 --> 00:51:51.495
<v Speaker 1>has new.

00:51:51.735 --> 00:51:53.735
<v Speaker 1>If you're writing c plus plus and you

00:51:53.735 --> 00:51:56.775
<v Speaker 1>use new to allocate memory in 2021,

00:51:56.775 --> 00:51:58.215
<v Speaker 1>you're probably doing something wrong.

00:52:00.215 --> 00:52:00.535
<v Speaker 1>You

00:52:01.390 --> 00:52:03.550
<v Speaker 1>gen generally, we try to avoid

00:52:03.790 --> 00:52:04.430
<v Speaker 1>allocating

00:52:04.670 --> 00:52:06.830
<v Speaker 1>a dynamic allocation as much as we can.

00:52:07.230 --> 00:52:09.310
<v Speaker 1>If we do have to allocate dynamically, we

00:52:09.310 --> 00:52:11.390
<v Speaker 1>try to manage that allocation

00:52:11.470 --> 00:52:11.950
<v Speaker 1>with

00:52:13.825 --> 00:52:16.465
<v Speaker 1>some standard container, like, unorderedset

00:52:16.465 --> 00:52:19.345
<v Speaker 1>here. Unorderedset is doing allocation internally

00:52:19.505 --> 00:52:21.745
<v Speaker 1>and not exposing that to us.

00:52:22.385 --> 00:52:24.385
<v Speaker 1>We could, if we wanted to, supply our

00:52:24.385 --> 00:52:26.305
<v Speaker 1>own allocator and do a bunch of ridiculous

00:52:26.305 --> 00:52:29.570
<v Speaker 1>stuff. But for, like, 99.99%

00:52:29.570 --> 00:52:31.650
<v Speaker 1>of our use cases, then,

00:52:32.050 --> 00:52:33.570
<v Speaker 1>this is just gonna handle all the memory

00:52:33.570 --> 00:52:34.690
<v Speaker 1>management for us.

00:52:35.330 --> 00:52:38.050
<v Speaker 1>If we do have to do our own

00:52:38.130 --> 00:52:39.090
<v Speaker 1>memory

00:52:39.250 --> 00:52:40.850
<v Speaker 1>management now, we would not

00:52:41.525 --> 00:52:43.765
<v Speaker 1>use new and delete,

00:52:44.565 --> 00:52:45.205
<v Speaker 1>because

00:52:45.765 --> 00:52:48.645
<v Speaker 1>as much as people say, oh, simply remember

00:52:48.645 --> 00:52:51.285
<v Speaker 1>to to call delete, like, that that doesn't

00:52:51.285 --> 00:52:53.925
<v Speaker 1>work. So in c plus plus 11,

00:52:55.130 --> 00:52:57.290
<v Speaker 1>they introduced smart pointers,

00:52:57.290 --> 00:52:58.490
<v Speaker 1>which are essentially

00:53:00.650 --> 00:53:03.610
<v Speaker 1>help you do memory management. So unique pointer

00:53:03.610 --> 00:53:04.890
<v Speaker 1>is the main one you would use. You

00:53:04.890 --> 00:53:07.575
<v Speaker 1>would create a unique pointer, and when that

00:53:07.575 --> 00:53:09.335
<v Speaker 1>unique pointer goes out of scope, it calls

00:53:09.335 --> 00:53:11.494
<v Speaker 1>delete automatically, so you don't need to remember

00:53:11.494 --> 00:53:12.295
<v Speaker 1>to do it.

00:53:13.015 --> 00:53:14.375
<v Speaker 0>Awesome. Thank you.

00:53:14.855 --> 00:53:16.855
<v Speaker 0>Okay. Let's tackle a couple of questions from

00:53:16.855 --> 00:53:18.455
<v Speaker 0>the chat, and then we'll try and squeeze

00:53:18.455 --> 00:53:20.855
<v Speaker 0>in one more of the extra system ones.

00:53:22.220 --> 00:53:25.260
<v Speaker 0>But let's see. Oh, Mozz. Hey, Mozz.

00:53:26.780 --> 00:53:28.859
<v Speaker 0>Oh, there's an interesting question. Hi, everyone. I

00:53:28.859 --> 00:53:30.220
<v Speaker 0>saw after goal, there would be no need

00:53:30.220 --> 00:53:32.220
<v Speaker 0>for c or c plus plus. Oh, come

00:53:32.220 --> 00:53:34.755
<v Speaker 0>on, Mozz. No. We're we're actually seeing a

00:53:34.755 --> 00:53:36.515
<v Speaker 0>good uptake of c plus plus in the

00:53:36.515 --> 00:53:39.394
<v Speaker 0>cloud native community. I think primarily driven by

00:53:39.394 --> 00:53:41.154
<v Speaker 0>Envoy. I'm not sure if you're familiar with

00:53:41.154 --> 00:53:43.875
<v Speaker 0>the project, but it's a a network

00:53:44.674 --> 00:53:45.555
<v Speaker 0>proxy.

00:53:45.555 --> 00:53:47.670
<v Speaker 0>And the reason I think Envoy and other

00:53:47.670 --> 00:53:49.270
<v Speaker 0>projects are now starting to use c plus

00:53:49.270 --> 00:53:51.349
<v Speaker 0>plus is for a lot of performance reasons

00:53:51.349 --> 00:53:52.150
<v Speaker 0>over

00:53:52.150 --> 00:53:54.390
<v Speaker 0>at Go. So no, Mozz. I don't think

00:53:54.390 --> 00:53:56.390
<v Speaker 0>Go means we don't need it. I think

00:53:56.390 --> 00:53:57.910
<v Speaker 0>there are definitely a lot of use cases

00:53:57.910 --> 00:53:59.685
<v Speaker 0>out there. I I don't know if you

00:53:59.685 --> 00:54:00.965
<v Speaker 0>want to add anything else to that or

00:54:00.965 --> 00:54:03.285
<v Speaker 0>just leave it at it. Yeah. Definitely. Like,

00:54:03.525 --> 00:54:05.765
<v Speaker 1>I think that what c plus plus gives

00:54:05.765 --> 00:54:06.725
<v Speaker 1>you is

00:54:06.965 --> 00:54:10.485
<v Speaker 1>full control over the layout of your data.

00:54:10.805 --> 00:54:14.460
<v Speaker 1>And and and you're aware, like, cache performance

00:54:14.460 --> 00:54:15.180
<v Speaker 1>is,

00:54:15.820 --> 00:54:18.620
<v Speaker 1>like, one of the most important,

00:54:19.020 --> 00:54:21.580
<v Speaker 1>areas of of optimizing your program,

00:54:21.820 --> 00:54:23.580
<v Speaker 1>then having the ability to do that is

00:54:23.580 --> 00:54:26.220
<v Speaker 1>super important. So, like, thinking about how your

00:54:26.220 --> 00:54:27.820
<v Speaker 1>data is laid out such that

00:54:28.355 --> 00:54:30.115
<v Speaker 1>it makes the most of the cache, such

00:54:30.115 --> 00:54:31.795
<v Speaker 1>that you don't have,

00:54:32.035 --> 00:54:34.435
<v Speaker 1>like, multiple threads contending over that

00:54:35.075 --> 00:54:37.315
<v Speaker 1>can just give you incredible

00:54:37.555 --> 00:54:40.675
<v Speaker 1>performance boost. I remember once, like,

00:54:41.474 --> 00:54:43.474
<v Speaker 1>this was for for a GPU, but

00:54:44.860 --> 00:54:47.180
<v Speaker 1>adding a single no op into

00:54:47.500 --> 00:54:48.540
<v Speaker 1>a loop,

00:54:49.100 --> 00:54:50.540
<v Speaker 1>improved performance

00:54:50.540 --> 00:54:52.700
<v Speaker 1>by 10 times because it made much better

00:54:52.700 --> 00:54:54.940
<v Speaker 1>use of the instruction cache, things like that,

00:54:55.500 --> 00:54:58.405
<v Speaker 1>which you just cannot do in in so

00:54:58.405 --> 00:55:00.645
<v Speaker 1>many other languages that don't give you that

00:55:00.645 --> 00:55:01.765
<v Speaker 1>much low level,

00:55:02.405 --> 00:55:04.565
<v Speaker 1>control over how you layer your data and

00:55:04.565 --> 00:55:07.605
<v Speaker 1>how it's it's used and cleaned up. Yeah.

00:55:08.340 --> 00:55:10.260
<v Speaker 0>That's a lot of projects that even are

00:55:10.260 --> 00:55:11.220
<v Speaker 0>using

00:55:11.220 --> 00:55:12.660
<v Speaker 0>Sego a lot of the time to bring

00:55:12.660 --> 00:55:14.580
<v Speaker 0>in some of this other stuff too. So

00:55:14.580 --> 00:55:16.180
<v Speaker 0>definitely very popular.

00:55:16.500 --> 00:55:17.060
<v Speaker 0>Okay.

00:55:17.540 --> 00:55:19.060
<v Speaker 0>Ben Woman is asking,

00:55:19.300 --> 00:55:21.540
<v Speaker 0>does c plus plus have an official or

00:55:21.540 --> 00:55:24.875
<v Speaker 0>unofficial documentation or reference site? Yeah. Basically, c

00:55:24.875 --> 00:55:27.035
<v Speaker 1>plus CPP reference is the

00:55:27.275 --> 00:55:29.994
<v Speaker 1>the de facto standard is the one which

00:55:29.994 --> 00:55:31.355
<v Speaker 1>most people will go to.

00:55:32.395 --> 00:55:35.355
<v Speaker 0>Alright. Carlos suggesting that Infinidash is written in

00:55:35.355 --> 00:55:37.515
<v Speaker 0>c plus plus I've

00:55:37.515 --> 00:55:39.195
<v Speaker 0>heard rumors otherwise, but we'll see.

00:55:39.910 --> 00:55:41.190
<v Speaker 0>Russell is asking,

00:55:41.430 --> 00:55:42.950
<v Speaker 0>are there any sites to find out a

00:55:42.950 --> 00:55:44.550
<v Speaker 0>duomatic c plus plus?

00:55:44.870 --> 00:55:45.990
<v Speaker 1>Good question.

00:55:46.390 --> 00:55:46.950
<v Speaker 1>I

00:55:47.830 --> 00:55:50.790
<v Speaker 1>think there's there's one called CPP

00:55:50.790 --> 00:55:51.590
<v Speaker 1>patterns

00:55:51.590 --> 00:55:53.350
<v Speaker 1>or did it change its name?

00:55:55.425 --> 00:55:57.025
<v Speaker 1>I'm just looking it up.

00:55:57.905 --> 00:55:59.585
<v Speaker 1>Yeah. CBP patterns.

00:56:00.945 --> 00:56:02.225
<v Speaker 1>Second one. Yeah.

00:56:03.425 --> 00:56:04.065
<v Speaker 1>Yep.

00:56:04.385 --> 00:56:05.345
<v Speaker 1>This is a decent one.

00:56:06.960 --> 00:56:08.320
<v Speaker 1>It tells you what

00:56:08.880 --> 00:56:10.720
<v Speaker 1>version of the language

00:56:10.880 --> 00:56:12.960
<v Speaker 1>it allows, things like that.

00:56:14.160 --> 00:56:16.160
<v Speaker 1>Doesn't look like it's been updated for C

00:56:16.160 --> 00:56:17.440
<v Speaker 1>plus plus 20.

00:56:17.680 --> 00:56:18.000
<v Speaker 1>But,

00:56:19.434 --> 00:56:20.795
<v Speaker 1>yeah, things like this,

00:56:21.835 --> 00:56:23.914
<v Speaker 1>going to Stack Overflow, like the usual kind

00:56:23.914 --> 00:56:25.195
<v Speaker 1>of places you would look.

00:56:25.674 --> 00:56:28.714
<v Speaker 1>There's also the the hash include c plus

00:56:28.714 --> 00:56:29.915
<v Speaker 1>plus Discord,

00:56:29.994 --> 00:56:32.474
<v Speaker 1>which is a Discord community for

00:56:32.950 --> 00:56:35.190
<v Speaker 1>c plus plus focused on making, like, a

00:56:35.190 --> 00:56:36.950
<v Speaker 1>welcoming, inclusive environment.

00:56:37.350 --> 00:56:39.990
<v Speaker 1>That's always a great place to go and

00:56:40.230 --> 00:56:42.070
<v Speaker 1>say, like, hey. I've got this this code.

00:56:42.070 --> 00:56:43.750
<v Speaker 1>Is there a better way to do this?

00:56:43.910 --> 00:56:46.470
<v Speaker 1>There's always people there willing to to help

00:56:46.470 --> 00:56:48.335
<v Speaker 1>out. Why don't we flip that question a

00:56:48.335 --> 00:56:49.855
<v Speaker 0>little bit then? You know, you're you're quite

00:56:49.855 --> 00:56:52.015
<v Speaker 0>involved in this c plus plus community. So,

00:56:52.015 --> 00:56:54.015
<v Speaker 0>like, what are the the bigger conferences that

00:56:54.015 --> 00:56:55.295
<v Speaker 0>maybe people can check out some of the

00:56:55.295 --> 00:56:56.575
<v Speaker 0>talks that are coming out?

00:56:56.895 --> 00:56:59.769
<v Speaker 1>Sure. Like, the biggest one is CPP Con.

00:56:59.769 --> 00:57:01.849
<v Speaker 1>I just so happen to have this, like,

00:57:01.849 --> 00:57:02.570
<v Speaker 1>right here.

00:57:03.769 --> 00:57:06.410
<v Speaker 1>Yeah. CPP Con is usually in September. It's

00:57:06.410 --> 00:57:07.849
<v Speaker 1>gonna be October this year.

00:57:08.970 --> 00:57:10.410
<v Speaker 1>It usually has, like,

00:57:10.730 --> 00:57:11.849
<v Speaker 1>six, seven, eight

00:57:12.505 --> 00:57:15.145
<v Speaker 1>tracks, runs for about a week. It's a

00:57:15.145 --> 00:57:17.305
<v Speaker 1>it's a pretty big conference.

00:57:17.705 --> 00:57:18.825
<v Speaker 1>I think I gave

00:57:19.305 --> 00:57:21.465
<v Speaker 1>four talks there last year. Oh, wow.

00:57:22.345 --> 00:57:25.225
<v Speaker 1>One year, I gave I gave five talks

00:57:25.225 --> 00:57:25.545
<v Speaker 1>and,

00:57:26.390 --> 00:57:28.150
<v Speaker 1>like, helped run a panel and things like

00:57:28.150 --> 00:57:29.910
<v Speaker 1>that. I would not recommend doing that. It

00:57:29.910 --> 00:57:32.390
<v Speaker 1>was exhausting. Sounds like a stressful week.

00:57:32.870 --> 00:57:33.510
<v Speaker 1>Yeah.

00:57:33.670 --> 00:57:35.190
<v Speaker 1>Yeah. That's c b p con.

00:57:35.430 --> 00:57:38.150
<v Speaker 1>C plus plus now is probably the best

00:57:38.150 --> 00:57:39.110
<v Speaker 1>one for,

00:57:39.270 --> 00:57:40.790
<v Speaker 1>like, expert level content.

00:57:42.365 --> 00:57:45.244
<v Speaker 1>And then the smaller ones like c plus

00:57:45.244 --> 00:57:46.365
<v Speaker 1>plus on c,

00:57:46.605 --> 00:57:47.885
<v Speaker 1>CPPP,

00:57:48.444 --> 00:57:50.685
<v Speaker 1>which is the c plus plus Paris,

00:57:51.724 --> 00:57:54.125
<v Speaker 1>the Madrid c plus plus Spain one.

00:57:54.660 --> 00:57:56.900
<v Speaker 1>There's a bunch of of smaller conferences as

00:57:56.900 --> 00:57:58.099
<v Speaker 1>well. ACCU

00:57:58.099 --> 00:57:59.940
<v Speaker 1>as well has a bunch of really great

00:57:59.940 --> 00:58:01.060
<v Speaker 1>c plus plus content.

00:58:01.619 --> 00:58:04.180
<v Speaker 0>Right. Definitely no shortage then of c plus

00:58:04.180 --> 00:58:05.940
<v Speaker 0>plus content. Yeah. Yeah. Yeah. And the the

00:58:05.940 --> 00:58:07.780
<v Speaker 1>conferences are only growing as well. Like, there's

00:58:07.780 --> 00:58:10.565
<v Speaker 1>new obviously, not right now, but previously, there

00:58:10.565 --> 00:58:12.484
<v Speaker 1>were, like, new ones popping up pretty much

00:58:12.484 --> 00:58:13.205
<v Speaker 1>every year.

00:58:13.684 --> 00:58:14.484
<v Speaker 0>Awesome.

00:58:15.125 --> 00:58:15.845
<v Speaker 0>Okay.

00:58:16.805 --> 00:58:18.565
<v Speaker 0>Let's use the next kind of fifteen minutes

00:58:18.565 --> 00:58:20.805
<v Speaker 0>to maybe just tackle one more of these.

00:58:20.805 --> 00:58:22.644
<v Speaker 0>We won't go through all the test cases,

00:58:22.644 --> 00:58:24.484
<v Speaker 0>but maybe if we can pick something that

00:58:25.340 --> 00:58:26.700
<v Speaker 0>shows off a little bit more of the

00:58:26.700 --> 00:58:29.420
<v Speaker 0>language. Is there any features you would you

00:58:29.420 --> 00:58:30.700
<v Speaker 0>think would be nice to show and we

00:58:30.700 --> 00:58:32.700
<v Speaker 0>can try and find an exercise that uses

00:58:32.700 --> 00:58:33.260
<v Speaker 0>them?

00:58:34.220 --> 00:58:35.180
<v Speaker 1>Talking about

00:58:35.340 --> 00:58:37.180
<v Speaker 1>type inference would be good, but I feel

00:58:37.180 --> 00:58:38.700
<v Speaker 1>like we can build that in pretty much

00:58:38.700 --> 00:58:39.180
<v Speaker 1>anywhere.

00:58:42.535 --> 00:58:45.895
<v Speaker 0>Let's see. What about Nothing involving randomness, so

00:58:45.895 --> 00:58:47.815
<v Speaker 1>that I don't have to explain randomness in

00:58:47.815 --> 00:58:48.775
<v Speaker 0>c plus plus.

00:58:50.055 --> 00:58:53.015
<v Speaker 0>It says pattern recognition here. Is that pattern

00:58:53.015 --> 00:58:53.255
<v Speaker 0>matching?

00:58:53.940 --> 00:58:55.780
<v Speaker 1>For it. There is not pattern matching, but

00:58:55.780 --> 00:58:57.380
<v Speaker 1>at least we can we can talk about

00:58:57.380 --> 00:58:58.260
<v Speaker 1>that and

00:58:59.140 --> 00:59:01.140
<v Speaker 1>and what might be coming in the language.

00:59:02.180 --> 00:59:04.579
<v Speaker 0>Yeah. Okay. Well, let's see what we can

00:59:04.579 --> 00:59:06.020
<v Speaker 0>kinda make of it. Even if we go

00:59:06.020 --> 00:59:07.940
<v Speaker 0>a little bit off script, that's alright. So

00:59:07.940 --> 00:59:08.579
<v Speaker 0>let me

00:59:09.295 --> 00:59:10.415
<v Speaker 0>clone this one.

00:59:10.895 --> 00:59:12.975
<v Speaker 0>Jump over here. So what is it asking

00:59:12.975 --> 00:59:13.695
<v Speaker 0>for?

00:59:14.575 --> 00:59:17.455
<v Speaker 0>Once does to generate the lyrics of the

00:59:17.455 --> 00:59:19.855
<v Speaker 0>song, I know an old lady who swallowed

00:59:19.855 --> 00:59:20.575
<v Speaker 0>a fly.

00:59:21.535 --> 00:59:23.055
<v Speaker 0>Not a song I'm familiar with,

00:59:24.770 --> 00:59:27.810
<v Speaker 0>but it's a cumulative song of unknown origin.

00:59:30.369 --> 00:59:31.730
<v Speaker 0>Yeah. I have no idea what this is

00:59:31.730 --> 00:59:32.370
<v Speaker 0>asking.

00:59:33.650 --> 00:59:35.810
<v Speaker 1>Yeah. So I think the the song is

00:59:35.810 --> 00:59:38.755
<v Speaker 1>usually like you you have a line and

00:59:38.755 --> 00:59:40.915
<v Speaker 1>then in the next verse, you repeat

00:59:41.315 --> 00:59:42.994
<v Speaker 1>that line and then add a line. And

00:59:42.994 --> 00:59:44.994
<v Speaker 1>then in the first after that, you repeat

00:59:44.994 --> 00:59:46.675
<v Speaker 1>the first two and then another one. So

00:59:46.675 --> 00:59:48.595
<v Speaker 1>it's it's like building up

00:59:50.910 --> 00:59:51.950
<v Speaker 1>the song.

00:59:52.510 --> 00:59:53.230
<v Speaker 0>Okay.

00:59:53.630 --> 00:59:55.230
<v Speaker 0>Let's see if they give us any code

00:59:55.230 --> 00:59:56.670
<v Speaker 0>to start with, and then we'll make a

00:59:56.670 --> 00:59:57.390
<v Speaker 0>decision.

00:59:57.710 --> 00:59:58.350
<v Speaker 1>Yeah.

01:00:00.270 --> 01:00:02.829
<v Speaker 0>So we got our test case here. We're

01:00:02.829 --> 01:00:04.030
<v Speaker 0>expecting a string.

01:00:04.895 --> 01:00:07.375
<v Speaker 0>Alright. Okay. So we're calling the verse function

01:00:07.375 --> 01:00:08.895
<v Speaker 0>and we're giving it how many

01:00:10.815 --> 01:00:12.974
<v Speaker 0>verses we want out of our new lines

01:00:12.974 --> 01:00:14.575
<v Speaker 0>added to it, I guess.

01:00:15.135 --> 01:00:15.535
<v Speaker 1>Yep.

01:00:17.260 --> 01:00:18.860
<v Speaker 0>Let's see what we have. Oh, we get

01:00:18.860 --> 01:00:19.500
<v Speaker 0>nothing.

01:00:22.860 --> 01:00:25.020
<v Speaker 0>So it's a maybe we could just make

01:00:25.020 --> 01:00:26.540
<v Speaker 0>it up. Like, it doesn't matter if the

01:00:26.540 --> 01:00:28.460
<v Speaker 0>test pass, but maybe we can talk about

01:00:28.460 --> 01:00:30.780
<v Speaker 0>pattern recognition and maybe we can talk about

01:00:31.415 --> 01:00:33.575
<v Speaker 0>type inference as we go. Are you comfortable

01:00:33.575 --> 01:00:35.734
<v Speaker 0>kinda just making this up? Yeah. Yeah. Yeah.

01:00:35.734 --> 01:00:37.015
<v Speaker 1>We can just make something up.

01:00:38.455 --> 01:00:39.255
<v Speaker 1>So the

01:00:41.255 --> 01:00:42.455
<v Speaker 1>yeah. Type inference,

01:00:42.695 --> 01:00:43.975
<v Speaker 1>why don't we just make a function

01:00:45.270 --> 01:00:47.750
<v Speaker 1>which doesn't do any return anything? Just we've

01:00:47.750 --> 01:00:50.070
<v Speaker 1>got something to play with. Yeah. Void means

01:00:50.070 --> 01:00:53.190
<v Speaker 1>I'm a function which which doesn't return anything.

01:00:53.990 --> 01:00:55.910
<v Speaker 1>Void is like a special type in c

01:00:55.910 --> 01:00:57.110
<v Speaker 1>plus plus It's

01:00:57.515 --> 01:01:00.155
<v Speaker 1>not quite a unit type if you're familiar

01:01:00.155 --> 01:01:02.555
<v Speaker 1>with the concept of unit type, but it's

01:01:04.235 --> 01:01:05.355
<v Speaker 1>the the

01:01:05.355 --> 01:01:07.515
<v Speaker 1>closest that c plus plus has, basically.

01:01:08.955 --> 01:01:10.955
<v Speaker 1>So so type inference in c plus plus,

01:01:10.955 --> 01:01:13.740
<v Speaker 1>like, previously, we've been declaring variables

01:01:13.740 --> 01:01:16.220
<v Speaker 1>by writing their type and then a name

01:01:16.220 --> 01:01:17.740
<v Speaker 1>and then an initializer.

01:01:17.900 --> 01:01:19.500
<v Speaker 1>You can also write auto

01:01:20.380 --> 01:01:21.900
<v Speaker 1>instead of a type. So if we write

01:01:21.900 --> 01:01:22.860
<v Speaker 1>auto here,

01:01:23.740 --> 01:01:24.620
<v Speaker 1>and then

01:01:25.905 --> 01:01:27.745
<v Speaker 1>name, yeah, equals

01:01:28.065 --> 01:01:28.705
<v Speaker 1>yep.

01:01:30.305 --> 01:01:34.065
<v Speaker 1>So this will based on the type of

01:01:34.065 --> 01:01:35.345
<v Speaker 1>the initializer,

01:01:35.905 --> 01:01:37.265
<v Speaker 1>will deduce

01:01:39.150 --> 01:01:41.630
<v Speaker 1>a type for that variable.

01:01:43.549 --> 01:01:46.510
<v Speaker 1>So this uses the same rules as as

01:01:46.510 --> 01:01:47.390
<v Speaker 1>templates

01:01:47.470 --> 01:01:48.109
<v Speaker 1>do,

01:01:48.349 --> 01:01:50.589
<v Speaker 1>which is kind of nice in in the

01:01:50.589 --> 01:01:53.154
<v Speaker 1>way that the it's like that this came

01:01:53.154 --> 01:01:55.154
<v Speaker 1>in c plus plus 11, kind of reused

01:01:55.154 --> 01:01:57.075
<v Speaker 1>a lot of the the existing rules in

01:01:57.075 --> 01:01:57.795
<v Speaker 1>the language.

01:01:58.515 --> 01:02:00.994
<v Speaker 1>But, basically, when when you're using

01:02:01.555 --> 01:02:03.234
<v Speaker 1>more complex c plus plus, you end up

01:02:03.234 --> 01:02:05.395
<v Speaker 1>with really, really, really long types.

01:02:06.210 --> 01:02:07.890
<v Speaker 1>You know, it might be like a

01:02:09.010 --> 01:02:10.530
<v Speaker 1>vector of

01:02:10.770 --> 01:02:11.970
<v Speaker 1>the iterator

01:02:11.970 --> 01:02:12.849
<v Speaker 1>types

01:02:12.849 --> 01:02:15.250
<v Speaker 1>for a vector of integers, and you don't

01:02:15.250 --> 01:02:17.250
<v Speaker 1>wanna write that type yourself.

01:02:17.330 --> 01:02:17.890
<v Speaker 1>So

01:02:19.155 --> 01:02:21.635
<v Speaker 1>we now allow you to write auto

01:02:21.715 --> 01:02:23.315
<v Speaker 1>in there, and it will work out the

01:02:23.315 --> 01:02:25.395
<v Speaker 1>type from the initializer.

01:02:25.395 --> 01:02:26.355
<v Speaker 1>It's

01:02:26.355 --> 01:02:29.075
<v Speaker 1>not like Rust in the it will, like,

01:02:29.075 --> 01:02:30.675
<v Speaker 1>look how you use

01:02:30.835 --> 01:02:31.955
<v Speaker 1>the the variable

01:02:32.360 --> 01:02:34.040
<v Speaker 1>downwards in the function. You know, like in

01:02:34.040 --> 01:02:36.280
<v Speaker 1>in Rust, you can say, I have a

01:02:36.520 --> 01:02:37.800
<v Speaker 1>this is a vec,

01:02:37.960 --> 01:02:41.320
<v Speaker 1>and later on, you, like, assign an int

01:02:41.320 --> 01:02:43.400
<v Speaker 1>into it, then it, like, looks forward and

01:02:43.400 --> 01:02:44.920
<v Speaker 1>says, oh, later on, you use an int,

01:02:44.920 --> 01:02:46.600
<v Speaker 1>so this must be a a vector of

01:02:46.600 --> 01:02:49.325
<v Speaker 1>of integers. And c plus plus is has

01:02:49.325 --> 01:02:49.965
<v Speaker 1>to be

01:02:51.005 --> 01:02:53.565
<v Speaker 1>based on the type of the initializer,

01:02:54.525 --> 01:02:56.045
<v Speaker 1>but it just it cleans up so much

01:02:56.045 --> 01:02:57.725
<v Speaker 1>code. And you can use this in

01:02:59.085 --> 01:03:01.085
<v Speaker 1>in range space for loops as well. Like,

01:03:01.085 --> 01:03:03.005
<v Speaker 1>earlier, we wrote char c,

01:03:04.280 --> 01:03:06.200
<v Speaker 1>which was the the type which we were

01:03:06.200 --> 01:03:08.040
<v Speaker 1>iterating over. But you could just write auto

01:03:08.040 --> 01:03:09.720
<v Speaker 1>there, it will work out for you.

01:03:10.040 --> 01:03:12.120
<v Speaker 0>So you're saying we could have done

01:03:12.440 --> 01:03:13.880
<v Speaker 0>auto c

01:03:14.600 --> 01:03:15.480
<v Speaker 0>name

01:03:15.880 --> 01:03:16.680
<v Speaker 1>Exactly.

01:03:16.680 --> 01:03:19.015
<v Speaker 1>Yep. And then whatever the

01:03:20.855 --> 01:03:21.575
<v Speaker 0>okay.

01:03:22.215 --> 01:03:24.455
<v Speaker 0>Yep. It seems to be complaining

01:03:24.615 --> 01:03:26.775
<v Speaker 0>about my supposed to type as missing and

01:03:26.775 --> 01:03:27.655
<v Speaker 0>assumed.

01:03:27.975 --> 01:03:29.335
<v Speaker 0>Yeah. But when I hover over,

01:03:29.840 --> 01:03:32.000
<v Speaker 0>is that just my editor again, maybe? Yeah.

01:03:32.000 --> 01:03:33.600
<v Speaker 1>I think it's just your editor. The the

01:03:33.600 --> 01:03:35.920
<v Speaker 1>compiler would be happy with that. Okay.

01:03:36.480 --> 01:03:37.920
<v Speaker 1>Oh, maybe something else we can talk about

01:03:37.920 --> 01:03:38.880
<v Speaker 1>is references.

01:03:39.520 --> 01:03:40.160
<v Speaker 1>Yeah.

01:03:40.560 --> 01:03:41.520
<v Speaker 1>So

01:03:42.405 --> 01:03:43.445
<v Speaker 1>if we

01:03:43.765 --> 01:03:45.685
<v Speaker 1>well, we write two functions.

01:03:50.165 --> 01:03:50.805
<v Speaker 1>Yeah.

01:03:52.485 --> 01:03:54.885
<v Speaker 1>And make that one take a string.

01:03:58.990 --> 01:04:00.589
<v Speaker 1>Yep. And then

01:04:01.390 --> 01:04:02.430
<v Speaker 1>write another

01:04:02.430 --> 01:04:03.230
<v Speaker 1>function

01:04:03.630 --> 01:04:05.630
<v Speaker 1>called, yeah, whatever.

01:04:06.269 --> 01:04:07.230
<v Speaker 1>Another one.

01:04:07.950 --> 01:04:10.910
<v Speaker 1>Some other. Yeah. Okay. And make that one

01:04:11.309 --> 01:04:14.875
<v Speaker 1>take a Std string ref, so ampersand.

01:04:15.035 --> 01:04:18.154
<v Speaker 0>Oh, ampersand. On the variable name or before

01:04:18.154 --> 01:04:19.355
<v Speaker 0>the standard string?

01:04:20.474 --> 01:04:23.275
<v Speaker 1>It's yeah. After standard string, it can be

01:04:23.355 --> 01:04:24.714
<v Speaker 1>it doesn't matter which side of the space

01:04:24.714 --> 01:04:25.994
<v Speaker 1>you put it on. Oh, okay.

01:04:26.769 --> 01:04:28.130
<v Speaker 1>Yep. So

01:04:29.089 --> 01:04:30.210
<v Speaker 1>these are

01:04:30.849 --> 01:04:34.529
<v Speaker 1>two different functions. Another takes the string by

01:04:34.529 --> 01:04:39.009
<v Speaker 1>value, which means that the inside another hello

01:04:39.009 --> 01:04:42.335
<v Speaker 1>is some completely new string, which is completely

01:04:42.335 --> 01:04:43.535
<v Speaker 1>separate from

01:04:44.015 --> 01:04:46.575
<v Speaker 1>any of the context outside the function. So

01:04:46.575 --> 01:04:50.255
<v Speaker 1>if we pass, say, our our name from

01:04:50.415 --> 01:04:52.815
<v Speaker 1>inside our hello function, the the David thing

01:04:52.815 --> 01:04:53.935
<v Speaker 1>into another,

01:04:54.095 --> 01:04:54.655
<v Speaker 1>then

01:04:55.660 --> 01:04:58.300
<v Speaker 1>nothing can ever happen to that name.

01:04:59.420 --> 01:05:02.220
<v Speaker 1>Yeah. It will be the the copy inside

01:05:02.220 --> 01:05:04.300
<v Speaker 1>of another is is something completely separate.

01:05:04.540 --> 01:05:06.700
<v Speaker 1>The version of some other, however,

01:05:07.020 --> 01:05:08.620
<v Speaker 1>has the ampersand

01:05:08.985 --> 01:05:09.705
<v Speaker 1>after,

01:05:10.585 --> 01:05:13.065
<v Speaker 1>after the string. This will actually not compile.

01:05:13.065 --> 01:05:14.745
<v Speaker 1>I'll get to that in a second. But,

01:05:16.265 --> 01:05:18.105
<v Speaker 1>when we put an ampersand after a type,

01:05:18.105 --> 01:05:20.105
<v Speaker 1>that means that it's a a reference to

01:05:21.400 --> 01:05:22.840
<v Speaker 1>that type. It's not,

01:05:23.160 --> 01:05:24.200
<v Speaker 1>a copy.

01:05:24.280 --> 01:05:25.000
<v Speaker 1>It's

01:05:25.160 --> 01:05:27.400
<v Speaker 1>like an alias for something else.

01:05:28.440 --> 01:05:31.320
<v Speaker 1>So in c plus plus references are mutable

01:05:31.320 --> 01:05:33.640
<v Speaker 1>by default. So if you pass

01:05:33.494 --> 01:05:36.134
<v Speaker 1>some string into some other, then some other

01:05:36.134 --> 01:05:39.494
<v Speaker 1>could, for example, change the first character of

01:05:39.575 --> 01:05:41.734
<v Speaker 1>of the name, or it could append

01:05:41.974 --> 01:05:44.934
<v Speaker 1>some additional data onto it. This is how

01:05:44.934 --> 01:05:45.255
<v Speaker 1>you,

01:05:46.710 --> 01:05:49.510
<v Speaker 1>you can, like, mutate things while passing them

01:05:49.590 --> 01:05:52.070
<v Speaker 1>around functions. And then if you wanted to

01:05:52.070 --> 01:05:53.350
<v Speaker 1>make it a

01:05:54.390 --> 01:05:56.470
<v Speaker 1>reference but you cannot change it, then you

01:05:56.470 --> 01:05:57.750
<v Speaker 1>would do const

01:05:57.750 --> 01:05:59.350
<v Speaker 1>std string ref,

01:05:59.750 --> 01:06:01.750
<v Speaker 1>in in the declaration of some other.

01:06:04.055 --> 01:06:06.135
<v Speaker 0>Okay. Mind if I ask a few questions?

01:06:06.375 --> 01:06:08.454
<v Speaker 1>Yeah. Go ahead. Okay. So if I hover

01:06:08.454 --> 01:06:10.694
<v Speaker 0>over David here, it's kind of the type

01:06:10.694 --> 01:06:12.375
<v Speaker 0>of inference is maybe suggesting that this is

01:06:12.375 --> 01:06:13.975
<v Speaker 0>a const char six,

01:06:14.214 --> 01:06:16.135
<v Speaker 0>but it doesn't seem to mind me passing

01:06:16.135 --> 01:06:18.830
<v Speaker 0>that as a standard string. Is there some

01:06:18.830 --> 01:06:21.550
<v Speaker 0>type juggling happening here? Yep. So

01:06:22.350 --> 01:06:23.790
<v Speaker 1>c plus plus has

01:06:23.950 --> 01:06:24.910
<v Speaker 1>implicit

01:06:24.910 --> 01:06:25.950
<v Speaker 1>conversions,

01:06:26.270 --> 01:06:28.350
<v Speaker 1>which is basically, in some cases,

01:06:28.830 --> 01:06:29.470
<v Speaker 1>you can

01:06:30.355 --> 01:06:31.315
<v Speaker 1>pass,

01:06:31.715 --> 01:06:33.315
<v Speaker 1>you can initialize,

01:06:33.795 --> 01:06:36.195
<v Speaker 1>some object with an object of a different

01:06:36.195 --> 01:06:36.755
<v Speaker 1>type.

01:06:37.075 --> 01:06:40.355
<v Speaker 1>And as long as there is some conversion

01:06:40.355 --> 01:06:41.075
<v Speaker 1>function

01:06:41.315 --> 01:06:43.715
<v Speaker 1>which can convert between the two implicitly,

01:06:43.715 --> 01:06:45.579
<v Speaker 1>then it will just work, and it will

01:06:45.579 --> 01:06:47.740
<v Speaker 1>do some magic to to convert it. And

01:06:47.740 --> 01:06:49.420
<v Speaker 1>there's a few different ways that you can

01:06:49.420 --> 01:06:50.300
<v Speaker 1>specify

01:06:50.300 --> 01:06:51.420
<v Speaker 1>those conversions.

01:06:52.619 --> 01:06:54.300
<v Speaker 1>So converting

01:06:54.300 --> 01:06:55.020
<v Speaker 1>a,

01:06:55.500 --> 01:06:58.825
<v Speaker 1>string literal to a std::string is one of

01:06:58.825 --> 01:07:01.705
<v Speaker 1>those cases where there is an implicit conversion

01:07:01.705 --> 01:07:03.065
<v Speaker 1>function, which will,

01:07:03.865 --> 01:07:06.585
<v Speaker 1>take the contents of the the string literal

01:07:06.585 --> 01:07:08.985
<v Speaker 1>and copy them internally into

01:07:09.065 --> 01:07:11.305
<v Speaker 1>a std::string, and that will potentially

01:07:11.305 --> 01:07:14.220
<v Speaker 1>allocate some memory dynamically,

01:07:14.220 --> 01:07:15.580
<v Speaker 1>which will then be freed when the std

01:07:15.580 --> 01:07:17.260
<v Speaker 1>string is is destroyed.

01:07:18.060 --> 01:07:19.340
<v Speaker 0>Right. Okay.

01:07:19.980 --> 01:07:22.940
<v Speaker 0>So if I were to implement my own

01:07:23.180 --> 01:07:25.340
<v Speaker 0>type in c plus plus and I wanted

01:07:25.340 --> 01:07:26.815
<v Speaker 0>to be able to convert it to a

01:07:26.815 --> 01:07:28.815
<v Speaker 0>string that would just be implementing a function

01:07:28.815 --> 01:07:32.175
<v Speaker 0>on Exactly. Right. Okay. Yep. And

01:07:33.535 --> 01:07:36.175
<v Speaker 1>implicit conversions are a little bit contentious because,

01:07:37.215 --> 01:07:38.655
<v Speaker 1>you know, in some places like this, they're

01:07:38.655 --> 01:07:40.095
<v Speaker 1>super useful. Like, of course, you wanna be

01:07:40.095 --> 01:07:41.055
<v Speaker 1>able to convert a

01:07:41.490 --> 01:07:44.290
<v Speaker 1>a string literal into a string. Like, that's

01:07:44.290 --> 01:07:46.370
<v Speaker 1>something which is is really useful to do.

01:07:46.530 --> 01:07:47.250
<v Speaker 1>In

01:07:47.330 --> 01:07:49.490
<v Speaker 1>some other places, like, they seem like they

01:07:49.490 --> 01:07:52.290
<v Speaker 1>might be ergonomic. They might make things easier,

01:07:52.290 --> 01:07:54.610
<v Speaker 1>but you can run into to issues where

01:07:54.610 --> 01:07:57.045
<v Speaker 1>you get, like, inputs and conversions where you

01:07:57.045 --> 01:07:59.765
<v Speaker 1>maybe didn't want them, and it can cause

01:07:59.765 --> 01:08:02.325
<v Speaker 1>some some additional errors which are really, really

01:08:02.325 --> 01:08:04.645
<v Speaker 1>difficult to see because, like like you said,

01:08:04.645 --> 01:08:06.885
<v Speaker 1>you you see that you can pass this,

01:08:07.125 --> 01:08:09.050
<v Speaker 1>thing of a different type to another function,

01:08:09.050 --> 01:08:11.530
<v Speaker 1>and it just works. Some some magic happens,

01:08:11.530 --> 01:08:14.410
<v Speaker 1>but it's not obvious that there's a conversion

01:08:14.410 --> 01:08:16.649
<v Speaker 1>happening here. You you have to know

01:08:17.050 --> 01:08:17.689
<v Speaker 1>that

01:08:17.930 --> 01:08:20.090
<v Speaker 1>the that these two types are different and

01:08:20.090 --> 01:08:21.930
<v Speaker 1>if there's some way to convert between them

01:08:21.930 --> 01:08:23.995
<v Speaker 1>to know that there's a conversion happening, it's

01:08:23.995 --> 01:08:25.915
<v Speaker 1>not clear from looking at the code.

01:08:26.795 --> 01:08:27.514
<v Speaker 0>Awesome.

01:08:27.915 --> 01:08:29.675
<v Speaker 0>Alright. I'll throw one more. We don't need

01:08:29.675 --> 01:08:31.354
<v Speaker 0>the code up anymore, I don't think, unless

01:08:31.354 --> 01:08:33.515
<v Speaker 0>we wanna jump back. But I'll throw one

01:08:33.515 --> 01:08:35.114
<v Speaker 0>more question at you just because, again, I

01:08:35.114 --> 01:08:36.234
<v Speaker 0>have curiosity.

01:08:36.234 --> 01:08:38.340
<v Speaker 0>Like, we've been now writing c plus plus

01:08:38.340 --> 01:08:40.020
<v Speaker 0>for a little over an hour,

01:08:40.340 --> 01:08:42.580
<v Speaker 0>and we haven't typed a single class.

01:08:43.300 --> 01:08:44.020
<v Speaker 0>Is

01:08:44.420 --> 01:08:46.979
<v Speaker 0>that normal in modern c plus plus that

01:08:46.979 --> 01:08:50.340
<v Speaker 0>you use maybe just functions within namespaces,

01:08:50.340 --> 01:08:51.780
<v Speaker 0>or does it just, again, come down to

01:08:51.780 --> 01:08:54.425
<v Speaker 0>the domain that we're actually building something out?

01:08:54.665 --> 01:08:56.904
<v Speaker 1>Yeah. It definitely comes down to the domain.

01:08:57.944 --> 01:08:59.224
<v Speaker 1>A lot of the power of c plus

01:08:59.224 --> 01:09:02.024
<v Speaker 1>plus comes from the ability to

01:09:02.904 --> 01:09:04.425
<v Speaker 1>create your own

01:09:06.050 --> 01:09:08.369
<v Speaker 1>to work at the level of your domain

01:09:08.369 --> 01:09:10.129
<v Speaker 1>without having to pay,

01:09:10.849 --> 01:09:13.409
<v Speaker 1>runtime cost in order to do that. So

01:09:13.409 --> 01:09:16.050
<v Speaker 1>what that means is creating your own types,

01:09:16.050 --> 01:09:17.809
<v Speaker 1>which express, you know, your

01:09:18.215 --> 01:09:20.295
<v Speaker 1>your business logic or whatever you wanna call

01:09:20.295 --> 01:09:20.774
<v Speaker 1>it,

01:09:22.135 --> 01:09:25.974
<v Speaker 1>being able to write templates which abstract,

01:09:26.295 --> 01:09:28.454
<v Speaker 1>common behaviors of your types,

01:09:29.175 --> 01:09:30.294
<v Speaker 1>being able to

01:09:31.175 --> 01:09:31.894
<v Speaker 1>create,

01:09:32.375 --> 01:09:33.414
<v Speaker 1>code which

01:09:34.110 --> 01:09:36.990
<v Speaker 1>can sometimes read, like, the operations you want

01:09:36.990 --> 01:09:38.670
<v Speaker 1>to do, but will, like,

01:09:40.110 --> 01:09:42.350
<v Speaker 1>compile to a bunch more code under the

01:09:42.350 --> 01:09:43.069
<v Speaker 1>hood.

01:09:43.790 --> 01:09:45.470
<v Speaker 1>But you don't have to, like, handle that,

01:09:45.470 --> 01:09:46.910
<v Speaker 1>but it will happen in a way which

01:09:46.910 --> 01:09:47.390
<v Speaker 1>is

01:09:48.244 --> 01:09:50.404
<v Speaker 1>which still gives you the performance that you

01:09:50.404 --> 01:09:53.284
<v Speaker 1>need. So the the the common term that's

01:09:53.284 --> 01:09:55.925
<v Speaker 1>used is zero overhead abstractions

01:09:56.085 --> 01:09:59.364
<v Speaker 1>Yeah. Which is another, like, slightly contentious term

01:09:59.364 --> 01:10:01.445
<v Speaker 1>in the community. But, basically, it means that

01:10:01.730 --> 01:10:04.770
<v Speaker 1>being able to write code a high level

01:10:04.770 --> 01:10:08.130
<v Speaker 1>of abstraction without paying undue performance cost.

01:10:08.770 --> 01:10:09.570
<v Speaker 0>Awesome.

01:10:10.370 --> 01:10:12.449
<v Speaker 0>Well, thank you very much for joining me

01:10:12.449 --> 01:10:15.185
<v Speaker 0>today. It's been really good fun learning c

01:10:15.185 --> 01:10:17.105
<v Speaker 0>plus plus. I'm really glad that we can,

01:10:17.105 --> 01:10:19.425
<v Speaker 0>you know, understand or dug into the tooling

01:10:19.425 --> 01:10:21.185
<v Speaker 0>a little bit. I had no idea about

01:10:21.185 --> 01:10:22.065
<v Speaker 0>CMake.

01:10:23.105 --> 01:10:24.705
<v Speaker 0>Really cool to see the way the tests

01:10:24.705 --> 01:10:26.465
<v Speaker 0>were structured and then just a few nice

01:10:26.465 --> 01:10:29.260
<v Speaker 0>implementation details of just to

01:10:29.980 --> 01:10:31.980
<v Speaker 0>acquaint myself with the language. But I I

01:10:31.980 --> 01:10:33.500
<v Speaker 0>feel like I understand things a lot better

01:10:33.500 --> 01:10:35.580
<v Speaker 0>now, and you've been into quite a fair

01:10:35.580 --> 01:10:37.100
<v Speaker 0>amount of detail on some of those features

01:10:37.100 --> 01:10:39.020
<v Speaker 0>features as well. So I just wanna say

01:10:39.020 --> 01:10:40.699
<v Speaker 0>thank you very much because it was really

01:10:40.699 --> 01:10:43.324
<v Speaker 0>good fun. Yeah. Thanks for having me. Alright.

01:10:43.324 --> 01:10:45.324
<v Speaker 0>Well, you have a wonderful day. Thank you

01:10:45.324 --> 01:10:47.645
<v Speaker 0>again. Thank you to our audience for watching.

01:10:47.645 --> 01:10:49.485
<v Speaker 0>Do you have any last words before I

01:10:49.485 --> 01:10:50.445
<v Speaker 0>I say goodbye?

01:10:51.645 --> 01:10:52.684
<v Speaker 1>No. I think

01:10:54.045 --> 01:10:55.645
<v Speaker 1>if you're interested in,

01:10:57.410 --> 01:10:59.970
<v Speaker 1>like, learning modern c plus plus, I would

01:10:59.970 --> 01:11:01.170
<v Speaker 1>have a look at,

01:11:02.690 --> 01:11:06.290
<v Speaker 1>Kate Gregory's Pluralsight courses. They are are really

01:11:06.290 --> 01:11:07.170
<v Speaker 1>good and

01:11:07.410 --> 01:11:09.330
<v Speaker 1>teach, like, modern c plus plus,

01:11:09.810 --> 01:11:11.490
<v Speaker 1>for for beginners in a way, which I

01:11:11.490 --> 01:11:13.344
<v Speaker 1>really like. There's a bunch of really good

01:11:13.344 --> 01:11:14.144
<v Speaker 1>books,

01:11:15.425 --> 01:11:15.824
<v Speaker 1>like,

01:11:16.465 --> 01:11:18.545
<v Speaker 1>true c plus plus is now updated for

01:11:18.545 --> 01:11:20.065
<v Speaker 1>c plus plus 17, I think. I can't

01:11:20.065 --> 01:11:21.585
<v Speaker 1>remember how much c plus plus 20 is

01:11:21.585 --> 01:11:22.144
<v Speaker 1>in there.

01:11:23.185 --> 01:11:25.290
<v Speaker 1>But, also, if you're, like you've done c

01:11:25.290 --> 01:11:29.050
<v Speaker 1>plus plus before and you are interested in,

01:11:29.050 --> 01:11:31.690
<v Speaker 1>like, how c plus plus 20 will change

01:11:31.690 --> 01:11:32.249
<v Speaker 1>things,

01:11:33.050 --> 01:11:35.449
<v Speaker 1>I'm really interested in, like, making good resources

01:11:35.449 --> 01:11:37.449
<v Speaker 1>for this because we're we're still in the

01:11:37.449 --> 01:11:39.485
<v Speaker 1>the education phase of this. Like, c plus

01:11:39.485 --> 01:11:40.685
<v Speaker 1>plus 20 is kind of new, and it

01:11:40.685 --> 01:11:42.205
<v Speaker 1>comes with a lot of really new,

01:11:42.685 --> 01:11:45.085
<v Speaker 1>like, big features which can really change the

01:11:45.085 --> 01:11:47.405
<v Speaker 1>way that we write c plus plus. Like,

01:11:47.405 --> 01:11:49.165
<v Speaker 1>we we talked about ranges and being able

01:11:49.165 --> 01:11:51.005
<v Speaker 1>to compose these in in a way which

01:11:51.005 --> 01:11:52.925
<v Speaker 1>you might be familiar with from from other

01:11:52.925 --> 01:11:55.520
<v Speaker 1>languages, like chaining iterators in Rust or whatever.

01:11:56.720 --> 01:11:58.320
<v Speaker 1>So, yeah, keep your eye out for resources

01:11:58.320 --> 01:12:00.480
<v Speaker 1>on that, and let me know if there's

01:12:00.480 --> 01:12:03.360
<v Speaker 1>anything that you're particularly interested in because,

01:12:03.680 --> 01:12:05.680
<v Speaker 1>yeah, I wanna, like, make good stuff on

01:12:05.680 --> 01:12:05.840
<v Speaker 1>this.

01:12:06.875 --> 01:12:08.955
<v Speaker 0>Alright. Well, I will make sure I include

01:12:08.955 --> 01:12:10.635
<v Speaker 0>a link to your YouTube channel and to

01:12:10.635 --> 01:12:12.475
<v Speaker 0>that Pluralsight course and all of those other

01:12:12.475 --> 01:12:14.795
<v Speaker 0>super plus reference websites that we mentioned at

01:12:14.795 --> 01:12:17.034
<v Speaker 0>the session. They'll all be in the description.

01:12:17.195 --> 01:12:18.715
<v Speaker 0>And thank you again. Have a great day,

01:12:18.715 --> 01:12:20.315
<v Speaker 0>Cy. Yeah. Thanks. See you. Bye.
