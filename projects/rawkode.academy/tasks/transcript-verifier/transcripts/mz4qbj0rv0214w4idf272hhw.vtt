WEBVTT

NOTE
Transcription provided by Deepgram
Request Id: 873cfeb0-7722-413f-96fe-2eb14bece594
Created: 2025-04-29T20:51:47.545Z
Duration: 5615.0327
Channels: 1

00:01:06.465 --> 00:01:09.265
<v Speaker 0>Hello, and welcome to another episode of Rawkode

00:01:09.265 --> 00:01:11.344
<v Speaker 0>live. I'm your host, Rawkode.

00:01:11.585 --> 00:01:14.465
<v Speaker 0>Today, we're gonna be continuing our exploration into

00:01:14.465 --> 00:01:16.784
<v Speaker 0>the Rust programming language. Now before we do

00:01:16.784 --> 00:01:18.545
<v Speaker 0>that, I just wanna take ten seconds to

00:01:18.545 --> 00:01:20.500
<v Speaker 0>say thank you to my employer. I work

00:01:20.500 --> 00:01:22.340
<v Speaker 0>for a company called Equinix Metal, and we

00:01:22.340 --> 00:01:24.180
<v Speaker 0>are a bare metal cloud company. If you

00:01:24.180 --> 00:01:26.580
<v Speaker 0>wanna check out Equinix Metal, there is $50

00:01:26.580 --> 00:01:28.180
<v Speaker 0>coupon for anyone that wants it. It is

00:01:28.180 --> 00:01:29.780
<v Speaker 0>Rawkode dash live.

00:01:29.860 --> 00:01:31.620
<v Speaker 0>And that's actually around one hundred hours of

00:01:31.620 --> 00:01:33.780
<v Speaker 0>bare metal compute time. So please enjoy.

00:01:34.605 --> 00:01:37.005
<v Speaker 0>Today, I am joined by

00:01:37.565 --> 00:01:40.285
<v Speaker 0>Jane Leslie. Hello, Jane. How are you? I'm

00:01:40.285 --> 00:01:40.765
<v Speaker 1>good.

00:01:41.245 --> 00:01:43.565
<v Speaker 0>So you are the organizer

00:01:43.565 --> 00:01:46.365
<v Speaker 0>of the awesome Rust Mentor Project and the

00:01:46.365 --> 00:01:48.925
<v Speaker 0>lead of the Rust Error Handling Working Group.

00:01:49.470 --> 00:01:50.110
<v Speaker 1>Yeah.

00:01:50.270 --> 00:01:51.710
<v Speaker 0>Do you want to give us a little

00:01:51.710 --> 00:01:53.630
<v Speaker 0>bit more information on you? And then maybe

00:01:53.630 --> 00:01:55.630
<v Speaker 0>we'll talk about those two projects as well.

00:01:55.950 --> 00:01:59.150
<v Speaker 1>Sure. Yeah. I've been programming with Rust for,

00:01:59.310 --> 00:01:59.790
<v Speaker 1>like,

00:02:00.590 --> 00:02:02.670
<v Speaker 1>two it's two or three years now. I

00:02:02.670 --> 00:02:04.190
<v Speaker 1>think it's been almost

00:02:04.190 --> 00:02:04.910
<v Speaker 1>three years now.

00:02:06.965 --> 00:02:09.445
<v Speaker 1>And I, you know, I got real into

00:02:09.445 --> 00:02:10.325
<v Speaker 1>error handling

00:02:10.485 --> 00:02:12.725
<v Speaker 1>because of, like, this library that I wrote

00:02:12.725 --> 00:02:14.725
<v Speaker 1>that I want to open source. And I

00:02:14.725 --> 00:02:16.485
<v Speaker 1>was I was kind of unhappy with the

00:02:16.485 --> 00:02:18.165
<v Speaker 1>error handling approach and just tried to fix

00:02:18.165 --> 00:02:19.845
<v Speaker 1>it and ended up realizing that it was,

00:02:19.845 --> 00:02:23.010
<v Speaker 1>like, ecosystem wide problems. And now I'm, like,

00:02:23.090 --> 00:02:25.090
<v Speaker 1>you know, leading the project group, trying to

00:02:25.090 --> 00:02:27.410
<v Speaker 1>fix the annoyances that that still

00:02:27.490 --> 00:02:29.090
<v Speaker 1>haunt that project.

00:02:29.730 --> 00:02:30.450
<v Speaker 1>And so,

00:02:30.930 --> 00:02:32.130
<v Speaker 1>yeah, I'm really into Rust

00:02:32.625 --> 00:02:33.265
<v Speaker 1>and

00:02:33.905 --> 00:02:35.985
<v Speaker 1>excited to help out.

00:02:36.385 --> 00:02:37.185
<v Speaker 0>Awesome.

00:02:37.185 --> 00:02:39.665
<v Speaker 0>And what about the awesome Rust mentors project?

00:02:39.665 --> 00:02:41.025
<v Speaker 0>Do wanna tell us a little bit about

00:02:41.025 --> 00:02:44.144
<v Speaker 0>that? Yeah. So that's just it's like a

00:02:44.144 --> 00:02:46.625
<v Speaker 1>list of people who are interested in mentoring

00:02:46.625 --> 00:02:48.385
<v Speaker 1>anyone who's interested in learning Rust.

00:02:49.200 --> 00:02:50.720
<v Speaker 1>So there's like it's just got a bunch

00:02:50.720 --> 00:02:52.480
<v Speaker 1>of people, their contact info,

00:02:52.800 --> 00:02:54.160
<v Speaker 1>kind of like the domains

00:02:54.800 --> 00:02:56.720
<v Speaker 1>of Rust that they're interested in, like, they're

00:02:56.720 --> 00:02:59.200
<v Speaker 1>interested in, like, async a wait, CLI applications,

00:02:59.200 --> 00:02:59.760
<v Speaker 1>etcetera etcetera,

00:03:00.575 --> 00:03:02.895
<v Speaker 1>and maybe some, like, background resources, so, like,

00:03:02.895 --> 00:03:04.495
<v Speaker 1>links to their blog and whatnot.

00:03:05.135 --> 00:03:06.815
<v Speaker 1>If you're, like, learning Rust and you, like,

00:03:06.815 --> 00:03:08.495
<v Speaker 1>just wanna kinda, like, get connected with the

00:03:08.495 --> 00:03:09.775
<v Speaker 1>community, I think it's a really good way

00:03:09.775 --> 00:03:11.775
<v Speaker 1>to, like, get to know people, especially, like,

00:03:11.775 --> 00:03:13.695
<v Speaker 1>some of the friendlier people in the community

00:03:13.695 --> 00:03:15.935
<v Speaker 1>are I think are I may be biased,

00:03:16.230 --> 00:03:17.830
<v Speaker 1>but I think these are the, you know,

00:03:17.830 --> 00:03:19.190
<v Speaker 1>the the good people.

00:03:20.390 --> 00:03:21.430
<v Speaker 1>And a lot of them are obviously or

00:03:21.430 --> 00:03:23.270
<v Speaker 1>my friends, probably unsurprisingly.

00:03:23.830 --> 00:03:25.510
<v Speaker 1>Though I do have lots of friends across

00:03:25.510 --> 00:03:27.269
<v Speaker 1>the Rust community because, like, you know, that's

00:03:27.269 --> 00:03:28.069
<v Speaker 1>where I hang out nowadays.

00:03:28.565 --> 00:03:28.805
<v Speaker 1>So

00:03:29.445 --> 00:03:31.605
<v Speaker 0>Yeah. I've gotta say as someone relatively new,

00:03:31.605 --> 00:03:34.005
<v Speaker 0>the Rust community has been extremely welcoming and

00:03:34.005 --> 00:03:36.245
<v Speaker 0>very helpful with all their content and the

00:03:36.245 --> 00:03:38.805
<v Speaker 0>conferences and the talks and example repositories.

00:03:38.805 --> 00:03:40.725
<v Speaker 0>Like, it's just a very welcoming place to

00:03:40.725 --> 00:03:41.285
<v Speaker 0>be. Yes.

00:03:41.970 --> 00:03:44.129
<v Speaker 0>For anyone who's not familiar, you can find

00:03:44.129 --> 00:03:46.450
<v Speaker 0>the awesome Rust mentors project on GitHub.

00:03:47.010 --> 00:03:48.690
<v Speaker 0>And it's got a list of of mentors.

00:03:48.690 --> 00:03:50.849
<v Speaker 0>So if you are familiar with Rust and

00:03:50.849 --> 00:03:52.450
<v Speaker 0>competent with Rust, feel free to send a

00:03:52.450 --> 00:03:54.129
<v Speaker 0>pull request and get yourself added to this

00:03:54.129 --> 00:03:56.875
<v Speaker 0>and help people out. Yes. Yes. We could

00:03:56.875 --> 00:03:58.875
<v Speaker 1>always use more mentors. So please.

00:03:59.355 --> 00:04:00.155
<v Speaker 0>Awesome.

00:04:00.474 --> 00:04:02.955
<v Speaker 0>So we have a couple of comments already.

00:04:03.915 --> 00:04:05.835
<v Speaker 0>Woo, Jane. There you go.

00:04:06.795 --> 00:04:08.875
<v Speaker 0>We got another woo hoo with a little

00:04:08.875 --> 00:04:09.595
<v Speaker 0>crab

00:04:09.880 --> 00:04:11.480
<v Speaker 0>and we got some good vibes coming from

00:04:11.480 --> 00:04:13.880
<v Speaker 0>cute daily. So thank you. If you have

00:04:13.880 --> 00:04:16.360
<v Speaker 0>any comments or questions as we kind of

00:04:16.760 --> 00:04:18.839
<v Speaker 0>work along our exercise today, just drop them

00:04:18.839 --> 00:04:19.880
<v Speaker 0>in the chat and we'll do our best

00:04:19.880 --> 00:04:20.760
<v Speaker 0>to handle them as well.

00:04:21.904 --> 00:04:23.265
<v Speaker 0>So today's plan

00:04:24.465 --> 00:04:27.185
<v Speaker 0>is a big one. Now we have already

00:04:27.185 --> 00:04:29.665
<v Speaker 0>had two episodes. My dog is going crazy.

00:04:29.665 --> 00:04:30.865
<v Speaker 0>I don't know if you can hear that.

00:04:31.265 --> 00:04:32.225
<v Speaker 0>There we go.

00:04:32.705 --> 00:04:35.040
<v Speaker 0>So we've already had two episodes and we

00:04:35.040 --> 00:04:37.040
<v Speaker 0>really took a look at the syntax of

00:04:37.040 --> 00:04:38.560
<v Speaker 0>Rust and

00:04:38.560 --> 00:04:41.440
<v Speaker 0>explored, you know, string types, numeric types. We

00:04:41.440 --> 00:04:43.040
<v Speaker 0>take a little bit of look at struts,

00:04:43.040 --> 00:04:44.800
<v Speaker 0>a little bit of error handling. But we

00:04:44.800 --> 00:04:47.520
<v Speaker 0>haven't actually written any Rust to actually compile

00:04:47.520 --> 00:04:49.520
<v Speaker 0>as a real application. And that's what we're

00:04:49.520 --> 00:04:50.885
<v Speaker 0>gonna explore today.

00:04:51.605 --> 00:04:53.365
<v Speaker 0>And we have a couple of potential sample

00:04:53.365 --> 00:04:55.125
<v Speaker 0>applications that we're gonna try and work through

00:04:55.125 --> 00:04:56.085
<v Speaker 0>to giving

00:04:56.645 --> 00:04:58.405
<v Speaker 0>on time constraints and how quickly we move.

00:04:58.405 --> 00:05:00.405
<v Speaker 0>But we have to start with other worlds.

00:05:00.405 --> 00:05:02.245
<v Speaker 0>I think that's everybody's foray into a new

00:05:02.245 --> 00:05:04.780
<v Speaker 0>language, so we just do that. And really,

00:05:04.780 --> 00:05:06.460
<v Speaker 0>it's not just about the print line statement

00:05:06.460 --> 00:05:08.300
<v Speaker 0>of the whole world, but the cargo command

00:05:08.300 --> 00:05:10.380
<v Speaker 0>to create the project, etcetera, and the tooling

00:05:10.380 --> 00:05:11.660
<v Speaker 0>that we use to build that.

00:05:12.460 --> 00:05:14.620
<v Speaker 0>The second idea will be that we try

00:05:14.620 --> 00:05:17.180
<v Speaker 0>to work with an anagram finder. I have

00:05:17.180 --> 00:05:19.645
<v Speaker 0>a very large file in my directory here

00:05:19.645 --> 00:05:21.085
<v Speaker 0>with all the English words in it. So

00:05:21.085 --> 00:05:22.445
<v Speaker 0>we'll see if we can write something that

00:05:22.445 --> 00:05:24.765
<v Speaker 0>can find potential anagram information.

00:05:25.324 --> 00:05:28.285
<v Speaker 0>And then a very contrived calculator which will

00:05:28.285 --> 00:05:30.365
<v Speaker 0>allow us to use English input as well

00:05:30.365 --> 00:05:33.005
<v Speaker 0>as numeric input. And hopefully, these three examples

00:05:33.005 --> 00:05:34.879
<v Speaker 0>will just allow us to explore some of

00:05:34.879 --> 00:05:35.360
<v Speaker 0>the

00:05:35.919 --> 00:05:38.080
<v Speaker 0>idiomatic Rust things that we need to learn

00:05:38.080 --> 00:05:39.599
<v Speaker 0>and the tooling to be able to work

00:05:39.599 --> 00:05:41.360
<v Speaker 0>with Rust on a daily basis.

00:05:42.719 --> 00:05:44.720
<v Speaker 0>You happy with that? Yes.

00:05:44.960 --> 00:05:47.875
<v Speaker 1>Sounds good. Alright. So as far as the

00:05:47.875 --> 00:05:50.035
<v Speaker 0>hello world goes, this is what everyone usually

00:05:50.035 --> 00:05:51.395
<v Speaker 0>does when they when they wanna learn a

00:05:51.395 --> 00:05:53.235
<v Speaker 0>new programming language. So,

00:05:53.875 --> 00:05:55.635
<v Speaker 0>I mean, I could just create a Rust

00:05:55.635 --> 00:05:58.115
<v Speaker 0>file, inject the code, and use

00:05:58.995 --> 00:06:01.315
<v Speaker 0>Rusty or Cargo Run or one of these

00:06:01.315 --> 00:06:03.069
<v Speaker 0>things. But if I was going to do

00:06:03.069 --> 00:06:05.310
<v Speaker 0>this as a real application, what would be

00:06:05.310 --> 00:06:07.150
<v Speaker 0>the first step for you as a as

00:06:07.150 --> 00:06:08.270
<v Speaker 0>a Rust developer?

00:06:09.550 --> 00:06:10.750
<v Speaker 1>For me, it's just like, you know, you

00:06:10.750 --> 00:06:14.430
<v Speaker 1>immediately go Cargo new and dash dash lib.

00:06:14.430 --> 00:06:15.870
<v Speaker 1>I I pretty much always do lib

00:06:16.355 --> 00:06:18.115
<v Speaker 1>because I like to when I'm writing even

00:06:18.115 --> 00:06:19.395
<v Speaker 1>if I'm writing a binary, I like to

00:06:19.395 --> 00:06:20.675
<v Speaker 1>split it into two so I can do

00:06:20.675 --> 00:06:21.875
<v Speaker 1>doc tests and stuff.

00:06:22.275 --> 00:06:23.875
<v Speaker 1>And then just whatever you're gonna name the

00:06:23.875 --> 00:06:24.435
<v Speaker 1>project.

00:06:24.835 --> 00:06:25.315
<v Speaker 1>So

00:06:26.435 --> 00:06:29.955
<v Speaker 1>and it's it cheats because the the default

00:06:29.490 --> 00:06:32.370
<v Speaker 1>generation is literally a hello world program, so

00:06:32.370 --> 00:06:34.050
<v Speaker 1>you're done. So you hit enter and you're

00:06:34.050 --> 00:06:34.530
<v Speaker 1>done.

00:06:36.690 --> 00:06:37.410
<v Speaker 0>Alright.

00:06:38.050 --> 00:06:40.449
<v Speaker 0>I'm curious about that lip thing then that

00:06:40.449 --> 00:06:41.569
<v Speaker 0>you mentioned. Mhmm.

00:06:42.405 --> 00:06:44.725
<v Speaker 0>What does that what do we do when

00:06:44.725 --> 00:06:47.285
<v Speaker 0>we tell cargo that dash dash lib? What's

00:06:47.285 --> 00:06:49.125
<v Speaker 0>different from maybe a normal application?

00:06:49.525 --> 00:06:51.605
<v Speaker 1>So with dash dash lib,

00:06:51.685 --> 00:06:55.205
<v Speaker 1>it changes slightly the, like, the the project

00:06:55.205 --> 00:06:56.885
<v Speaker 1>it generates. It generates a lib dot r

00:06:56.885 --> 00:06:58.245
<v Speaker 1>s instead of a main dot r s.

00:06:59.740 --> 00:07:00.380
<v Speaker 1>And

00:07:00.700 --> 00:07:01.340
<v Speaker 1>it

00:07:01.900 --> 00:07:04.780
<v Speaker 1>doesn't I think it specifically generates a slightly

00:07:04.780 --> 00:07:06.460
<v Speaker 1>different gitignore file

00:07:06.540 --> 00:07:09.500
<v Speaker 1>because with, like, with the bins, you want

00:07:09.500 --> 00:07:11.660
<v Speaker 1>to usually commit the cargo dot lock file.

00:07:11.914 --> 00:07:14.395
<v Speaker 1>But with libs, you generally don't want to

00:07:14.395 --> 00:07:16.074
<v Speaker 1>commit the cargo dot lock file. So, actually,

00:07:16.074 --> 00:07:17.675
<v Speaker 1>we should probably delete that. That's a good

00:07:17.675 --> 00:07:20.155
<v Speaker 1>point because we are actually creating a binary.

00:07:22.074 --> 00:07:22.634
<v Speaker 0>Okay.

00:07:24.900 --> 00:07:26.740
<v Speaker 1>So we do wanna commit the cargo dot

00:07:26.740 --> 00:07:28.580
<v Speaker 1>lock. But other than that, it's it's pretty

00:07:28.580 --> 00:07:31.220
<v Speaker 1>much generating the same files as far as

00:07:31.220 --> 00:07:33.460
<v Speaker 1>I know. Like, it's gonna create a cargo

00:07:33.460 --> 00:07:35.780
<v Speaker 1>dot toml, has, you know, whatever name you

00:07:35.780 --> 00:07:37.460
<v Speaker 1>gave it and just the defaults

00:07:37.985 --> 00:07:39.585
<v Speaker 1>whatever is, like, the newest stuff. So it

00:07:39.585 --> 00:07:41.425
<v Speaker 1>always put 02/2018 edition

00:07:41.825 --> 00:07:43.905
<v Speaker 1>for a new project now. And then probably

00:07:43.905 --> 00:07:46.145
<v Speaker 1>in two years, it'll say 02/2021.

00:07:46.705 --> 00:07:47.345
<v Speaker 1>And

00:07:48.545 --> 00:07:50.865
<v Speaker 1>I think that is it. I guess it

00:07:50.865 --> 00:07:52.705
<v Speaker 1>does generate a target directory, which

00:07:53.660 --> 00:07:55.100
<v Speaker 1>is fine. Surprising,

00:07:55.100 --> 00:07:56.140
<v Speaker 1>but not weird.

00:07:56.940 --> 00:07:59.020
<v Speaker 0>So with regards to this edition, and that's

00:07:59.020 --> 00:08:00.940
<v Speaker 0>not actually something I think I've asked any

00:08:00.940 --> 00:08:03.100
<v Speaker 0>of the previous guests. But what is significant

00:08:03.100 --> 00:08:04.060
<v Speaker 0>about the 2018?

00:08:05.405 --> 00:08:06.125
<v Speaker 1>So

00:08:06.764 --> 00:08:09.245
<v Speaker 1>one of the the cool things that Rust

00:08:09.245 --> 00:08:12.604
<v Speaker 1>does is we we allow breaking changes in

00:08:12.604 --> 00:08:13.485
<v Speaker 1>the language,

00:08:13.565 --> 00:08:15.164
<v Speaker 1>and we do so in kind of a

00:08:15.164 --> 00:08:17.645
<v Speaker 1>structured manner that allows you to, like, interoperate

00:08:17.645 --> 00:08:21.300
<v Speaker 1>between different edition, like like, libraries written on

00:08:21.300 --> 00:08:23.540
<v Speaker 1>different editions with the same compiler.

00:08:23.780 --> 00:08:26.180
<v Speaker 1>And so when you enable the 02/2018

00:08:26.180 --> 00:08:29.540
<v Speaker 1>edition, it's essentially a set of features that

00:08:29.540 --> 00:08:31.380
<v Speaker 1>are not backwards compatible. Like, a lot of

00:08:31.380 --> 00:08:32.914
<v Speaker 1>features and a lot of different, like, settings

00:08:32.914 --> 00:08:35.394
<v Speaker 1>on, like, which warnings are, like, errors versus

00:08:35.394 --> 00:08:36.115
<v Speaker 1>warnings

00:08:36.834 --> 00:08:39.954
<v Speaker 1>become activated when you turn on this edition

00:08:39.954 --> 00:08:41.714
<v Speaker 1>equals twenty eighteen.

00:08:42.194 --> 00:08:44.115
<v Speaker 1>And so, like, the compiler has, like, all

00:08:44.115 --> 00:08:45.954
<v Speaker 1>of these, like, switching logic on, like, if

00:08:45.954 --> 00:08:47.970
<v Speaker 1>it's if you're currently compiling a twenty eighteen

00:08:47.970 --> 00:08:50.050
<v Speaker 1>crate, you're gonna use these rules. And if

00:08:50.050 --> 00:08:51.649
<v Speaker 1>you're not, you're gonna be, like, twenty fifteen

00:08:51.649 --> 00:08:53.170
<v Speaker 1>and using these rules, and soon there'll be

00:08:53.170 --> 00:08:55.009
<v Speaker 1>a twenty twenty one, which have a whole

00:08:55.009 --> 00:08:56.529
<v Speaker 1>new set of rules added on.

00:08:57.250 --> 00:08:59.730
<v Speaker 1>There are some restrictions, like, the standard library

00:08:59.730 --> 00:09:01.649
<v Speaker 1>is not allowed to do breaking changes because

00:09:01.649 --> 00:09:03.635
<v Speaker 1>it's linked to both versions.

00:09:04.195 --> 00:09:06.274
<v Speaker 1>So it has to be API

00:09:06.274 --> 00:09:08.915
<v Speaker 1>compatible with two with old code and new

00:09:08.915 --> 00:09:11.475
<v Speaker 1>code. But the language itself is allowed to,

00:09:11.475 --> 00:09:13.475
<v Speaker 1>like, introduce new keywords and everything.

00:09:14.520 --> 00:09:15.960
<v Speaker 0>Alright. Awesome.

00:09:16.760 --> 00:09:18.440
<v Speaker 0>Alright. So let's take a look at our

00:09:18.440 --> 00:09:19.960
<v Speaker 0>lepto r s end.

00:09:20.920 --> 00:09:23.160
<v Speaker 0>It looks like we've just got some test

00:09:23.160 --> 00:09:24.520
<v Speaker 0>test configuration.

00:09:24.840 --> 00:09:26.200
<v Speaker 0>Yes. So I could delete all that?

00:09:27.644 --> 00:09:29.725
<v Speaker 1>Yeah. I mean, it's I I think it's,

00:09:29.725 --> 00:09:31.485
<v Speaker 1>like, maybe it's

00:09:31.485 --> 00:09:33.005
<v Speaker 1>it's okay to leave it or to delete

00:09:33.005 --> 00:09:34.524
<v Speaker 1>it whether or not it depends on if

00:09:34.524 --> 00:09:36.204
<v Speaker 1>you're plant you're gonna, like, write lots of

00:09:36.204 --> 00:09:38.204
<v Speaker 1>little tests while you're going, which is kinda,

00:09:38.204 --> 00:09:39.725
<v Speaker 1>you know, on dev style type thing. If

00:09:39.725 --> 00:09:40.605
<v Speaker 1>you prefer to just, like,

00:09:42.000 --> 00:09:44.560
<v Speaker 1>do lots of testing or upfront or you

00:09:44.560 --> 00:09:46.079
<v Speaker 1>prefer to just, like, kind of

00:09:47.040 --> 00:09:49.199
<v Speaker 1>test it in the by running it, you

00:09:49.199 --> 00:09:50.800
<v Speaker 1>know. Yeah. Maybe we should I

00:09:52.000 --> 00:09:53.279
<v Speaker 0>was just gonna say maybe we should write

00:09:53.279 --> 00:09:54.720
<v Speaker 0>a small test or under her little world

00:09:54.720 --> 00:09:57.375
<v Speaker 0>application, you know, just to to explore that

00:09:57.375 --> 00:09:58.415
<v Speaker 0>concept. So

00:09:59.135 --> 00:10:01.375
<v Speaker 0>does Rust use a main function, like like

00:10:01.375 --> 00:10:02.015
<v Speaker 0>go?

00:10:02.654 --> 00:10:05.935
<v Speaker 1>Yes. It's main and then the the signature

00:10:05.935 --> 00:10:06.975
<v Speaker 1>is basically

00:10:07.935 --> 00:10:11.695
<v Speaker 1>no arguments and then it returns a termination

00:10:11.695 --> 00:10:14.600
<v Speaker 1>type. Termination is a trait that just says,

00:10:14.600 --> 00:10:17.000
<v Speaker 1>like, I can give you an exit code.

00:10:17.560 --> 00:10:20.040
<v Speaker 1>And right now, it's unstable, so you can't

00:10:20.040 --> 00:10:21.960
<v Speaker 1>implement termination on your own types without going

00:10:21.960 --> 00:10:23.480
<v Speaker 1>to the nightly compiler,

00:10:23.880 --> 00:10:26.040
<v Speaker 1>and I think, like, maybe enabling some features.

00:10:26.040 --> 00:10:28.585
<v Speaker 1>But there are a couple of types that

00:10:28.585 --> 00:10:31.545
<v Speaker 1>are stable that do implement termination. So you

00:10:31.545 --> 00:10:33.625
<v Speaker 1>can use results and you can use a

00:10:33.625 --> 00:10:35.705
<v Speaker 1>unit type, is, like, no return type. It's

00:10:35.705 --> 00:10:36.985
<v Speaker 1>implicitly a unit.

00:10:37.785 --> 00:10:39.385
<v Speaker 1>And both of those will, like,

00:10:40.220 --> 00:10:42.140
<v Speaker 1>do the, like, error reporting if there's an

00:10:42.140 --> 00:10:44.700
<v Speaker 1>error or just, like, exit status or whatever.

00:10:44.940 --> 00:10:46.700
<v Speaker 0>Okay. So to to make sure I understood

00:10:46.700 --> 00:10:47.260
<v Speaker 0>that,

00:10:47.580 --> 00:10:49.260
<v Speaker 0>this is what you mean by the unit

00:10:49.260 --> 00:10:51.500
<v Speaker 0>or no return type and that implements that

00:10:51.500 --> 00:10:52.300
<v Speaker 0>termination tree?

00:10:52.845 --> 00:10:54.524
<v Speaker 1>Yes. And so if you leave this as

00:10:54.524 --> 00:10:56.845
<v Speaker 1>is, it will compile because that is type

00:10:56.845 --> 00:10:59.404
<v Speaker 1>checking because, like, you could change main to

00:10:59.404 --> 00:11:01.565
<v Speaker 1>put, like, a return type and have that

00:11:01.565 --> 00:11:03.165
<v Speaker 1>be e like, returns unit.

00:11:04.629 --> 00:11:06.870
<v Speaker 1>And, like, this is equivalent.

00:11:06.870 --> 00:11:09.350
<v Speaker 1>Like, I think that, like, Rust syntax sugar

00:11:09.350 --> 00:11:09.910
<v Speaker 1>is

00:11:10.550 --> 00:11:13.269
<v Speaker 1>a way of that. But, like, functionally, it's

00:11:13.269 --> 00:11:14.629
<v Speaker 1>as if it were there all the time.

00:11:14.629 --> 00:11:16.149
<v Speaker 1>Whenever you don't have a return type on

00:11:16.149 --> 00:11:18.149
<v Speaker 1>a function, it's returning unit.

00:11:18.709 --> 00:11:19.269
<v Speaker 0>Oh, okay.

00:11:20.815 --> 00:11:22.575
<v Speaker 0>And then we can do print.

00:11:22.655 --> 00:11:23.215
<v Speaker 0>Oh,

00:11:23.535 --> 00:11:24.415
<v Speaker 0>hello.

00:11:27.695 --> 00:11:28.895
<v Speaker 0>Will this compile?

00:11:29.135 --> 00:11:31.215
<v Speaker 1>Yeah. I believe so. It should compile.

00:11:32.150 --> 00:11:33.670
<v Speaker 1>Well, it won't compile because it's in a

00:11:33.750 --> 00:11:35.190
<v Speaker 1>it's a a lib dot r s file.

00:11:35.190 --> 00:11:36.630
<v Speaker 1>So you're gonna need to make a new

00:11:36.630 --> 00:11:38.470
<v Speaker 1>main dot r s. Or it I mean,

00:11:38.470 --> 00:11:39.430
<v Speaker 1>it would compile

00:11:39.590 --> 00:11:42.550
<v Speaker 1>because you just have hello world colon colon

00:11:42.550 --> 00:11:44.390
<v Speaker 1>main as like a library function.

00:11:45.185 --> 00:11:46.945
<v Speaker 1>It just wouldn't run because it's not it's

00:11:46.945 --> 00:11:48.225
<v Speaker 1>not a pin. So you need to, like,

00:11:48.225 --> 00:11:49.265
<v Speaker 1>make a main file.

00:11:49.585 --> 00:11:51.425
<v Speaker 0>Alright. Alright. Okay.

00:11:52.785 --> 00:11:53.985
<v Speaker 0>But we have a main to r s

00:11:53.985 --> 00:11:56.065
<v Speaker 0>as well and this is a special file.

00:11:56.225 --> 00:11:57.425
<v Speaker 1>Yes. And so then if you put an

00:11:57.425 --> 00:11:58.145
<v Speaker 1>f n main here,

00:11:59.030 --> 00:12:00.310
<v Speaker 1>it's going to

00:12:00.790 --> 00:12:02.310
<v Speaker 1>be much happier. And then you could, for

00:12:02.310 --> 00:12:05.510
<v Speaker 1>example, you could just call hello underscore world

00:12:08.390 --> 00:12:09.510
<v Speaker 1>colon colon main.

00:12:15.435 --> 00:12:16.154
<v Speaker 0>That?

00:12:16.315 --> 00:12:18.475
<v Speaker 1>And yeah. And that this should compile and

00:12:18.475 --> 00:12:19.115
<v Speaker 1>run.

00:12:22.394 --> 00:12:23.435
<v Speaker 1>Why

00:12:24.635 --> 00:12:25.675
<v Speaker 1>is it upset?

00:12:26.315 --> 00:12:27.915
<v Speaker 0>Oh, this is not yeah. Yeah.

00:12:28.899 --> 00:12:29.620
<v Speaker 0>Okay.

00:12:32.020 --> 00:12:34.899
<v Speaker 0>So that just means I had help. Right?

00:12:34.899 --> 00:12:35.779
<v Speaker 1>Exactly.

00:12:38.899 --> 00:12:41.300
<v Speaker 0>If I leave the semicolon off, that's what

00:12:41.300 --> 00:12:42.899
<v Speaker 0>count as an expression and it would return

00:12:42.899 --> 00:12:45.125
<v Speaker 0>whatever this function returns. And it's that's a

00:12:45.125 --> 00:12:46.805
<v Speaker 1>unit and it would still work. Yes.

00:12:47.925 --> 00:12:49.285
<v Speaker 0>Okay. So I

00:12:49.525 --> 00:12:51.845
<v Speaker 0>know this is a contrived or simple hello

00:12:51.845 --> 00:12:53.765
<v Speaker 0>world application, but let's assume this application is

00:12:53.765 --> 00:12:55.605
<v Speaker 0>gonna make us a million dollars. Like, how

00:12:55.605 --> 00:12:56.805
<v Speaker 0>do I build it? How do I run

00:12:56.805 --> 00:12:58.005
<v Speaker 0>it? And how do I do the tests?

00:12:58.529 --> 00:13:01.089
<v Speaker 0>What will we do? So cargo build is

00:13:01.089 --> 00:13:02.450
<v Speaker 1>high oh, so you can do cargo check.

00:13:02.450 --> 00:13:03.650
<v Speaker 1>Let's start with cargo check.

00:13:03.890 --> 00:13:06.850
<v Speaker 1>So cargo check is essentially checking that it

00:13:06.850 --> 00:13:09.089
<v Speaker 1>compiles, but not generating any artifacts. So it

00:13:09.089 --> 00:13:10.769
<v Speaker 1>does all the type checking, but not any

00:13:10.769 --> 00:13:13.655
<v Speaker 1>of, like, the I think, linking or whatever.

00:13:14.135 --> 00:13:15.735
<v Speaker 1>And then cargo build

00:13:15.895 --> 00:13:18.135
<v Speaker 1>is what actually makes your artifacts.

00:13:19.415 --> 00:13:21.015
<v Speaker 1>And so this is, you know, obviously, it's

00:13:21.015 --> 00:13:22.055
<v Speaker 1>gonna take a bit longer.

00:13:22.455 --> 00:13:25.655
<v Speaker 1>And then cargo run is what runs the

00:13:25.655 --> 00:13:26.135
<v Speaker 1>main.

00:13:27.730 --> 00:13:29.170
<v Speaker 1>And so this should give us hello world,

00:13:29.170 --> 00:13:31.170
<v Speaker 1>and then cargo test is

00:13:31.170 --> 00:13:32.930
<v Speaker 1>how you would run the tests.

00:13:36.050 --> 00:13:36.850
<v Speaker 0>Nice.

00:13:37.090 --> 00:13:39.010
<v Speaker 0>All pretty self explanatory there.

00:13:40.130 --> 00:13:41.570
<v Speaker 0>Okay.

00:13:41.570 --> 00:13:43.650
<v Speaker 0>Let's

00:13:42.435 --> 00:13:45.395
<v Speaker 0>make this a little bit more interesting then.

00:13:45.395 --> 00:13:46.035
<v Speaker 0>So

00:13:46.915 --> 00:13:48.915
<v Speaker 0>what if I want to be able to

00:13:48.915 --> 00:13:52.995
<v Speaker 0>tweak this to take a name and pass

00:13:52.995 --> 00:13:54.355
<v Speaker 0>that n instead of world?

00:13:55.100 --> 00:13:55.820
<v Speaker 0>Okay.

00:13:56.780 --> 00:13:57.820
<v Speaker 1>So you would

00:13:58.940 --> 00:14:00.220
<v Speaker 1>there's a lot of ways you could do

00:14:00.220 --> 00:14:01.660
<v Speaker 1>it. So let's start with the simplest one

00:14:01.660 --> 00:14:04.220
<v Speaker 1>and let's just use a string. So

00:14:04.460 --> 00:14:07.580
<v Speaker 1>just let's say name and then colon and

00:14:07.580 --> 00:14:10.140
<v Speaker 1>then the type which would be ampersand s

00:14:10.140 --> 00:14:10.620
<v Speaker 1>t r.

00:14:15.735 --> 00:14:17.735
<v Speaker 1>And then in this one, you're gonna just

00:14:17.735 --> 00:14:21.335
<v Speaker 1>replace that with a formatting specifier, I think,

00:14:21.335 --> 00:14:23.735
<v Speaker 1>is what it's called technically. Yes. And then

00:14:24.375 --> 00:14:25.655
<v Speaker 1>comma and name.

00:14:26.830 --> 00:14:28.270
<v Speaker 1>And that will do, you know, your whole

00:14:28.270 --> 00:14:32.030
<v Speaker 1>string interpolation print f style thingy and inserts

00:14:32.030 --> 00:14:34.350
<v Speaker 1>that and runs the display trait

00:14:34.990 --> 00:14:36.670
<v Speaker 1>and gets that done.

00:14:37.470 --> 00:14:39.390
<v Speaker 0>Of course. And now this takes an argument.

00:14:39.390 --> 00:14:41.385
<v Speaker 0>So I mean, I could just cheat and

00:14:41.385 --> 00:14:43.065
<v Speaker 0>pass this in like this for now. Right?

00:14:43.225 --> 00:14:43.945
<v Speaker 1>Yes.

00:14:44.665 --> 00:14:47.465
<v Speaker 0>Okay. So if I run do I need

00:14:47.465 --> 00:14:49.065
<v Speaker 0>to always do a build or cargo or

00:14:49.065 --> 00:14:50.745
<v Speaker 0>cargo run did that for me? Cargo run

00:14:50.745 --> 00:14:52.905
<v Speaker 1>will always do the the the build

00:14:53.785 --> 00:14:55.065
<v Speaker 1>as a prerequisite. Yes.

00:14:56.500 --> 00:14:57.780
<v Speaker 0>Okay. So

00:14:59.060 --> 00:15:01.300
<v Speaker 0>let's I'm gonna just make this as as

00:15:01.300 --> 00:15:03.220
<v Speaker 0>contrived as possible now. So

00:15:04.100 --> 00:15:06.900
<v Speaker 0>I'm gonna write a test case here. So

00:15:06.900 --> 00:15:07.860
<v Speaker 0>is

00:15:08.845 --> 00:15:10.685
<v Speaker 0>is that at is that mandatory or can

00:15:10.685 --> 00:15:12.285
<v Speaker 0>I just put anything here?

00:15:13.645 --> 00:15:15.085
<v Speaker 1>You can put any

00:15:16.285 --> 00:15:18.765
<v Speaker 1>any test name. Yeah. Any name. It'll just

00:15:18.765 --> 00:15:19.725
<v Speaker 1>be the name of the test. Yeah.

00:15:21.879 --> 00:15:24.040
<v Speaker 0>Okay. And then if I

00:15:24.600 --> 00:15:27.000
<v Speaker 0>I'm gonna break all my code now completely.

00:15:27.000 --> 00:15:29.160
<v Speaker 0>But let's say I want to call main

00:15:29.319 --> 00:15:30.839
<v Speaker 0>with no parameters

00:15:31.160 --> 00:15:32.120
<v Speaker 0>and then

00:15:33.959 --> 00:15:36.600
<v Speaker 0>assert that I get back hello world.

00:15:37.745 --> 00:15:39.665
<v Speaker 0>I know we'll fail right now.

00:15:39.905 --> 00:15:41.745
<v Speaker 1>So this shouldn't compile.

00:15:43.985 --> 00:15:45.185
<v Speaker 0>Because of the

00:15:45.505 --> 00:15:48.705
<v Speaker 0>the type mismatch here? Or Yes. Exactly. Yeah.

00:15:48.705 --> 00:15:51.505
<v Speaker 1>It's it's expecting a an argument and it's

00:15:51.505 --> 00:15:52.225
<v Speaker 1>not getting any.

00:15:54.120 --> 00:15:55.800
<v Speaker 0>Yeah. I'm I'm gonna pretend we never made

00:15:55.800 --> 00:15:57.720
<v Speaker 0>that change for a moment. So Okay.

00:15:58.279 --> 00:16:00.040
<v Speaker 0>Because I had my alright. Okay. And so

00:16:00.040 --> 00:16:02.600
<v Speaker 1>also, this is search. Well, it's still not

00:16:02.600 --> 00:16:05.480
<v Speaker 1>compile because the the print line is a

00:16:05.480 --> 00:16:07.720
<v Speaker 1>side effect, not a return type.

00:16:09.785 --> 00:16:10.905
<v Speaker 1>Yeah. Okay.

00:16:16.825 --> 00:16:17.545
<v Speaker 0>K.

00:16:18.905 --> 00:16:21.065
<v Speaker 0>Oh, it doesn't like that. Yes. And so

00:16:21.065 --> 00:16:22.585
<v Speaker 1>that won't compile because

00:16:23.400 --> 00:16:25.000
<v Speaker 1>so when you put the str as an

00:16:25.000 --> 00:16:25.720
<v Speaker 1>argument,

00:16:26.280 --> 00:16:27.240
<v Speaker 1>it gets

00:16:27.640 --> 00:16:29.880
<v Speaker 1>some there's some syntax sugar applied. It's called

00:16:29.880 --> 00:16:31.640
<v Speaker 1>the lifetime elision rules.

00:16:32.040 --> 00:16:34.840
<v Speaker 1>And this can still apply in return arguments,

00:16:34.840 --> 00:16:36.760
<v Speaker 1>but it there there are, like, certain rules

00:16:36.760 --> 00:16:38.875
<v Speaker 1>that have to be satisfied. Specifically, you need

00:16:38.875 --> 00:16:39.675
<v Speaker 1>to have,

00:16:39.995 --> 00:16:42.395
<v Speaker 1>like, a a self argument

00:16:42.795 --> 00:16:45.115
<v Speaker 1>in order to in order to align lifetimes

00:16:45.115 --> 00:16:46.715
<v Speaker 1>in the return arguments.

00:16:47.675 --> 00:16:49.115
<v Speaker 1>Or it might be if you only have

00:16:49.115 --> 00:16:51.115
<v Speaker 1>one argument. It might I think it might

00:16:51.115 --> 00:16:52.715
<v Speaker 1>align the lifetime in that case too.

00:16:53.940 --> 00:16:56.500
<v Speaker 1>But because you have no arg input arguments,

00:16:56.899 --> 00:16:59.940
<v Speaker 1>it's go it doesn't have anything to get

00:16:59.940 --> 00:17:02.339
<v Speaker 1>the lifetime from of this string. This this

00:17:02.339 --> 00:17:04.419
<v Speaker 1>borrow is like this reference has to be

00:17:04.419 --> 00:17:06.660
<v Speaker 1>constrained to some, like, dirt this, like, some

00:17:06.660 --> 00:17:08.020
<v Speaker 1>scope in the program, essentially,

00:17:08.625 --> 00:17:11.105
<v Speaker 1>where, it thinks that that that string would

00:17:11.105 --> 00:17:11.825
<v Speaker 1>be valid

00:17:13.345 --> 00:17:15.665
<v Speaker 1>and or that reference would be valid. And

00:17:15.665 --> 00:17:16.304
<v Speaker 1>so

00:17:17.105 --> 00:17:18.224
<v Speaker 1>in this case,

00:17:18.945 --> 00:17:22.065
<v Speaker 1>because we're not actually borrowing any existing reference,

00:17:22.279 --> 00:17:23.880
<v Speaker 1>the thing we're trying to say is, like,

00:17:23.880 --> 00:17:25.880
<v Speaker 1>this is just a static reference. It's a

00:17:25.880 --> 00:17:27.559
<v Speaker 1>reference to, like, a piece of data that

00:17:27.559 --> 00:17:28.200
<v Speaker 1>is just

00:17:28.600 --> 00:17:30.840
<v Speaker 1>linked into a specific part part of the

00:17:30.840 --> 00:17:32.440
<v Speaker 1>binary, and it just lives there forever. It

00:17:32.440 --> 00:17:34.120
<v Speaker 1>exists for the duration of the program. And

00:17:34.120 --> 00:17:36.039
<v Speaker 1>so we have to manually write in tick

00:17:36.039 --> 00:17:38.745
<v Speaker 1>static after the ampersand, and that just says,

00:17:38.745 --> 00:17:40.585
<v Speaker 1>you know, this is a string that always

00:17:40.585 --> 00:17:41.385
<v Speaker 1>exists.

00:17:42.425 --> 00:17:44.424
<v Speaker 1>And then it won't have to, you know,

00:17:44.425 --> 00:17:47.544
<v Speaker 1>be derived from some input lifetime,

00:17:47.545 --> 00:17:49.465
<v Speaker 1>which is what you normally do. Like, lifetime

00:17:49.465 --> 00:17:52.210
<v Speaker 1>parameters are always just, like, relations. Like, is

00:17:52.210 --> 00:17:55.650
<v Speaker 1>this something that comes from this other thing?

00:17:56.930 --> 00:17:57.570
<v Speaker 0>Okay.

00:17:57.730 --> 00:17:59.730
<v Speaker 0>That's a really good explanation. I have I

00:17:59.730 --> 00:18:01.890
<v Speaker 0>have not really understood that previously before and

00:18:01.890 --> 00:18:03.170
<v Speaker 0>that kinda made a lot more sense to

00:18:03.170 --> 00:18:03.730
<v Speaker 0>me, so thanks.

00:18:05.285 --> 00:18:07.285
<v Speaker 0>No. I'm thinking because we're gonna be allowing

00:18:07.285 --> 00:18:09.845
<v Speaker 0>this world to be interpolated later, should we

00:18:09.845 --> 00:18:11.445
<v Speaker 0>just go ahead and make this

00:18:12.085 --> 00:18:13.205
<v Speaker 0>uppercase string?

00:18:15.285 --> 00:18:16.645
<v Speaker 0>Or we just don't put that as an

00:18:16.645 --> 00:18:17.684
<v Speaker 0>uppercase string?

00:18:19.205 --> 00:18:20.679
<v Speaker 1>So we're not gonna be able yeah. You're

00:18:20.679 --> 00:18:21.799
<v Speaker 1>right. We're not gonna be able to add

00:18:21.799 --> 00:18:23.959
<v Speaker 1>anything in to the string

00:18:24.600 --> 00:18:27.240
<v Speaker 1>if we use a static string because, like,

00:18:27.240 --> 00:18:28.840
<v Speaker 1>it's a static piece of memory that we're

00:18:28.840 --> 00:18:30.039
<v Speaker 1>not supposed to modify.

00:18:31.000 --> 00:18:32.200
<v Speaker 1>And so yes.

00:18:33.165 --> 00:18:34.365
<v Speaker 0>Oh, so

00:18:37.725 --> 00:18:39.725
<v Speaker 0>They're happy? No. It's not happy.

00:18:42.765 --> 00:18:44.605
<v Speaker 0>Expecting a function Super.

00:18:46.960 --> 00:18:48.640
<v Speaker 0>Oh. Oh, yeah. Because this is a the

00:18:48.640 --> 00:18:49.679
<v Speaker 0>one module.

00:18:49.760 --> 00:18:50.480
<v Speaker 0>Yes.

00:18:51.840 --> 00:18:52.960
<v Speaker 0>Yeah. Okay.

00:18:53.520 --> 00:18:54.800
<v Speaker 0>Superman. That's

00:18:54.800 --> 00:18:56.000
<v Speaker 0>no happier.

00:18:57.280 --> 00:18:58.880
<v Speaker 0>Now let's remove

00:18:58.675 --> 00:19:00.835
<v Speaker 0>this. So this doesn't take a parameter anymore,

00:19:00.835 --> 00:19:02.755
<v Speaker 0>but it's actually not gonna do anything.

00:19:02.835 --> 00:19:05.635
<v Speaker 0>So let's just make this past roughly to

00:19:05.635 --> 00:19:06.755
<v Speaker 0>where we had it.

00:19:08.035 --> 00:19:09.715
<v Speaker 0>And then we can do a return.

00:19:10.115 --> 00:19:12.270
<v Speaker 1>And you're probably gonna need a just an

00:19:12.270 --> 00:19:14.670
<v Speaker 1>empty format string that has like a single

00:19:14.990 --> 00:19:15.710
<v Speaker 0>Alright.

00:19:18.750 --> 00:19:19.870
<v Speaker 0>Cool. Okay.

00:19:20.830 --> 00:19:22.350
<v Speaker 0>Now let's go back and see if our

00:19:22.350 --> 00:19:24.510
<v Speaker 0>cargo run works, which it does. And our

00:19:24.510 --> 00:19:26.190
<v Speaker 0>cargo test, which should.

00:19:27.835 --> 00:19:30.395
<v Speaker 0>And now we wanna make this our $2,000,000

00:19:30.395 --> 00:19:32.154
<v Speaker 0>application, which means parameter.

00:19:36.794 --> 00:19:37.835
<v Speaker 0>I

00:19:37.835 --> 00:19:39.755
<v Speaker 0>I still really struggle with when to use

00:19:39.755 --> 00:19:41.195
<v Speaker 0>an uppercase string and when to use this

00:19:41.195 --> 00:19:42.154
<v Speaker 0>as

00:19:42.580 --> 00:19:45.300
<v Speaker 0>ampersand string. If we're gonna be reading

00:19:45.620 --> 00:19:48.180
<v Speaker 0>m poo and the previous function, would that

00:19:48.180 --> 00:19:49.460
<v Speaker 0>mean I pass it through as an uppercase

00:19:49.460 --> 00:19:51.300
<v Speaker 0>string because it's dynamic? Is that like a

00:19:51.300 --> 00:19:52.100
<v Speaker 0>good heuristic?

00:19:54.945 --> 00:19:57.504
<v Speaker 1>The the question is if you're gonna modify

00:19:57.985 --> 00:20:00.945
<v Speaker 1>the the piece of data that, like, is

00:20:00.945 --> 00:20:02.224
<v Speaker 1>the input string.

00:20:02.544 --> 00:20:03.825
<v Speaker 1>So in this case,

00:20:04.945 --> 00:20:06.144
<v Speaker 1>we could do that.

00:20:06.625 --> 00:20:09.170
<v Speaker 1>We could, like, basically, like, expect them to

00:20:09.170 --> 00:20:10.530
<v Speaker 1>give us a string and then, like, they

00:20:10.530 --> 00:20:12.210
<v Speaker 1>are giving us the name and we're going

00:20:12.210 --> 00:20:13.170
<v Speaker 1>to prepend

00:20:13.170 --> 00:20:14.529
<v Speaker 1>hello on it.

00:20:15.250 --> 00:20:17.250
<v Speaker 1>And that would work, so you could.

00:20:17.810 --> 00:20:19.730
<v Speaker 1>I think it makes a bit more sense

00:20:19.730 --> 00:20:20.130
<v Speaker 1>to

00:20:20.530 --> 00:20:21.410
<v Speaker 1>expect

00:20:21.410 --> 00:20:24.345
<v Speaker 1>just a a stir because then we can,

00:20:24.345 --> 00:20:26.345
<v Speaker 1>like, we can make our own starting string

00:20:26.345 --> 00:20:27.705
<v Speaker 1>and then we can just use the plus

00:20:27.705 --> 00:20:29.705
<v Speaker 1>operator, which can catenate strings,

00:20:30.265 --> 00:20:32.184
<v Speaker 1>and it'll be a bit simpler.

00:20:35.065 --> 00:20:37.145
<v Speaker 0>Okay. Cool. So

00:20:38.690 --> 00:20:41.090
<v Speaker 0>assuming we were doing TDD and we were

00:20:41.090 --> 00:20:42.370
<v Speaker 0>doing this,

00:20:43.250 --> 00:20:45.250
<v Speaker 0>the test case first. So we've got users

00:20:45.250 --> 00:20:47.410
<v Speaker 0>world as default, but we also want to

00:20:47.410 --> 00:20:48.289
<v Speaker 0>accept

00:20:48.450 --> 00:20:50.130
<v Speaker 0>first accept the name,

00:20:52.295 --> 00:20:53.975
<v Speaker 0>means we're gonna do

00:20:54.455 --> 00:20:57.095
<v Speaker 0>pivot, and we expect pivot here.

00:20:58.375 --> 00:21:01.015
<v Speaker 0>And we're in a predicament now where

00:21:01.255 --> 00:21:02.775
<v Speaker 0>we need to handle

00:21:02.775 --> 00:21:05.190
<v Speaker 0>both of these cases where we have an

00:21:05.350 --> 00:21:07.190
<v Speaker 0>a parameter and we don't have a parameter.

00:21:07.590 --> 00:21:10.550
<v Speaker 0>What is the idiomatic Rust way of handling

00:21:10.550 --> 00:21:11.110
<v Speaker 0>that?

00:21:11.750 --> 00:21:13.510
<v Speaker 1>So this is one this is one of

00:21:13.510 --> 00:21:15.350
<v Speaker 1>those things where Rust isn't, like,

00:21:16.455 --> 00:21:17.735
<v Speaker 1>super opinionated,

00:21:17.735 --> 00:21:19.575
<v Speaker 1>I would say. And so there's a lot

00:21:19.575 --> 00:21:21.095
<v Speaker 1>of ways to handle,

00:21:21.575 --> 00:21:22.215
<v Speaker 1>like,

00:21:22.615 --> 00:21:23.734
<v Speaker 1>overloads,

00:21:23.895 --> 00:21:24.455
<v Speaker 1>essentially.

00:21:27.255 --> 00:21:28.135
<v Speaker 1>And

00:21:30.690 --> 00:21:32.450
<v Speaker 1>you can like, you could just have multiple

00:21:32.450 --> 00:21:34.450
<v Speaker 1>functions. You could have, like, multiple main like,

00:21:34.450 --> 00:21:36.290
<v Speaker 1>main and then main with arg or something

00:21:36.290 --> 00:21:38.530
<v Speaker 1>is one way to do it. You could

00:21:38.530 --> 00:21:41.810
<v Speaker 1>define a trait that has an associated type,

00:21:41.810 --> 00:21:43.650
<v Speaker 1>which is, like, the input and then, like,

00:21:43.650 --> 00:21:45.985
<v Speaker 1>do some type system shenanigans, but that's probably,

00:21:45.985 --> 00:21:48.545
<v Speaker 1>like, way way too much. And I'm not

00:21:48.545 --> 00:21:49.825
<v Speaker 1>even sure you could get, like, a nice

00:21:49.825 --> 00:21:51.265
<v Speaker 1>to use API out of that in this

00:21:51.265 --> 00:21:51.745
<v Speaker 1>case.

00:21:53.345 --> 00:21:55.585
<v Speaker 1>In this I I would recommend for the

00:21:55.665 --> 00:21:57.185
<v Speaker 1>for just this simple example where it's just,

00:21:57.185 --> 00:21:58.145
<v Speaker 1>like, a single argument

00:21:58.930 --> 00:22:02.049
<v Speaker 1>to do an into an input into

00:22:02.050 --> 00:22:02.770
<v Speaker 1>option.

00:22:03.730 --> 00:22:04.370
<v Speaker 1>So

00:22:05.330 --> 00:22:07.170
<v Speaker 1>what you can do is

00:22:07.570 --> 00:22:11.250
<v Speaker 1>instead of ampersand str, right, you do

00:22:11.650 --> 00:22:13.250
<v Speaker 1>input into

00:22:14.145 --> 00:22:15.905
<v Speaker 1>and then inside of the per type parameter

00:22:15.905 --> 00:22:19.265
<v Speaker 1>for into, it's option ampersand stir.

00:22:20.385 --> 00:22:21.985
<v Speaker 1>And so what that's gonna let us do

00:22:21.985 --> 00:22:23.664
<v Speaker 1>is either pass

00:22:23.825 --> 00:22:24.785
<v Speaker 1>an option

00:22:25.585 --> 00:22:27.265
<v Speaker 1>or pass

00:22:27.770 --> 00:22:29.369
<v Speaker 1>just the stir itself.

00:22:30.330 --> 00:22:32.409
<v Speaker 1>And so it'll kinda get so you would

00:22:32.409 --> 00:22:34.490
<v Speaker 1>have to change the interface on, like, number

00:22:34.490 --> 00:22:36.490
<v Speaker 1>nine, like, line nine. Just put a none

00:22:36.490 --> 00:22:37.849
<v Speaker 1>inside of the main.

00:22:38.649 --> 00:22:40.445
<v Speaker 1>But other than that, we can make this

00:22:40.445 --> 00:22:42.765
<v Speaker 1>work where you're passing none or you're passing

00:22:42.765 --> 00:22:43.725
<v Speaker 1>in David.

00:22:43.965 --> 00:22:45.325
<v Speaker 1>It's kinda like that's the way that I

00:22:45.325 --> 00:22:47.565
<v Speaker 1>like to do this exam exact example. And

00:22:47.565 --> 00:22:50.365
<v Speaker 1>so instead of option, it's impull into option.

00:22:51.565 --> 00:22:53.085
<v Speaker 1>Like let me see if I can type.

00:22:53.085 --> 00:22:53.725
<v Speaker 1>Oh, I cannot type.

00:22:55.190 --> 00:22:55.990
<v Speaker 0>Like that?

00:22:56.550 --> 00:22:59.110
<v Speaker 1>The into is a is, like, around the

00:22:59.110 --> 00:23:00.309
<v Speaker 1>option. Like, it's,

00:23:00.470 --> 00:23:02.230
<v Speaker 1>like, capital I into

00:23:05.270 --> 00:23:07.350
<v Speaker 1>and then open angle bracket

00:23:07.990 --> 00:23:08.950
<v Speaker 1>and then

00:23:09.505 --> 00:23:10.945
<v Speaker 1>close angle bracket. Yes.

00:23:11.745 --> 00:23:13.745
<v Speaker 1>Does this not like the what's this saying

00:23:13.745 --> 00:23:15.504
<v Speaker 1>on the the the ampersand?

00:23:17.265 --> 00:23:18.144
<v Speaker 0>Lifetime.

00:23:19.825 --> 00:23:20.385
<v Speaker 1>Really?

00:23:21.600 --> 00:23:22.240
<v Speaker 1>Sure.

00:23:22.400 --> 00:23:23.840
<v Speaker 1>Yeah. Oh, that's it.

00:23:26.000 --> 00:23:26.720
<v Speaker 0>Okay.

00:23:26.880 --> 00:23:27.760
<v Speaker 0>I

00:23:27.760 --> 00:23:29.119
<v Speaker 0>have no idea.

00:23:30.240 --> 00:23:32.240
<v Speaker 1>And so the way this so so

00:23:32.880 --> 00:23:34.799
<v Speaker 1>oh, you've not you've not been introduced? Okay.

00:23:34.799 --> 00:23:37.904
<v Speaker 1>So in Rust, there are three ways

00:23:38.065 --> 00:23:39.345
<v Speaker 1>to specify

00:23:40.145 --> 00:23:41.505
<v Speaker 1>generic

00:23:41.505 --> 00:23:42.385
<v Speaker 1>types

00:23:42.385 --> 00:23:43.664
<v Speaker 1>in functions.

00:23:44.065 --> 00:23:46.625
<v Speaker 1>So let let's do main two and main

00:23:46.625 --> 00:23:48.465
<v Speaker 1>three, just, like, copy this function, and we'll

00:23:48.465 --> 00:23:51.590
<v Speaker 1>do all three versions. That's cool. Okay.

00:23:52.790 --> 00:23:53.350
<v Speaker 1>So

00:23:53.830 --> 00:23:56.390
<v Speaker 1>the first one is the is the into

00:23:56.390 --> 00:23:57.110
<v Speaker 1>option.

00:23:57.910 --> 00:23:58.549
<v Speaker 1>Now

00:23:58.870 --> 00:24:00.950
<v Speaker 1>change the input into in both of these

00:24:00.950 --> 00:24:01.910
<v Speaker 1>to just t.

00:24:03.475 --> 00:24:05.554
<v Speaker 0>To just what? Sorry? To just t.

00:24:05.955 --> 00:24:08.195
<v Speaker 1>Like, just the capital t.

00:24:10.274 --> 00:24:12.514
<v Speaker 1>Like, the entire type should just be t.

00:24:12.514 --> 00:24:14.995
<v Speaker 1>Like, no option, no ampersands there. Just

00:24:17.730 --> 00:24:19.010
<v Speaker 1>And do that on the second one as

00:24:19.010 --> 00:24:19.490
<v Speaker 1>well.

00:24:24.290 --> 00:24:26.210
<v Speaker 1>And then on both of those, main two

00:24:26.210 --> 00:24:27.570
<v Speaker 1>and main three, we have to add a

00:24:27.570 --> 00:24:30.050
<v Speaker 1>lifetime parameter. So, basically, we have to declare

00:24:30.050 --> 00:24:33.885
<v Speaker 1>the type that is generic. Right? So it's

00:24:33.885 --> 00:24:36.525
<v Speaker 1>like, before the open parenthesis, you're gonna do

00:24:36.525 --> 00:24:38.685
<v Speaker 1>an open angle bracket, capital t, close angle

00:24:38.685 --> 00:24:39.325
<v Speaker 1>bracket.

00:24:39.485 --> 00:24:41.805
<v Speaker 1>No. No. No. Out right after the function

00:24:41.805 --> 00:24:42.125
<v Speaker 1>name.

00:24:46.799 --> 00:24:47.679
<v Speaker 1>And then

00:24:47.919 --> 00:24:49.440
<v Speaker 1>in the first one,

00:24:49.760 --> 00:24:52.799
<v Speaker 1>we're gonna do a a colon directly after

00:24:52.799 --> 00:24:54.719
<v Speaker 1>the t inside of the angle bracket.

00:24:56.480 --> 00:24:59.039
<v Speaker 1>In in the no. In the in

00:24:59.039 --> 00:25:00.880
<v Speaker 1>the type

00:25:00.205 --> 00:25:01.165
<v Speaker 1>declaration,

00:25:01.165 --> 00:25:03.405
<v Speaker 1>in the, like, the type parameter. Yeah. And

00:25:03.405 --> 00:25:06.045
<v Speaker 1>then we're gonna put the same into option

00:25:06.125 --> 00:25:08.285
<v Speaker 1>ampersands turn, but we're not gonna put impl.

00:25:10.765 --> 00:25:13.370
<v Speaker 1>And so this is saying we are declaring

00:25:13.370 --> 00:25:15.610
<v Speaker 1>a generic type, which is basically it's like

00:25:15.610 --> 00:25:17.929
<v Speaker 1>a variable for types. Right? It's like if

00:25:17.929 --> 00:25:18.649
<v Speaker 1>if,

00:25:19.370 --> 00:25:21.289
<v Speaker 1>you know, your name is a variable for

00:25:21.289 --> 00:25:23.690
<v Speaker 1>strings at runtime, t is a variable for

00:25:23.690 --> 00:25:25.370
<v Speaker 1>types that compile time where it could be

00:25:25.370 --> 00:25:26.970
<v Speaker 1>a string or it could be an option

00:25:26.970 --> 00:25:28.010
<v Speaker 1>string, etcetera, etcetera.

00:25:29.264 --> 00:25:31.344
<v Speaker 1>And then in the

00:25:31.664 --> 00:25:34.065
<v Speaker 1>the third one, in main three, we're gonna

00:25:34.065 --> 00:25:35.745
<v Speaker 1>go after the return type, and we're gonna

00:25:35.745 --> 00:25:36.784
<v Speaker 1>put a new line.

00:25:38.625 --> 00:25:40.225
<v Speaker 1>And we're gonna type where

00:25:41.250 --> 00:25:42.610
<v Speaker 1>and then new line

00:25:43.570 --> 00:25:46.370
<v Speaker 1>and then t colon and then the same

00:25:46.370 --> 00:25:46.610
<v Speaker 1>thing.

00:26:03.865 --> 00:26:05.544
<v Speaker 0>There you go. So

00:26:05.785 --> 00:26:08.105
<v Speaker 1>all three of these are the same thing.

00:26:08.105 --> 00:26:10.745
<v Speaker 1>There is one very slight difference

00:26:10.680 --> 00:26:12.440
<v Speaker 1>in that you cannot

00:26:12.840 --> 00:26:13.720
<v Speaker 1>manually

00:26:13.720 --> 00:26:16.360
<v Speaker 1>specify the type of the first one. The

00:26:16.360 --> 00:26:17.720
<v Speaker 1>first one is like a is like a

00:26:17.720 --> 00:26:20.120
<v Speaker 1>a more restrictive anonymous

00:26:20.440 --> 00:26:21.560
<v Speaker 1>type parameter,

00:26:21.800 --> 00:26:23.560
<v Speaker 1>so you can't do, like, turbo fish. So,

00:26:23.560 --> 00:26:25.320
<v Speaker 1>like, normally, in in main, you could type,

00:26:25.320 --> 00:26:28.005
<v Speaker 1>like, super main colon colon open angle bracket

00:26:28.005 --> 00:26:29.445
<v Speaker 1>and then the actual type, and then it

00:26:29.445 --> 00:26:31.524
<v Speaker 1>would type check. It would not infer the

00:26:31.524 --> 00:26:32.084
<v Speaker 1>type.

00:26:32.804 --> 00:26:33.364
<v Speaker 1>But

00:26:33.684 --> 00:26:35.524
<v Speaker 1>with the the first one, because it's an

00:26:35.524 --> 00:26:37.044
<v Speaker 1>impl, that's disabled.

00:26:37.284 --> 00:26:39.760
<v Speaker 1>But the second two, because they are actually

00:26:39.760 --> 00:26:42.320
<v Speaker 1>declared in the the type parameter list, then

00:26:42.320 --> 00:26:44.800
<v Speaker 1>you can actually turbo fish and specify what

00:26:44.800 --> 00:26:46.240
<v Speaker 1>you think the type should be.

00:26:46.640 --> 00:26:48.320
<v Speaker 1>But in all these cases, we're saying there

00:26:48.320 --> 00:26:49.840
<v Speaker 1>is going to be like, we accept multiple

00:26:49.840 --> 00:26:51.815
<v Speaker 1>different types of types. So it's gonna it's

00:26:51.815 --> 00:26:53.815
<v Speaker 1>gonna generate a compile time multiple versions of

00:26:53.815 --> 00:26:55.575
<v Speaker 1>this function that accepts different types.

00:26:56.135 --> 00:26:59.174
<v Speaker 1>And as long as it has an into

00:26:59.175 --> 00:26:59.895
<v Speaker 1>option,

00:27:00.055 --> 00:27:02.375
<v Speaker 1>it'll work. And an into option star, it

00:27:02.375 --> 00:27:03.655
<v Speaker 1>will work. And right now,

00:27:04.580 --> 00:27:06.580
<v Speaker 1>all these like, we're not actually like, the

00:27:06.580 --> 00:27:08.020
<v Speaker 1>tests are gonna fail because we haven't actually

00:27:08.020 --> 00:27:10.580
<v Speaker 1>started using that type parameter correctly yet, but,

00:27:10.580 --> 00:27:12.019
<v Speaker 1>like, we can then,

00:27:12.260 --> 00:27:12.820
<v Speaker 1>like,

00:27:13.540 --> 00:27:15.860
<v Speaker 1>implement like, to call the into trait to

00:27:15.860 --> 00:27:17.545
<v Speaker 1>get an option, and then we can check

00:27:17.545 --> 00:27:19.625
<v Speaker 1>it option, see if we have a name,

00:27:19.625 --> 00:27:21.065
<v Speaker 1>and then handle the default case and do

00:27:21.065 --> 00:27:23.145
<v Speaker 1>everything that our tests kinda expect us to

00:27:23.145 --> 00:27:23.545
<v Speaker 1>do.

00:27:24.185 --> 00:27:25.385
<v Speaker 0>Okay. Awesome.

00:27:26.185 --> 00:27:27.705
<v Speaker 0>So just to make sure I understood this

00:27:27.705 --> 00:27:28.025
<v Speaker 0>correctly.

00:27:28.900 --> 00:27:30.900
<v Speaker 0>These are two different approaches for providing a

00:27:30.900 --> 00:27:32.900
<v Speaker 0>function that takes a generic type when they

00:27:32.900 --> 00:27:34.260
<v Speaker 0>were given a little bit of guidance to

00:27:34.260 --> 00:27:35.620
<v Speaker 0>what we think that generic type is gonna

00:27:35.620 --> 00:27:38.100
<v Speaker 0>be. I'm assuming with this one, can I

00:27:38.100 --> 00:27:40.740
<v Speaker 0>have multiple implementations of this where the WER

00:27:40.785 --> 00:27:43.745
<v Speaker 0>type is different without changing the name?

00:27:44.065 --> 00:27:46.705
<v Speaker 1>No. Yeah. Rust doesn't do overloads like that.

00:27:47.905 --> 00:27:50.145
<v Speaker 1>That that's like what you're what you're talking

00:27:50.145 --> 00:27:52.225
<v Speaker 1>about is called specialization.

00:27:53.025 --> 00:27:53.265
<v Speaker 1>And

00:27:54.310 --> 00:27:57.270
<v Speaker 1>I'm not sure specialization will be usable directly

00:27:57.270 --> 00:27:59.030
<v Speaker 1>on functions. I think it it'll have to

00:27:59.030 --> 00:28:00.950
<v Speaker 1>be done via traits.

00:28:03.110 --> 00:28:04.950
<v Speaker 1>I'm not sure. It's like the feature doesn't

00:28:04.950 --> 00:28:07.030
<v Speaker 1>exist yet. So it's like

00:28:07.595 --> 00:28:08.235
<v Speaker 0>Okay.

00:28:08.715 --> 00:28:10.155
<v Speaker 0>I'm I'm just thinking, I guess. Let this

00:28:10.155 --> 00:28:11.835
<v Speaker 0>list to me. I had a lot of

00:28:11.835 --> 00:28:13.915
<v Speaker 0>a Alexa experience. This feels like a guard

00:28:13.915 --> 00:28:15.675
<v Speaker 0>where we're saying we expect this type of

00:28:15.675 --> 00:28:17.115
<v Speaker 0>function to be exist here. But I would

00:28:17.115 --> 00:28:19.435
<v Speaker 0>normally expect that to be over loadable, but

00:28:19.835 --> 00:28:20.155
<v Speaker 0>It's not.

00:28:21.220 --> 00:28:23.220
<v Speaker 0>That that's fine. So let's comment this one

00:28:23.220 --> 00:28:24.100
<v Speaker 0>out just now.

00:28:24.820 --> 00:28:26.660
<v Speaker 0>This one, I understand.

00:28:27.140 --> 00:28:29.140
<v Speaker 0>You explained that very well. And I wanna

00:28:29.140 --> 00:28:30.820
<v Speaker 0>do one more thing with this one before

00:28:30.820 --> 00:28:32.660
<v Speaker 0>we move on. Who'd have thought we'd spend

00:28:32.660 --> 00:28:34.264
<v Speaker 0>so much time on Hello World? Like

00:28:35.784 --> 00:28:38.024
<v Speaker 0>but it's it's really a lot of noise

00:28:38.024 --> 00:28:40.184
<v Speaker 0>coming from here, so I really appreciate that.

00:28:40.345 --> 00:28:43.225
<v Speaker 0>Now I wanna talk about the semantic differences

00:28:43.225 --> 00:28:43.945
<v Speaker 0>between

00:28:44.424 --> 00:28:47.705
<v Speaker 0>these. Now my understanding of Rust, I think,

00:28:47.705 --> 00:28:50.190
<v Speaker 0>is this this this is just an online

00:28:50.190 --> 00:28:52.350
<v Speaker 0>type where we're saying that something that implements

00:28:52.350 --> 00:28:54.670
<v Speaker 0>the n two trait, so it can automatically

00:28:54.670 --> 00:28:57.470
<v Speaker 0>do the conversion for us. Mhmm. Whereas if

00:28:57.470 --> 00:28:58.750
<v Speaker 0>we do this option,

00:28:59.390 --> 00:29:01.470
<v Speaker 0>we would expect the option to be passed

00:29:01.470 --> 00:29:03.470
<v Speaker 0>in, meaning we would call some

00:29:03.885 --> 00:29:04.684
<v Speaker 0>David.

00:29:04.925 --> 00:29:07.404
<v Speaker 0>Mean Exactly. Is that right? Okay. Yes.

00:29:08.605 --> 00:29:09.325
<v Speaker 0>Cool.

00:29:09.485 --> 00:29:11.725
<v Speaker 0>Yeah. I I've never seen this in line

00:29:11.725 --> 00:29:12.845
<v Speaker 0>implementation

00:29:12.845 --> 00:29:15.404
<v Speaker 0>of a tree kind of type parameter. That's

00:29:15.645 --> 00:29:16.525
<v Speaker 0>pretty nifty.

00:29:17.085 --> 00:29:19.005
<v Speaker 1>Yeah. It comes in handy sometimes. Like,

00:29:19.510 --> 00:29:22.070
<v Speaker 1>I I I tend to prefer wearer bounds

00:29:22.070 --> 00:29:24.150
<v Speaker 1>as like a rule just because, like, I

00:29:24.150 --> 00:29:25.510
<v Speaker 1>think they look a lot nicer and they're

00:29:25.510 --> 00:29:26.389
<v Speaker 1>easier to read.

00:29:26.790 --> 00:29:27.350
<v Speaker 1>But

00:29:27.830 --> 00:29:30.790
<v Speaker 1>especially for, like, really short traits,

00:29:31.725 --> 00:29:33.805
<v Speaker 1>I find it can be really nice and

00:29:33.805 --> 00:29:37.165
<v Speaker 1>definitely and even more readable than whereabouts. Just

00:29:37.165 --> 00:29:39.004
<v Speaker 1>do, like, import as ref

00:29:39.165 --> 00:29:40.845
<v Speaker 1>u h or something like that, you know.

00:29:40.845 --> 00:29:42.045
<v Speaker 1>And if you're just it's just gonna be,

00:29:42.045 --> 00:29:45.165
<v Speaker 1>like, very short, like, 10 characters or less

00:29:45.165 --> 00:29:45.965
<v Speaker 1>trait name.

00:29:46.370 --> 00:29:48.210
<v Speaker 1>It fits well into a type position.

00:29:49.170 --> 00:29:52.050
<v Speaker 0>Alright. Awesome. Okay. I'll leave that comment today

00:29:52.050 --> 00:29:53.330
<v Speaker 0>because when I push this code up and

00:29:53.330 --> 00:29:54.690
<v Speaker 0>added to the show notes, I think those

00:29:54.690 --> 00:29:56.850
<v Speaker 0>examples might be useful for for other people.

00:29:56.850 --> 00:29:57.330
<v Speaker 0>So

00:29:58.130 --> 00:29:59.650
<v Speaker 0>let's make our test pass and then we'll

00:29:59.650 --> 00:30:01.490
<v Speaker 0>move on to the next example. So

00:30:01.975 --> 00:30:04.695
<v Speaker 0>right now, this is still gonna fail, but

00:30:04.695 --> 00:30:06.534
<v Speaker 0>we could well, let's see what happens when

00:30:06.534 --> 00:30:07.254
<v Speaker 0>it fails.

00:30:11.975 --> 00:30:13.815
<v Speaker 1>Your main has to put none in it.

00:30:15.770 --> 00:30:16.889
<v Speaker 0>Of course. Okay.

00:30:18.809 --> 00:30:21.529
<v Speaker 0>Also, my app my application didn't compile, so

00:30:21.529 --> 00:30:23.370
<v Speaker 0>the test didn't run? Mhmm. Is that what

00:30:23.450 --> 00:30:26.169
<v Speaker 0>alright. Okay. So the default work, we don't

00:30:26.169 --> 00:30:27.929
<v Speaker 0>have the names. And then we update our

00:30:27.929 --> 00:30:28.330
<v Speaker 0>code,

00:30:29.255 --> 00:30:31.174
<v Speaker 0>like, good TDD developers,

00:30:31.575 --> 00:30:34.054
<v Speaker 0>and we say, okay. This is the

00:30:36.375 --> 00:30:37.094
<v Speaker 0>name.

00:30:39.255 --> 00:30:41.414
<v Speaker 1>And that won't work. But yeah. So that's,

00:30:41.414 --> 00:30:42.695
<v Speaker 1>like, the first step. Right?

00:30:43.620 --> 00:30:45.780
<v Speaker 1>And so the reason that won't work is

00:30:45.780 --> 00:30:46.500
<v Speaker 1>because

00:30:47.060 --> 00:30:50.580
<v Speaker 1>right now, the only thing the compiler knows

00:30:50.580 --> 00:30:52.500
<v Speaker 1>about that type is that it implements the

00:30:52.500 --> 00:30:53.460
<v Speaker 1>into trait.

00:30:53.700 --> 00:30:55.700
<v Speaker 1>It does not know if you can display

00:30:55.700 --> 00:30:56.900
<v Speaker 1>it. It does not know,

00:30:57.725 --> 00:30:59.965
<v Speaker 1>like, if it is already a string or

00:30:59.965 --> 00:31:02.125
<v Speaker 1>an option string. Like, it's less so it

00:31:02.125 --> 00:31:04.044
<v Speaker 1>will not let you do anything

00:31:04.285 --> 00:31:07.085
<v Speaker 1>except call into. It's literally the only thing

00:31:07.085 --> 00:31:08.685
<v Speaker 1>you can do with this type. And so

00:31:08.685 --> 00:31:10.365
<v Speaker 1>first, you have to like, before you I

00:31:10.365 --> 00:31:11.565
<v Speaker 1>would do this on, like, a line before

00:31:11.565 --> 00:31:12.925
<v Speaker 1>that so you don't get, like, some, like,

00:31:12.925 --> 00:31:14.370
<v Speaker 1>super long thing.

00:31:15.090 --> 00:31:17.170
<v Speaker 1>Just do, like, let name equal name dot

00:31:17.170 --> 00:31:17.890
<v Speaker 1>into.

00:31:18.290 --> 00:31:20.530
<v Speaker 1>And this is just gonna first invoke

00:31:20.770 --> 00:31:23.970
<v Speaker 1>that trait that we constrained the type by.

00:31:23.970 --> 00:31:26.530
<v Speaker 1>And so that now we know for sure

00:31:26.770 --> 00:31:27.890
<v Speaker 1>that name

00:31:28.315 --> 00:31:29.595
<v Speaker 1>is an option

00:31:29.995 --> 00:31:31.035
<v Speaker 1>static string.

00:31:31.195 --> 00:31:31.755
<v Speaker 1>Right?

00:31:32.075 --> 00:31:34.155
<v Speaker 1>And so you can print that, and it

00:31:34.155 --> 00:31:35.915
<v Speaker 1>will probably still not compile because I don't

00:31:35.915 --> 00:31:38.315
<v Speaker 1>think option implements display. I think it only

00:31:38.315 --> 00:31:39.674
<v Speaker 1>implements debug.

00:31:39.915 --> 00:31:41.275
<v Speaker 1>And we could unwrap it, but that would

00:31:41.275 --> 00:31:42.790
<v Speaker 1>not that would break the default case. But

00:31:42.790 --> 00:31:44.150
<v Speaker 1>but that might be, like, a fun, you

00:31:44.150 --> 00:31:46.070
<v Speaker 1>know, half next step.

00:31:48.150 --> 00:31:48.789
<v Speaker 0>Okay.

00:31:49.590 --> 00:31:51.670
<v Speaker 0>So I understood that correctly. That is just

00:31:51.670 --> 00:31:53.590
<v Speaker 0>con that's just confirms that we have an

00:31:53.590 --> 00:31:53.830
<v Speaker 0>option

00:31:54.565 --> 00:31:57.044
<v Speaker 0>string types. And we It does

00:31:57.685 --> 00:32:00.245
<v Speaker 1>the conversion and gives us the the the

00:32:00.245 --> 00:32:02.405
<v Speaker 1>type that is now, like, statically known.

00:32:03.845 --> 00:32:04.725
<v Speaker 0>K. So

00:32:04.965 --> 00:32:07.285
<v Speaker 0>would that work? No. It would work. Yeah.

00:32:07.285 --> 00:32:09.320
<v Speaker 1>That would work. But your main would still

00:32:09.320 --> 00:32:11.640
<v Speaker 1>probably not compile. No. Your main would compile.

00:32:12.920 --> 00:32:15.400
<v Speaker 0>So why are you complaining at me, Rust?

00:32:18.840 --> 00:32:20.280
<v Speaker 0>I don't know why the error is at

00:32:20.280 --> 00:32:21.560
<v Speaker 0>the bottom of the docs and not the

00:32:21.560 --> 00:32:21.800
<v Speaker 0>top.

00:32:22.725 --> 00:32:24.405
<v Speaker 0>I keep meaning to fail an issue for

00:32:24.405 --> 00:32:24.965
<v Speaker 0>that.

00:32:27.365 --> 00:32:29.845
<v Speaker 0>It takes one parameter, but two were given.

00:32:30.725 --> 00:32:33.445
<v Speaker 0>Oh. Oh. I see the string from. Yes.

00:32:33.445 --> 00:32:34.725
<v Speaker 1>So you just change it to a format.

00:32:38.190 --> 00:32:41.070
<v Speaker 1>Not not string format. Just Yeah. For yeah.

00:32:41.070 --> 00:32:42.429
<v Speaker 0>There we go. Yeah.

00:32:44.510 --> 00:32:45.230
<v Speaker 0>K.

00:32:47.790 --> 00:32:49.630
<v Speaker 1>So it should compile.

00:32:50.924 --> 00:32:52.524
<v Speaker 0>Doesn't implement display.

00:32:52.605 --> 00:32:53.565
<v Speaker 1>But

00:32:53.565 --> 00:32:55.325
<v Speaker 1>you don't you you're not using display. You're

00:32:55.325 --> 00:32:56.684
<v Speaker 1>using debug.

00:32:56.764 --> 00:32:59.164
<v Speaker 0>Oh, it just took a moment. Oh, okay.

00:32:59.245 --> 00:33:01.005
<v Speaker 1>Yeah. So that should compile, but should fail

00:33:01.005 --> 00:33:01.485
<v Speaker 1>tests.

00:33:05.059 --> 00:33:07.460
<v Speaker 0>Yes. Because we have okay. So now we

00:33:07.460 --> 00:33:09.219
<v Speaker 0>have the option type.

00:33:09.460 --> 00:33:12.740
<v Speaker 1>Yes. And so now we just wanna do

00:33:12.740 --> 00:33:16.179
<v Speaker 1>is unwrap it and provide the default case.

00:33:16.179 --> 00:33:17.539
<v Speaker 1>So we're gonna do unwrap

00:33:17.735 --> 00:33:20.054
<v Speaker 1>or unwrap underscore or

00:33:20.135 --> 00:33:20.934
<v Speaker 1>and then

00:33:21.575 --> 00:33:22.295
<v Speaker 1>world.

00:33:23.495 --> 00:33:25.175
<v Speaker 1>And so that's gonna give us I think

00:33:25.175 --> 00:33:26.535
<v Speaker 1>it needs to be lower case based on,

00:33:26.535 --> 00:33:28.054
<v Speaker 1>like, your Yeah.

00:33:28.935 --> 00:33:29.255
<v Speaker 1>Yeah.

00:33:30.140 --> 00:33:32.060
<v Speaker 1>And so that'll either give us the string

00:33:32.060 --> 00:33:34.220
<v Speaker 1>that we were passed in via the into

00:33:34.220 --> 00:33:36.700
<v Speaker 1>type, or it will give us the default

00:33:36.700 --> 00:33:38.860
<v Speaker 1>case. And that should pass through your tests.

00:33:40.300 --> 00:33:40.860
<v Speaker 0>Yay.

00:33:44.085 --> 00:33:46.085
<v Speaker 0>Nice. Okay. Cool. So

00:33:48.965 --> 00:33:50.565
<v Speaker 0>the next step would be

00:33:51.445 --> 00:33:53.685
<v Speaker 0>if we want to accept and

00:33:55.765 --> 00:33:57.285
<v Speaker 1>What kind of input you wanna accept?

00:33:58.910 --> 00:34:00.990
<v Speaker 0>Why don't we like, I don't feel we

00:34:00.990 --> 00:34:02.670
<v Speaker 0>need to go down the route of prompting

00:34:02.670 --> 00:34:03.790
<v Speaker 0>interactively.

00:34:03.790 --> 00:34:05.150
<v Speaker 0>So if if we could just make it

00:34:05.150 --> 00:34:07.870
<v Speaker 0>satisfy something like cargo run with the first

00:34:07.870 --> 00:34:09.630
<v Speaker 0>parameter and we'll just pull that out, pass

00:34:09.630 --> 00:34:11.645
<v Speaker 0>it through, and then Okay. So

00:34:15.965 --> 00:34:17.885
<v Speaker 1>the the easiest way to get the the

00:34:17.885 --> 00:34:21.165
<v Speaker 1>parameters is from stood and it's one of

00:34:21.165 --> 00:34:22.925
<v Speaker 1>the modules in this shared library,

00:34:23.165 --> 00:34:24.364
<v Speaker 1>and it provides

00:34:24.364 --> 00:34:25.645
<v Speaker 1>the args functions.

00:34:26.219 --> 00:34:27.340
<v Speaker 1>So args,

00:34:27.340 --> 00:34:28.620
<v Speaker 1>the the

00:34:28.859 --> 00:34:30.380
<v Speaker 1>fourth one in that list,

00:34:30.859 --> 00:34:33.020
<v Speaker 1>gives you an iterator type,

00:34:33.179 --> 00:34:35.500
<v Speaker 1>which is gonna iterate over all the args

00:34:35.900 --> 00:34:37.580
<v Speaker 1>in the command line.

00:34:39.420 --> 00:34:40.219
<v Speaker 1>And

00:34:40.764 --> 00:34:43.405
<v Speaker 1>the the first one should be the program

00:34:43.405 --> 00:34:45.645
<v Speaker 1>names. You're gonna want the second one. So,

00:34:45.645 --> 00:34:46.205
<v Speaker 1>like,

00:34:46.844 --> 00:34:48.525
<v Speaker 1>dot nth one

00:34:51.885 --> 00:34:55.165
<v Speaker 1>with just n t h. Oh, nth.

00:34:57.839 --> 00:35:00.160
<v Speaker 1>And then, like, let yeah. Let me pull

00:35:00.160 --> 00:35:01.599
<v Speaker 1>that. And then

00:35:02.160 --> 00:35:04.960
<v Speaker 1>you could probably just pass that straight in

00:35:05.680 --> 00:35:07.760
<v Speaker 1>and because that's that's an option as an

00:35:07.760 --> 00:35:10.160
<v Speaker 1>into option, so that works. And that'll just

00:35:10.974 --> 00:35:12.655
<v Speaker 1>if you don't give it an argument,

00:35:13.135 --> 00:35:14.734
<v Speaker 1>it will do hello world. And if you

00:35:14.734 --> 00:35:16.815
<v Speaker 1>give it an argument, it'll do hello whoever.

00:35:17.375 --> 00:35:19.535
<v Speaker 0>But we get an uppercase string instead of

00:35:20.255 --> 00:35:22.494
<v Speaker 1>Oh, okay. So then do as ref after

00:35:22.494 --> 00:35:22.734
<v Speaker 1>name.

00:35:24.630 --> 00:35:26.070
<v Speaker 0>As ref.

00:35:27.829 --> 00:35:29.430
<v Speaker 1>Oh, what do we got now?

00:35:31.910 --> 00:35:34.630
<v Speaker 0>Yes. I think we As d ref?

00:35:39.964 --> 00:35:41.484
<v Speaker 0>Does not live long enough.

00:35:44.365 --> 00:35:45.964
<v Speaker 0>Yeah. It says name does not, like, live

00:35:45.964 --> 00:35:46.925
<v Speaker 0>long enough

00:35:47.164 --> 00:35:48.525
<v Speaker 0>borrowed value.

00:35:49.484 --> 00:35:50.285
<v Speaker 0>Borrowed

00:35:50.285 --> 00:35:51.805
<v Speaker 0>value does not live long enough. There we

00:35:51.805 --> 00:35:51.964
<v Speaker 0>go.

00:35:53.060 --> 00:35:54.900
<v Speaker 1>Oh, because because

00:35:55.620 --> 00:35:57.860
<v Speaker 1>because we constrained it to a static type.

00:35:58.340 --> 00:35:59.940
<v Speaker 1>So can you go back to the live

00:35:59.940 --> 00:36:00.900
<v Speaker 1>dot r s?

00:36:01.860 --> 00:36:03.940
<v Speaker 1>And can you just instead of static,

00:36:04.340 --> 00:36:06.420
<v Speaker 1>can you can you add a just do

00:36:06.420 --> 00:36:07.380
<v Speaker 1>tick a

00:36:08.575 --> 00:36:09.375
<v Speaker 1>and then

00:36:09.615 --> 00:36:12.255
<v Speaker 1>add a a generic parameter for just the

00:36:12.255 --> 00:36:12.895
<v Speaker 1>lifetime?

00:36:13.775 --> 00:36:15.375
<v Speaker 1>So go back to the main like, the

00:36:15.375 --> 00:36:17.535
<v Speaker 1>function name and open angle brackets and then

00:36:17.535 --> 00:36:18.415
<v Speaker 1>tick a.

00:36:19.615 --> 00:36:21.615
<v Speaker 1>And let's see if that's happy. Yeah. There

00:36:21.615 --> 00:36:23.810
<v Speaker 1>we go. We're good. I don't know why

00:36:23.810 --> 00:36:26.690
<v Speaker 1>it's not able to infer a lifetime inside

00:36:26.690 --> 00:36:29.090
<v Speaker 1>of the trait the into trait. That's that's

00:36:29.090 --> 00:36:29.730
<v Speaker 1>strange.

00:36:30.130 --> 00:36:30.690
<v Speaker 1>Must be

00:36:33.010 --> 00:36:35.570
<v Speaker 0>Okay. So let's break that down as well

00:36:35.235 --> 00:36:36.755
<v Speaker 0>briefly then. So when we use the tech

00:36:36.755 --> 00:36:38.835
<v Speaker 0>static, what we're saying is this string will

00:36:38.835 --> 00:36:40.355
<v Speaker 0>live in memory for the lifetime of the

00:36:40.355 --> 00:36:41.715
<v Speaker 0>program's execution.

00:36:42.035 --> 00:36:44.435
<v Speaker 0>Yes. When we say tech a,

00:36:44.995 --> 00:36:46.675
<v Speaker 0>and this is part of the signature here

00:36:46.675 --> 00:36:48.195
<v Speaker 0>in this function, what we're saying is the

00:36:48.195 --> 00:36:49.715
<v Speaker 0>string will live long enough for this function

00:36:49.715 --> 00:36:52.650
<v Speaker 0>to run only. Is that no? No. No.

00:36:52.650 --> 00:36:54.250
<v Speaker 1>What we're saying is

00:36:54.730 --> 00:36:57.849
<v Speaker 1>the string will live for some generic lifetime.

00:36:57.849 --> 00:37:00.410
<v Speaker 1>So tick a is a generic parameter that

00:37:00.410 --> 00:37:01.370
<v Speaker 1>is like

00:37:01.849 --> 00:37:03.690
<v Speaker 1>it it's acting like generic, though it's like

00:37:03.690 --> 00:37:05.255
<v Speaker 1>not really the same thing because it has,

00:37:05.255 --> 00:37:06.535
<v Speaker 1>like, all sort of special case rules because

00:37:06.535 --> 00:37:07.735
<v Speaker 1>lifetimes are wild.

00:37:09.015 --> 00:37:09.655
<v Speaker 1>But,

00:37:09.815 --> 00:37:12.135
<v Speaker 1>essentially, it's saying, like, there is there is

00:37:12.135 --> 00:37:13.495
<v Speaker 1>some lifetime

00:37:14.695 --> 00:37:15.335
<v Speaker 1>that,

00:37:15.495 --> 00:37:17.975
<v Speaker 1>you know, that this function will accept or,

00:37:17.975 --> 00:37:19.815
<v Speaker 1>like, this will accept, like, any lifetime, really.

00:37:21.119 --> 00:37:21.680
<v Speaker 1>And

00:37:22.640 --> 00:37:25.039
<v Speaker 1>the this is specifying, you know, whatever that

00:37:25.039 --> 00:37:27.440
<v Speaker 1>specific lifetime is. Like, it's it's not the

00:37:27.440 --> 00:37:29.440
<v Speaker 1>lifetime of this function. It's the lifetime of

00:37:29.440 --> 00:37:31.200
<v Speaker 1>the data that is being passed in. It

00:37:31.200 --> 00:37:32.000
<v Speaker 1>is, like, actually,

00:37:32.495 --> 00:37:34.255
<v Speaker 1>when you pass in the data, it infers

00:37:34.255 --> 00:37:36.735
<v Speaker 1>the lifetime that that variable is associated with

00:37:36.815 --> 00:37:38.575
<v Speaker 1>from the data that it's passed in. So

00:37:38.575 --> 00:37:40.575
<v Speaker 1>now for that, like, specific piece of data

00:37:40.575 --> 00:37:42.495
<v Speaker 1>that you passed in, it's like that's what

00:37:42.495 --> 00:37:44.095
<v Speaker 1>the tick a means. It's like the string

00:37:44.095 --> 00:37:46.340
<v Speaker 1>that you're passing in in the main function

00:37:46.340 --> 00:37:48.420
<v Speaker 1>is the tick a is referring to how

00:37:48.420 --> 00:37:49.700
<v Speaker 1>long that string lives.

00:37:49.940 --> 00:37:51.940
<v Speaker 1>And the the entire like, how you use

00:37:51.940 --> 00:37:53.460
<v Speaker 1>that throughout the rest of the function definition

00:37:53.460 --> 00:37:54.820
<v Speaker 1>is basically constraining,

00:37:54.820 --> 00:37:57.380
<v Speaker 1>like, oh, however long that input string lives,

00:37:57.380 --> 00:37:58.820
<v Speaker 1>you have to make sure, like, my output

00:37:58.820 --> 00:38:00.260
<v Speaker 1>type. If I were to, like, put tick

00:38:00.260 --> 00:38:02.625
<v Speaker 1>a as like constraint on the like the

00:38:02.625 --> 00:38:05.025
<v Speaker 1>borrow of like a return type, then like

00:38:05.025 --> 00:38:07.105
<v Speaker 1>just make sure that like whatever I returned

00:38:07.105 --> 00:38:09.905
<v Speaker 1>to you doesn't live longer than that borrow

00:38:09.905 --> 00:38:11.025
<v Speaker 1>that you made

00:38:11.185 --> 00:38:13.745
<v Speaker 1>on this string in the main function

00:38:13.905 --> 00:38:15.265
<v Speaker 1>is what you're essentially saying.

00:38:15.849 --> 00:38:16.650
<v Speaker 0>Awesome.

00:38:16.730 --> 00:38:17.450
<v Speaker 0>Cool.

00:38:18.650 --> 00:38:21.210
<v Speaker 0>So the compiler works out then. Right? Yes.

00:38:21.210 --> 00:38:24.569
<v Speaker 1>Okay. We have a couple more comments there.

00:38:24.569 --> 00:38:27.690
<v Speaker 0>So Patrick says, never consider using that interesting.

00:38:27.690 --> 00:38:29.690
<v Speaker 0>That's nifty. Yep. I I thought the same.

00:38:29.985 --> 00:38:32.225
<v Speaker 0>But also followed up with, could we use

00:38:32.225 --> 00:38:34.385
<v Speaker 0>a tick underscore for the lifetime instead of

00:38:34.385 --> 00:38:36.305
<v Speaker 0>tick a? Yeah. Let's try it. Get get

00:38:36.305 --> 00:38:39.025
<v Speaker 1>rid of the the parameter, the declaration and

00:38:39.745 --> 00:38:41.905
<v Speaker 1>no. No. You did just put nothing there.

00:38:42.145 --> 00:38:44.145
<v Speaker 1>Like, get rid of the the angle brackets

00:38:44.145 --> 00:38:46.760
<v Speaker 1>altogether and just put tick underscore. And

00:38:48.280 --> 00:38:49.320
<v Speaker 1>see if that works.

00:38:52.599 --> 00:38:53.720
<v Speaker 0>No.

00:38:53.720 --> 00:38:54.600
<v Speaker 0>I can't Can

00:38:55.240 --> 00:38:56.839
<v Speaker 1>you run it in the terminal? I just

00:38:56.839 --> 00:38:58.119
<v Speaker 1>wanna see if it gives I think it

00:38:58.119 --> 00:38:59.800
<v Speaker 1>might be cutting off some of the diagnostic.

00:39:01.665 --> 00:39:02.225
<v Speaker 0>Don't

00:39:02.945 --> 00:39:03.505
<v Speaker 1>Sure.

00:39:05.265 --> 00:39:07.265
<v Speaker 1>Missing license is fire. Okay. It does not

00:39:07.265 --> 00:39:09.665
<v Speaker 1>specifically say that you're not allowed to do

00:39:10.385 --> 00:39:12.305
<v Speaker 1>interesting. Okay. Go back. Yeah. I was just

00:39:12.385 --> 00:39:14.385
<v Speaker 1>I was expecting the diagnostic to be, like,

00:39:15.119 --> 00:39:17.119
<v Speaker 1>more aware of the situation. Because a lot

00:39:17.119 --> 00:39:19.279
<v Speaker 1>of times, like, Rust actually understand like, the

00:39:19.279 --> 00:39:21.680
<v Speaker 1>compiler understands a lot more than just the

00:39:21.680 --> 00:39:23.760
<v Speaker 1>language. This is, like, if you ever watch

00:39:23.760 --> 00:39:26.160
<v Speaker 1>Esteban's talk at RustConf, he he goes into

00:39:26.160 --> 00:39:26.240
<v Speaker 1>this.

00:39:27.135 --> 00:39:29.535
<v Speaker 1>It's it's quite good talk. Highly recommend it.

00:39:30.415 --> 00:39:32.175
<v Speaker 1>Where, like, you have to understand, like, a

00:39:32.175 --> 00:39:33.935
<v Speaker 1>superset of the language

00:39:34.095 --> 00:39:36.255
<v Speaker 1>in order to, like, do good error messages.

00:39:36.255 --> 00:39:38.335
<v Speaker 1>You have to understand what people meant,

00:39:38.655 --> 00:39:40.095
<v Speaker 1>not what they said. Even if what they,

00:39:40.095 --> 00:39:42.495
<v Speaker 1>like, said is completely nonsensical in your language.

00:39:42.950 --> 00:39:44.869
<v Speaker 1>And so I would have expected in this

00:39:44.869 --> 00:39:47.509
<v Speaker 1>case for it to be like, no. You're

00:39:47.509 --> 00:39:50.630
<v Speaker 1>not allowed to put an inferred lifetime here

00:39:50.630 --> 00:39:52.230
<v Speaker 1>because of this rule and to give you,

00:39:52.230 --> 00:39:54.069
<v Speaker 1>like, a clear explanation, but it didn't. So

00:39:54.069 --> 00:39:55.109
<v Speaker 1>I was that's what I was a little

00:39:55.109 --> 00:39:56.070
<v Speaker 1>bit surprised by.

00:39:56.390 --> 00:39:59.165
<v Speaker 0>Oh, okay. Cool. Yeah. So one of the

00:39:59.165 --> 00:40:01.165
<v Speaker 0>previous guests was talking about the error messages

00:40:01.165 --> 00:40:03.005
<v Speaker 0>and the effort to enter their to the

00:40:03.005 --> 00:40:05.325
<v Speaker 0>point where I think JavaScript style async await

00:40:05.325 --> 00:40:07.485
<v Speaker 0>was actually implemented in the compiler so that

00:40:07.485 --> 00:40:09.565
<v Speaker 0>they could recommend or explain how to do

00:40:09.565 --> 00:40:11.085
<v Speaker 0>it in the Rust way, which I thought

00:40:11.085 --> 00:40:11.725
<v Speaker 0>was very clever.

00:40:13.950 --> 00:40:15.790
<v Speaker 0>Okay. So we should be we should be

00:40:15.790 --> 00:40:17.310
<v Speaker 0>done, I think, whoever

00:40:17.790 --> 00:40:19.870
<v Speaker 0>very contrived hello world. But I I think

00:40:20.190 --> 00:40:21.230
<v Speaker 1>And now we should be able to run

00:40:21.230 --> 00:40:22.030
<v Speaker 1>it. We should be able to run it

00:40:22.030 --> 00:40:23.950
<v Speaker 1>and pass in an argument and have it

00:40:23.950 --> 00:40:25.710
<v Speaker 1>do with no argument, it should do the

00:40:25.710 --> 00:40:26.030
<v Speaker 1>default.

00:40:27.615 --> 00:40:28.655
<v Speaker 1>Hello, world.

00:40:30.175 --> 00:40:31.375
<v Speaker 0>Ta da. Oh.

00:40:33.775 --> 00:40:35.615
<v Speaker 0>We covered a lot of

00:40:36.015 --> 00:40:38.415
<v Speaker 0>nice Rust things there. So that was that

00:40:38.415 --> 00:40:39.215
<v Speaker 0>was great.

00:40:39.375 --> 00:40:40.255
<v Speaker 0>Let's

00:40:40.255 --> 00:40:42.660
<v Speaker 0>move on then. Unless you think there's anything

00:40:42.660 --> 00:40:44.020
<v Speaker 0>you wanna add to this before we go

00:40:44.020 --> 00:40:44.500
<v Speaker 0>back.

00:40:44.980 --> 00:40:46.900
<v Speaker 1>Yeah. Somehow we managed to get into both

00:40:46.900 --> 00:40:47.780
<v Speaker 1>lifetimes

00:40:47.780 --> 00:40:50.180
<v Speaker 1>and all the different types of generics while

00:40:50.180 --> 00:40:51.700
<v Speaker 1>doing hello world.

00:40:52.740 --> 00:40:55.335
<v Speaker 1>Yeah. I haven't like made anyone like tune

00:40:55.335 --> 00:40:57.015
<v Speaker 1>out because it's like, I was coming here

00:40:57.015 --> 00:40:57.895
<v Speaker 1>for faces.

00:40:58.615 --> 00:41:00.215
<v Speaker 0>So No. No. No. I think that was

00:41:00.215 --> 00:41:01.895
<v Speaker 0>that was great. So

00:41:02.855 --> 00:41:04.535
<v Speaker 0>we have a letter r s. We have

00:41:04.535 --> 00:41:05.895
<v Speaker 0>something we're shipping to the library. We can

00:41:05.895 --> 00:41:07.495
<v Speaker 0>then add a main dot r s

00:41:07.815 --> 00:41:10.210
<v Speaker 0>and that just worked. So I'm happy with

00:41:10.210 --> 00:41:10.770
<v Speaker 0>that.

00:41:12.370 --> 00:41:14.370
<v Speaker 0>Let's move on to the next one then.

00:41:14.370 --> 00:41:15.010
<v Speaker 0>Okay.

00:41:16.850 --> 00:41:17.810
<v Speaker 0>With this.

00:41:18.050 --> 00:41:18.930
<v Speaker 0>Now

00:41:19.810 --> 00:41:21.410
<v Speaker 0>yeah. We did all that. Oh, we didn't

00:41:21.410 --> 00:41:24.085
<v Speaker 0>ask in line, but let's skip that. Let's

00:41:24.085 --> 00:41:26.725
<v Speaker 0>do the word one then. So let's see.

00:41:28.085 --> 00:41:29.925
<v Speaker 0>W l words.

00:41:32.005 --> 00:41:33.045
<v Speaker 0>I mean, hello world.

00:41:36.840 --> 00:41:38.920
<v Speaker 0>We could create a peg word fail here.

00:41:38.920 --> 00:41:41.720
<v Speaker 0>I'm gonna do cargo new. We'll see anagram

00:41:41.720 --> 00:41:42.840
<v Speaker 0>finder

00:41:44.920 --> 00:41:46.920
<v Speaker 0>and put up this here. I won't bother

00:41:46.920 --> 00:41:48.040
<v Speaker 0>opening a new code.

00:41:50.155 --> 00:41:52.075
<v Speaker 0>And we have our labs r s.

00:41:53.675 --> 00:41:55.755
<v Speaker 0>So if we break this problem down, what

00:41:55.755 --> 00:41:57.355
<v Speaker 0>we wanna be able to do first is

00:41:57.355 --> 00:41:59.355
<v Speaker 0>the exact same as our hello world where

00:41:59.355 --> 00:42:01.115
<v Speaker 0>we have some function

00:42:01.595 --> 00:42:04.474
<v Speaker 0>of dynamic grams, which takes

00:42:04.210 --> 00:42:05.650
<v Speaker 0>a word

00:42:07.170 --> 00:42:08.210
<v Speaker 0>of typed

00:42:09.810 --> 00:42:11.730
<v Speaker 0>string. I guess we could do that.

00:42:14.690 --> 00:42:16.450
<v Speaker 0>And we want to return

00:42:17.995 --> 00:42:19.195
<v Speaker 0>something here,

00:42:21.035 --> 00:42:22.875
<v Speaker 0>an array or a slice

00:42:23.195 --> 00:42:24.715
<v Speaker 0>of other strings.

00:42:25.035 --> 00:42:25.755
<v Speaker 1>Mhmm.

00:42:29.355 --> 00:42:30.475
<v Speaker 0>Would that be

00:42:30.955 --> 00:42:31.435
<v Speaker 0>this,

00:42:32.740 --> 00:42:33.460
<v Speaker 0>This?

00:42:35.300 --> 00:42:37.780
<v Speaker 1>No. It would be it would be around

00:42:37.780 --> 00:42:39.380
<v Speaker 1>it. So it would probably

00:42:40.180 --> 00:42:40.740
<v Speaker 1>so

00:42:42.180 --> 00:42:43.300
<v Speaker 1>this specific

00:42:43.300 --> 00:42:43.940
<v Speaker 1>signature

00:42:45.125 --> 00:42:47.204
<v Speaker 1>would probably be a little bit difficult because,

00:42:47.204 --> 00:42:48.885
<v Speaker 1>like, if we're gonna pass a slice, it

00:42:48.885 --> 00:42:50.005
<v Speaker 1>has to be, like,

00:42:50.405 --> 00:42:52.165
<v Speaker 1>reference to own data.

00:42:52.405 --> 00:42:55.204
<v Speaker 1>And if we're only passing an input as

00:42:55.204 --> 00:42:56.085
<v Speaker 1>the stir,

00:42:57.365 --> 00:42:59.440
<v Speaker 1>then it'll be a little different. Let's let's

00:42:59.440 --> 00:43:02.400
<v Speaker 1>have this function also take the dictionary

00:43:02.720 --> 00:43:03.920
<v Speaker 1>as an input.

00:43:05.520 --> 00:43:07.120
<v Speaker 1>So, like, all the words, like,

00:43:13.115 --> 00:43:14.715
<v Speaker 1>Even that, I'm not sure. I think it

00:43:14.715 --> 00:43:16.395
<v Speaker 1>might be best to just, like, return an

00:43:16.635 --> 00:43:19.035
<v Speaker 1>like, a a vec of own strings and

00:43:19.035 --> 00:43:20.635
<v Speaker 1>not deal with the lifetime

00:43:21.035 --> 00:43:22.955
<v Speaker 1>parts here. So get rid of the dictionary

00:43:22.955 --> 00:43:23.755
<v Speaker 1>argument.

00:43:25.275 --> 00:43:27.810
<v Speaker 0>Okay. So And then just the vec and

00:43:27.810 --> 00:43:29.730
<v Speaker 1>then angle bracket string.

00:43:30.050 --> 00:43:31.650
<v Speaker 1>And it should be a capital d.

00:43:34.530 --> 00:43:35.970
<v Speaker 0>Capital d. Yeah.

00:43:37.810 --> 00:43:40.130
<v Speaker 1>And then you can put to do as

00:43:40.130 --> 00:43:41.170
<v Speaker 1>the macro

00:43:41.330 --> 00:43:43.330
<v Speaker 1>in there, and it will not

00:43:43.745 --> 00:43:45.425
<v Speaker 1>give you compiler errors anymore.

00:43:47.185 --> 00:43:47.985
<v Speaker 0>Okay.

00:43:49.265 --> 00:43:50.705
<v Speaker 0>So we

00:43:50.705 --> 00:43:53.425
<v Speaker 0>also need then load dictionary.

00:43:55.265 --> 00:43:56.705
<v Speaker 0>We'll just leave, like, after now.

00:44:00.390 --> 00:44:02.950
<v Speaker 0>And let's just let's make this artificial for

00:44:02.950 --> 00:44:04.870
<v Speaker 0>the time being. So let's say it can

00:44:05.190 --> 00:44:05.750
<v Speaker 0>it

00:44:06.390 --> 00:44:08.790
<v Speaker 0>finds no anagrams.

00:44:09.430 --> 00:44:12.550
<v Speaker 0>What we're gonna do is call find anagrams

00:44:13.134 --> 00:44:14.575
<v Speaker 0>or the words

00:44:15.375 --> 00:44:16.255
<v Speaker 0>anagram.

00:44:19.615 --> 00:44:21.775
<v Speaker 0>And we should get back zero?

00:44:21.934 --> 00:44:23.055
<v Speaker 0>No. None?

00:44:24.174 --> 00:44:25.695
<v Speaker 1>We should get back

00:44:26.894 --> 00:44:27.454
<v Speaker 1>a back,

00:44:28.380 --> 00:44:31.099
<v Speaker 1>but let's just do just do vec exclamation

00:44:31.099 --> 00:44:33.500
<v Speaker 1>mark and then, like, nothing. It should yeah.

00:44:33.500 --> 00:44:35.420
<v Speaker 1>That'll work. Though I would normally do square

00:44:35.420 --> 00:44:37.339
<v Speaker 1>brackets just as, a style thing,

00:44:37.900 --> 00:44:39.099
<v Speaker 1>but I

00:44:39.260 --> 00:44:41.019
<v Speaker 1>think macro rules will accept

00:44:41.925 --> 00:44:44.325
<v Speaker 1>anything there, maybe. It depends on how you

00:44:44.325 --> 00:44:46.245
<v Speaker 1>define it. Macro rules are a little weird,

00:44:46.245 --> 00:44:47.845
<v Speaker 1>and I'm not actually that good at them.

00:44:47.845 --> 00:44:49.445
<v Speaker 1>If you wanna get into macros, you should

00:44:49.445 --> 00:44:51.045
<v Speaker 1>have Jam on next because

00:44:51.205 --> 00:44:52.965
<v Speaker 1>he's very good at macros.

00:44:53.285 --> 00:44:54.245
<v Speaker 0>Definitely.

00:44:54.885 --> 00:44:56.805
<v Speaker 0>Okay. If we I forgot the super.

00:44:57.540 --> 00:44:59.140
<v Speaker 1>And if you wanna if you don't wanna

00:44:59.140 --> 00:45:00.900
<v Speaker 1>keep remembering the super, go back real quick,

00:45:00.900 --> 00:45:02.020
<v Speaker 1>delete that super.

00:45:02.260 --> 00:45:02.980
<v Speaker 1>And then

00:45:03.620 --> 00:45:05.300
<v Speaker 1>in the top of the module,

00:45:06.260 --> 00:45:08.820
<v Speaker 1>like yeah. Just put use super colon colon

00:45:08.820 --> 00:45:09.620
<v Speaker 1>star,

00:45:09.780 --> 00:45:11.620
<v Speaker 1>and that'll just import everything

00:45:11.780 --> 00:45:12.820
<v Speaker 1>from the

00:45:13.105 --> 00:45:14.065
<v Speaker 1>above scope.

00:45:14.305 --> 00:45:15.105
<v Speaker 0>Nice.

00:45:15.425 --> 00:45:17.265
<v Speaker 0>Okay. Let's run our test.

00:45:19.745 --> 00:45:20.705
<v Speaker 0>The right directory.

00:45:25.839 --> 00:45:28.320
<v Speaker 0>Okay. Could not infer the type.

00:45:30.800 --> 00:45:31.760
<v Speaker 1>That's

00:45:32.079 --> 00:45:33.120
<v Speaker 1>interesting.

00:45:35.040 --> 00:45:36.480
<v Speaker 1>It should be all in for the type

00:45:36.480 --> 00:45:38.320
<v Speaker 1>there. This might be something to do with

00:45:38.320 --> 00:45:39.520
<v Speaker 1>how assert is implemented.

00:45:41.975 --> 00:45:44.215
<v Speaker 1>You can just I would like, just get

00:45:44.215 --> 00:45:45.655
<v Speaker 1>rid of the assert equals

00:45:45.815 --> 00:45:46.615
<v Speaker 1>and

00:45:49.575 --> 00:45:51.095
<v Speaker 1>just do, like, if

00:45:51.735 --> 00:45:54.055
<v Speaker 1>and then find anagrams equals equals

00:45:54.295 --> 00:45:55.895
<v Speaker 1>like, just, like, write basically, write out the

00:45:55.895 --> 00:45:56.535
<v Speaker 1>assert ourselves.

00:46:05.060 --> 00:46:06.500
<v Speaker 1>Or I guess it should be not equals

00:46:06.500 --> 00:46:07.540
<v Speaker 1>because we wanna

00:46:08.420 --> 00:46:09.780
<v Speaker 1>and then just panic.

00:46:12.755 --> 00:46:13.635
<v Speaker 1>And then

00:46:14.675 --> 00:46:15.235
<v Speaker 1>yeah.

00:46:17.395 --> 00:46:20.435
<v Speaker 1>I'm surprised it cannot infer the type parameter

00:46:20.435 --> 00:46:22.035
<v Speaker 1>there. I guess you could I guess it's

00:46:22.035 --> 00:46:22.275
<v Speaker 1>because

00:46:22.915 --> 00:46:24.995
<v Speaker 1>oh, I know why. It's because you can

00:46:24.995 --> 00:46:26.115
<v Speaker 1>compare types

00:46:26.980 --> 00:46:29.220
<v Speaker 1>that aren't the same. So the way that

00:46:29.220 --> 00:46:31.300
<v Speaker 1>the equal trait is defined

00:46:31.460 --> 00:46:34.180
<v Speaker 1>or the partial equal trait is defined allows

00:46:34.180 --> 00:46:35.140
<v Speaker 1>for, like,

00:46:35.620 --> 00:46:37.700
<v Speaker 1>lots it's it's a generic on the other

00:46:37.700 --> 00:46:40.500
<v Speaker 1>side, essentially. And so

00:46:40.125 --> 00:46:43.085
<v Speaker 1>the compiler isn't able to, like,

00:46:43.565 --> 00:46:44.285
<v Speaker 1>prove

00:46:44.445 --> 00:46:46.605
<v Speaker 1>that because you're doing an equality on these

00:46:46.605 --> 00:46:48.605
<v Speaker 1>two types, they should be the same type.

00:46:49.005 --> 00:46:49.885
<v Speaker 1>And so

00:46:51.325 --> 00:46:53.165
<v Speaker 1>we have to write it out by hand.

00:46:53.165 --> 00:46:55.165
<v Speaker 1>We have to, like, basically, like, define the

00:46:55.165 --> 00:46:55.485
<v Speaker 1>back.

00:46:56.510 --> 00:46:57.869
<v Speaker 1>The easiest way to do that is just

00:46:57.869 --> 00:47:00.510
<v Speaker 1>to not use the macro. And so instead

00:47:00.510 --> 00:47:03.230
<v Speaker 1>of vec exclamation park, we're gonna just do

00:47:05.550 --> 00:47:06.190
<v Speaker 1>yeah.

00:47:07.710 --> 00:47:08.830
<v Speaker 1>Oh, yeah. That works too.

00:47:09.435 --> 00:47:10.315
<v Speaker 0>Alright.

00:47:10.395 --> 00:47:13.515
<v Speaker 1>Yep. That's that's definitely that works. And then

00:47:14.075 --> 00:47:15.995
<v Speaker 0>there, we can do this the

00:47:16.235 --> 00:47:17.595
<v Speaker 0>Yep. This way.

00:47:20.955 --> 00:47:21.435
<v Speaker 0>And

00:47:22.640 --> 00:47:24.000
<v Speaker 0>and words.

00:47:29.280 --> 00:47:30.000
<v Speaker 0>See.

00:47:32.320 --> 00:47:33.520
<v Speaker 0>Test pass. Okay.

00:47:35.495 --> 00:47:37.095
<v Speaker 0>So I'm

00:47:37.095 --> 00:47:39.255
<v Speaker 0>not gonna keep adding new tests. Oh, yeah.

00:47:42.455 --> 00:47:43.095
<v Speaker 0>Okay.

00:47:45.335 --> 00:47:46.135
<v Speaker 0>Well,

00:47:46.215 --> 00:47:47.415
<v Speaker 0>I was gonna say I'll just keep adding

00:47:47.415 --> 00:47:49.530
<v Speaker 0>more assertions, but then I'll get confused. I

00:47:49.530 --> 00:47:52.410
<v Speaker 0>don't like being confused. So it can find

00:47:52.410 --> 00:47:53.130
<v Speaker 0>a

00:47:53.530 --> 00:47:54.410
<v Speaker 0>single

00:47:54.650 --> 00:47:55.450
<v Speaker 0>anagram.

00:47:56.090 --> 00:47:57.530
<v Speaker 0>I guess it doesn't really matter. It just

00:47:57.690 --> 00:47:59.050
<v Speaker 0>it finds anagrams.

00:48:00.890 --> 00:48:02.410
<v Speaker 0>Yeah. I always struggle with the naming things

00:48:02.410 --> 00:48:04.170
<v Speaker 0>more than writing the actual code sometimes.

00:48:06.625 --> 00:48:07.825
<v Speaker 0>So string

00:48:07.904 --> 00:48:08.705
<v Speaker 0>from

00:48:10.065 --> 00:48:11.825
<v Speaker 0>and these I know these aren't real, but

00:48:11.825 --> 00:48:13.904
<v Speaker 0>we'll just we'll make it past the fake

00:48:13.904 --> 00:48:16.625
<v Speaker 0>case first. So if I say find anagrams

00:48:16.944 --> 00:48:17.744
<v Speaker 0>or

00:48:18.065 --> 00:48:19.984
<v Speaker 0>David, it's gonna return

00:48:20.144 --> 00:48:20.785
<v Speaker 0>words.

00:48:22.190 --> 00:48:23.070
<v Speaker 0>Alright?

00:48:24.589 --> 00:48:25.390
<v Speaker 1>Sure.

00:48:25.390 --> 00:48:26.830
<v Speaker 0>Yeah. Why not?

00:48:27.390 --> 00:48:29.230
<v Speaker 0>I should just think of a real anagram.

00:48:29.230 --> 00:48:30.190
<v Speaker 0>Where did that pass?

00:48:36.655 --> 00:48:37.695
<v Speaker 0>One test.

00:48:38.335 --> 00:48:39.295
<v Speaker 0>Oh, yeah.

00:48:41.454 --> 00:48:42.175
<v Speaker 0>Test.

00:48:45.295 --> 00:48:46.095
<v Speaker 0>Yeah. That's better.

00:48:48.110 --> 00:48:50.030
<v Speaker 0>You know any anagrams? I can't think of

00:48:50.030 --> 00:48:51.550
<v Speaker 0>one off my head. I've got pressure. I

00:48:51.550 --> 00:48:53.870
<v Speaker 1>would just do, like, v I d d

00:48:53.870 --> 00:48:57.150
<v Speaker 1>a. Just fucking make up one. And then

00:48:57.150 --> 00:48:59.230
<v Speaker 1>you probably should lowercase the the d in

00:48:59.230 --> 00:49:01.230
<v Speaker 1>the David because we don't wanna actually and

00:49:01.310 --> 00:49:02.750
<v Speaker 1>yeah. In your name because we don't wanna

00:49:03.135 --> 00:49:03.935
<v Speaker 1>have to k.

00:49:04.575 --> 00:49:06.415
<v Speaker 0>Okay. Yeah. We're we're not using the word

00:49:06.415 --> 00:49:08.015
<v Speaker 0>fail right now, so it doesn't matter. You're

00:49:08.015 --> 00:49:11.375
<v Speaker 0>right. Good call. Okay. So now this is

00:49:11.375 --> 00:49:12.975
<v Speaker 0>gonna fail. So we need to make this

00:49:12.975 --> 00:49:14.175
<v Speaker 0>actually do something.

00:49:14.895 --> 00:49:15.135
<v Speaker 0>So

00:49:16.470 --> 00:49:18.710
<v Speaker 0>before we start doing a load dictionary, let's

00:49:18.710 --> 00:49:19.990
<v Speaker 0>just say if

00:49:20.230 --> 00:49:20.950
<v Speaker 0>word

00:49:21.110 --> 00:49:22.070
<v Speaker 0>equals

00:49:22.550 --> 00:49:23.430
<v Speaker 0>David.

00:49:26.869 --> 00:49:28.470
<v Speaker 0>A vector of

00:49:28.710 --> 00:49:30.550
<v Speaker 0>string

00:49:30.204 --> 00:49:30.925
<v Speaker 0>from

00:49:36.925 --> 00:49:38.605
<v Speaker 0>this is what pet TVD is all about.

00:49:38.605 --> 00:49:39.165
<v Speaker 0>Right?

00:49:40.845 --> 00:49:43.005
<v Speaker 1>This is this is

00:49:42.800 --> 00:49:45.440
<v Speaker 1>professional software development folks. This is what we

00:49:45.440 --> 00:49:46.880
<v Speaker 1>do. This is what we're paid for.

00:49:47.200 --> 00:49:48.000
<v Speaker 0>Exactly.

00:49:48.800 --> 00:49:49.600
<v Speaker 0>It was

00:49:50.000 --> 00:49:51.599
<v Speaker 0>they said that if you got that wrong,

00:49:51.599 --> 00:49:53.840
<v Speaker 0>I'm contriving it and still getting it wrong.

00:49:53.840 --> 00:49:55.200
<v Speaker 0>So let's see what did I do.

00:49:57.755 --> 00:49:59.835
<v Speaker 0>Find oh, I called it the wrong way

00:49:59.835 --> 00:50:00.395
<v Speaker 0>around.

00:50:01.835 --> 00:50:04.715
<v Speaker 0>Yeah. David should return. Vita.

00:50:07.755 --> 00:50:08.075
<v Speaker 0>Okay.

00:50:10.299 --> 00:50:13.099
<v Speaker 0>So one more test. I'll remember

00:50:13.099 --> 00:50:13.820
<v Speaker 0>the

00:50:14.779 --> 00:50:15.900
<v Speaker 0>annotation,

00:50:15.900 --> 00:50:18.140
<v Speaker 0>and this time but I don't need that

00:50:18.140 --> 00:50:18.940
<v Speaker 0>anymore.

00:50:20.299 --> 00:50:22.539
<v Speaker 0>We now can't take it anymore. We need

00:50:22.539 --> 00:50:23.579
<v Speaker 0>another anagram.

00:50:24.035 --> 00:50:26.115
<v Speaker 0>So let's just pick the

00:50:26.675 --> 00:50:28.915
<v Speaker 0>let's take a look at this word style.

00:50:32.595 --> 00:50:34.035
<v Speaker 1>Those are interesting words.

00:50:37.829 --> 00:50:39.430
<v Speaker 1>Emphasis and c.

00:50:39.670 --> 00:50:41.270
<v Speaker 1>That's my favorite word.

00:50:43.990 --> 00:50:45.670
<v Speaker 1>The the word two.

00:50:46.789 --> 00:50:48.470
<v Speaker 0>It's supposed to be every word in the

00:50:48.470 --> 00:50:49.190
<v Speaker 0>English language.

00:50:50.055 --> 00:50:51.734
<v Speaker 0>You know what? I'm just gonna Google it.

00:50:51.734 --> 00:50:52.295
<v Speaker 0>Like,

00:50:52.615 --> 00:50:53.895
<v Speaker 0>anagram, please.

00:50:54.454 --> 00:50:55.415
<v Speaker 0>What's

00:50:55.415 --> 00:50:56.535
<v Speaker 0>the first anagram?

00:50:58.055 --> 00:51:00.295
<v Speaker 0>Elapsed and asleep. There we go.

00:51:01.095 --> 00:51:02.535
<v Speaker 0>That's our test case. Oops.

00:51:04.780 --> 00:51:05.820
<v Speaker 0>Okay. So

00:51:06.619 --> 00:51:08.859
<v Speaker 0>we're gonna pass in asleep, and we expect

00:51:08.859 --> 00:51:10.619
<v Speaker 0>to get back our

00:51:11.260 --> 00:51:13.340
<v Speaker 0>words. We can just redefine that

00:51:13.579 --> 00:51:15.260
<v Speaker 0>as back

00:51:16.425 --> 00:51:17.225
<v Speaker 0>string

00:51:17.385 --> 00:51:18.105
<v Speaker 0>from

00:51:19.865 --> 00:51:20.905
<v Speaker 0>a lapse.

00:51:21.225 --> 00:51:21.945
<v Speaker 0>Mhmm.

00:51:22.745 --> 00:51:24.425
<v Speaker 0>And that should fail because we haven't run

00:51:24.425 --> 00:51:25.225
<v Speaker 0>any

00:51:25.225 --> 00:51:25.865
<v Speaker 0>code yet.

00:51:30.630 --> 00:51:31.270
<v Speaker 0>Okay.

00:51:31.430 --> 00:51:32.150
<v Speaker 0>So

00:51:32.390 --> 00:51:34.470
<v Speaker 0>I guess what we oh, we got some

00:51:34.470 --> 00:51:36.230
<v Speaker 0>comment. I was too busy with my fake

00:51:36.230 --> 00:51:37.750
<v Speaker 0>code there. Sorry about that. Yeah.

00:51:39.510 --> 00:51:41.190
<v Speaker 0>Race car. Good one.

00:51:42.070 --> 00:51:43.964
<v Speaker 0>That does the next the next test case.

00:51:43.964 --> 00:51:46.285
<v Speaker 1>Stop stop trying to feed palindromes into our

00:51:46.285 --> 00:51:49.244
<v Speaker 1>anagram machine. You're gonna mess it up. It's

00:51:49.244 --> 00:51:51.325
<v Speaker 1>fragile. It's a fragile baby.

00:51:53.484 --> 00:51:54.605
<v Speaker 0>Okay. So

00:51:55.085 --> 00:51:55.644
<v Speaker 0>shall we

00:51:56.580 --> 00:51:58.420
<v Speaker 0>handle the load of the dictionary?

00:51:59.380 --> 00:52:00.420
<v Speaker 1>Sure. Yeah.

00:52:00.980 --> 00:52:02.980
<v Speaker 0>Let's

00:52:02.820 --> 00:52:04.500
<v Speaker 0>so the code test, what we wanna do

00:52:04.500 --> 00:52:06.020
<v Speaker 0>is open the file

00:52:06.180 --> 00:52:07.700
<v Speaker 0>Mhmm. Split

00:52:07.780 --> 00:52:09.220
<v Speaker 0>on a new line

00:52:09.795 --> 00:52:12.275
<v Speaker 1>Mhmm. And store a set of words.

00:52:13.795 --> 00:52:14.755
<v Speaker 0>Simple. Right?

00:52:15.714 --> 00:52:17.635
<v Speaker 1>And return and probably return the set of

00:52:17.635 --> 00:52:18.195
<v Speaker 1>words.

00:52:19.234 --> 00:52:20.035
<v Speaker 0>Return

00:52:20.194 --> 00:52:21.075
<v Speaker 0>words. Okay.

00:52:23.400 --> 00:52:24.040
<v Speaker 0>So

00:52:24.520 --> 00:52:27.079
<v Speaker 0>when I can try this example, I thought

00:52:27.079 --> 00:52:28.920
<v Speaker 0>it would be good because we'd maybe have

00:52:28.920 --> 00:52:30.039
<v Speaker 0>to rely

00:52:30.039 --> 00:52:31.880
<v Speaker 0>on a third party create. I don't know

00:52:31.880 --> 00:52:33.480
<v Speaker 0>if this is all in the standard library,

00:52:33.480 --> 00:52:35.640
<v Speaker 0>I'll use your guidance here. It is it

00:52:35.640 --> 00:52:37.480
<v Speaker 1>is all in the standard library. Alright. Okay.

00:52:37.635 --> 00:52:38.355
<v Speaker 0>Well,

00:52:38.835 --> 00:52:40.515
<v Speaker 0>why don't we just artificially

00:52:40.515 --> 00:52:41.555
<v Speaker 0>contrive

00:52:41.795 --> 00:52:44.115
<v Speaker 0>magic words, a create enter a project just

00:52:44.115 --> 00:52:45.635
<v Speaker 0>so we can go over that for people?

00:52:46.835 --> 00:52:48.835
<v Speaker 0>So do you have a favorite crate?

00:52:49.555 --> 00:52:50.835
<v Speaker 1>A favorite crate?

00:52:52.910 --> 00:52:55.310
<v Speaker 0>Alright. Yeah. Let's use struct ops. Let's let's

00:52:55.310 --> 00:52:57.790
<v Speaker 1>make the interface to running this thing nice.

00:52:57.790 --> 00:52:58.830
<v Speaker 1>Like, if you need a if you need

00:52:58.830 --> 00:52:59.630
<v Speaker 1>a crate,

00:52:59.790 --> 00:53:01.710
<v Speaker 1>struct ops are great crate to just pull

00:53:01.710 --> 00:53:03.230
<v Speaker 1>in for like little

00:53:03.310 --> 00:53:03.790
<v Speaker 1>tools.

00:53:05.325 --> 00:53:06.525
<v Speaker 0>Okay. So

00:53:06.845 --> 00:53:09.405
<v Speaker 0>for anyone who's not familiar with crates.io,

00:53:09.405 --> 00:53:11.325
<v Speaker 0>it is just where you find other Rust

00:53:11.325 --> 00:53:13.805
<v Speaker 0>libraries. You can search. You can click on

00:53:13.805 --> 00:53:15.645
<v Speaker 0>it. It has a link to the repository

00:53:15.645 --> 00:53:16.925
<v Speaker 0>here if you wanna go check out the

00:53:16.925 --> 00:53:19.130
<v Speaker 0>code and a copy button for a copy

00:53:19.130 --> 00:53:21.050
<v Speaker 0>and enter our cargo dot toml.

00:53:21.450 --> 00:53:23.530
<v Speaker 0>For cargo dot toml, we just drop that

00:53:23.530 --> 00:53:25.290
<v Speaker 0>in like so, and we now have struct

00:53:25.290 --> 00:53:27.210
<v Speaker 0>available to us at our project.

00:53:27.370 --> 00:53:29.370
<v Speaker 1>Can I actually introduce another way to add

00:53:29.370 --> 00:53:31.530
<v Speaker 1>struct up to or to add dependencies?

00:53:31.795 --> 00:53:34.035
<v Speaker 1>Do you have Cargo Edit installed?

00:53:37.715 --> 00:53:39.235
<v Speaker 0>No. Is that a plugin? It it it'll

00:53:39.235 --> 00:53:41.075
<v Speaker 1>be Cargo Add is the thing. Cargo Edit

00:53:41.075 --> 00:53:42.755
<v Speaker 1>is the is the thing is the actual

00:53:42.755 --> 00:53:45.715
<v Speaker 1>tool. If you yeah. So so look up

00:53:45.715 --> 00:53:48.690
<v Speaker 1>Cargo Edit on GitHub or, like like, Google

00:53:48.690 --> 00:53:49.490
<v Speaker 1>Cargo

00:53:49.570 --> 00:53:51.570
<v Speaker 1>Edit. It should be from Killer Cup is,

00:53:51.570 --> 00:53:52.690
<v Speaker 1>I think, the author.

00:53:56.530 --> 00:53:57.170
<v Speaker 1>There we go.

00:53:58.905 --> 00:54:00.425
<v Speaker 1>And so it should just give you, like

00:54:00.505 --> 00:54:02.105
<v Speaker 1>it's probably just cargo install

00:54:02.265 --> 00:54:05.385
<v Speaker 1>cargo edit. Yeah. So run that.

00:54:07.225 --> 00:54:09.385
<v Speaker 1>And this is this is, like you know,

00:54:09.385 --> 00:54:10.665
<v Speaker 1>if you if you do Rust a lot,

00:54:10.665 --> 00:54:12.505
<v Speaker 1>you should have this installed, in my opinion,

00:54:12.505 --> 00:54:13.625
<v Speaker 1>because it's just

00:54:14.190 --> 00:54:16.589
<v Speaker 1>it's like I I I hate having to,

00:54:16.589 --> 00:54:18.270
<v Speaker 1>like, look up the version number

00:54:18.510 --> 00:54:20.270
<v Speaker 1>and be like, what exact what's the newest

00:54:20.270 --> 00:54:22.030
<v Speaker 1>version number? I go go to creates, find

00:54:22.030 --> 00:54:23.710
<v Speaker 1>the thing, copy it. It's just too much

00:54:23.710 --> 00:54:24.190
<v Speaker 1>work.

00:54:24.670 --> 00:54:26.589
<v Speaker 1>I I just wanna write cargo ad struct

00:54:26.589 --> 00:54:28.270
<v Speaker 1>top and have it find the version number,

00:54:28.655 --> 00:54:30.095
<v Speaker 1>put it in my TOML file, and be

00:54:30.095 --> 00:54:31.375
<v Speaker 1>done with it. And that's what that's what

00:54:31.375 --> 00:54:33.615
<v Speaker 1>cargo edit does. So you just you just

00:54:33.615 --> 00:54:34.974
<v Speaker 1>have to know the name of the dependency

00:54:34.974 --> 00:54:36.655
<v Speaker 1>you wanna add. And you could do, like,

00:54:36.655 --> 00:54:39.535
<v Speaker 1>cargo add struct op dash dash dev,

00:54:39.695 --> 00:54:41.375
<v Speaker 1>and it'll add it to your dev dependencies.

00:54:41.375 --> 00:54:43.220
<v Speaker 1>So it won't even, like, it'll even make

00:54:43.220 --> 00:54:44.660
<v Speaker 1>the section if you don't already have it.

00:54:44.660 --> 00:54:46.340
<v Speaker 1>It's it's very nice. Oh, nice.

00:54:46.579 --> 00:54:47.460
<v Speaker 1>Highly

00:54:47.460 --> 00:54:48.180
<v Speaker 1>recommend.

00:54:48.420 --> 00:54:50.260
<v Speaker 0>Oh, no. We are

00:54:50.420 --> 00:54:53.300
<v Speaker 0>waiting on the infamous cargo build things.

00:54:54.099 --> 00:54:54.820
<v Speaker 1>Yes.

00:54:54.900 --> 00:54:56.020
<v Speaker 1>This is

00:54:56.955 --> 00:54:59.355
<v Speaker 1>a maybe we could go to the

00:54:59.755 --> 00:55:01.835
<v Speaker 1>the hello world example. I was thinking because

00:55:01.835 --> 00:55:03.995
<v Speaker 1>I actually kinda want to introduce this for

00:55:04.075 --> 00:55:05.675
<v Speaker 1>when we were doing that example, which is

00:55:05.675 --> 00:55:06.955
<v Speaker 1>what made me think of it when you

00:55:06.955 --> 00:55:09.130
<v Speaker 1>asked for a crate. Oh, okay. So we

00:55:09.130 --> 00:55:11.530
<v Speaker 1>could change the the hello world example to

00:55:11.530 --> 00:55:13.610
<v Speaker 1>instead of using stood n to

00:55:14.250 --> 00:55:15.770
<v Speaker 1>use struct opt.

00:55:17.930 --> 00:55:20.250
<v Speaker 0>So Okay. So if I just paste this

00:55:20.250 --> 00:55:22.010
<v Speaker 0>n oh, no. It's not on my buffer

00:55:22.010 --> 00:55:24.505
<v Speaker 0>anymore. Struct op equals

00:55:24.505 --> 00:55:25.305
<v Speaker 0>star.

00:55:25.305 --> 00:55:26.185
<v Speaker 0>That works. Just

00:55:26.985 --> 00:55:28.185
<v Speaker 1>just do 0.3.

00:55:30.905 --> 00:55:31.545
<v Speaker 1>Yeah.

00:55:32.425 --> 00:55:33.065
<v Speaker 1>It

00:55:33.385 --> 00:55:35.785
<v Speaker 1>shouldn't do star usually in in Rustland. They're,

00:55:35.785 --> 00:55:38.345
<v Speaker 1>like, very, very strongly discouraged

00:55:38.345 --> 00:55:38.905
<v Speaker 1>to do.

00:55:41.260 --> 00:55:43.579
<v Speaker 0>I just copied it. Yeah. It it it'll

00:55:43.579 --> 00:55:45.900
<v Speaker 1>it'll fill in the 21 automatically.

00:55:46.380 --> 00:55:48.220
<v Speaker 0>And I don't know. Keep in red squiggles.

00:55:48.220 --> 00:55:50.300
<v Speaker 0>Maybe Rust Analyzer is just a bit confused

00:55:50.300 --> 00:55:51.660
<v Speaker 0>today. So Yeah.

00:55:52.525 --> 00:55:54.525
<v Speaker 1>I also saw when you opened Versus Code

00:55:54.525 --> 00:55:56.205
<v Speaker 1>that you're not on the current version of

00:55:56.205 --> 00:55:58.045
<v Speaker 1>Rust Analyzer. So you might wanna, like, close

00:55:58.045 --> 00:55:59.725
<v Speaker 1>it and reopen it and click the download.

00:55:59.725 --> 00:56:00.765
<v Speaker 1>But I'm not sure if you wanna, like,

00:56:00.765 --> 00:56:02.685
<v Speaker 1>wait for more things to so

00:56:04.285 --> 00:56:06.685
<v Speaker 1>so are you familiar with struct opt? I

00:56:06.685 --> 00:56:09.450
<v Speaker 0>am not. No. Okay. So it's kind of

00:56:09.450 --> 00:56:10.410
<v Speaker 1>all in the name.

00:56:10.810 --> 00:56:13.770
<v Speaker 1>You define a struct. So just like after

00:56:13.770 --> 00:56:16.810
<v Speaker 1>main or before, you know, whichever style preference.

00:56:16.890 --> 00:56:18.650
<v Speaker 1>So you just do, like, struct and whatever

00:56:18.650 --> 00:56:20.490
<v Speaker 1>you want to have, like, the type be.

00:56:20.490 --> 00:56:22.435
<v Speaker 1>I would just do, like, either options or

00:56:22.435 --> 00:56:24.275
<v Speaker 1>args, like, whichever you prefer.

00:56:27.875 --> 00:56:29.875
<v Speaker 0>Sorry. I don't understand. Oh, you need to

00:56:29.875 --> 00:56:31.234
<v Speaker 1>give it a type name because this is

00:56:31.315 --> 00:56:33.155
<v Speaker 1>like, we're defining a struct. Right? And so,

00:56:33.155 --> 00:56:35.075
<v Speaker 1>like, after the struct keyword,

00:56:35.740 --> 00:56:37.740
<v Speaker 1>you have to give it, like Oh, alright.

00:56:37.740 --> 00:56:40.300
<v Speaker 0>Okay. Okay. Fine. Whatever you're naming this type.

00:56:43.020 --> 00:56:44.380
<v Speaker 1>Hello, Prems. Perfect.

00:56:46.860 --> 00:56:49.180
<v Speaker 1>And then you're just going to push a

00:56:49.180 --> 00:56:49.900
<v Speaker 1>derive

00:56:50.705 --> 00:56:52.945
<v Speaker 1>in front of the the struct up.

00:56:53.745 --> 00:56:54.945
<v Speaker 1>So derive

00:56:55.265 --> 00:56:56.785
<v Speaker 1>and then parentheses.

00:56:57.025 --> 00:56:58.865
<v Speaker 1>We have an extra c in there. And

00:56:58.865 --> 00:57:01.665
<v Speaker 1>then I think it's struct up all lowercase

00:57:03.240 --> 00:57:05.000
<v Speaker 1>because you have to it's, like, scoped. It's

00:57:05.000 --> 00:57:06.920
<v Speaker 1>still, like, the the, like, the macro exists

00:57:06.920 --> 00:57:09.400
<v Speaker 1>in the namespace of the crate. And then

00:57:09.400 --> 00:57:11.160
<v Speaker 1>cap yeah. That one. Big,

00:57:11.400 --> 00:57:13.320
<v Speaker 1>capital s, capital o. Yep.

00:57:15.240 --> 00:57:17.714
<v Speaker 0>Oh, my computer is struggling.

00:57:18.595 --> 00:57:20.035
<v Speaker 1>Having a good time.

00:57:21.234 --> 00:57:23.395
<v Speaker 0>Yeah. I can't I can't type anymore.

00:57:23.714 --> 00:57:26.035
<v Speaker 0>Wow. That is exciting.

00:57:26.115 --> 00:57:27.075
<v Speaker 1>Maybe yep.

00:57:28.820 --> 00:57:30.820
<v Speaker 0>Yeah. We'll we'll just watch that.

00:57:31.140 --> 00:57:32.100
<v Speaker 0>Sorry.

00:57:33.060 --> 00:57:35.220
<v Speaker 1>So yeah. So I'll I'll explain what struct

00:57:35.220 --> 00:57:37.620
<v Speaker 1>opt does. So struct opt,

00:57:37.860 --> 00:57:38.740
<v Speaker 1>it generates

00:57:40.660 --> 00:57:42.695
<v Speaker 1>a and it's it's a library that's built

00:57:42.695 --> 00:57:44.615
<v Speaker 1>on top of CLAP. CLAP stands for command

00:57:44.615 --> 00:57:47.735
<v Speaker 1>line argument parser. It's like the premier

00:57:47.975 --> 00:57:48.855
<v Speaker 1>kind of

00:57:49.415 --> 00:57:50.215
<v Speaker 1>biggest,

00:57:50.215 --> 00:57:52.935
<v Speaker 1>most used argument parser library in Rust. It's

00:57:52.935 --> 00:57:54.215
<v Speaker 1>not the only one. There are lots of

00:57:54.215 --> 00:57:55.815
<v Speaker 1>other good ones. A lot of people don't

00:57:55.815 --> 00:57:56.055
<v Speaker 1>like,

00:57:56.619 --> 00:57:58.619
<v Speaker 1>a lot of people don't use clap because

00:57:58.619 --> 00:58:01.180
<v Speaker 1>it generates a lot of code. And so,

00:58:01.180 --> 00:58:03.020
<v Speaker 1>like, if you have those constraints, that's why,

00:58:03.020 --> 00:58:05.580
<v Speaker 1>like, Google wrote r h, which is kind

00:58:05.580 --> 00:58:06.940
<v Speaker 1>of like, we wanna have a struct up

00:58:06.940 --> 00:58:09.099
<v Speaker 1>that's actually good if you have, like, you

00:58:09.099 --> 00:58:10.859
<v Speaker 1>know, binary size constraints.

00:58:11.645 --> 00:58:13.565
<v Speaker 1>And so we're gonna generate efficient code, whereas

00:58:13.565 --> 00:58:15.325
<v Speaker 1>struct up and clap are kind of like,

00:58:15.325 --> 00:58:16.925
<v Speaker 1>we wanna give you every feature you could

00:58:16.925 --> 00:58:19.325
<v Speaker 1>possibly want from a command line argument parser,

00:58:19.484 --> 00:58:21.645
<v Speaker 1>whatever the cost. And I think it's usually

00:58:21.645 --> 00:58:23.085
<v Speaker 1>worth it personally, so I just use struct

00:58:23.085 --> 00:58:23.965
<v Speaker 1>up. But

00:58:24.685 --> 00:58:26.285
<v Speaker 1>there are lots of options out there. But

00:58:26.559 --> 00:58:29.279
<v Speaker 1>clap gives you the argument parser. And then

00:58:29.279 --> 00:58:31.520
<v Speaker 1>struct opt, what it does is it looks

00:58:31.520 --> 00:58:33.840
<v Speaker 1>at the definition of a structure

00:58:34.319 --> 00:58:35.840
<v Speaker 1>and infers

00:58:36.160 --> 00:58:37.359
<v Speaker 1>a lot of, like,

00:58:37.680 --> 00:58:39.839
<v Speaker 1>the what type of arguments that you would

00:58:39.839 --> 00:58:40.240
<v Speaker 1>get

00:58:40.645 --> 00:58:43.845
<v Speaker 1>in the the argument parser from the structure.

00:58:43.845 --> 00:58:45.845
<v Speaker 1>And so, like, for example, if you have

00:58:45.845 --> 00:58:46.805
<v Speaker 1>a name

00:58:46.965 --> 00:58:49.765
<v Speaker 1>and a string, right, what's what's referring right

00:58:49.765 --> 00:58:52.085
<v Speaker 1>there is that you have a an argument

00:58:52.245 --> 00:58:54.405
<v Speaker 1>where the flag is called or the name

00:58:54.405 --> 00:58:55.605
<v Speaker 1>of the argument is name

00:58:56.070 --> 00:58:58.150
<v Speaker 1>and the type that it expects to get

00:58:58.150 --> 00:58:59.990
<v Speaker 1>is a string. And so it will parse

00:58:59.990 --> 00:59:01.190
<v Speaker 1>it as a string. If you were to

00:59:01.190 --> 00:59:03.430
<v Speaker 1>put a u h there, it would only

00:59:03.430 --> 00:59:04.790
<v Speaker 1>accept numbers

00:59:05.270 --> 00:59:07.990
<v Speaker 1>and probably only numbers between zero and two

00:59:07.990 --> 00:59:10.135
<v Speaker 1>fifty six. And, like, if you passed it

00:59:10.214 --> 00:59:11.815
<v Speaker 1>like, even though the like, at the command

00:59:11.815 --> 00:59:12.855
<v Speaker 1>line, like, when it gets it out of

00:59:12.855 --> 00:59:15.095
<v Speaker 1>stood args, it's, like, actually a string.

00:59:15.414 --> 00:59:17.494
<v Speaker 1>But struct opt and clap are gonna parse

00:59:17.494 --> 00:59:19.575
<v Speaker 1>it and make sure that it, like, actually

00:59:19.575 --> 00:59:21.255
<v Speaker 1>matches the exact type you have.

00:59:21.654 --> 00:59:23.414
<v Speaker 1>And then you can put

00:59:24.970 --> 00:59:26.010
<v Speaker 1>attributes

00:59:26.010 --> 00:59:28.570
<v Speaker 1>on each argument to kind of basically, like,

00:59:29.290 --> 00:59:30.010
<v Speaker 1>add

00:59:31.930 --> 00:59:34.090
<v Speaker 1>kinda like like to invoke the functions you

00:59:34.090 --> 00:59:35.690
<v Speaker 1>would normally do when building a command line.

00:59:35.690 --> 00:59:36.810
<v Speaker 1>So if you do

00:59:37.610 --> 00:59:38.810
<v Speaker 1>before lucky number,

00:59:41.055 --> 00:59:42.175
<v Speaker 1>put a

00:59:42.655 --> 00:59:45.135
<v Speaker 1>attribute. So as hash,

00:59:45.135 --> 00:59:46.255
<v Speaker 1>yeah, opens

00:59:46.335 --> 00:59:48.575
<v Speaker 1>square bracket and then struct opt

00:59:50.495 --> 00:59:51.695
<v Speaker 1>and then parentheses

00:59:53.420 --> 00:59:54.380
<v Speaker 1>short,

00:59:54.700 --> 00:59:55.740
<v Speaker 1>comma, long.

00:59:57.819 --> 00:59:59.740
<v Speaker 1>So this is saying we wanna have a

00:59:59.740 --> 01:00:01.900
<v Speaker 1>long and short argument. So now this is

01:00:01.900 --> 01:00:02.700
<v Speaker 1>basically

01:00:02.700 --> 01:00:04.940
<v Speaker 1>turning it into, like, a flag.

01:00:05.395 --> 01:00:07.875
<v Speaker 1>So you can do dash l, I think,

01:00:07.875 --> 01:00:09.395
<v Speaker 1>would probably be what it generates

01:00:09.555 --> 01:00:10.275
<v Speaker 1>or

01:00:10.435 --> 01:00:12.675
<v Speaker 1>dash dash lucky dash

01:00:12.755 --> 01:00:14.995
<v Speaker 1>number or maybe lucky underscore number. I'm not

01:00:14.995 --> 01:00:15.875
<v Speaker 1>sure exactly

01:00:15.955 --> 01:00:18.595
<v Speaker 1>if struct up normalizes the underscores.

01:00:19.670 --> 01:00:21.750
<v Speaker 1>So this one is now an optional argument

01:00:21.750 --> 01:00:23.830
<v Speaker 1>because you've added those, whereas the name one

01:00:23.830 --> 01:00:26.870
<v Speaker 1>is a positional argument because you don't tell

01:00:26.870 --> 01:00:29.510
<v Speaker 1>struct up that it's a a flag.

01:00:30.950 --> 01:00:32.950
<v Speaker 1>And then you can also do something like

01:00:32.950 --> 01:00:35.245
<v Speaker 1>you can put string for name in option

01:00:35.405 --> 01:00:36.205
<v Speaker 1>in an option,

01:00:36.685 --> 01:00:38.605
<v Speaker 1>and struct up will automatically,

01:00:38.605 --> 01:00:41.085
<v Speaker 1>like, assume that this argument doesn't have to

01:00:41.085 --> 01:00:42.765
<v Speaker 1>be present. And so now

01:00:42.925 --> 01:00:44.605
<v Speaker 1>you can pass in you could like, with

01:00:44.605 --> 01:00:46.380
<v Speaker 1>this command line, you could pass in no

01:00:46.380 --> 01:00:48.220
<v Speaker 1>arguments and it won't give you an error.

01:00:48.299 --> 01:00:49.740
<v Speaker 1>And if you passed in one argument with

01:00:49.740 --> 01:00:51.660
<v Speaker 1>no flag, it'll know it's the name. And

01:00:51.660 --> 01:00:53.820
<v Speaker 1>if you pass in, like, a dash l,

01:00:54.140 --> 01:00:55.980
<v Speaker 1>it'll know it's the lucky number. And so

01:00:55.980 --> 01:00:57.579
<v Speaker 1>it's, like, generating all of this

01:00:58.175 --> 01:00:59.775
<v Speaker 1>just from what you put in. You can

01:00:59.775 --> 01:01:01.215
<v Speaker 1>put in a spec if you want multiple

01:01:01.215 --> 01:01:03.935
<v Speaker 1>arguments. It's like it's so intuitive and easy

01:01:03.935 --> 01:01:05.615
<v Speaker 1>to remember for me. It's like the best

01:01:05.615 --> 01:01:06.975
<v Speaker 1>thing. I fucking love it.

01:01:08.255 --> 01:01:11.055
<v Speaker 0>Okay. So let's go through the process of

01:01:11.055 --> 01:01:13.695
<v Speaker 0>removing this lane and actually

01:01:14.160 --> 01:01:16.400
<v Speaker 0>getting our struct from struct up.

01:01:16.640 --> 01:01:17.040
<v Speaker 0>What

01:01:17.520 --> 01:01:18.880
<v Speaker 0>what's the process of that? I just did,

01:01:18.880 --> 01:01:20.000
<v Speaker 0>like, options

01:01:20.319 --> 01:01:21.360
<v Speaker 0>equals,

01:01:22.480 --> 01:01:24.720
<v Speaker 0>I guess, struct up something? You know, it's

01:01:24.720 --> 01:01:26.240
<v Speaker 1>just gonna be held because this is this

01:01:26.240 --> 01:01:27.760
<v Speaker 1>derive is implementing

01:01:28.240 --> 01:01:29.200
<v Speaker 1>a trait.

01:01:29.934 --> 01:01:31.535
<v Speaker 1>And so I think it's just gonna be

01:01:31.535 --> 01:01:34.655
<v Speaker 1>hello params colon colon from underscore

01:01:34.655 --> 01:01:35.375
<v Speaker 1>arcs.

01:01:38.575 --> 01:01:39.934
<v Speaker 1>And then this will probably give you a

01:01:39.934 --> 01:01:41.694
<v Speaker 1>compiler error, but compiler error will be helpful.

01:01:41.694 --> 01:01:42.734
<v Speaker 1>So we, like, we just wanna look at

01:01:42.734 --> 01:01:43.535
<v Speaker 1>the compiler error.

01:01:44.520 --> 01:01:46.440
<v Speaker 1>And it should say

01:01:48.920 --> 01:01:51.240
<v Speaker 1>it should say that we're missing a

01:01:51.720 --> 01:01:54.040
<v Speaker 1>trait in scope because, like, you can only

01:01:54.040 --> 01:01:56.360
<v Speaker 1>use trait methods on on types if the

01:01:56.360 --> 01:01:57.480
<v Speaker 1>trait is in scope.

01:01:57.720 --> 01:01:59.480
<v Speaker 1>And so I think there is also a

01:01:59.480 --> 01:02:01.985
<v Speaker 1>struct opt trait that this thing is actually

01:02:01.985 --> 01:02:03.905
<v Speaker 1>implementing. So we we're gonna have to do,

01:02:03.905 --> 01:02:05.985
<v Speaker 1>like, a use struct opt struct opt,

01:02:06.065 --> 01:02:06.785
<v Speaker 1>probably.

01:02:07.505 --> 01:02:09.425
<v Speaker 1>Yeah. So use struct opt struct opt right

01:02:09.425 --> 01:02:11.985
<v Speaker 1>there. So copy that line near the bottom.

01:02:12.545 --> 01:02:14.065
<v Speaker 1>Just shove that in there somewhere.

01:02:17.220 --> 01:02:18.340
<v Speaker 1>Now

01:02:21.860 --> 01:02:24.260
<v Speaker 0>Yeah. Now now we just need options

01:02:24.660 --> 01:02:26.500
<v Speaker 1>dot name dot as d ref.

01:02:40.115 --> 01:02:42.355
<v Speaker 1>And then so you can do cargo

01:02:42.355 --> 01:02:43.714
<v Speaker 1>run

01:02:43.420 --> 01:02:45.660
<v Speaker 1>and then dash dash. So the dash

01:02:47.820 --> 01:02:49.900
<v Speaker 1>why does it say that's required?

01:02:50.140 --> 01:02:51.900
<v Speaker 1>Oh, because it's not an option. You have

01:02:51.900 --> 01:02:54.140
<v Speaker 1>to have so even with the flag, it

01:02:54.140 --> 01:02:55.900
<v Speaker 1>has to like, the option is is, like,

01:02:55.900 --> 01:02:57.100
<v Speaker 1>you need to specify that.

01:03:01.375 --> 01:03:04.015
<v Speaker 0>K. So we can add a cargo run

01:03:04.015 --> 01:03:05.214
<v Speaker 0>on it. So why don't we get hello

01:03:05.214 --> 01:03:07.615
<v Speaker 0>world? I noticed that I added a a

01:03:07.615 --> 01:03:10.015
<v Speaker 0>help So that's gonna that's gonna give you

01:03:10.015 --> 01:03:11.775
<v Speaker 1>the cargo because you're still in the cargo

01:03:11.775 --> 01:03:13.855
<v Speaker 1>command line. So you do a dash dash

01:03:13.490 --> 01:03:15.809
<v Speaker 1>nothing after that to say, I'm at the

01:03:15.890 --> 01:03:17.410
<v Speaker 1>this is the end of the cargo arguments,

01:03:17.410 --> 01:03:19.250
<v Speaker 1>then everything after that will be passed into

01:03:19.250 --> 01:03:20.690
<v Speaker 1>the binary you're running. And so that's how

01:03:20.690 --> 01:03:22.930
<v Speaker 1>you you get the help. And so by

01:03:22.930 --> 01:03:25.089
<v Speaker 0>just using this struct up thing, which is

01:03:25.089 --> 01:03:27.485
<v Speaker 0>relatively trivial, we now get this usage which

01:03:27.485 --> 01:03:29.485
<v Speaker 0>says, hey. You've got a positional parameter and

01:03:29.485 --> 01:03:31.645
<v Speaker 0>some optional parameters here. Mhmm.

01:03:32.285 --> 01:03:33.645
<v Speaker 1>And if you and also if you go

01:03:33.645 --> 01:03:34.685
<v Speaker 1>back, you can

01:03:35.245 --> 01:03:37.085
<v Speaker 1>you can go back to the hello world

01:03:37.085 --> 01:03:39.245
<v Speaker 1>example. You can document it. So just put

01:03:39.245 --> 01:03:41.965
<v Speaker 1>a doc comment line above the name and

01:03:41.965 --> 01:03:43.085
<v Speaker 1>it's like the

01:03:43.460 --> 01:03:45.619
<v Speaker 1>it's, like, the per the the thing that

01:03:45.619 --> 01:03:47.539
<v Speaker 1>we're gonna say hello. It's a triple forward

01:03:47.539 --> 01:03:48.180
<v Speaker 1>slash.

01:03:51.460 --> 01:03:53.300
<v Speaker 0>Triple oh, yeah. Of course.

01:03:54.180 --> 01:03:56.099
<v Speaker 0>Alright. I was in JavaScript mode, I think,

01:03:56.099 --> 01:03:58.795
<v Speaker 0>there or something. See. Or Elixir. So we

01:03:58.795 --> 01:03:59.835
<v Speaker 0>can say this is

01:04:01.195 --> 01:04:02.235
<v Speaker 0>my help.

01:04:04.475 --> 01:04:04.875
<v Speaker 0>Yep.

01:04:09.380 --> 01:04:10.980
<v Speaker 1>And that shows up

01:04:11.220 --> 01:04:13.860
<v Speaker 1>as the the org's name now says it's

01:04:13.860 --> 01:04:15.620
<v Speaker 1>mail text. And you can do the same

01:04:15.620 --> 01:04:16.980
<v Speaker 1>thing for lucky number.

01:04:17.220 --> 01:04:17.780
<v Speaker 1>And,

01:04:18.180 --> 01:04:19.860
<v Speaker 1>probably, I think you could put a doc

01:04:19.860 --> 01:04:21.780
<v Speaker 1>comment on the struct itself, and it'll probably

01:04:21.780 --> 01:04:22.340
<v Speaker 1>be, like

01:04:23.025 --> 01:04:25.265
<v Speaker 1>like, kinda like the paragraph summary at the

01:04:25.265 --> 01:04:27.345
<v Speaker 1>top of the the thing. It's

01:04:28.145 --> 01:04:29.265
<v Speaker 1>it's all very nice.

01:04:29.905 --> 01:04:31.425
<v Speaker 0>Cool. Very cool. Great.

01:04:31.825 --> 01:04:33.664
<v Speaker 0>And we have

01:04:35.390 --> 01:04:38.110
<v Speaker 0>cargo ad now. Yes.

01:04:39.470 --> 01:04:41.470
<v Speaker 0>So that is one cargo ad. It says,

01:04:41.470 --> 01:04:43.390
<v Speaker 0>okay. I want the name of a crate.

01:04:44.270 --> 01:04:45.390
<v Speaker 1>CD struck dot.

01:04:45.950 --> 01:04:47.870
<v Speaker 0>I think we already added that. Why do

01:04:47.870 --> 01:04:49.310
<v Speaker 0>I move it from the

01:04:49.630 --> 01:04:50.430
<v Speaker 1>Sure. Sure.

01:04:54.285 --> 01:04:56.285
<v Speaker 0>They're gone. And we see it's dropped out.

01:04:56.925 --> 01:04:59.565
<v Speaker 0>Alright. So it resolves the version for us.

01:04:59.565 --> 01:05:02.365
<v Speaker 0>It's added it here. Mhmm. You also said

01:05:02.365 --> 01:05:03.725
<v Speaker 0>I could do dev?

01:05:04.045 --> 01:05:04.685
<v Speaker 1>Yep.

01:05:04.925 --> 01:05:06.230
<v Speaker 1>Yes. Okay.

01:05:07.109 --> 01:05:09.030
<v Speaker 0>Okay. That's now my new favorite cargo plug

01:05:09.030 --> 01:05:09.510
<v Speaker 0>in.

01:05:12.790 --> 01:05:15.670
<v Speaker 0>Okay. That is a nice little segue there.

01:05:15.670 --> 01:05:17.430
<v Speaker 0>Although, I think my computer was a little

01:05:17.430 --> 01:05:19.109
<v Speaker 0>hot. Let's do this. I'm sorry.

01:05:21.885 --> 01:05:23.885
<v Speaker 0>Okay. So we we said we could do

01:05:23.885 --> 01:05:25.485
<v Speaker 0>this all from a standard library, but we've

01:05:25.485 --> 01:05:26.445
<v Speaker 0>now explored

01:05:27.325 --> 01:05:28.685
<v Speaker 0>the crates. So

01:05:29.725 --> 01:05:32.125
<v Speaker 0>let's get started with opening the file. I

01:05:32.125 --> 01:05:33.645
<v Speaker 0>most I don't think we'll we'll get through

01:05:33.645 --> 01:05:35.740
<v Speaker 0>this with the time remaining. So we'll just

01:05:35.740 --> 01:05:37.020
<v Speaker 0>do a couple of bits and pieces and

01:05:37.020 --> 01:05:38.540
<v Speaker 0>then we'll we'll wrap it. Okay.

01:05:39.339 --> 01:05:39.980
<v Speaker 1>So

01:05:40.619 --> 01:05:42.859
<v Speaker 1>let's do, like, just the easiest thing we

01:05:42.859 --> 01:05:43.500
<v Speaker 1>can do.

01:05:45.099 --> 01:05:47.660
<v Speaker 1>So there is a helper method in the

01:05:47.660 --> 01:05:48.619
<v Speaker 1>standard library

01:05:49.020 --> 01:05:49.660
<v Speaker 1>that

01:05:49.895 --> 01:05:51.974
<v Speaker 1>will just read a file. Right? And so

01:05:51.974 --> 01:05:53.494
<v Speaker 1>this is gonna, like, shove it all into

01:05:53.494 --> 01:05:54.295
<v Speaker 1>a string,

01:05:54.935 --> 01:05:56.615
<v Speaker 1>and it's it's, know, it's gonna make a

01:05:56.615 --> 01:05:58.135
<v Speaker 1>big allocation, and then we're gonna have to

01:05:58.135 --> 01:05:59.255
<v Speaker 1>cut it up and make a bunch more

01:05:59.255 --> 01:06:01.494
<v Speaker 1>allocations. So it's not necessarily the most efficient.

01:06:01.494 --> 01:06:02.775
<v Speaker 1>Do you wanna do it the the the

01:06:02.775 --> 01:06:03.990
<v Speaker 1>easy way or do because, like, do you

01:06:03.990 --> 01:06:05.270
<v Speaker 1>wanna move forward or you just wanna just,

01:06:05.270 --> 01:06:06.550
<v Speaker 1>like, show people how to do file IO

01:06:06.550 --> 01:06:07.350
<v Speaker 1>correctly?

01:06:08.790 --> 01:06:10.230
<v Speaker 0>Your preference.

01:06:13.270 --> 01:06:15.110
<v Speaker 0>Are we trying to it correctly? File IO.

01:06:15.110 --> 01:06:17.110
<v Speaker 1>Let's just do file IO correctly. Yeah. So

01:06:17.110 --> 01:06:18.630
<v Speaker 1>can you open the browser?

01:06:20.575 --> 01:06:21.855
<v Speaker 1>And then I want you to just type

01:06:21.855 --> 01:06:31.055
<v Speaker 1>in the the in the URL field, stood.rs/buffreader,

01:06:31.055 --> 01:06:33.215
<v Speaker 1>b u f r e a d e

01:06:33.215 --> 01:06:33.375
<v Speaker 1>r.

01:06:34.420 --> 01:06:36.100
<v Speaker 1>And so this just automatically

01:06:36.100 --> 01:06:39.060
<v Speaker 1>goes to the standard library docs and does

01:06:39.060 --> 01:06:40.420
<v Speaker 1>a search. And so now you can click

01:06:40.420 --> 01:06:42.100
<v Speaker 1>the first one, which is struct.

01:06:42.420 --> 01:06:44.740
<v Speaker 1>And so this is this is the important

01:06:44.740 --> 01:06:47.540
<v Speaker 1>type for doing IO in Rust correctly. Like,

01:06:47.540 --> 01:06:49.460
<v Speaker 1>you can open the file directly and read

01:06:49.460 --> 01:06:50.100
<v Speaker 1>from it directly,

01:06:50.605 --> 01:06:53.805
<v Speaker 1>but, like, that's gonna do a ton

01:06:53.805 --> 01:06:56.605
<v Speaker 1>of operating system, like, calls. Right? So it's

01:06:56.605 --> 01:06:58.045
<v Speaker 1>gonna be a lot slower.

01:06:58.845 --> 01:07:01.005
<v Speaker 1>And so you're always supposed to use buff

01:07:01.005 --> 01:07:03.645
<v Speaker 1>read around the file, which will, like, actually

01:07:03.645 --> 01:07:05.245
<v Speaker 1>allocate a buffer that you can read a

01:07:05.245 --> 01:07:07.050
<v Speaker 1>bunch of bytes into, and then you can

01:07:07.050 --> 01:07:08.570
<v Speaker 1>read out of that at your leisure, and

01:07:08.570 --> 01:07:10.810
<v Speaker 1>it makes it all much more efficient.

01:07:11.770 --> 01:07:12.810
<v Speaker 1>And so then

01:07:13.210 --> 01:07:15.930
<v Speaker 1>let let's just do a bit more explanation.

01:07:17.050 --> 01:07:19.130
<v Speaker 1>Then the next thing we're gonna want is,

01:07:19.690 --> 01:07:21.895
<v Speaker 1>lines, which I think is from the buff

01:07:21.895 --> 01:07:23.255
<v Speaker 1>read trait. So if you look at the

01:07:23.255 --> 01:07:25.335
<v Speaker 1>trade implementations on the sidebar,

01:07:25.335 --> 01:07:26.535
<v Speaker 1>it says buff read

01:07:27.335 --> 01:07:28.855
<v Speaker 1>down at the very bottom.

01:07:29.494 --> 01:07:31.575
<v Speaker 1>Right there. Yeah. And so if you click

01:07:31.575 --> 01:07:33.575
<v Speaker 1>on the traits, like, just click on actual

01:07:33.734 --> 01:07:34.775
<v Speaker 1>the buff read word,

01:07:35.589 --> 01:07:37.589
<v Speaker 1>it'll take us to the trait, and then

01:07:37.589 --> 01:07:39.750
<v Speaker 1>we can see the provided methods

01:07:40.150 --> 01:07:41.510
<v Speaker 1>on the sidebar.

01:07:42.790 --> 01:07:44.550
<v Speaker 1>And this lines function,

01:07:44.710 --> 01:07:46.950
<v Speaker 1>the one right above it, this is the

01:07:46.950 --> 01:07:49.030
<v Speaker 1>thing we are looking for. This is going

01:07:49.030 --> 01:07:50.309
<v Speaker 1>to return an iterator

01:07:50.785 --> 01:07:52.705
<v Speaker 1>over the lines

01:07:53.105 --> 01:07:54.945
<v Speaker 1>that splits it at the new lines, trims

01:07:54.945 --> 01:07:56.465
<v Speaker 1>the new line, and just gives us each

01:07:56.465 --> 01:07:58.225
<v Speaker 1>word of the file. And so what we're

01:07:58.225 --> 01:08:00.305
<v Speaker 1>gonna do is we're gonna open the file

01:08:00.465 --> 01:08:03.265
<v Speaker 1>with stood f s file open,

01:08:03.425 --> 01:08:05.265
<v Speaker 1>and then we're going to shove that file

01:08:05.265 --> 01:08:07.560
<v Speaker 1>inside of the buff reader so that it's

01:08:07.560 --> 01:08:09.080
<v Speaker 1>able to buffer the output. And then we're

01:08:09.080 --> 01:08:11.000
<v Speaker 1>going to call the lines method through the

01:08:11.000 --> 01:08:13.560
<v Speaker 1>buff read trait on the buff reader, and

01:08:13.560 --> 01:08:15.160
<v Speaker 1>that'll give us an iterator that we can

01:08:15.160 --> 01:08:17.000
<v Speaker 1>just do, like, a for each loop or

01:08:17.000 --> 01:08:19.479
<v Speaker 1>we can, like, do a collect or whatever

01:08:19.479 --> 01:08:20.680
<v Speaker 1>to generate our collection.

01:08:21.805 --> 01:08:24.524
<v Speaker 0>Alright. Cool. So let's

01:08:25.405 --> 01:08:26.444
<v Speaker 0>back a little bit.

01:08:26.765 --> 01:08:28.285
<v Speaker 0>So I might just copy these first two

01:08:28.285 --> 01:08:30.925
<v Speaker 0>lines. Right? Yes. Okay. So

01:08:31.405 --> 01:08:32.845
<v Speaker 0>we're gonna open our file.

01:08:35.520 --> 01:08:36.479
<v Speaker 0>Words

01:08:36.479 --> 01:08:37.599
<v Speaker 0>dot text.

01:08:38.560 --> 01:08:39.359
<v Speaker 0>Could you

01:08:40.080 --> 01:08:42.160
<v Speaker 0>I know that's this question mark here won't

01:08:42.160 --> 01:08:44.479
<v Speaker 0>work. Right? Because we don't return a result

01:08:44.479 --> 01:08:46.080
<v Speaker 0>type. Correct.

01:08:46.319 --> 01:08:48.479
<v Speaker 0>Now is that standard to do within library

01:08:48.479 --> 01:08:50.479
<v Speaker 0>functions or just the main? Like, what's the

01:08:50.479 --> 01:08:51.439
<v Speaker 0>the rule for that?

01:08:52.055 --> 01:08:54.215
<v Speaker 1>The rule for returning our result?

01:08:54.455 --> 01:08:55.895
<v Speaker 0>Or just would would you do that in

01:08:55.895 --> 01:08:57.895
<v Speaker 0>this function or would you just actually handle

01:08:57.895 --> 01:09:00.455
<v Speaker 0>this case properly? Like, what would be your

01:09:00.455 --> 01:09:01.574
<v Speaker 0>preferred approach?

01:09:02.455 --> 01:09:02.854
<v Speaker 1>So,

01:09:04.880 --> 01:09:08.639
<v Speaker 1>normally, I would propagate out the error. Like,

01:09:08.640 --> 01:09:10.319
<v Speaker 1>if if I don't like, if there's something

01:09:10.319 --> 01:09:11.840
<v Speaker 1>I know I can do in this case,

01:09:11.840 --> 01:09:13.359
<v Speaker 1>like, there's not a file,

01:09:13.680 --> 01:09:15.359
<v Speaker 1>I know that I'm gonna just return an

01:09:15.359 --> 01:09:16.399
<v Speaker 1>empty dictionary,

01:09:16.560 --> 01:09:18.000
<v Speaker 1>then that's what I would do. Like, I

01:09:18.000 --> 01:09:21.465
<v Speaker 1>would just, like, do an if let equals

01:09:21.705 --> 01:09:22.745
<v Speaker 1>the file,

01:09:22.905 --> 01:09:25.705
<v Speaker 1>and then else I would just immediately return.

01:09:27.305 --> 01:09:28.425
<v Speaker 1>Oh, sorry. Sorry.

01:09:29.225 --> 01:09:31.064
<v Speaker 1>It's instead of the, like,

01:09:31.305 --> 01:09:33.545
<v Speaker 1>if let f or not, like,

01:09:35.739 --> 01:09:37.100
<v Speaker 1>you have to do a let first because

01:09:37.100 --> 01:09:38.380
<v Speaker 1>we're gonna have to get the binding out.

01:09:38.380 --> 01:09:40.060
<v Speaker 1>So let f

01:09:40.060 --> 01:09:41.019
<v Speaker 1>equals

01:09:41.819 --> 01:09:42.859
<v Speaker 1>if let.

01:09:46.859 --> 01:09:47.739
<v Speaker 1>Okay.

01:09:47.739 --> 01:09:48.699
<v Speaker 1>The capital o,

01:09:49.984 --> 01:09:51.024
<v Speaker 1>parenthesis,

01:09:51.984 --> 01:09:53.904
<v Speaker 1>f inside the parenthesis,

01:09:53.984 --> 01:09:55.264
<v Speaker 1>and single equals,

01:09:57.585 --> 01:09:59.344
<v Speaker 1>and then delete the semicolon,

01:09:59.585 --> 01:10:02.145
<v Speaker 1>and then add up add up brackets,

01:10:02.865 --> 01:10:04.065
<v Speaker 1>and then put f in there,

01:10:05.300 --> 01:10:06.420
<v Speaker 1>then else,

01:10:08.580 --> 01:10:10.420
<v Speaker 1>and then just return,

01:10:11.940 --> 01:10:15.140
<v Speaker 1>you know, return back. Yeah. Sure. And then

01:10:15.140 --> 01:10:18.180
<v Speaker 1>a semicolon after the final one. And

01:10:18.925 --> 01:10:19.724
<v Speaker 1>yes.

01:10:21.645 --> 01:10:23.244
<v Speaker 1>Can you do control dot?

01:10:23.725 --> 01:10:26.045
<v Speaker 1>Never mind. You you already got it.

01:10:27.485 --> 01:10:28.844
<v Speaker 0>Okay. So

01:10:31.180 --> 01:10:33.100
<v Speaker 0>yeah. Okay. So I understand that I've let

01:10:33.180 --> 01:10:35.180
<v Speaker 0>we're okay. So we're basically, you know, pulling

01:10:35.180 --> 01:10:37.180
<v Speaker 0>that out, making sure that it's okay, not

01:10:37.180 --> 01:10:38.060
<v Speaker 0>an error.

01:10:38.140 --> 01:10:38.780
<v Speaker 0>Mhmm.

01:10:39.420 --> 01:10:41.900
<v Speaker 0>Else let equal tier teams slightly

01:10:42.300 --> 01:10:43.260
<v Speaker 0>proposed.

01:10:44.300 --> 01:10:46.300
<v Speaker 1>Yeah. So this is

01:10:47.635 --> 01:10:50.435
<v Speaker 1>this is something there's, like, proposals for fixing

01:10:50.435 --> 01:10:52.835
<v Speaker 1>this. And, eventually, we're gonna basically have the

01:10:52.835 --> 01:10:55.635
<v Speaker 1>inverse of an if let where there'll be,

01:10:55.635 --> 01:10:57.395
<v Speaker 1>like, a let else. So you could do

01:10:57.395 --> 01:10:58.835
<v Speaker 1>let f equals

01:11:00.540 --> 01:11:02.060
<v Speaker 1>like, let okay

01:11:02.860 --> 01:11:06.139
<v Speaker 1>f equals file open else

01:11:06.620 --> 01:11:07.500
<v Speaker 1>return,

01:11:08.060 --> 01:11:09.900
<v Speaker 1>and that'll kinda, like, you know, bring it

01:11:09.900 --> 01:11:12.540
<v Speaker 1>into the outer scope automatically. Instead, because we

01:11:12.540 --> 01:11:15.145
<v Speaker 1>don't have that, we have to, like, use

01:11:15.145 --> 01:11:17.225
<v Speaker 1>the fact that everything in Rust is an

01:11:17.225 --> 01:11:17.864
<v Speaker 1>expression.

01:11:18.265 --> 01:11:20.665
<v Speaker 1>And so this if statement, like, with all

01:11:20.665 --> 01:11:21.545
<v Speaker 1>its branches

01:11:21.625 --> 01:11:23.945
<v Speaker 1>can have a value as long as every

01:11:23.945 --> 01:11:24.664
<v Speaker 1>branch

01:11:25.065 --> 01:11:26.025
<v Speaker 1>of the

01:11:26.265 --> 01:11:27.385
<v Speaker 1>of the if

01:11:27.800 --> 01:11:28.760
<v Speaker 1>returns

01:11:28.760 --> 01:11:30.120
<v Speaker 1>the same type.

01:11:30.520 --> 01:11:31.080
<v Speaker 1>And

01:11:31.560 --> 01:11:33.400
<v Speaker 1>we cut even though we don't actually do

01:11:33.400 --> 01:11:35.000
<v Speaker 1>that, we only return the type in one

01:11:35.000 --> 01:11:36.440
<v Speaker 1>of them, we can get away with it

01:11:36.440 --> 01:11:39.080
<v Speaker 1>because of the never type in Rust. So

01:11:39.080 --> 01:11:40.840
<v Speaker 1>there is a special type in Rust that

01:11:40.840 --> 01:11:43.400
<v Speaker 1>says just, like, basically, you're never going to

01:11:43.005 --> 01:11:44.764
<v Speaker 1>execute anything after this.

01:11:45.565 --> 01:11:48.764
<v Speaker 1>And it's for things like stood exit or

01:11:48.764 --> 01:11:50.605
<v Speaker 1>a return. Like, you know when you return,

01:11:50.605 --> 01:11:52.125
<v Speaker 1>you're gone. Like, you're out of that function.

01:11:52.125 --> 01:11:53.885
<v Speaker 1>So everything after that is never gonna get

01:11:53.885 --> 01:11:57.000
<v Speaker 1>run. And so Rust uses the return type

01:11:57.000 --> 01:11:59.000
<v Speaker 1>of a of a return expression

01:11:59.240 --> 01:12:01.960
<v Speaker 1>to then know that every expression after that

01:12:01.960 --> 01:12:03.640
<v Speaker 1>isn't run. And

01:12:04.360 --> 01:12:06.280
<v Speaker 1>when it gets an error type, it will

01:12:06.280 --> 01:12:08.760
<v Speaker 1>treat it like any other type for type

01:12:08.760 --> 01:12:12.125
<v Speaker 1>checking purposes. And so even though the never

01:12:12.125 --> 01:12:15.725
<v Speaker 1>isn't a file, it's like it's file enough

01:12:15.725 --> 01:12:17.645
<v Speaker 1>for us. So it it'll type check and

01:12:17.645 --> 01:12:19.405
<v Speaker 1>just let us keep going because it knows

01:12:19.405 --> 01:12:22.365
<v Speaker 1>that it'll never actually try and exit that

01:12:22.365 --> 01:12:23.005
<v Speaker 1>else statement.

01:12:24.290 --> 01:12:25.010
<v Speaker 0>Okay.

01:12:25.650 --> 01:12:27.650
<v Speaker 0>Random thought that popped in my head when

01:12:27.650 --> 01:12:29.250
<v Speaker 0>you were kind of explaining that. We Mhmm.

01:12:29.250 --> 01:12:32.210
<v Speaker 0>We used unwrap r earlier. Is there an

01:12:32.210 --> 01:12:33.409
<v Speaker 0>error r?

01:12:37.650 --> 01:12:38.930
<v Speaker 1>It's still called unwrap.

01:12:39.614 --> 01:12:42.255
<v Speaker 1>Yeah. Option and result both use the same

01:12:42.255 --> 01:12:43.614
<v Speaker 1>kind of like Alright.

01:12:43.855 --> 01:12:45.375
<v Speaker 1>So you could do unwrap or

01:12:46.255 --> 01:12:46.974
<v Speaker 1>but

01:12:47.375 --> 01:12:48.655
<v Speaker 1>if we did that,

01:12:49.614 --> 01:12:51.614
<v Speaker 1>we would not be able to call

01:12:51.695 --> 01:12:52.494
<v Speaker 1>the return

01:12:53.050 --> 01:12:54.890
<v Speaker 1>That's why we have to use this if

01:12:54.890 --> 01:12:56.730
<v Speaker 1>let because if let is, like, the fundamental

01:12:56.730 --> 01:12:58.650
<v Speaker 1>language control flow things and so it can

01:12:58.650 --> 01:13:00.890
<v Speaker 1>do, like, all this fancy stuff of, like,

01:13:00.970 --> 01:13:02.250
<v Speaker 1>you know, exiting.

01:13:02.730 --> 01:13:04.650
<v Speaker 1>But if you do a unwrap or, it's

01:13:04.650 --> 01:13:05.530
<v Speaker 1>just an expression.

01:13:06.975 --> 01:13:07.854
<v Speaker 0>Cool.

01:13:08.415 --> 01:13:11.295
<v Speaker 0>Okay. So we've opened the file. We've returned

01:13:11.295 --> 01:13:13.534
<v Speaker 0>an empty dictionary, but it doesn't exist. We've

01:13:13.534 --> 01:13:15.455
<v Speaker 0>got our buffer there now. Going back to

01:13:15.455 --> 01:13:16.574
<v Speaker 0>this code,

01:13:16.975 --> 01:13:19.614
<v Speaker 0>I guess we want to we followed the

01:13:19.614 --> 01:13:21.614
<v Speaker 0>buffer tray. We clicked on this.

01:13:26.630 --> 01:13:27.670
<v Speaker 0>We do we want

01:13:29.030 --> 01:13:29.590
<v Speaker 0>what

01:13:29.910 --> 01:13:31.990
<v Speaker 0>are we copying now? Sorry. So as you're

01:13:31.990 --> 01:13:34.230
<v Speaker 1>basically gonna copy it I mean, it's just

01:13:34.230 --> 01:13:36.665
<v Speaker 1>the the third line, the thing after cursor.

01:13:36.665 --> 01:13:39.065
<v Speaker 1>Because instead of cursor not not lit not

01:13:39.065 --> 01:13:41.545
<v Speaker 1>the the third populated line. Sorry. I wasn't

01:13:41.545 --> 01:13:43.305
<v Speaker 1>counting the empty lines. Yeah. So but we're

01:13:43.305 --> 01:13:45.305
<v Speaker 1>not using cursor. We're using buffread. So it's

01:13:45.305 --> 01:13:47.545
<v Speaker 1>where the cursor goes, we're gonna just call

01:13:47.545 --> 01:13:48.185
<v Speaker 1>buffread.

01:13:49.590 --> 01:13:50.789
<v Speaker 1>So reader.

01:13:51.909 --> 01:13:53.909
<v Speaker 1>And, yeah, we can leave the unwrap there.

01:13:53.909 --> 01:13:56.550
<v Speaker 1>That's that's totally legit. And this is gonna

01:13:56.550 --> 01:13:58.230
<v Speaker 1>complain. It's the same thing that happened with

01:13:58.230 --> 01:13:59.989
<v Speaker 1>struct opt where you don't have the trait

01:13:59.989 --> 01:14:02.465
<v Speaker 1>and scope because that method is implemented on

01:14:02.465 --> 01:14:04.385
<v Speaker 1>the trait, not on buff reader.

01:14:04.865 --> 01:14:06.784
<v Speaker 1>And so, yeah, once you add buff read,

01:14:06.945 --> 01:14:07.905
<v Speaker 1>it will work.

01:14:08.705 --> 01:14:11.665
<v Speaker 1>And the buff read, each, like, each line

01:14:11.665 --> 01:14:13.630
<v Speaker 1>is a result because it could have, like,

01:14:13.630 --> 01:14:15.390
<v Speaker 1>had an error when it was reading the

01:14:15.390 --> 01:14:17.470
<v Speaker 1>line from the underlying file on the file

01:14:17.470 --> 01:14:19.710
<v Speaker 1>system. And so that map unwrap is just,

01:14:19.710 --> 01:14:22.350
<v Speaker 1>saying, if there are any errors here, I

01:14:22.350 --> 01:14:23.630
<v Speaker 1>just want you to panic,

01:14:24.270 --> 01:14:25.790
<v Speaker 1>which I think is fine. We we don't

01:14:25.790 --> 01:14:27.775
<v Speaker 1>have to do, like, we could we could

01:14:27.775 --> 01:14:29.695
<v Speaker 1>skip them. We do you wanna skip them

01:14:29.695 --> 01:14:31.535
<v Speaker 1>if they have errors? I don't know. Let's

01:14:31.535 --> 01:14:33.695
<v Speaker 1>just panic. It's fine. Yeah. We'll panic.

01:14:34.015 --> 01:14:36.815
<v Speaker 0>Okay. So now we have the lanes

01:14:36.815 --> 01:14:37.775
<v Speaker 0>iterator.

01:14:37.775 --> 01:14:39.695
<v Speaker 0>If we wanna convert that into a a

01:14:39.695 --> 01:14:41.295
<v Speaker 0>set, I guess. Mhmm.

01:14:44.360 --> 01:14:45.960
<v Speaker 0>Is that the hash set in Rust, isn't

01:14:45.960 --> 01:14:46.439
<v Speaker 0>it?

01:14:47.560 --> 01:14:49.719
<v Speaker 1>Yeah. Sure. We can use hash set. Is

01:14:49.719 --> 01:14:51.639
<v Speaker 0>there something else you would use? Well, we

01:14:51.639 --> 01:14:53.880
<v Speaker 1>used the back in the other the else

01:14:53.880 --> 01:14:56.635
<v Speaker 1>statement on line 10. So so I was

01:14:56.635 --> 01:14:58.155
<v Speaker 1>thinking it would just be like a back.

01:14:58.155 --> 01:14:59.675
<v Speaker 1>But then we don't get, like, the the

01:14:59.675 --> 01:15:01.594
<v Speaker 1>properties of, like, an actual set, so we

01:15:01.594 --> 01:15:03.594
<v Speaker 1>could have duplicate words. But I think it's

01:15:03.594 --> 01:15:04.395
<v Speaker 1>fine because we're, like

01:15:05.594 --> 01:15:07.915
<v Speaker 1>we already know that, you know, the words

01:15:07.915 --> 01:15:09.594
<v Speaker 1>file is, like, trusted input.

01:15:10.290 --> 01:15:11.409
<v Speaker 0>Oh, we hope.

01:15:12.690 --> 01:15:14.690
<v Speaker 0>Should be alright. Okay. So

01:15:15.410 --> 01:15:17.730
<v Speaker 0>what do we do with our lines ator

01:15:17.730 --> 01:15:18.770
<v Speaker 0>here then?

01:15:19.330 --> 01:15:21.010
<v Speaker 1>So this one's actually

01:15:21.650 --> 01:15:23.490
<v Speaker 1>this we can just use collect, which is,

01:15:23.490 --> 01:15:24.690
<v Speaker 1>like, one of the coolest

01:15:25.015 --> 01:15:26.855
<v Speaker 1>one of the cooler functions in the standard

01:15:26.855 --> 01:15:27.574
<v Speaker 1>library.

01:15:28.455 --> 01:15:29.415
<v Speaker 1>And so

01:15:30.295 --> 01:15:31.014
<v Speaker 1>collect

01:15:31.255 --> 01:15:34.775
<v Speaker 1>uses a bunch of type system awesomeness

01:15:34.935 --> 01:15:35.815
<v Speaker 1>to basically

01:15:37.060 --> 01:15:40.100
<v Speaker 1>generate the type of collection from the iterator

01:15:40.100 --> 01:15:41.860
<v Speaker 1>that you, like, you want. Like, you tell

01:15:41.860 --> 01:15:44.420
<v Speaker 1>it, like, turn the like, what type to

01:15:44.420 --> 01:15:45.780
<v Speaker 1>make from the iterator. And you can make

01:15:45.780 --> 01:15:48.020
<v Speaker 1>any type. Right? And so, like, I could

01:15:48.179 --> 01:15:50.179
<v Speaker 1>you could say collect colon colon

01:15:50.500 --> 01:15:52.715
<v Speaker 1>hash set, and it would generate a hash

01:15:52.715 --> 01:15:53.914
<v Speaker 1>set from the iterator.

01:15:54.554 --> 01:15:56.474
<v Speaker 1>Yeah. You need the the square brackets. We

01:15:56.474 --> 01:15:57.994
<v Speaker 1>don't we don't need the colon colon at

01:15:57.994 --> 01:15:59.994
<v Speaker 1>all. Right? Because we can let Rust infer

01:15:59.994 --> 01:16:02.235
<v Speaker 1>this. And so we literally just do collect.

01:16:04.410 --> 01:16:06.010
<v Speaker 1>And then you probably just you just get

01:16:06.010 --> 01:16:08.010
<v Speaker 1>rid of the return. I mean because, like,

01:16:08.010 --> 01:16:09.770
<v Speaker 1>you can have the last expression

01:16:10.090 --> 01:16:13.530
<v Speaker 1>in a function is always the return,

01:16:13.850 --> 01:16:15.050
<v Speaker 1>which is, like, what we're doing on line

01:16:15.050 --> 01:16:16.730
<v Speaker 1>eight. We're not, like, actually returning it. So

01:16:16.730 --> 01:16:17.930
<v Speaker 1>you can do that. You don't have to

01:16:17.930 --> 01:16:19.815
<v Speaker 1>call return. We've been doing that in a

01:16:19.815 --> 01:16:22.135
<v Speaker 1>lot of places, but it's entirely unnecessary. It's

01:16:22.135 --> 01:16:23.735
<v Speaker 1>like, I think you get warnings in Rust

01:16:23.735 --> 01:16:25.735
<v Speaker 1>if you do it. It's like not idiomatic.

01:16:26.855 --> 01:16:28.935
<v Speaker 0>Okay. I'll try and get that bad habit

01:16:28.935 --> 01:16:30.215
<v Speaker 0>out of me for sure.

01:16:31.095 --> 01:16:33.015
<v Speaker 0>So that's our load text. Right? That was

01:16:33.530 --> 01:16:35.770
<v Speaker 0>just using the standard library. It was pretty

01:16:35.770 --> 01:16:36.570
<v Speaker 0>simple.

01:16:36.730 --> 01:16:38.010
<v Speaker 0>Yes. Okay.

01:16:39.210 --> 01:16:40.570
<v Speaker 0>So let's see.

01:16:43.610 --> 01:16:45.289
<v Speaker 0>So here, we

01:16:45.770 --> 01:16:46.810
<v Speaker 0>want the

01:16:48.185 --> 01:16:50.744
<v Speaker 0>dictionary equals load dictionary.

01:16:51.225 --> 01:16:51.864
<v Speaker 1>Mhmm.

01:16:52.745 --> 01:16:54.264
<v Speaker 0>And then

01:16:55.305 --> 01:16:56.105
<v Speaker 0>let's

01:16:56.985 --> 01:16:59.545
<v Speaker 0>how long have we got? Okay. Like, ten

01:16:59.545 --> 01:17:01.800
<v Speaker 0>minutes. So let's iterate over the dictionary and

01:17:01.800 --> 01:17:03.400
<v Speaker 0>that's just a really simple test to see

01:17:03.400 --> 01:17:05.560
<v Speaker 0>if it's the same number if the length's

01:17:05.560 --> 01:17:07.800
<v Speaker 0>the same and we'll Mhmm. Skip the word.

01:17:07.800 --> 01:17:09.559
<v Speaker 0>If they're if they are the same,

01:17:10.040 --> 01:17:11.560
<v Speaker 0>then we'll see what we wanna do after

01:17:11.560 --> 01:17:12.440
<v Speaker 0>that. So Sure.

01:17:13.085 --> 01:17:15.565
<v Speaker 0>We have got a dictionary and then are

01:17:15.565 --> 01:17:16.684
<v Speaker 0>we doing ator?

01:17:16.844 --> 01:17:19.405
<v Speaker 1>Yeah. We're we'll definitely use the iterator interface.

01:17:19.565 --> 01:17:22.045
<v Speaker 1>Iterator is like real good. There's we can

01:17:22.045 --> 01:17:23.565
<v Speaker 1>chain a lot of functions to kinda like

01:17:23.565 --> 01:17:26.125
<v Speaker 1>build up the rules that we wanna apply

01:17:26.125 --> 01:17:27.005
<v Speaker 1>to this iterator.

01:17:27.969 --> 01:17:29.810
<v Speaker 0>Okay. So how would we add some sort

01:17:29.810 --> 01:17:31.889
<v Speaker 0>of filter on the the length of the

01:17:31.889 --> 01:17:34.290
<v Speaker 0>the two strings? So there so there is

01:17:34.290 --> 01:17:37.090
<v Speaker 1>the filter method on the iterator trait,

01:17:37.570 --> 01:17:39.010
<v Speaker 1>which takes

01:17:39.994 --> 01:17:42.074
<v Speaker 1>it as a self parameter. So it's like

01:17:42.074 --> 01:17:44.315
<v Speaker 1>a method on thing. It takes an iterator

01:17:44.315 --> 01:17:47.434
<v Speaker 1>and you and then a closure.

01:17:49.195 --> 01:17:50.314
<v Speaker 1>So filter.

01:17:50.795 --> 01:17:53.195
<v Speaker 0>It it's not let it's not completing, so

01:17:53.195 --> 01:17:54.235
<v Speaker 0>I just assumed that it was wrong.

01:17:55.420 --> 01:17:57.420
<v Speaker 1>Yeah. It should work. It should it should

01:17:57.420 --> 01:17:59.420
<v Speaker 1>still work. And then you're so you're gonna

01:17:59.420 --> 01:18:00.619
<v Speaker 1>put that and then

01:18:00.940 --> 01:18:01.739
<v Speaker 1>l

01:18:05.820 --> 01:18:08.460
<v Speaker 1>and then l dot len equals word dot

01:18:08.460 --> 01:18:08.860
<v Speaker 1>len.

01:18:10.845 --> 01:18:12.364
<v Speaker 1>It should be parentheses.

01:18:12.445 --> 01:18:13.645
<v Speaker 1>So those are methods.

01:18:13.885 --> 01:18:14.844
<v Speaker 0>Ah, okay.

01:18:20.445 --> 01:18:23.085
<v Speaker 1>And then so now we have only words

01:18:23.085 --> 01:18:24.205
<v Speaker 1>of same length.

01:18:24.980 --> 01:18:25.940
<v Speaker 1>And then

01:18:26.420 --> 01:18:29.540
<v Speaker 1>next, we need to, like, do the actual

01:18:29.540 --> 01:18:31.860
<v Speaker 1>anagram thing where we, like, make sure all

01:18:31.860 --> 01:18:33.139
<v Speaker 1>the characters are the same.

01:18:34.340 --> 01:18:36.420
<v Speaker 0>Okay. Why don't we

01:18:36.820 --> 01:18:39.925
<v Speaker 0>simplify this for the time that we have

01:18:39.925 --> 01:18:40.885
<v Speaker 0>remaining

01:18:41.364 --> 01:18:42.804
<v Speaker 0>and call this

01:18:44.565 --> 01:18:46.645
<v Speaker 0>this count anagrams?

01:18:48.085 --> 01:18:49.525
<v Speaker 0>Oh, no. Because Rust don't actually do it.

01:18:49.525 --> 01:18:50.805
<v Speaker 0>Yeah. We just count how many words have

01:18:50.805 --> 01:18:51.925
<v Speaker 0>the same length over there.

01:18:53.929 --> 01:18:54.730
<v Speaker 0>So

01:18:54.730 --> 01:18:56.170
<v Speaker 0>this is gonna return

01:18:56.650 --> 01:18:57.449
<v Speaker 0>u

01:18:59.770 --> 01:19:01.209
<v Speaker 0>u 32.

01:19:03.449 --> 01:19:05.850
<v Speaker 0>We'll return zero as the default case, and

01:19:05.850 --> 01:19:07.210
<v Speaker 0>let's just get rid of our tests.

01:19:07.695 --> 01:19:09.534
<v Speaker 1>You can probably I think you don't need

01:19:09.534 --> 01:19:11.135
<v Speaker 1>a default case because we're we have the

01:19:11.135 --> 01:19:13.375
<v Speaker 1>iterator is already, like, implicitly going to have

01:19:13.375 --> 01:19:17.375
<v Speaker 1>a default case of, like, zero length iterator.

01:19:21.080 --> 01:19:22.280
<v Speaker 0>Okay. Well

01:19:22.760 --> 01:19:24.040
<v Speaker 1>Oh, no. No. No. You can you everything

01:19:24.040 --> 01:19:25.640
<v Speaker 1>else you did was good. Oh, well, I

01:19:25.640 --> 01:19:27.640
<v Speaker 0>was gonna we we can do account if

01:19:27.640 --> 01:19:28.760
<v Speaker 0>they have the same length. And I was

01:19:28.760 --> 01:19:31.320
<v Speaker 0>like, but it's actually not gonna be difficult

01:19:31.320 --> 01:19:32.885
<v Speaker 0>to work out if it's an anagram, is

01:19:32.885 --> 01:19:34.165
<v Speaker 0>it? I mean, if we've already got the

01:19:34.165 --> 01:19:35.605
<v Speaker 0>words of the same length, we really just

01:19:35.605 --> 01:19:37.285
<v Speaker 0>wanna create a hash set of all the

01:19:37.285 --> 01:19:38.805
<v Speaker 0>letters and then just say if they're equal

01:19:38.805 --> 01:19:40.085
<v Speaker 0>to the hash set of the letters of

01:19:40.085 --> 01:19:41.364
<v Speaker 0>the other words. So we could probably just

01:19:41.364 --> 01:19:43.285
<v Speaker 0>do that. Right? Sure. Yeah. Let's do that.

01:19:43.285 --> 01:19:46.405
<v Speaker 1>That's easy enough. So let's let's do let's

01:19:46.405 --> 01:19:48.324
<v Speaker 1>write a word to

01:19:50.380 --> 01:19:52.139
<v Speaker 1>to to letters

01:19:52.220 --> 01:19:52.940
<v Speaker 1>thing

01:19:53.980 --> 01:19:55.980
<v Speaker 1>that takes a set a string.

01:19:57.500 --> 01:19:59.100
<v Speaker 0>Okay. So word

01:19:59.180 --> 01:20:00.139
<v Speaker 0>string

01:20:00.220 --> 01:20:01.660
<v Speaker 0>return. To hash set.

01:20:02.955 --> 01:20:05.675
<v Speaker 0>Hash set of Or should we hash map?

01:20:08.315 --> 01:20:09.755
<v Speaker 1>Or I think we we could just, like,

01:20:09.755 --> 01:20:11.355
<v Speaker 1>sort the characters and then say if they're

01:20:11.355 --> 01:20:12.155
<v Speaker 1>equal. Right?

01:20:13.755 --> 01:20:15.675
<v Speaker 0>Yeah. I thought if we did a hash

01:20:15.675 --> 01:20:17.960
<v Speaker 0>set, I mean, they would be the same.

01:20:17.960 --> 01:20:19.560
<v Speaker 1>But a hash set would require that the

01:20:19.560 --> 01:20:21.480
<v Speaker 1>characters are unique.

01:20:21.720 --> 01:20:23.800
<v Speaker 1>Otherwise, it would, like, deduplicate them.

01:20:24.040 --> 01:20:25.480
<v Speaker 1>So if you you'd you'd end up with

01:20:25.480 --> 01:20:27.160
<v Speaker 1>a Vita with one d.

01:20:28.280 --> 01:20:30.680
<v Speaker 0>Okay. So really what we want is word

01:20:30.680 --> 01:20:32.360
<v Speaker 0>to sorted

01:20:33.065 --> 01:20:34.025
<v Speaker 0>errors.

01:20:36.265 --> 01:20:38.025
<v Speaker 0>Here's me thinking this is a really easy

01:20:38.025 --> 01:20:40.185
<v Speaker 0>thing to do, and then I or even

01:20:40.185 --> 01:20:42.025
<v Speaker 0>turn up with an algorithm. Okay. So I

01:20:42.025 --> 01:20:43.465
<v Speaker 1>might just do, like, a vec care. I

01:20:43.465 --> 01:20:44.745
<v Speaker 1>don't I don't know if there's, like, a

01:20:44.745 --> 01:20:46.025
<v Speaker 1>way to sort

01:20:47.760 --> 01:20:49.760
<v Speaker 1>a string in place off the top of

01:20:49.760 --> 01:20:50.400
<v Speaker 1>my head.

01:20:51.920 --> 01:20:53.600
<v Speaker 1>And then I think it's just

01:20:55.760 --> 01:20:59.120
<v Speaker 1>you're gonna do word dot cares

01:21:00.594 --> 01:21:01.954
<v Speaker 1>dot collect,

01:21:04.675 --> 01:21:06.675
<v Speaker 1>and then let that equal some back

01:21:06.915 --> 01:21:08.915
<v Speaker 1>or, like, colon so you can do after

01:21:08.915 --> 01:21:09.874
<v Speaker 1>the collect

01:21:09.954 --> 01:21:11.235
<v Speaker 1>before the parentheses.

01:21:12.730 --> 01:21:15.210
<v Speaker 1>And you actually don't need the the car

01:21:15.210 --> 01:21:15.849
<v Speaker 1>there.

01:21:18.969 --> 01:21:20.169
<v Speaker 1>So colon colon

01:21:20.730 --> 01:21:21.769
<v Speaker 1>parentheses

01:21:21.849 --> 01:21:23.770
<v Speaker 1>square bracket or angle brackets

01:21:25.775 --> 01:21:28.175
<v Speaker 1>and then back and then angle brackets with

01:21:28.175 --> 01:21:29.454
<v Speaker 1>an underscore in between.

01:21:30.255 --> 01:21:32.655
<v Speaker 1>Because the it already knows the chars iterator

01:21:32.655 --> 01:21:34.895
<v Speaker 1>is a is an iterator or characters. And

01:21:34.895 --> 01:21:36.655
<v Speaker 1>so it's able to infer that inner type.

01:21:36.655 --> 01:21:38.690
<v Speaker 1>It just can't infer the collection type. And

01:21:38.690 --> 01:21:40.530
<v Speaker 1>so you can only specify the collection and

01:21:40.530 --> 01:21:42.610
<v Speaker 1>let it infer the the item from the

01:21:42.610 --> 01:21:43.410
<v Speaker 1>iterator.

01:21:44.210 --> 01:21:46.450
<v Speaker 1>And then so we do need to sort

01:21:46.450 --> 01:21:47.330
<v Speaker 1>that still.

01:21:48.050 --> 01:21:49.890
<v Speaker 1>So we'll have to do, like, a let

01:21:49.890 --> 01:21:51.090
<v Speaker 1>unsorted

01:21:51.090 --> 01:21:52.530
<v Speaker 1>equal online 23.

01:21:57.094 --> 01:21:57.974
<v Speaker 0>Okay.

01:21:57.974 --> 01:22:00.135
<v Speaker 0>So let unsorted.

01:22:01.014 --> 01:22:01.735
<v Speaker 0>Yep.

01:22:04.534 --> 01:22:07.494
<v Speaker 1>Let me look up sort

01:22:06.810 --> 01:22:08.570
<v Speaker 1>in this here and see where it lives.

01:22:10.250 --> 01:22:11.929
<v Speaker 1>I never sort things.

01:22:13.290 --> 01:22:15.130
<v Speaker 1>So it's on the slice

01:22:15.130 --> 01:22:15.929
<v Speaker 1>type.

01:22:16.890 --> 01:22:19.690
<v Speaker 1>So it should just work on back because

01:22:19.690 --> 01:22:21.290
<v Speaker 1>that d refs to slice.

01:22:21.875 --> 01:22:23.874
<v Speaker 1>And so you're just gonna call that sort.

01:22:25.315 --> 01:22:26.915
<v Speaker 1>And you're gonna have to put a mute,

01:22:26.915 --> 01:22:29.715
<v Speaker 1>a mutt after the the let or yeah.

01:22:35.420 --> 01:22:36.380
<v Speaker 1>And then

01:22:36.620 --> 01:22:37.500
<v Speaker 1>unsorted,

01:22:37.500 --> 01:22:38.940
<v Speaker 1>and then, like yeah. That does not return

01:22:38.940 --> 01:22:40.300
<v Speaker 1>the value. So it's just gonna be a

01:22:40.300 --> 01:22:42.060
<v Speaker 1>a colon afterwards, and then you have to

01:22:42.060 --> 01:22:43.260
<v Speaker 1>return unsorted.

01:22:43.260 --> 01:22:43.820
<v Speaker 1>Just

01:22:44.380 --> 01:22:45.340
<v Speaker 1>unsorted by itself.

01:22:47.755 --> 01:22:49.035
<v Speaker 1>Yeah. Remember, you're trying to get out of

01:22:49.035 --> 01:22:51.035
<v Speaker 1>that habit. No return statements. Okay.

01:22:53.515 --> 01:22:54.235
<v Speaker 0>Cool.

01:22:54.635 --> 01:22:56.315
<v Speaker 1>And then now, actually, you should be able

01:22:56.315 --> 01:22:57.755
<v Speaker 1>to get rid of the turbo fish and

01:22:57.755 --> 01:22:59.355
<v Speaker 1>collect because I think it will still be

01:22:59.355 --> 01:23:01.550
<v Speaker 1>able to infer. Let's see. It might break

01:23:01.550 --> 01:23:02.829
<v Speaker 1>because of the sort. Let's see if it

01:23:02.829 --> 01:23:04.269
<v Speaker 1>breaks. Just, like, get rid of everything. So

01:23:04.269 --> 01:23:05.389
<v Speaker 1>how do you Yeah. Yeah.

01:23:06.590 --> 01:23:08.590
<v Speaker 1>Does does it break? Yeah. It breaks because

01:23:08.590 --> 01:23:10.429
<v Speaker 1>it needs to know it needs to know

01:23:10.429 --> 01:23:12.030
<v Speaker 1>by the time it does sort.

01:23:12.269 --> 01:23:13.710
<v Speaker 1>And then the ord, it's not able to

01:23:13.710 --> 01:23:14.510
<v Speaker 1>figure it out. Okay.

01:23:15.405 --> 01:23:16.284
<v Speaker 1>Oh, well.

01:23:17.245 --> 01:23:19.565
<v Speaker 0>Okay. So now that we have a dictionary

01:23:19.565 --> 01:23:21.645
<v Speaker 0>with an iterator and a filter,

01:23:22.285 --> 01:23:24.685
<v Speaker 0>are we doing some sort of map or

01:23:24.925 --> 01:23:27.645
<v Speaker 1>iterator? Let's do let's do map

01:23:28.550 --> 01:23:29.829
<v Speaker 1>and then just

01:23:29.910 --> 01:23:32.469
<v Speaker 1>word two sorted letters. That's it. No closure.

01:23:35.830 --> 01:23:38.230
<v Speaker 1>And then just delete the parentheses and the

01:23:38.230 --> 01:23:40.310
<v Speaker 1>arguments. Like, it's literally we're just gonna pass

01:23:40.310 --> 01:23:40.870
<v Speaker 1>in the function.

01:23:42.065 --> 01:23:44.705
<v Speaker 1>And then let's before we do this, let's

01:23:44.705 --> 01:23:48.064
<v Speaker 1>make the sorted version of the input word.

01:23:48.225 --> 01:23:51.105
<v Speaker 1>So let's do, like, after dictionary, let's say,

01:23:51.105 --> 01:23:53.025
<v Speaker 1>like, let expected equal

01:23:53.585 --> 01:23:55.505
<v Speaker 1>word to sorted letter word.

01:24:00.230 --> 01:24:01.830
<v Speaker 1>And then we're gonna do

01:24:02.550 --> 01:24:03.909
<v Speaker 1>a dot filter

01:24:07.270 --> 01:24:08.710
<v Speaker 1>and disclosure.

01:24:08.710 --> 01:24:11.685
<v Speaker 1>So, like, a, you know, vertical line l

01:24:11.685 --> 01:24:14.645
<v Speaker 1>or whatever w w equals expected.

01:24:16.885 --> 01:24:18.725
<v Speaker 0>It should be assign this or just return

01:24:18.725 --> 01:24:19.205
<v Speaker 0>it?

01:24:19.605 --> 01:24:20.965
<v Speaker 1>Yes. So we can if you delete the

01:24:20.965 --> 01:24:22.485
<v Speaker 1>VAC on line 45

01:24:22.890 --> 01:24:24.650
<v Speaker 1>and then just put a collect after the

01:24:24.650 --> 01:24:26.410
<v Speaker 1>filter, it should work, I think.

01:24:32.570 --> 01:24:33.690
<v Speaker 1>Let's see what Rawkode said.

01:24:37.475 --> 01:24:39.554
<v Speaker 1>Okay. So can you just

01:24:42.675 --> 01:24:44.915
<v Speaker 1>before the map, do a

01:24:48.515 --> 01:24:50.514
<v Speaker 1>let's see if we can do, like, dot

01:24:51.155 --> 01:24:52.275
<v Speaker 1>map

01:24:54.380 --> 01:24:56.060
<v Speaker 1>and then parentheses

01:24:56.380 --> 01:24:57.180
<v Speaker 1>w.

01:24:58.940 --> 01:25:00.219
<v Speaker 1>Oh, sorry. The

01:25:01.580 --> 01:25:02.219
<v Speaker 1>and

01:25:04.140 --> 01:25:07.020
<v Speaker 1>just do ampersand star w.

01:25:10.175 --> 01:25:12.014
<v Speaker 1>Ampersand. Sorry. Not underscore.

01:25:12.895 --> 01:25:14.494
<v Speaker 1>Let's see if that works. Does that does

01:25:14.494 --> 01:25:15.775
<v Speaker 1>that what does that give us? What does

01:25:15.775 --> 01:25:16.414
<v Speaker 1>it say?

01:25:18.255 --> 01:25:19.295
<v Speaker 1>Do two stars.

01:25:23.160 --> 01:25:25.000
<v Speaker 1>And then put an ampersand before the w

01:25:25.000 --> 01:25:25.880
<v Speaker 1>and filter.

01:25:28.040 --> 01:25:28.760
<v Speaker 0>Or

01:25:28.920 --> 01:25:30.440
<v Speaker 0>this one? No. The first one.

01:25:33.455 --> 01:25:34.415
<v Speaker 1>And then

01:25:35.055 --> 01:25:37.695
<v Speaker 1>then you're gonna have to do a final

01:25:39.215 --> 01:25:42.175
<v Speaker 1>shit. See, because we're mapping it. We're we're

01:25:42.175 --> 01:25:44.895
<v Speaker 1>destroying the original word. And so we've we

01:25:45.055 --> 01:25:46.255
<v Speaker 1>we've got ourselves

01:25:46.495 --> 01:25:48.175
<v Speaker 1>we we can't do this

01:25:48.590 --> 01:25:49.389
<v Speaker 1>as, like

01:25:50.829 --> 01:25:52.349
<v Speaker 1>we can't we can't chain this the way

01:25:52.349 --> 01:25:54.349
<v Speaker 1>I wanted to. So we have we have

01:25:54.349 --> 01:25:56.510
<v Speaker 1>to do it all as, like, I think

01:25:56.510 --> 01:25:58.189
<v Speaker 1>a single filter map.

01:25:59.550 --> 01:26:01.710
<v Speaker 1>So delete everything after

01:26:03.005 --> 01:26:05.405
<v Speaker 1>the first filter of the LEN or

01:26:05.804 --> 01:26:08.125
<v Speaker 1>just, I guess, delete everything except for the

01:26:08.125 --> 01:26:08.844
<v Speaker 1>collect,

01:26:09.244 --> 01:26:11.085
<v Speaker 1>and then put dot filter map.

01:26:15.530 --> 01:26:17.930
<v Speaker 1>And then it's gonna be word, and then

01:26:18.090 --> 01:26:20.090
<v Speaker 1>yep. So we're gonna do

01:26:20.890 --> 01:26:21.610
<v Speaker 1>let

01:26:22.250 --> 01:26:23.290
<v Speaker 1>actual

01:26:24.570 --> 01:26:25.770
<v Speaker 1>equal

01:26:27.755 --> 01:26:29.515
<v Speaker 1>word two sorted letters

01:26:29.515 --> 01:26:31.435
<v Speaker 1>and an ampersand w, I think. Or we

01:26:31.435 --> 01:26:32.635
<v Speaker 1>might just be able to put w. I

01:26:32.635 --> 01:26:34.315
<v Speaker 1>think w will just work. It's already a

01:26:34.315 --> 01:26:36.235
<v Speaker 1>reference, so it'll already deref.

01:26:39.035 --> 01:26:40.715
<v Speaker 1>Yeah. So it's we still have to, like,

01:26:40.715 --> 01:26:41.515
<v Speaker 1>actually do the thing.

01:26:42.650 --> 01:26:44.489
<v Speaker 1>And then do if

01:26:45.770 --> 01:26:47.689
<v Speaker 1>actual equals expected.

01:26:50.250 --> 01:26:51.289
<v Speaker 1>Double yeah.

01:26:52.570 --> 01:26:53.289
<v Speaker 1>Then

01:26:53.530 --> 01:26:54.250
<v Speaker 1>some w.

01:26:57.954 --> 01:26:58.675
<v Speaker 1>Else,

01:26:59.875 --> 01:27:00.754
<v Speaker 1>none.

01:27:04.434 --> 01:27:06.354
<v Speaker 1>Now why is it upsetting us now?

01:27:08.114 --> 01:27:10.195
<v Speaker 1>Because we're doing okay. So instead of iter

01:27:10.195 --> 01:27:12.140
<v Speaker 1>in the first line, into iter.

01:27:13.340 --> 01:27:13.980
<v Speaker 0>You

01:27:14.540 --> 01:27:16.460
<v Speaker 0>tell me what the difference between those are?

01:27:16.620 --> 01:27:18.780
<v Speaker 1>Yes. So into iter is that, like, the

01:27:18.780 --> 01:27:20.460
<v Speaker 1>actual fundamental trait

01:27:20.540 --> 01:27:23.340
<v Speaker 1>that is implemented on all these types. Iter

01:27:23.340 --> 01:27:25.660
<v Speaker 1>is it's like a convention, like new,

01:27:26.435 --> 01:27:28.195
<v Speaker 1>where it's, like, the way to say, I

01:27:28.195 --> 01:27:29.715
<v Speaker 1>want to, like,

01:27:30.275 --> 01:27:32.835
<v Speaker 1>the type and iterate over it. And so

01:27:32.835 --> 01:27:35.555
<v Speaker 1>iter is always going to, like, intro to

01:27:35.635 --> 01:27:37.315
<v Speaker 1>like, it's going to reference the thing and

01:27:37.315 --> 01:27:39.635
<v Speaker 1>give you a borrow over references of, like,

01:27:39.780 --> 01:27:41.780
<v Speaker 1>the borrow on the container that it makes.

01:27:41.940 --> 01:27:43.699
<v Speaker 1>Whereas into iter is always going to be,

01:27:43.699 --> 01:27:45.859
<v Speaker 1>like, based on whatever type it currently is,

01:27:46.020 --> 01:27:47.619
<v Speaker 1>I am going to convert this into the

01:27:47.619 --> 01:27:50.340
<v Speaker 1>iterator that is implemented for that type. So

01:27:50.340 --> 01:27:51.459
<v Speaker 1>for a vec,

01:27:51.699 --> 01:27:53.219
<v Speaker 1>you have, like, a couple of into iter

01:27:53.219 --> 01:27:54.820
<v Speaker 1>definitions. So, like, if it's

01:27:55.335 --> 01:27:57.255
<v Speaker 1>if it's a or just the back itself,

01:27:57.255 --> 01:27:59.735
<v Speaker 1>into iter will give you the item owned.

01:28:00.055 --> 01:28:02.215
<v Speaker 1>If it's a reference to a back, it'll

01:28:02.215 --> 01:28:04.695
<v Speaker 1>give you a reference to each item. If

01:28:04.695 --> 01:28:06.375
<v Speaker 1>it's a mutable reference to a back, it'll

01:28:06.375 --> 01:28:07.895
<v Speaker 1>give you a mutable reference to each item.

01:28:07.895 --> 01:28:09.960
<v Speaker 1>So this is into iter is the thing

01:28:09.960 --> 01:28:12.360
<v Speaker 1>that the four trait work the four loop

01:28:12.520 --> 01:28:14.680
<v Speaker 1>syntax works on. So that's why you can

01:28:14.680 --> 01:28:19.480
<v Speaker 1>do something like four word in in ampersand

01:28:19.560 --> 01:28:20.200
<v Speaker 1>vec

01:28:20.535 --> 01:28:23.095
<v Speaker 1>and have it just, like, give you not,

01:28:23.095 --> 01:28:25.015
<v Speaker 1>like, destroy your vector and actually, like, iterate

01:28:25.015 --> 01:28:26.935
<v Speaker 1>over it by reference. It's because it's calling

01:28:26.935 --> 01:28:29.495
<v Speaker 1>the, like, the specific into iter implementation

01:28:29.815 --> 01:28:31.495
<v Speaker 1>for a reference to a vec.

01:28:33.200 --> 01:28:34.560
<v Speaker 1>And so in this case, we want to

01:28:34.560 --> 01:28:36.240
<v Speaker 1>do owned iteration of the back. So we

01:28:36.240 --> 01:28:38.080
<v Speaker 1>wanna keep the strings that were in the

01:28:38.080 --> 01:28:41.680
<v Speaker 1>dictionary and return those out as owned strings

01:28:41.840 --> 01:28:43.600
<v Speaker 1>to the final thing. So if we, like

01:28:43.680 --> 01:28:45.360
<v Speaker 1>if the if the dictionary were static, then

01:28:45.360 --> 01:28:47.360
<v Speaker 1>we could, like, you know, return static strs.

01:28:47.615 --> 01:28:49.695
<v Speaker 1>Or if the the dictionary's input, we could

01:28:49.695 --> 01:28:52.015
<v Speaker 1>have a borrow to the dictionary. But because

01:28:52.015 --> 01:28:54.255
<v Speaker 1>we've, like, kind of, like, constructed this as

01:28:54.255 --> 01:28:56.815
<v Speaker 1>a temporary value internally, we have to, like,

01:28:57.375 --> 01:28:59.455
<v Speaker 1>destroy it and return pieces of it, really.

01:29:00.175 --> 01:29:00.815
<v Speaker 0>Okay.

01:29:02.255 --> 01:29:03.215
<v Speaker 0>Alright. Let's

01:29:03.720 --> 01:29:05.480
<v Speaker 0>test if this works then. The test will

01:29:05.480 --> 01:29:07.159
<v Speaker 0>fail, but, I mean, we should

01:29:08.600 --> 01:29:10.520
<v Speaker 1>We might get, like, a lot of extra

01:29:10.520 --> 01:29:12.119
<v Speaker 1>anagrams if we're lucky.

01:29:13.320 --> 01:29:14.840
<v Speaker 1>But we can probably remove this truck top

01:29:14.840 --> 01:29:15.080
<v Speaker 1>that

01:29:16.040 --> 01:29:16.440
<v Speaker 1>let's see.

01:29:18.575 --> 01:29:20.095
<v Speaker 0>I'll give it a few seconds to see

01:29:20.095 --> 01:29:22.015
<v Speaker 0>if it wants to move you on by.

01:29:22.095 --> 01:29:23.535
<v Speaker 0>I guess what we can is there a

01:29:23.535 --> 01:29:24.975
<v Speaker 0>stair contains?

01:29:25.055 --> 01:29:26.815
<v Speaker 0>Or I guess I could do You could

01:29:26.815 --> 01:29:28.495
<v Speaker 1>just do a search and then

01:29:29.935 --> 01:29:31.695
<v Speaker 1>find anagram stock contains.

01:29:39.679 --> 01:29:41.760
<v Speaker 1>And it's not gonna be words. It's gonna

01:29:41.760 --> 01:29:42.719
<v Speaker 1>just be like

01:29:43.360 --> 01:29:45.679
<v Speaker 1>parentheses elapse. Like, you're not gonna be able

01:29:45.679 --> 01:29:46.000
<v Speaker 1>to do

01:29:50.375 --> 01:29:52.295
<v Speaker 1>because contains only is gonna it's gonna be

01:29:52.295 --> 01:29:54.695
<v Speaker 1>the item of the back. You're gonna, like,

01:29:54.695 --> 01:29:56.535
<v Speaker 1>look for a single item. It's you're not

01:29:56.535 --> 01:29:58.054
<v Speaker 1>gonna be able to, like, compare a

01:29:58.535 --> 01:30:00.614
<v Speaker 1>collection to a collection with the contains method.

01:30:04.100 --> 01:30:06.020
<v Speaker 0>Started to string from one. Yeah.

01:30:11.860 --> 01:30:12.980
<v Speaker 0>What have I done?

01:30:18.500 --> 01:30:20.035
<v Speaker 1>Oh. It expects a a reference to a

01:30:20.035 --> 01:30:23.715
<v Speaker 1>string. Yes. The the the borrow checking and,

01:30:23.715 --> 01:30:24.435
<v Speaker 1>like, lifetime

01:30:24.675 --> 01:30:26.275
<v Speaker 1>like, the type type rules when it comes

01:30:26.275 --> 01:30:28.995
<v Speaker 1>to references can be, like, annoying and weird.

01:30:29.155 --> 01:30:30.035
<v Speaker 1>And it's

01:30:30.800 --> 01:30:34.000
<v Speaker 1>if you're ever confused by them, I highly

01:30:34.000 --> 01:30:37.120
<v Speaker 1>recommend looking up and, like, really familiarizing yourself

01:30:37.120 --> 01:30:38.960
<v Speaker 1>with all the syntax sugar that exists in

01:30:38.960 --> 01:30:42.480
<v Speaker 1>Rust. There's this awesome website called cheats.rs,

01:30:42.480 --> 01:30:43.520
<v Speaker 1>which, like, you can bring it up right

01:30:43.520 --> 01:30:44.720
<v Speaker 1>now. I wanted to show you the section.

01:30:45.324 --> 01:30:46.524
<v Speaker 1>Sheets .rs.

01:30:46.525 --> 01:30:50.045
<v Speaker 1>And then on the behind the scenes, scroll

01:30:50.045 --> 01:30:52.604
<v Speaker 1>down. It should be on the left column.

01:30:52.844 --> 01:30:54.604
<v Speaker 1>Yeah. Sync language sugar.

01:30:55.804 --> 01:30:56.445
<v Speaker 1>So

01:30:56.605 --> 01:30:59.804
<v Speaker 1>these all of these sections are, like

01:31:00.820 --> 01:31:02.980
<v Speaker 1>they're real good things to read. If you're

01:31:02.980 --> 01:31:04.100
<v Speaker 1>not if you don't wanna read anything else

01:31:04.100 --> 01:31:06.260
<v Speaker 1>about the language, like, read these things and

01:31:06.260 --> 01:31:08.580
<v Speaker 1>you will have, like, all all that, like,

01:31:08.580 --> 01:31:11.140
<v Speaker 1>I'm just, like, peppering ampersands and stars in

01:31:11.140 --> 01:31:12.580
<v Speaker 1>there to try and, like all of that

01:31:12.580 --> 01:31:14.580
<v Speaker 1>makes sense if you've read these sections and

01:31:14.580 --> 01:31:17.625
<v Speaker 1>understand how dref works, how coercions work, how

01:31:17.625 --> 01:31:20.585
<v Speaker 1>lifetime malition works, how method resolution works. Like,

01:31:20.585 --> 01:31:22.344
<v Speaker 1>all this stuff is, like, the thing that

01:31:22.344 --> 01:31:23.784
<v Speaker 1>makes Rust, like, not

01:31:24.264 --> 01:31:26.185
<v Speaker 1>really verbose. Like, it would be way more

01:31:26.185 --> 01:31:28.505
<v Speaker 1>verbose. But, like, they can't fix everything and

01:31:28.505 --> 01:31:30.185
<v Speaker 1>so, like, not if you don't understand the

01:31:30.185 --> 01:31:31.470
<v Speaker 1>kind of things it's trying to do for

01:31:31.470 --> 01:31:32.990
<v Speaker 1>you behind the scenes, you're not able to

01:31:32.990 --> 01:31:34.750
<v Speaker 1>help it do those things for you.

01:31:35.630 --> 01:31:38.670
<v Speaker 0>Awesome. I'll definitely make my way through those.

01:31:39.230 --> 01:31:40.750
<v Speaker 0>I I don't wanna keep you too much

01:31:40.750 --> 01:31:42.270
<v Speaker 0>longer because we're kinda over where we said

01:31:42.270 --> 01:31:44.670
<v Speaker 0>we'd be. So I'll just run a test

01:31:44.405 --> 01:31:45.764
<v Speaker 0>and we'll see what happens.

01:31:49.925 --> 01:31:51.844
<v Speaker 0>Well, it did work.

01:31:52.805 --> 01:31:54.885
<v Speaker 1>It found an anagram on accident.

01:31:55.925 --> 01:31:58.725
<v Speaker 0>Well, I think it was okay with

01:31:59.710 --> 01:32:01.470
<v Speaker 0>the the sleep one worked. I think it's

01:32:01.470 --> 01:32:02.030
<v Speaker 0>just

01:32:02.590 --> 01:32:04.190
<v Speaker 0>this one found an anagram.

01:32:04.350 --> 01:32:06.990
<v Speaker 1>Yeah. Yeah. Because because it didn't expect you

01:32:06.990 --> 01:32:08.910
<v Speaker 1>to have any anagrams, but it actually does

01:32:08.910 --> 01:32:10.030
<v Speaker 1>have anagrams.

01:32:12.270 --> 01:32:14.875
<v Speaker 0>That works. We special case it anymore. There

01:32:14.875 --> 01:32:15.515
<v Speaker 0>we go. Awesome.

01:32:17.035 --> 01:32:17.835
<v Speaker 0>That was

01:32:19.035 --> 01:32:21.595
<v Speaker 0>really enlightening. I think even though the examples

01:32:21.595 --> 01:32:25.115
<v Speaker 0>are particularly trivial and contrived, like just exploring

01:32:25.115 --> 01:32:26.715
<v Speaker 0>the language and you bring in your knowledge

01:32:26.715 --> 01:32:28.315
<v Speaker 0>and sharing that there was was really really

01:32:28.315 --> 01:32:31.060
<v Speaker 0>cool. There was a lot to digest there,

01:32:31.060 --> 01:32:33.219
<v Speaker 0>and I hope that other people find that.

01:32:33.219 --> 01:32:34.500
<v Speaker 0>No. No. Don't be sorry. That was a

01:32:34.500 --> 01:32:35.780
<v Speaker 0>miss. I hope other people find that as

01:32:35.780 --> 01:32:37.380
<v Speaker 0>useful as I did. So I just wanna

01:32:37.380 --> 01:32:38.980
<v Speaker 0>say thank you for taking some time out

01:32:38.980 --> 01:32:40.900
<v Speaker 0>of your day today. No. No. But going

01:32:40.900 --> 01:32:43.140
<v Speaker 0>through that with me and, you know, hopefully,

01:32:43.845 --> 01:32:45.445
<v Speaker 0>lots of other people will find this very,

01:32:45.445 --> 01:32:46.805
<v Speaker 0>very useful. So thank And,

01:32:47.365 --> 01:32:48.805
<v Speaker 1>Mike, you're welcome. Thank you for having me

01:32:48.805 --> 01:32:50.485
<v Speaker 1>on. Like, it's it's been really fun. So

01:32:50.485 --> 01:32:51.845
<v Speaker 1>it's a good morning, you know,

01:32:52.405 --> 01:32:54.085
<v Speaker 1>with fun teaching people Rust. That's that's like

01:32:54.085 --> 01:32:55.685
<v Speaker 1>my favorite thing. I started Rust Mentors to

01:32:55.685 --> 01:32:58.165
<v Speaker 1>do this exact thing. So, like, absolutely.

01:32:58.165 --> 01:33:00.760
<v Speaker 1>My pleasure. Awesome. Well, thank you very much.

01:33:00.760 --> 01:33:02.600
<v Speaker 0>You have an awesome day and I'll see

01:33:02.600 --> 01:33:04.040
<v Speaker 0>you again soon. Okay. See you.
