---
import type { HTMLAttributes } from "astro/types";

interface Props extends HTMLAttributes<"div"> {
	seed?: string; // Optional seed for deterministic generation
}

const { seed = "default-seed", ...rest } = Astro.props;
---

<style is:inline>
  /* Starfield wrapper */
  .starfield {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #121212; /* Dark background for stars */
    overflow: hidden;
    z-index: 0;
    pointer-events: auto; /* Ensure the starfield can receive events */
  }

  /* Instant background visibility */
  body {
    background: #121212;
  }

  /* Star styles */
  .star {
    position: absolute;
    width: 1.5px;
    height: 1.5px;
    background-color: #ffffff;
    border-radius: 50%;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0.6);
    transform: translate(-50%, -50%); /* Center the star on its coordinates */
    cursor: pointer; /* Add hover indicator */
    z-index: 5; /* Ensure stars are above the background */
    pointer-events: auto; /* Explicitly enable pointer events */
  }

  /* Star hover effect */
  .star:hover {
    transform: translate(-50%, -50%) scale(1.5);
    box-shadow: 0 0 3px rgba(255, 255, 255, 0.9);
    transition: all 0.2s ease;
  }

  /* Larger stars */
  .star-tiny {
    width: 1px;
    height: 1px;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
  }

  .star-small {
    width: 2px;
    height: 2px;
    box-shadow: 0 0 2px rgba(255, 255, 255, 0.7);
  }

  .star-medium {
    width: 3px;
    height: 3px;
    box-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
  }

  .star-large {
    width: 4px;
    height: 4px;
    box-shadow: 0 0 4px rgba(255, 255, 255, 0.9);
  }

  .star-xlarge {
    width: 5px;
    height: 5px;
    box-shadow: 0 0 5px rgba(255, 255, 255, 1);
  }

  /* Energy line styling */
  .energy-line {
    position: absolute;
    width: 20px;
    height: 2px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 1px;
    box-shadow:
      0 0 4px 1px rgba(120, 220, 255, 0.8),
      0 0 8px 2px rgba(50, 180, 255, 0.5),
      0 0 12px 4px rgba(30, 120, 255, 0.3);
    z-index: 10;
    pointer-events: none;
    transform-origin: center left;
  }

  /* Energy dot styling */
  .energy-dot {
    position: absolute;
    width: 4px;
    height: 4px;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 50%;
    box-shadow:
      0 0 6px 2px rgba(120, 220, 255, 0.9),
      0 0 12px 4px rgba(50, 180, 255, 0.6),
      0 0 18px 6px rgba(30, 120, 255, 0.3);
    z-index: 10;
    pointer-events: none;
    transform: translate(-50%, -50%); /* Center the dot on its coordinates */
  }

  /* Updated constellation line styling */
  .constellation-line {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.25);
    transform-origin: 0 0;
    z-index: 5;
    height: 0.8px !important;
    transition: all 0.4s ease;
    box-shadow: 0 0 3px rgba(255, 255, 255, 0.1);
    pointer-events: auto; /* Explicitly ensure lines are interactive */
  }

  /* Constellation group */
  .constellation-group {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none; /* Group itself is not interactive */
    z-index: 10; /* Keep explicit z-index */
  }

  /* Constellation Name Label */
  .constellation-label {
    position: absolute;
    color: rgba(170, 220, 255, 0.95); /* Slightly brighter blue */
    font-size: 12px;
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; /* Cleaner font */
    /* Multi-layered shadow for better contrast */
    text-shadow:
      /* Original blue glow */
      0 0 7px rgba(100, 180, 255, 0.9),
      /* Subtle dark outline */
      1px 1px 1px rgba(0, 0, 0, 0.7),
      -1px -1px 1px rgba(0, 0, 0, 0.7),
      1px -1px 1px rgba(0, 0, 0, 0.7),
      -1px 1px 1px rgba(0, 0, 0, 0.7);
    transform: translate(-50%, -50%); /* Center on coordinates */
    z-index: 15;
    pointer-events: none;
    opacity: 1; /* Always visible */
    white-space: nowrap;
  }

  /* Individual Star Name Label (similar to constellation) */
  .star-label {
    position: absolute;
    color: rgba(120, 210, 255, 0.85); /* Match energy burst label color */
    font-size: 10px; /* Smaller font */
    font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
    text-shadow: 0 0 4px rgba(0, 100, 200, 0.9); /* Match energy burst label shadow */
    transform: translate(-50%, -150%); /* Position above star */
    z-index: 15; /* Make sure it's above stars and constellation lines */
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.3s ease;
    white-space: nowrap;
  }

  /* Path line styling - for energy travel paths */
  .path-line {
    position: absolute;
    transform-origin: 0 0;
    z-index: 4;
    height: 1px !important;
    transition: opacity 0.3s ease;
    overflow: hidden;

    /* Create dashed lines with a background pattern */
    background: repeating-linear-gradient(
      90deg,
      rgba(255, 255, 255, 0.5),
      rgba(255, 255, 255, 0.5) 6px,
      transparent 6px,
      transparent 12px
    );

    /* Explicitly animate the background position */
    animation: dashMove 0.8s linear infinite;
  }

  /* Animation for moving dashed line */
  @keyframes dashMove {
    from { background-position-x: 0; }
    to { background-position-x: 24px; }
  }

  /* Travel Indicator Specific Styles - Moved to TravelIndicator.astro component */

  /* Comet styles */
  .comet {
    position: absolute;
    /* Base styles - will be overridden by size classes */
    background-color: rgba(200, 220, 255, 0.85);
    border-radius: 50%;
    z-index: 20;
    pointer-events: none;
    transform: translate(-50%, -50%);
  }

  /* Medium size (current default) */
  .comet.comet-medium {
      width: 3px;
      height: 3px;
      box-shadow:
        0 0 5px 2px rgba(150, 200, 255, 0.6),
        0 0 10px 4px rgba(100, 180, 255, 0.3),
        0 0 15px 6px rgba(50, 150, 255, 0.15);
  }

  /* Small size */
  .comet.comet-small {
      width: 2px;
      height: 2px;
      box-shadow:
        0 0 3px 1px rgba(150, 200, 255, 0.55),
        0 0 7px 2px rgba(100, 180, 255, 0.25),
        0 0 11px 4px rgba(50, 150, 255, 0.1);
  }

  /* Tiny size */
  .comet.comet-tiny {
      width: 1px;
      height: 1px;
      box-shadow:
        0 0 2px 1px rgba(150, 200, 255, 0.5),
        0 0 4px 1px rgba(100, 180, 255, 0.2),
        0 0 7px 2px rgba(50, 150, 255, 0.08);
  }

  .comet-tail-particle {
    position: absolute;
    width: 2px;
    height: 2px;
    background-color: rgba(180, 210, 255, 0.6); /* Fainter blue */
    border-radius: 50%;
    box-shadow: 0 0 3px 1px rgba(150, 200, 255, 0.4);
    z-index: 19; /* Below comet head but above most other things */
    pointer-events: none;
    opacity: 0; /* Start invisible */
    transition: opacity 0.5s ease-out; /* Fade in/out */
  }

  /* --- Blinking Animation --- */
  @keyframes blinkAnimation {
    0%, 100% { opacity: var(--star-base-opacity, 0.8); } /* Use CSS variable for max */
    50% { opacity: 0.2; } /* Minimum opacity */
  }

  .blinking-star {
    animation: blinkAnimation 7s infinite alternate ease-in-out; /* 7-second cycle */
    /* animation-delay is set inline via JS for randomness */
  }
  /* --- End Blinking Animation --- */
</style>

<!-- Space background with stars -->
<div class="starfield" id="starfield" {...rest}>
  <!-- Stars will be generated by script -->
</div>

<script is:inline define:vars={{ initialSeed: seed }}>
  (function() {
    // Get starfield container
    const starField = document.getElementById('starfield');
    if (!starField) return;

    // --- Game Loop State ---
    let gameLoopId = null;
    let lastTimestamp = 0;
    const TARGET_FRAMERATE = 60;
    const FRAME_TIME = 1000 / TARGET_FRAMERATE;
    let deltaTime = 0;
    let accumulator = 0;
    let isPaused = false;

    // Effects management
    let pendingEffects = []; // Array to manage effects that would have used timeouts
    // --- End Game Loop State ---

    // --- Tab Visibility Handling ---
    document.addEventListener('visibilitychange', () => {
      if (document.hidden) {
        pauseGameLoop();
      } else {
        resumeGameLoop();
      }
    }, false);

    // Also handle page unload to ensure we stop all animations
    window.addEventListener('beforeunload', () => {
      pauseGameLoop();
    });

    // Remove window blur/focus listeners as they cause pausing when clicking outside tab
    // --- End Tab Visibility Handling ---

    // --- Seeded PRNG (Mulberry32) ---
    function mulberry32(a) {
      return function() {
        var t = a += 0x6D2B79F5;
        t = Math.imul(t ^ t >>> 15, t | 1);
        t ^= t + Math.imul(t ^ t >>> 7, t | 61);
        return ((t ^ t >>> 14) >>> 0) / 4294967296;
      }
    }

    // Function to create a numeric hash from a string seed
    function cyrb53(str, seed = 0) {
        let h1 = 0xdeadbeef ^ seed, h2 = 0x41c6ce57 ^ seed;
        for (let i = 0, ch; i < str.length; i++) {
            ch = str.charCodeAt(i);
            h1 = Math.imul(h1 ^ ch, 2654435761);
            h2 = Math.imul(h2 ^ ch, 1597334677);
        }
        h1 = Math.imul(h1 ^ (h1>>>16), 2246822507) ^ Math.imul(h2 ^ (h2>>>13), 3266489909);
        h2 = Math.imul(h2 ^ (h2>>>16), 2246822507) ^ Math.imul(h1 ^ (h1>>>13), 3266489909);
        return 4294967296 * (2097151 & h2) + (h1>>>0);
    };

    // Initialize the random number generator with the seed
    const numericSeed = cyrb53(initialSeed);
    let random = mulberry32(numericSeed);
    console.log(`Starfield initialized with seed: "${initialSeed}" (Numeric: ${numericSeed})`);
    // --- End Seeded PRNG Setup ---

    // --- Single Label for Star Hovers ---
    let starHoverLabel = document.createElement('div');
    starHoverLabel.id = 'star-hover-label';
    starHoverLabel.className = 'star-label';
    starField.appendChild(starHoverLabel);
    // --- End Single Label Setup ---

    // Configuration
    const gridCellSize = 25;
    const starCount = 1200;
    const constellationCount = 10;
    const maxStarsPerConstellation = 7;
    const minStarsPerConstellation = 4;
    const maxConnectionDistance = 5;
    const constellationBorderMargin = 10; // Minimum % distance from viewport edge
    const gridDensityFactor = 0.3;
    const cometSpeed = 0.01; // Percentage of screen width per second
    const cometInterval = 3000; // Milliseconds between *potential* new comet spawns
    const maxComets = 5; // Maximum number of simultaneous comets
    const tailParticleLife = 1200; // Reduced lifetime for shorter tail
    const particlesPerSecond = 60; // Reduced density

    // Track elements to clean up on resize
    let allStarElements = [];
    let allConstellationElements = [];
    let allEnergyBursts = [];
    let allStars = [];

    // --- Comet State (Modified for Multiple Comets) ---
    let activeComets = []; // Array to hold active comet objects
    let cometParticles = []; // Keep single array for particles, they manage their own lifecycle
    let nextCometSpawnTime = 0; // When to spawn the next comet
    let nextCometId = 0; // Simple ID generator for comets
    // --- End Comet State ---

    // --- Energy Burst State ---
    let activeEnergyBursts = []; // Array to track active energy bursts
    let nextEnergyBurstTime = 0; // When to spawn the next energy burst
    // --- End Energy Burst State ---

    let activeEnergyBurstsCount = 0;
    const maxParallelBursts = 1;

    // Track which stars are part of constellations
    const constellationStars = new Set();

    // Keep track of constellation areas to prevent overlap
    const usedAreas = [];

    // Keep track of used constellation sections
    let usedSections = new Set();
    // Keep track of placed label approximate centers to avoid overlap
    let placedLabelCenters = [];

    // Initialize the starfield
    generateStarfield();

    // Add window resize handler with debounce
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        // Clear existing starfield
        clearStarfield();

        // Reset constellation tracking
        constellationStars.clear();
        usedAreas.length = 0;
        usedSections.clear();
        placedLabelCenters = []; // Reset label positions

        // Stop all animations
        stopGameLoop();

        // Re-initialize RNG for consistency after resize
        random = mulberry32(numericSeed);

        // Regenerate with new dimensions
        generateStarfield();
      }, 250);
    });

    // Function to clear the existing starfield
    function clearStarfield() {
      // Remove stars, constellations, energy bursts
      allStarElements.forEach(el => el?.parentNode?.removeChild(el));
      allConstellationElements.forEach(el => el?.parentNode?.removeChild(el));
      allEnergyBursts.forEach(el => el?.parentNode?.removeChild(el));

      // Reset tracking arrays
      allStarElements = [];
      allConstellationElements = [];
      allEnergyBursts = [];
      activeComets = [];
      cometParticles = [];
      activeEnergyBursts = [];
    }

    // Start the game loop
    function startGameLoop() {
      if (gameLoopId === null) {
        lastTimestamp = performance.now();
        gameLoopId = requestAnimationFrame(gameLoop);
      }
    }

    // Stop the game loop
    function stopGameLoop() {
      if (gameLoopId !== null) {
        cancelAnimationFrame(gameLoopId);
        gameLoopId = null;
      }
    }

    // Pause the game loop without stopping it completely
    function pauseGameLoop() {
      if (!isPaused) {
        console.log('Starfield game loop paused - tab inactive');

        // Store current time for pause duration calculation
        const pauseStartTime = performance.now();

        // Set pause flag first to prevent any new updates
        isPaused = true;

        // Cancel any active animation frame
        if (gameLoopId !== null) {
          cancelAnimationFrame(gameLoopId);
          gameLoopId = null;
        }

        // Store pause start time for all pending effects
        pendingEffects.forEach(effect => {
          effect.pauseStartTime = pauseStartTime;
        });

        // Store pause start time for comets
        activeComets.forEach(comet => {
          comet.pauseStartTime = pauseStartTime;
        });

        // Store pause start time for energy bursts
        activeEnergyBursts.forEach(burst => {
          burst.pauseStartTime = pauseStartTime;

          // Pause travel indicator animation if exists
          if (burst.travelSlot) {
            const travelDot = burst.travelSlot.querySelector('.travel-indicator-dot');
            if (travelDot) {
              travelDot.style.animationPlayState = 'paused';
            }
          }
        });

        // Stop any pending comet spawns by setting the time far in the future
        nextCometSpawnTime = Number.MAX_SAFE_INTEGER;
        nextEnergyBurstTime = Number.MAX_SAFE_INTEGER;
      }
    }

    // Resume the game loop
    function resumeGameLoop() {
      if (isPaused) {
        console.log('Starfield game loop resumed - tab active');

        // Current time for resuming
        const resumeTime = performance.now();

        // Calculate how long we were paused
        let pauseDuration = 0;

        // Adjust times for pending effects
        pendingEffects.forEach(effect => {
          if (effect.pauseStartTime) {
            pauseDuration = resumeTime - effect.pauseStartTime;

            // Extend all scheduled times by the pause duration
            if (effect.fadeTime) effect.fadeTime += pauseDuration;
            if (effect.removeTime) effect.removeTime += pauseDuration;

            // Clear the pause start time
            delete effect.pauseStartTime;
          }
        });

        // Adjust comet animation times
        activeComets.forEach(comet => {
          if (comet.pauseStartTime) {
            pauseDuration = resumeTime - comet.pauseStartTime;
            comet.startTime += pauseDuration;
            comet.lastParticleSpawnTime += pauseDuration;
            delete comet.pauseStartTime;
          }
        });

        // Adjust energy burst animation times
        activeEnergyBursts.forEach(burst => {
          if (burst.pauseStartTime) {
            pauseDuration = resumeTime - burst.pauseStartTime;
            burst.startTime += pauseDuration;
            delete burst.pauseStartTime;

            // Resume travel indicator animation if exists
            if (burst.travelSlot) {
              const travelDot = burst.travelSlot.querySelector('.travel-indicator-dot');
              if (travelDot) {
                travelDot.style.animationPlayState = 'running';
              }
            }
          }
        });

        // Reset timing variables
        lastTimestamp = resumeTime;
        accumulator = 0;

        // Schedule next events
        nextCometSpawnTime = resumeTime + 1000 + Math.random() * 2000;
        nextEnergyBurstTime = resumeTime + 2000 + Math.floor(random() * 5000);

        // Reset pause flag AFTER all setup is complete
        isPaused = false;

        // Restart the animation loop
        if (gameLoopId === null) {
          gameLoopId = requestAnimationFrame(gameLoop);
        }
      }
    }

    // Main game loop
    function gameLoop(timestamp) {
      // If we're paused, don't process anything
      if (isPaused) {
        console.log("Game loop running while paused - this shouldn't happen");
        return;
      }

      // Calculate frame time and update FPS counter
      const currentFrameTime = timestamp;
      deltaTime = currentFrameTime - lastTimestamp;

      // Protect against very large time steps (e.g., after tab was inactive)
      if (deltaTime > 1000) {
        console.log(`Large delta time detected: ${deltaTime}ms - capping to 1000ms`);
        deltaTime = 1000; // Cap at 1 second
      }

      lastTimestamp = currentFrameTime;

      // Fixed time step accumulator
      accumulator += deltaTime;

      // Process updates with fixed time step
      while (accumulator >= FRAME_TIME && !isPaused) {
        // Update game state with fixed delta
        updateGameState(FRAME_TIME);
        accumulator -= FRAME_TIME;
      }

      // Render the current state (can be interpolated for smoother visuals)
      if (!isPaused) {
        renderGameState(accumulator / FRAME_TIME);
      }

      // Schedule next frame only if we're not paused
      if (!isPaused) {
        gameLoopId = requestAnimationFrame(gameLoop);
      }
    }

    // Update all game state with fixed time step
    function updateGameState() {
      // Don't update anything if paused
      if (isPaused) return;

      // 1. Update comets
      updateComets();

      // 2. Check for new comet spawns
      const currentTime = performance.now();
      if (currentTime >= nextCometSpawnTime && !isPaused) {
        if (activeComets.length < maxComets) {
          createComet(window.innerWidth, window.innerHeight);
        }
        // Schedule next spawn check with some randomness
        nextCometSpawnTime = currentTime + cometInterval + Math.random() * 1000;
      }

      // 3. Update energy bursts
      updateEnergyBursts();

      // 4. Check for new energy bursts
      if (currentTime >= nextEnergyBurstTime && activeEnergyBurstsCount < maxParallelBursts && !isPaused) {
        // Try to create a new energy burst
        tryCreateEnergyBurst();
        // Schedule next energy burst with longer minimum delay (4-12 seconds)
        nextEnergyBurstTime = currentTime + 4000 + Math.floor(random() * 8000);
      }

      // 5. Update time-based effects that would have used timeouts
      updatePendingEffects(currentTime);
    }

    // Process all pending effects based on their scheduled times
    function updatePendingEffects(currentTime) {
      if (pendingEffects.length === 0) return;

      // Process each effect
      const effectsToRemove = [];

      for (let i = 0; i < pendingEffects.length; i++) {
        const effect = pendingEffects[i];

        // Regular single element effects
        if (effect.element) {
          // Skip if element is already gone
          if (!effect.element.parentNode) {
            effectsToRemove.push(i);
            continue;
          }

          // Check if it's time to fade out
          if (!effect.hasFaded && currentTime >= effect.fadeTime) {
            if (effect.fadeAction) {
              // Use custom fade action if provided
              effect.fadeAction();
            } else {
              // Default fade out
              effect.element.style.opacity = '0';
            }
            effect.hasFaded = true;
          }

          // Check if it's time to remove
          if (currentTime >= effect.removeTime) {
            if (effect.element.parentNode) {
              effect.element.parentNode.removeChild(effect.element);
              // Also remove from allEnergyBursts if present
              const elIndex = allEnergyBursts.indexOf(effect.element);
              if (elIndex > -1) allEnergyBursts.splice(elIndex, 1);
            }
            effectsToRemove.push(i);
          }
        }
        // Multi-element cleanup effects
        else if (effect.elements) {
          // Check if it's time to remove all elements
          if (currentTime >= effect.removeTime) {
            effect.elements.forEach(el => {
              if (el && el.parentNode) {
                el.parentNode.removeChild(el);
                // Also remove from global tracking arrays if needed
                const elIndex = allEnergyBursts.indexOf(el);
                if (elIndex > -1) allEnergyBursts.splice(elIndex, 1);
              }
            });

            // Call onRemove handler if provided
            if (effect.onRemove) {
              effect.onRemove();
            }

            effectsToRemove.push(i);
          }
        }
      }

      // Remove processed effects (in reverse order to avoid index issues)
      if (effectsToRemove.length > 0) {
        for (let i = effectsToRemove.length - 1; i >= 0; i--) {
          pendingEffects.splice(effectsToRemove[i], 1);
        }
      }
    }

    // Update all comets and their particles
    function updateComets() {
      const currentTime = performance.now();
      const cometsToRemove = [];

      activeComets.forEach(comet => {
        const elapsed = currentTime - comet.startTime;
        const progress = Math.min(elapsed / comet.duration, 1);

        // Update position
        comet.currentX = comet.startX + (comet.endX - comet.startX) * progress;
        comet.currentY = comet.startY + (comet.endY - comet.startY) * progress;

        // Check if it's time to spawn a particle
        const timeSinceLastParticle = currentTime - comet.lastParticleSpawnTime;
        const effectiveParticlesPerSecond = particlesPerSecond * (0.5 + comet.sizeFactor * 0.5);
        const particlesToSpawn = Math.floor(timeSinceLastParticle / (1000 / effectiveParticlesPerSecond));

        if (particlesToSpawn > 0) {
          for (let i = 0; i < particlesToSpawn; i++) {
            createCometParticle(comet, elapsed, i, particlesToSpawn, currentTime);
          }
          comet.lastParticleSpawnTime = currentTime;
        }

        // Check if comet is finished
        if (progress >= 1) {
          cometsToRemove.push(comet.id);
        }
      });

      // Remove finished comets
      if (cometsToRemove.length > 0) {
        for (const id of cometsToRemove) {
          const cometIndex = activeComets.findIndex(c => c.id === id);
          if (cometIndex >= 0) {
            const comet = activeComets[cometIndex];
        if (comet.element && comet.element.parentNode) {
          comet.element.parentNode.removeChild(comet.element);
        }
            activeComets.splice(cometIndex, 1);
          }
        }
      }

      // Clean up particles (just maintain the reference array - DOM elements removed by their own timeouts)
      cometParticles = cometParticles.filter(p => p.element && p.element.parentNode);
    }

    // Create a single comet particle
    function createCometParticle(comet, elapsed, particleIndex, totalParticles, currentTime) {
      const spawnProgress = Math.min((elapsed - (totalParticles - 1 - particleIndex) * (1000 / (particlesPerSecond * (0.5 + comet.sizeFactor * 0.5)))) / comet.duration, 1);
      if (spawnProgress < 0) return;

      const particleX = comet.startX + (comet.endX - comet.startX) * spawnProgress;
      const particleY = comet.startY + (comet.endY - comet.startY) * spawnProgress;

      const maxOffset = 0.1 + spawnProgress * 0.4;
      const perpendicularAngle = comet.angle + Math.PI / 2;
      const randomOffsetMagnitude = (Math.random() - 0.5) * maxOffset;
      const offsetX = Math.cos(perpendicularAngle) * randomOffsetMagnitude;
      const offsetY = Math.sin(perpendicularAngle) * randomOffsetMagnitude;

      const particle = document.createElement('div');
      particle.className = 'comet-tail-particle';

      const baseParticleSize = 0.5 + Math.random() * 1.0;
      const particleSize = Math.max(0.3, baseParticleSize * comet.sizeFactor);
      particle.style.width = `${particleSize}px`;
      particle.style.height = `${particleSize}px`;

      particle.style.left = `${particleX + offsetX}%`;
      particle.style.top = `${particleY + offsetY}%`;

      const initialOpacity = 0.3 + Math.random() * 0.5;
      particle.style.opacity = initialOpacity.toFixed(2);

      starField.appendChild(particle);

      const lifetimeMultiplier = 1 - spawnProgress;
      const dynamicLifetime = Math.max(200, tailParticleLife * lifetimeMultiplier * (0.8 + comet.sizeFactor * 0.2));

      // Instead of using timeouts, create an effect object with scheduled times
      const particleEffect = {
        element: particle,
        creationTime: currentTime,
        fadeTime: currentTime + dynamicLifetime,
        removeTime: currentTime + dynamicLifetime + 500,
        spawnProgress: spawnProgress,
        hasFaded: false
      };

      // Add to tracked particles and effects list
      cometParticles.push(particleEffect);
      pendingEffects.push(particleEffect);
    }

    // Update all energy bursts
    function updateEnergyBursts() {
      const currentTime = performance.now();
      const burstsToRemove = [];

      activeEnergyBursts.forEach(burst => {
        const elapsed = currentTime - burst.startTime;
        const progress = Math.min(elapsed / burst.duration, 1);

        // Update dot position with easing
        const easeOutQuad = 1 - (1 - progress) * (1 - progress);
        burst.currentX = burst.startX + (burst.endX - burst.startX) * easeOutQuad;
        burst.currentY = burst.startY + (burst.endY - burst.startY) * easeOutQuad;

        // Check if the burst is finished
        if (progress >= 1) {
          burstsToRemove.push(burst);

          // Create end flash effect
          const flash = document.createElement('div');
          flash.style.cssText = `position: absolute; left: ${burst.endX}%; top: ${burst.endY}%; width: 8px; height: 8px; background-color: rgba(255, 255, 255, 0.9); border-radius: 50%; transform: translate(-50%, -50%); box-shadow: 0 0 10px 5px rgba(100, 200, 255, 0.8); opacity: 1; transition: all 0.3s ease-out; z-index: 12;`;
          starField.appendChild(flash);
          allEnergyBursts.push(flash);

          // Add to pending effects instead of using setTimeout
          pendingEffects.push({
            element: flash,
            creationTime: currentTime,
            fadeTime: currentTime + 50,
            removeTime: currentTime + 400,
            hasFaded: false,
            fadeAction: () => {
              flash.style.opacity = '0';
              flash.style.width = '12px';
              flash.style.height = '12px';
              flash.style.boxShadow = '0 0 15px 8px rgba(100, 200, 255, 0)';
            }
          });

          // Fade out path and labels
          burst.pathLine.style.opacity = '0';
          burst.sourceLabel.style.opacity = '0';
          burst.destLabel.style.opacity = '0';

          // Add cleanup actions to pending effects instead of using setTimeout
          const elementsToCleanup = [burst.energyDot, burst.pathLine, burst.sourceLabel, burst.destLabel];
          pendingEffects.push({
            elements: elementsToCleanup,
            creationTime: currentTime,
            fadeTime: currentTime, // No fade needed, already faded
            removeTime: currentTime + 350,
            hasFaded: true,
            onRemove: () => {
              // When this effect is processed, decrease the active burst count
              activeEnergyBurstsCount--;

              // Add a minimum cooldown before another burst can start
              const currentNextBurstTime = nextEnergyBurstTime;
              const minimumNextTime = currentTime + 3000; // At least 3 seconds after a burst ends
              if (currentNextBurstTime < minimumNextTime) {
                nextEnergyBurstTime = minimumNextTime;
              }

              // Update travel indicator UI
              if (burst.travelSlot) {
                burst.travelSlot.classList.remove('active');
                burst.travelSlot.style.display = 'none';
                const travelIndicator = document.getElementById('travel-indicator');
                const anyActiveSlots = travelIndicator?.querySelector('.travel-slot.active');
                if (!anyActiveSlots && travelIndicator) {
                  travelIndicator.classList.remove('visible');
                  travelIndicator.dataset.visible = 'false';
                }
              }
            }
          });
        }
      });

      // Remove finished bursts
      for (const burst of burstsToRemove) {
        const index = activeEnergyBursts.indexOf(burst);
        if (index >= 0) {
          activeEnergyBursts.splice(index, 1);
        }
      }
    }

    // Render the current game state
    function renderGameState() {
      // Update DOM elements based on current state
      // 1. Render comets
      activeComets.forEach(comet => {
        comet.element.style.left = `${comet.currentX}%`;
        comet.element.style.top = `${comet.currentY}%`;
      });

      // 2. Render energy bursts
      activeEnergyBursts.forEach(burst => {
        burst.energyDot.style.left = `${burst.currentX}%`;
        burst.energyDot.style.top = `${burst.currentY}%`;
      });
    }

    // Try to create an energy burst between two random stars
    function tryCreateEnergyBurst() {
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      if (allStars.length >= 10 && activeEnergyBurstsCount < maxParallelBursts) {
        const safeMargin = 8;
        const visibleStars = allStars.filter(star =>
          star.x >= safeMargin && star.x <= (100 - safeMargin) &&
          star.y >= safeMargin && star.y <= (100 - safeMargin)
        );

        if (visibleStars.length >= 2) {
          const startIndex = Math.floor(random() * visibleStars.length);
          const startStar = visibleStars[startIndex];
          const startStarClassName = startStar.element.className;
          const potentialEndStars = visibleStars.filter(star =>
            star.id !== startStar.id && star.element.className === startStarClassName
          );

          if (potentialEndStars.length > 0) {
            const endIndex = Math.floor(random() * potentialEndStars.length);
            const endStar = potentialEndStars[endIndex];
            createEnergyBurst(startStar, endStar, viewportWidth, viewportHeight);
            return true;
          }
        }
      }
      return false;
    }

    // createStar uses seeded random
    function createStar(x, y, isBig) {
      const star = document.createElement('div');
      const starId = `star-${random().toString(36).substring(2, 9)}`;
      star.id = starId;
      const stargateName = generateStargateName();
      const offsetX = (random() * 0.8 - 0.4);
      const offsetY = (random() * 0.8 - 0.4);
      star.style.left = `${x + offsetX}%`;
      star.style.top = `${y + offsetY}%`;
      const sizeRandom = random();

      if (isBig && sizeRandom > 0.9) star.className = 'star star-xlarge';
      else if (isBig && sizeRandom > 0.7) star.className = 'star star-large';
      else if (isBig || sizeRandom > 0.85) star.className = 'star star-medium';
      else if (sizeRandom > 0.6) star.className = 'star star-small';
      else if (sizeRandom > 0.3) star.className = 'star';
      else star.className = 'star star-tiny';

      let baseBrightness;
      if (star.className.includes('star-xlarge')) baseBrightness = 0.9;
      else if (star.className.includes('star-large')) baseBrightness = 0.8;
      else if (star.className.includes('star-medium')) baseBrightness = 0.7;
      else if (star.className.includes('star-small')) baseBrightness = 0.6;
      else if (star.className.includes('star-tiny')) baseBrightness = 0.4;
      else baseBrightness = 0.5;

      const randomBrightness = random() * 0.3;
      const finalOpacity = (baseBrightness + randomBrightness).toFixed(2);

      // --- Apply Blinking Randomly (now seeded) ---
      const blinkChance = 0.15; // 15% chance to blink
      if (random() < blinkChance) { // Use SEEDED random() for blinking decision
          star.classList.add('blinking-star');
          // Set the base opacity for the animation via CSS variable
          star.style.setProperty('--star-base-opacity', finalOpacity);
          // Set random delay so blinks aren't synchronized
          const delay = random() * 7; // Use SEEDED random() for delay (up to animation duration 7s)
          star.style.animationDelay = `-${delay.toFixed(2)}s`;
      } else {
          // If not blinking, just set the static opacity
          star.style.opacity = finalOpacity;
      }
      // --- End Apply Blinking ---

      if (random() > 0.7) {
        const hue = Math.floor(random() * 60);
        star.style.backgroundColor = `hsl(${hue}, 100%, ${90 + Math.floor(random() * 10)}%)`;
      }

      return {
        element: star, id: starId, x: x + offsetX, y: y + offsetY, name: stargateName
      };
    }

    // generateStargateName uses seeded random
    function generateStargateName() {
      const prefix = random() > 0.7 ? 'M' : 'P';
      const firstDigit = Math.floor(random() * 9) + 1;
      const middleLetter = String.fromCharCode(65 + Math.floor(random() * 26));
      const secondDigit = Math.floor(random() * 9);
      const suffix = Math.floor(random() * 900) + 100;
      return `${prefix}${firstDigit}${middleLetter}${secondDigit}-${suffix}`;
    }

    // generateConstellationName uses seeded random
    function generateConstellationName() {
      const greekLetters = ['Alpha', 'Beta', 'Gamma', 'Delta', 'Epsilon', 'Zeta', 'Eta', 'Theta', 'Iota', 'Kappa', 'Lambda', 'Mu', 'Nu', 'Xi', 'Omicron', 'Pi', 'Rho', 'Sigma', 'Tau', 'Upsilon', 'Phi', 'Chi', 'Psi', 'Omega'];
      const latinGenitives = ['Lyrae', 'Cygni', 'Orionis', 'Majoris', 'Minoris', 'Andromedae', 'Aquilae', 'Aurigae', 'Bootis', 'Cancri', 'Centauri', 'Capricorni', 'Draconis', 'Geminorum', 'Herculis', 'Leonis', 'Pegasi', 'Persei', 'Piscium', 'Sagittarii', 'Scorpii', 'Tauri', 'Ursae', 'Virginis'];
      const letter = greekLetters[Math.floor(random() * greekLetters.length)];
      const genitive = latinGenitives[Math.floor(random() * latinGenitives.length)];
      return `${letter} ${genitive}`;
    }

    // Calculate entropy using seeded random
    function calculateEntropy(fromStar, toStar, existingPath, existingLines) {
      const dx = toStar.x - fromStar.x;
      const dy = toStar.y - fromStar.y;
      const distance = Math.sqrt(dx*dx + dy*dy);
      let entropy = distance;

      // --- Intersection Penalty ---
      const intersectionPenalty = 1000; // High penalty for crossing lines
      const p1 = { x: fromStar.x, y: fromStar.y };
      const q1 = { x: toStar.x, y: toStar.y };
      for (const existingLine of existingLines) {
          const p2 = { x: existingLine.x1, y: existingLine.y1 };
          const q2 = { x: existingLine.x2, y: existingLine.y2 };
          if (lineSegmentsIntersect(p1, q1, p2, q2)) {
              entropy += intersectionPenalty;
              break; // One intersection is enough to penalize heavily
          }
      }
      // --- End Intersection Penalty ---

      const minPreferredDistance = 3.5;
      const shortDistancePenaltyFactor = 10;
      if (distance < minPreferredDistance) {
        entropy += Math.pow(minPreferredDistance - distance, 2) * shortDistancePenaltyFactor;
      }

      let proximityBonus = 0;
      for (const star of existingPath) {
        if (star.id === fromStar.id) continue;
        const dxOther = toStar.x - star.x;
        const dyOther = toStar.y - star.y;
        const distOther = Math.sqrt(dxOther*dxOther + dyOther*dyOther);
        if (distOther < maxConnectionDistance * 1.5) {
          proximityBonus += (maxConnectionDistance * 1.5 - distOther) / 2;
        }
      }
      entropy -= proximityBonus;

      const nearMissThreshold = 2.5;
      const nearMissPenaltyFactor = 8;
      for (const line of existingLines) {
        if ((line.x1 === fromStar.x && line.y1 === fromStar.y) || (line.x2 === fromStar.x && line.y2 === fromStar.y)) continue;
        const nearMiss = linePointDistance(line.x1, line.y1, line.x2, line.y2, toStar.x, toStar.y);
        if (nearMiss < nearMissThreshold) {
          entropy += Math.pow(nearMissThreshold - nearMiss, 2) * nearMissPenaltyFactor;
        }
      }

      entropy += random() * 2; // Use seeded random for randomness adjustment

      return entropy;
    }

    // linePointDistance remains the same (no randomness)
    function linePointDistance(x1, y1, x2, y2, px, py) {
      const lengthSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);
      if (lengthSq === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));
      const t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lengthSq));
      const projX = x1 + t * (x2 - x1);
      const projY = y1 + t * (y2 - y1);
      return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
    }

    // --- Geometry Helpers for Line Intersection ---
    // Helper to find orientation of ordered triplet (p, q, r).
    // Returns 0 --> p, q and r are collinear
    // Returns 1 --> Clockwise
    // Returns 2 --> Counterclockwise
    function orientation(p, q, r) {
        const val = (q.y - p.y) * (r.x - q.x) - (q.x - p.x) * (r.y - q.y);
        if (Math.abs(val) < 0.00001) return 0; // Collinear (using epsilon)
        return (val > 0) ? 1 : 2; // Clockwise or Counterclockwise
    }

    // Given three collinear points p, q, r, the function checks if
    // point q lies on line segment 'pr'
    function onSegment(p, q, r) {
        return (q.x <= Math.max(p.x, r.x) && q.x >= Math.min(p.x, r.x) &&
                q.y <= Math.max(p.y, r.y) && q.y >= Math.min(p.y, r.y));
    }

    // Main function to check if line segment 'p1q1' and 'p2q2' intersect.
    function lineSegmentsIntersect(p1, q1, p2, q2) {
        // Exclude checks where segments share an endpoint immediately
        if ((p1.x === p2.x && p1.y === p2.y) || (p1.x === q2.x && p1.y === q2.y) ||
            (q1.x === p2.x && q1.y === p2.y) || (q1.x === q2.x && q1.y === q2.y)) {
            return false;
        }

        // Find the four orientations needed for general and special cases
        const o1 = orientation(p1, q1, p2);
        const o2 = orientation(p1, q1, q2);
        const o3 = orientation(p2, q2, p1);
        const o4 = orientation(p2, q2, q1);

        // General case
        if (o1 !== 0 && o2 !== 0 && o3 !== 0 && o4 !== 0) { // Ensure none are collinear first for general case
             if (o1 !== o2 && o3 !== o4) {
                return true;
             }
        }

        // Special Cases for collinearity
        // p1, q1 and p2 are collinear and p2 lies on segment p1q1
        if (o1 === 0 && onSegment(p1, p2, q1)) return true;
        // p1, q1 and q2 are collinear and q2 lies on segment p1q1
        if (o2 === 0 && onSegment(p1, q2, q1)) return true;
        // p2, q2 and p1 are collinear and p1 lies on segment p2q2
        if (o3 === 0 && onSegment(p2, p1, q2)) return true;
        // p2, q2 and q1 are collinear and q1 lies on segment p2q2
        if (o4 === 0 && onSegment(p2, q1, q2)) return true;

        return false; // Doesn't intersect
    }
    // --- End Geometry Helpers ---

    // findNearbyStars remains the same (no randomness)
    function findNearbyStars(grid, centerX, centerY, maxDistance) {
      const results = [];
      const gridRows = grid.length;
      const gridCols = grid[0].length;
      for (let dy = -maxDistance; dy <= maxDistance; dy++) {
        for (let dx = -maxDistance; dx <= maxDistance; dx++) {
          const x = centerX + dx;
          const y = centerY + dy;
          if (x < 0 || x >= gridCols || y < 0 || y >= gridRows || !grid[y][x]) continue;
          const distSquared = dx*dx + dy*dy;
          if (distSquared > maxDistance*maxDistance) continue;
          results.push(grid[y][x]);
        }
      }
      return results;
    }

    // findValidStartingCell uses seeded random
    function findValidStartingCell(grid) {
      const gridRows = grid.length;
      const gridCols = grid[0].length;
      const sectionsX = 3, sectionsY = 3;
      const sectionWidth = gridCols / sectionsX;
      const sectionHeight = gridRows / sectionsY;
      let sectionX, sectionY, attempts = 0;

      do {
        if (usedSections.size >= sectionsX * sectionsY || attempts > 20) {
          usedSections.clear(); // Reset if full or stuck
        }
        sectionX = Math.floor(random() * sectionsX);
        sectionY = Math.floor(random() * sectionsY);
        attempts++;
      } while (usedSections.has(`${sectionX},${sectionY}`) && attempts < 20);

      usedSections.add(`${sectionX},${sectionY}`);

      const minX = Math.floor(sectionX * sectionWidth);
      const maxX = Math.floor((sectionX + 1) * sectionWidth);
      const minY = Math.floor(sectionY * sectionHeight);
      const maxY = Math.floor((sectionY + 1) * sectionHeight);

      for (let attempt = 0; attempt < 100; attempt++) {
        const y = minY + Math.floor(random() * (maxY - minY));
        const x = minX + Math.floor(random() * (maxX - minX));
        if (y < 0 || y >= gridRows || x < 0 || x >= gridCols) continue; // Bounds check

        const cellXPercent = (x / gridCols) * 100;
        const cellYPercent = (y / gridRows) * 100;

        // --- Check Border Margin ---
        if (cellXPercent < constellationBorderMargin || cellXPercent > (100 - constellationBorderMargin) ||
            cellYPercent < constellationBorderMargin || cellYPercent > (100 - constellationBorderMargin))
        {
            continue; // Too close to border
        }
        // --- End Border Check ---

        if (grid[y] && grid[y][x] && !constellationStars.has(grid[y][x].id)) {
          let isValid = true;
          // const cellX = (x / gridCols) * 100; // Already calculated
          // const cellY = (y / gridRows) * 100;
          for (const area of usedAreas) {
            // Check overlap with existing constellation areas (existing check)
            if (!(cellXPercent + 5 < area.minX || cellXPercent - 5 > area.maxX || cellYPercent + 5 < area.minY || cellYPercent - 5 > area.maxY)) {
              isValid = false; break;
            }
          }
          if (isValid) return { x, y, star: grid[y][x] };
        }
      }

      // Fallback using seeded random
      for (let attempt = 0; attempt < 100; attempt++) {
        const y = Math.floor(random() * gridRows);
        const x = Math.floor(random() * gridCols);

        const cellXPercent = (x / gridCols) * 100;
        const cellYPercent = (y / gridRows) * 100;

        // --- Check Border Margin (Fallback) ---
        if (cellXPercent < constellationBorderMargin || cellXPercent > (100 - constellationBorderMargin) ||
            cellYPercent < constellationBorderMargin || cellYPercent > (100 - constellationBorderMargin))
        {
            continue; // Too close to border
        }
        // --- End Border Check ---

        if (grid[y] && grid[y][x] && !constellationStars.has(grid[y][x].id)) {
          let isValid = true;
          // const cellX = (x / gridCols) * 100; // Already calculated
          // const cellY = (y / gridRows) * 100;
          for (const area of usedAreas) {
             if (!(cellXPercent + 5 < area.minX || cellXPercent - 5 > area.maxX || cellYPercent + 5 < area.minY || cellYPercent - 5 > area.maxY)) {
              isValid = false; break;
            }
          }
          if (isValid) return { x, y, star: grid[y][x] };
        }
      }

      // Last resort (unlikely with seeded RNG but keep as fallback)
      if (usedAreas.length < 3) {
        for (let y = 0; y < gridRows; y++) {
          for (let x = 0; x < gridCols; x++) {
            if (grid[y][x] && !constellationStars.has(grid[y][x].id)) {
              return { x, y, star: grid[y][x] };
            }
          }
        }
      }
      return null;
    }

    // createConnectingLine remains the same (no randomness)
    function createConnectingLine(star1, star2, container, viewportWidth, viewportHeight) {
      const line = document.createElement('div');
      const star1XPx = (star1.x / 100) * viewportWidth;
      const star1YPx = (star1.y / 100) * viewportHeight;
      const star2XPx = (star2.x / 100) * viewportWidth;
      const star2YPx = (star2.y / 100) * viewportHeight;
      const dxPx = star2XPx - star1XPx;
      const dyPx = star2YPx - star1YPx;
      const distancePx = Math.sqrt(dxPx * dxPx + dyPx * dyPx);
      const angle = Math.atan2(dyPx, dxPx) * 180 / Math.PI;
      const distancePercent = (distancePx / viewportWidth) * 100;
      line.className = 'constellation-line';
      line.style.position = 'absolute';
      line.style.left = `${star1.x}%`;
      line.style.top = `${star1.y}%`;
      line.style.width = `${distancePercent}%`;
      line.style.height = '0.8px';
      line.style.backgroundColor = 'rgba(255, 255, 255, 0.25)';
      line.style.boxShadow = '0 0 3px rgba(255, 255, 255, 0.1)';
      line.style.transformOrigin = '0 0';
      line.style.transform = `rotate(${angle}deg)`;
      line.style.zIndex = '5';
      container.appendChild(line);
      return line;
    }

    // getGroupBounds remains the same (no randomness)
    function getGroupBounds(stars) {
      let minX = 100, minY = 100, maxX = 0, maxY = 0;
      stars.forEach(star => {
        minX = Math.min(minX, star.x);
        minY = Math.min(minY, star.y);
        maxX = Math.max(maxX, star.x);
        maxY = Math.max(maxY, star.y);
      });
      return { minX, minY, maxX, maxY };
    }

    // Main function to generate the starfield
    function generateStarfield() {
      // Get current viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Create a document fragment for better performance
      const fragment = document.createDocumentFragment();

      // Reset all stars array
      allStars = [];

      // Calculate grid dimensions based on current viewport
      const gridRows = Math.ceil(viewportHeight / gridCellSize);
      const gridCols = Math.ceil(viewportWidth / gridCellSize);

      // Create grid representation
      const grid = new Array(gridRows);
      for (let y = 0; y < gridRows; y++) {
        grid[y] = new Array(gridCols).fill(null);
      }

      // Track all stars by ID for easier lookup
      const starsById = {};

      // First, ensure grid has enough stars placed for constellations, but with more randomness
      let gridStarsPlaced = 0;
      const desiredGridStars = Math.floor(gridRows * gridCols * gridDensityFactor);

      // Place stars directly on grid with some variation
      while (gridStarsPlaced < desiredGridStars) {
        // Choose a random grid cell using seeded random
        const gridY = Math.floor(random() * gridRows);
        const gridX = Math.floor(random() * gridCols);

        // Skip if cell already has a star
        if (grid[gridY][gridX]) continue;

        // Add more randomness to grid positioning using seeded random
        const randomOffset = 0.6; // Larger offset for more scattered look
        const xPercent = ((gridX + random() * randomOffset - randomOffset/2) / gridCols) * 100;
        const yPercent = ((gridY + random() * randomOffset - randomOffset/2) / gridRows) * 100;

        // Constrain to viewport
        const safeXPercent = Math.max(0.5, Math.min(99.5, xPercent));
        const safeYPercent = Math.max(0.5, Math.min(99.5, yPercent));

        // Always make these stars bigger (potential constellation candidates)
        const star = createStar(safeXPercent, safeYPercent, true);

        // Store grid coordinates
        star.gridX = gridX;
        star.gridY = gridY;

        // Add to lookup and grid
        starsById[star.id] = star;
        grid[gridY][gridX] = star;

        // Add to all stars array for random selection
        allStars.push(star);

        // Track the element for cleanup
        allStarElements.push(star.element);

        // Add to fragment
        fragment.appendChild(star.element);
        gridStarsPlaced++;
      }

      // Create clusters of stars in some areas for a more realistic look
      const numClusters = Math.floor(random() * 10) + 5; // 5-15 clusters
      for (let c = 0; c < numClusters; c++) {
        const clusterX = random() * 100;
        const clusterY = random() * 100;
        const clusterSize = Math.floor(random() * 30) + 15; // 15-45 stars per cluster
        const clusterRadius = random() * 12 + 5; // 5-17% radius

        for (let i = 0; i < clusterSize; i++) {
          // Create stars in a Gaussian-like distribution around the cluster center using seeded random
          const angle = random() * Math.PI * 2;
          const distance = random() * clusterRadius * (random() + 0.5); // More stars toward center

          const starX = clusterX + Math.cos(angle) * distance;
          const starY = clusterY + Math.sin(angle) * distance;

          // Skip if outside viewport
          if (starX < 0 || starX > 100 || starY < 0 || starY > 100) continue;

          // These are smaller background stars (not for constellations)
          const star = createStar(starX, starY, false);

          // Map to nearest grid cell
          const gridX = Math.floor((starX / 100) * gridCols);
          const gridY = Math.floor((starY / 100) * gridRows);

          // Store grid coordinates
          if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
            star.gridX = gridX;
            star.gridY = gridY;
          }

          // Add to lookup
          starsById[star.id] = star;

          // Add to all stars array for random selection
          allStars.push(star);

          // Track the element for cleanup
          allStarElements.push(star.element);

          // Add to fragment
          fragment.appendChild(star.element);
        }
      }

      // Fill remaining space with randomly scattered stars
      const remainingStars = starCount - gridStarsPlaced - (numClusters * 30); // Approx calculation
      for (let i = 0; i < remainingStars; i++) {
        // Regular stars with random positioning using seeded random
        const xPercent = random() * 100;
        const yPercent = random() * 100;

        // These stars can be any size using seeded random
        const isBig = random() > 0.9; // Reduced probability of big stars
        const star = createStar(xPercent, yPercent, isBig);

        // Map to nearest grid cell
        const gridX = Math.floor((xPercent / 100) * gridCols);
        const gridY = Math.floor((yPercent / 100) * gridRows);

        // Store grid coordinates if in bounds
        if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
          star.gridX = gridX;
          star.gridY = gridY;

          // Only add to grid if it's a big star and the cell is empty
          if (isBig && !grid[gridY][gridX]) {
            grid[gridY][gridX] = star;
          }
        }

        // Add to lookup
        starsById[star.id] = star;

        // Add to all stars array for random selection
        allStars.push(star);

        // Track the element for cleanup
        allStarElements.push(star.element);

        // Add to fragment
        fragment.appendChild(star.element);
      }

      // Keep track of ALL line segments across ALL constellations
      const allLineSegments = [];

      // Wave function collapse implementation for constellations
      for (let c = 0; c < constellationCount; c++) {
        // Find a valid starting point on the grid using seeded random
        let startingCell = findValidStartingCell(grid);
        if (!startingCell) continue;

        // Create a group container for this constellation
        const constellationGroup = document.createElement('div');
        constellationGroup.className = 'constellation-group';

        // Track elements for cleanup
        allConstellationElements.push(constellationGroup);

        // Start with the first star
        const firstStar = startingCell.star;

        // Initialize the constellation path with the first star
        const constellationPath = [firstStar];
        constellationStars.add(firstStar.id);

        // Keep track of connections *within* this constellation
        const currentConstellationLines = [];

        // Track all possible directions for each star in the constellation
        const possibleConnections = new Map();

        // Initialize the wave function for the first star
        possibleConnections.set(firstStar.id, findNearbyStars(grid, firstStar.gridX, firstStar.gridY, maxConnectionDistance)
          .filter(star => !constellationStars.has(star.id))
          .map(star => ({ star: star, entropy: 0 }))
        );

        // Continue until we reach the desired size or have no more valid options
        while (constellationPath.length < maxStarsPerConstellation && possibleConnections.size > 0) {
          // Find star with lowest entropy (fewest valid connections) to collapse next
          let lowestEntropyStar = null;
          let lowestEntropy = Infinity;
          let lowestEntropyConnections = [];

          // For each star in our constellation that has possible connections
          for (const [starId, potentialConnections] of possibleConnections.entries()) {
            if (potentialConnections.length === 0) {
              possibleConnections.delete(starId);
              continue;
            }

            const currentStar = starsById[starId];
            const validConnectionsForStar = [];

            // Calculate entropy for all potential connections
            for (const connection of potentialConnections) {
              const nextStar = connection.star;

              // --- Check Border Margin for nextStar ---
              const nextXPercent = nextStar.x;
              const nextYPercent = nextStar.y;
              if (nextXPercent < constellationBorderMargin || nextXPercent > (100 - constellationBorderMargin) ||
                  nextYPercent < constellationBorderMargin || nextYPercent > (100 - constellationBorderMargin))
              {
                  connection.entropy = Infinity; // Disqualify if too close to border
              } else {
                  // --- End Border Check ---
                  connection.entropy = calculateEntropy(
                    currentStar, nextStar, constellationPath,
                    [...allLineSegments, ...currentConstellationLines]
                  );

                  const isExtendingLastSegment = constellationPath.length > 0 && currentStar.id === constellationPath[constellationPath.length - 1].id;
                  if (isExtendingLastSegment) {
                    connection.entropy = Math.max(0, connection.entropy - 5.0); // Slightly prefer extending
                  }
              }
              validConnectionsForStar.push(connection);
            }

            const minEntropyConn = validConnectionsForStar.reduce(
              (min, conn) => conn.entropy < min.entropy ? conn : min,
              { entropy: Infinity }
            );

            if (minEntropyConn.entropy === Infinity) {
                possibleConnections.delete(starId);
                continue;
            }

            if (minEntropyConn.entropy < lowestEntropy) {
              lowestEntropy = minEntropyConn.entropy;
              lowestEntropyStar = currentStar; // 'B'
              lowestEntropyConnections = validConnectionsForStar;
            }
          }

          // If we found a valid lowest entropy star to connect from
          if (lowestEntropyStar && lowestEntropyConnections.length > 0) {
            lowestEntropyConnections.sort((a, b) => a.entropy - b.entropy);

            let connectionMade = false;
            for (const connection of lowestEntropyConnections) {
                const nextStar = connection.star;
                const potentialLine = { x1: lowestEntropyStar.x, y1: lowestEntropyStar.y, x2: nextStar.x, y2: nextStar.y };
                let wouldIntersect = false;
                const minStarClearance = 1.5;

                // --- Final Intersection Check ---
                const p1 = { x: potentialLine.x1, y: potentialLine.y1 };
                const q1 = { x: potentialLine.x2, y: potentialLine.y2 };
                for (const existingLine of currentConstellationLines) {
                    const p2 = { x: existingLine.x1, y: existingLine.y1 };
                    const q2 = { x: existingLine.x2, y: existingLine.y2 };
                    if (lineSegmentsIntersect(p1, q1, p2, q2)) {
                        wouldIntersect = true;
                        break;
                    }
                }
                if (wouldIntersect) continue; // Try the next best connection if this one intersects
                // --- End Final Intersection Check ---

                // Check for near-miss with other stars (existing check)
                for (const starId of constellationStars) {
                    if (starId === lowestEntropyStar.id || starId === nextStar.id) continue;
                    const otherStar = starsById[starId];
                    if (!otherStar) continue;
                    const distToStar = linePointDistance(potentialLine.x1, potentialLine.y1, potentialLine.x2, potentialLine.y2, otherStar.x, otherStar.y);
                    if (distToStar < minStarClearance) {
                        wouldIntersect = true;
                        break;
                    }
                }

                if (!wouldIntersect) {
                  constellationPath.push(nextStar);
                  constellationStars.add(nextStar.id);
                  currentConstellationLines.push(potentialLine);
                  const newConnections = findNearbyStars(grid, nextStar.gridX, nextStar.gridY, maxConnectionDistance)
                    .filter(star => {
                        if (constellationStars.has(star.id)) return false;
                        // --- Check Border Margin for newly found connections ---
                        const starXPercent = star.x;
                        const starYPercent = star.y;
                        if (starXPercent < constellationBorderMargin || starXPercent > (100 - constellationBorderMargin) ||
                            starYPercent < constellationBorderMargin || starYPercent > (100 - constellationBorderMargin))
                        {
                            return false; // Filter out stars too close to border
                        }
                        // --- End Border Check ---
                        return true;
                    })
                    .map(star => ({ star: star, entropy: 0 }));
                  possibleConnections.set(nextStar.id, newConnections);
                  for (const [id, starConnections] of possibleConnections.entries()) {
                    if (id !== nextStar.id) {
                      possibleConnections.set(id, starConnections.filter(conn => conn.star.id !== nextStar.id));
                    }
                  }
                  connectionMade = true;
                  break;
                }
            }
            if (!connectionMade) {
                 possibleConnections.delete(lowestEntropyStar.id);
            }
          } else {
            break;
          }
        }

        // Only create constellation if we have enough stars
        if (constellationPath.length >= minStarsPerConstellation) {
          // Render connection lines
          for (const connectionLine of currentConstellationLines) {
            const lineElement = createConnectingLine(
              { x: connectionLine.x1, y: connectionLine.y1 },
              { x: connectionLine.x2, y: connectionLine.y2 },
              constellationGroup, viewportWidth, viewportHeight
            );
            if (lineElement) allConstellationElements.push(lineElement);
            allLineSegments.push(connectionLine);
          }

          // --- Calculate Centroid for Label ---
          let totalX = 0, totalY = 0;
          constellationPath.forEach(star => {
            totalX += star.x;
            totalY += star.y;
          });
          const centroidX = totalX / constellationPath.length;
          const centroidY = totalY / constellationPath.length;
          // --- End Centroid Calculation ---

          // --- Place Label ---
          const constellationName = generateConstellationName();
          const label = document.createElement('div');
          label.className = 'constellation-label';
          label.textContent = constellationName;
          // Position at centroid, ensuring it stays within reasonable bounds
          label.style.left = `${Math.max(5, Math.min(95, centroidX))}%`; // Keep slightly away from absolute edge
          label.style.top = `${Math.max(5, Math.min(95, centroidY))}%`;
          allConstellationElements.push(label);
          starField.appendChild(label);
          placedLabelCenters.push({ x: centroidX, y: centroidY }); // Still track position for potential future use
          // --- End Label Placement Logic ---

          usedAreas.push(getGroupBounds(constellationPath)); // Still use bounds for area tracking
          fragment.appendChild(constellationGroup);
        }
      }

      // Add all elements to the DOM at once
      starField.appendChild(fragment);

      // Event Delegation setup (remains the same)
      document.addEventListener('DOMContentLoaded', function() {
        console.log('Starfield DOM loaded, setting up event handlers');
        setupStarHoverEvents();
      });
      function setupStarHoverEvents() {
        starField.addEventListener('mouseover', handleStarMouseOver, true);
        starField.addEventListener('mouseout', handleStarMouseOut, true);
        console.log('Star hover events attached to starfield');
      }
      function handleStarMouseOver(event) {
        if (event.target.classList.contains('star')) {
          const starElement = event.target;
          const starId = starElement.id;
          console.log("Star hover detected:", starId);
          for (const star of allStars) {
            if (star.id === starId && star.name) {
              starHoverLabel.textContent = star.name;
              starHoverLabel.style.left = starElement.style.left;
              starHoverLabel.style.top = starElement.style.top;
              starHoverLabel.style.opacity = '1';
              break;
            }
          }
        }
      }
      function handleStarMouseOut(event) {
        if (event.target.classList.contains('star')) {
          setTimeout(() => { starHoverLabel.style.opacity = '0'; }, 50);
        }
      }

      // Initialize times for the first spawn events
      const currentTime = performance.now();
      nextCometSpawnTime = currentTime + 1000 + Math.random() * 2000;
      nextEnergyBurstTime = currentTime + 2000 + Math.floor(random() * 5000);

      // Start the unified game loop
      startGameLoop();
    }

    // Create and animate a comet - Modified for the new game loop
    function createComet() {
      const maxSpawnAttempts = 10;
      const minSeparationDistance = 20; // Minimum % distance from other comets
      let foundSeparatedPath = false;

      let startXPercent, startYPercent, endXPercent, endYPercent, angle, distance, normalizedDx, normalizedDy, durationMs, cometSizeClass, particleSizeFactor;

      for (let attempt = 0; attempt < maxSpawnAttempts; attempt++) {
          // --- Generate Potential Path & Size ---
          const sizeRoll = Math.random();
          cometSizeClass = 'comet-medium'; // Default (current size)
          particleSizeFactor = 1.0;
          if (sizeRoll < 0.4) { cometSizeClass = 'comet-small'; particleSizeFactor = 0.6; }
          else if (sizeRoll < 0.7) { cometSizeClass = 'comet-tiny'; particleSizeFactor = 0.3; }

          const startSide = Math.floor(Math.random() * 4);
          const endSide = (startSide + 1 + Math.floor(Math.random() * 2)) % 4;
          const margin = 5;

          switch (startSide) {
            case 0: startXPercent = Math.random() * 100; startYPercent = -margin; break;
            case 1: startXPercent = 100 + margin; startYPercent = Math.random() * 100; break;
            case 2: startXPercent = Math.random() * 100; startYPercent = 100 + margin; break;
            case 3: startXPercent = -margin; startYPercent = Math.random() * 100; break;
          }
          switch (endSide) {
            case 0: endXPercent = Math.random() * 100; endYPercent = -margin; break;
            case 1: endXPercent = 100 + margin; endYPercent = Math.random() * 100; break;
            case 2: endXPercent = Math.random() * 100; endYPercent = 100 + margin; break;
            case 3: endXPercent = -margin; endYPercent = Math.random() * 100; break;
          }

          // --- Check Separation ---
          let isTooClose = false;
          const currentTimeForCheck = performance.now(); // Use consistent time for checking all active comets

          for (const existingComet of activeComets) {
              // Calculate current position of the existing comet
              const elapsed = currentTimeForCheck - existingComet.startTime;
              const progress = Math.min(elapsed / existingComet.duration, 1);
              const existingX = existingComet.startX + (existingComet.endX - existingComet.startX) * progress;
              const existingY = existingComet.startY + (existingComet.endY - existingComet.startY) * progress;

              // Calculate distance between new start and existing current position
              const dx = startXPercent - existingX;
              const dy = startYPercent - existingY;
              const distSq = dx * dx + dy * dy; // Use squared distance to avoid sqrt

              if (distSq < minSeparationDistance * minSeparationDistance) {
                  isTooClose = true;
                  break; // No need to check other comets
              }
          }

          if (!isTooClose) {
              foundSeparatedPath = true;
              // Calculate final path details now that we've accepted it
              const dxFinal = endXPercent - startXPercent;
              const dyFinal = endYPercent - startYPercent;
              distance = Math.sqrt(dxFinal * dxFinal + dyFinal * dyFinal);
              angle = Math.atan2(dyFinal, dxFinal);
              normalizedDx = dxFinal / distance;
              normalizedDy = dyFinal / distance;
              durationMs = (distance / cometSpeed) * 10;
              break; // Exit the attempt loop
          }
      } // End spawn attempt loop

      // If no suitable path found after attempts, skip spawning this time
      if (!foundSeparatedPath) {
          return;
      }

      // --- Create Comet Element and Object (using the found path/size) ---
      const cometElement = document.createElement('div');
      cometElement.className = `comet ${cometSizeClass}`;
      cometElement.style.left = `${startXPercent}%`;
      cometElement.style.top = `${startYPercent}%`;
      starField.appendChild(cometElement);

      const newComet = {
        id: nextCometId++,
        element: cometElement,
        sizeFactor: particleSizeFactor,
        startX: startXPercent,
        startY: startYPercent,
        currentX: startXPercent, // Current position for rendering
        currentY: startYPercent,
        endX: endXPercent,
        endY: endYPercent,
        angle: angle, // Use calculated angle
        dx: normalizedDx, // Use calculated normalized vectors
        dy: normalizedDy,
        startTime: performance.now(),
        duration: durationMs, // Use calculated duration
        lastParticleSpawnTime: performance.now()
      };

      // Add to active comets
      activeComets.push(newComet);
      console.log(`Comet ${newComet.id} created (${cometSizeClass}). Active: ${activeComets.length}`);
    }

    // Create energy burst - Modified for the new game loop
    function createEnergyBurst(star1, star2, viewportWidth, viewportHeight) {
      activeEnergyBurstsCount++;
      const travelIndicator = document.getElementById('travel-indicator');
      const availableSlot = travelIndicator?.querySelector('.travel-slot:not(.active)');
      let currentSlot = null;
      const startX = star1.x, startY = star1.y, endX = star2.x, endY = star2.y;
      const star1XPx = (startX / 100) * viewportWidth, star1YPx = (startY / 100) * viewportHeight;
      const star2XPx = (endX / 100) * viewportWidth, star2YPx = (endY / 100) * viewportHeight;
      const dxPx = star2XPx - star1XPx, dyPx = star2YPx - star1YPx;
      const distancePx = Math.sqrt(dxPx * dxPx + dyPx * dyPx);
      const angle = Math.atan2(dyPx, dxPx) * 180 / Math.PI;
      const distancePercent = (distancePx / viewportWidth) * 100;

      const pathLine = document.createElement('div');
      pathLine.className = 'path-line';
      pathLine.style.position = 'absolute'; pathLine.style.left = `${startX}%`; pathLine.style.top = `${startY}%`;
      pathLine.style.width = `${distancePercent}%`; pathLine.style.transformOrigin = '0 0'; pathLine.style.transform = `rotate(${angle}deg)`;
      pathLine.style.animationDirection = 'normal';
      starField.appendChild(pathLine); allEnergyBursts.push(pathLine);

      const energyDot = document.createElement('div');
      energyDot.className = 'energy-dot'; starField.appendChild(energyDot); allEnergyBursts.push(energyDot);

      const sourceLabel = document.createElement('div');
      sourceLabel.style.cssText = `position: absolute; left: ${startX}%; top: ${startY}%; color: rgba(120, 210, 255, 0.85); font-size: 11px; font-family: monospace; text-shadow: 0 0 4px rgba(0, 100, 200, 0.9); transform: translate(-50%, -50%) translate(0, -15px); z-index: 12; pointer-events: none;`;
      sourceLabel.textContent = star1.name; starField.appendChild(sourceLabel); allEnergyBursts.push(sourceLabel);

      const destLabel = document.createElement('div');
      destLabel.style.cssText = `position: absolute; left: ${endX}%; top: ${endY}%; color: rgba(120, 210, 255, 0.85); font-size: 11px; font-family: monospace; text-shadow: 0 0 4px rgba(0, 100, 200, 0.9); transform: translate(-50%, -50%) translate(0, -15px); z-index: 12; pointer-events: none;`;
      destLabel.textContent = star2.name; starField.appendChild(destLabel); allEnergyBursts.push(destLabel);

      energyDot.style.left = `${startX}%`; energyDot.style.top = `${startY}%`;
      const baseSpeed = 6; const duration = Math.max(1000, (distancePercent / baseSpeed) * 1000);

      if (travelIndicator && availableSlot) {
        currentSlot = availableSlot; currentSlot.classList.add('active'); currentSlot.style.display = 'block';
        travelIndicator.classList.add('visible'); travelIndicator.dataset.visible = 'true';
        const travelStartName = currentSlot.querySelector('.travel-start-name');
        const travelEndName = currentSlot.querySelector('.travel-end-name');
        const travelDot = currentSlot.querySelector('.travel-indicator-dot');
        if (travelStartName && travelEndName && travelDot) {
           travelStartName.textContent = star1.name; travelEndName.textContent = star2.name;
           travelDot.style.animationDuration = `${duration}ms`;
           travelDot.classList.remove('travel-indicator-dot'); void travelDot.offsetWidth; travelDot.classList.add('travel-indicator-dot');
        }
      }

      // Create energy burst object for tracking in game loop
      const burst = {
        startX: startX,
        startY: startY,
        currentX: startX,
        currentY: startY,
        endX: endX,
        endY: endY,
        startTime: performance.now(),
        duration: duration,
        energyDot: energyDot,
        pathLine: pathLine,
        sourceLabel: sourceLabel,
        destLabel: destLabel,
        travelSlot: currentSlot
      };

      activeEnergyBursts.push(burst);
    }

    // Calculate entropy using seeded random
  })();
</script>
