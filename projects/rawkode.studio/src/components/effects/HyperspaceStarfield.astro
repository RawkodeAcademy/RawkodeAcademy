---
// Empty frontmatter for now
---

<style is:inline>
  /* Hyperspace wrapper */
  .hyperspace {
    position: fixed;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    background: #121212; /* Dark background for stars */
    overflow: hidden;
    z-index: 0;
  }

  /* Instant background visibility */
  body {
    background: #121212;
  }

  /* Star styles */
  .star {
    position: absolute;
    width: 1.5px;
    height: 1.5px;
    background-color: #ffffff;
    border-radius: 50%;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0.6);
    transform: translate(-50%, -50%); /* Center the star on its coordinates */
  }

  /* Larger stars */
  .star-tiny {
    width: 1px;
    height: 1px;
    box-shadow: 0 0 1px rgba(255, 255, 255, 0.5);
  }

  .star-small {
    width: 2px;
    height: 2px;
    box-shadow: 0 0 2px rgba(255, 255, 255, 0.7);
  }

  .star-medium {
    width: 3px;
    height: 3px;
    box-shadow: 0 0 3px rgba(255, 255, 255, 0.8);
  }

  .star-large {
    width: 4px;
    height: 4px;
    box-shadow: 0 0 4px rgba(255, 255, 255, 0.9);
  }

  .star-xlarge {
    width: 5px;
    height: 5px;
    box-shadow: 0 0 5px rgba(255, 255, 255, 1);
  }

  /* Energy line styling */
  .energy-line {
    position: absolute;
    width: 20px;
    height: 2px;
    background-color: rgba(255, 255, 255, 0.9);
    border-radius: 1px;
    box-shadow:
      0 0 4px 1px rgba(120, 220, 255, 0.8),
      0 0 8px 2px rgba(50, 180, 255, 0.5),
      0 0 12px 4px rgba(30, 120, 255, 0.3);
    z-index: 10;
    pointer-events: none;
    transform-origin: center left;
  }

  /* Energy dot styling */
  .energy-dot {
    position: absolute;
    width: 4px;
    height: 4px;
    background-color: rgba(255, 255, 255, 0.95);
    border-radius: 50%;
    box-shadow:
      0 0 6px 2px rgba(120, 220, 255, 0.9),
      0 0 12px 4px rgba(50, 180, 255, 0.6),
      0 0 18px 6px rgba(30, 120, 255, 0.3);
    z-index: 10;
    pointer-events: none;
    transform: translate(-50%, -50%); /* Center the dot on its coordinates */
  }

  /* Updated constellation line styling */
  .constellation-line {
    position: absolute;
    background-color: rgba(255, 255, 255, 0.25);
    transform-origin: 0 0;
    z-index: 5;
    height: 0.8px !important;
    transition: all 0.4s ease;
    box-shadow: 0 0 3px rgba(255, 255, 255, 0.1);
  }

  /* Constellation group */
  .constellation-group {
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
  }

  /* Interact area for each group */
  .constellation-interact {
    position: absolute;
    background-color: transparent;
    cursor: pointer;
    z-index: 10;
    pointer-events: auto;
  }

  /* Hover effects for constellations */
  .constellation-interact:hover + .constellation-group .constellation-line {
    background-color: rgba(255, 255, 255, 0.5);
    box-shadow: 0 0 10px rgba(255, 255, 255, 0.4);
    height: 1.2px !important;
  }

  .constellation-interact:hover + .constellation-group .star {
    background-color: #fff;
    box-shadow: 0 0 10px #fff, 0 0 20px rgba(255, 255, 255, 0.8);
  }

  /* Path line styling - for energy travel paths */
  .path-line {
    position: absolute;
    transform-origin: 0 0;
    z-index: 4;
    height: 1px !important;
    transition: opacity 0.3s ease;
    overflow: hidden;

    /* Create dashed lines with a background pattern */
    background: repeating-linear-gradient(
      90deg,
      rgba(255, 255, 255, 0.5),
      rgba(255, 255, 255, 0.5) 6px,
      transparent 6px,
      transparent 12px
    );

    /* Explicitly animate the background position */
    animation: dashMove 0.8s linear infinite;
  }

  /* Animation for moving dashed line */
  @keyframes dashMove {
    from { background-position-x: 0; }
    to { background-position-x: 24px; }
  }
</style>

<!-- Space background with stars -->
<div class="hyperspace" id="hyperspace">
  <!-- Stars will be generated by script -->
</div>

<script is:inline>
  (function() {
    // Get starfield container
    const starField = document.getElementById('hyperspace');
    if (!starField) return;

    // Configuration
    const gridCellSize = 25; // Smaller cell size (was 40px)
    const starCount = 1200; // Increased star count (was 800)
    const constellationCount = 10; // Show 10 constellations
    const maxStarsPerConstellation = 7; // Max stars per constellation
    const minStarsPerConstellation = 4; // Min stars per constellation
    const maxConnectionDistance = 5; // Max distance between stars in grid cells
    const gridDensityFactor = 0.3; // Increased density for symbol creation

    // Track elements to clean up on resize
    let allStarElements = [];
    let allConstellationElements = [];
    let allEnergyBursts = [];
    let energyIntervals = [];
    let allStars = []; // Track all stars for random selection

    // Flag to track if an energy dot is currently traveling
    let isEnergyDotTraveling = false;

    // Track which stars are part of constellations
    const constellationStars = new Set();

    // Keep track of constellation areas to prevent overlap
    const usedAreas = [];

    // Initialize the starfield
    generateStarfield();

    // Add window resize handler with debounce
    let resizeTimer;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimer);
      resizeTimer = setTimeout(() => {
        // Clear existing starfield
        clearStarfield();

        // Reset constellation tracking
        constellationStars.clear();
        usedAreas.length = 0;

        // Stop all energy burst animations
        energyIntervals.forEach(interval => clearInterval(interval));
        energyIntervals = [];

        // Regenerate with new dimensions
        generateStarfield();
      }, 250); // Debounce to prevent too many recalculations
    });

    // Function to clear the existing starfield
    function clearStarfield() {
      // Remove all star elements
      allStarElements.forEach(element => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });

      // Remove all constellation elements
      allConstellationElements.forEach(element => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });

      // Remove all energy burst elements
      allEnergyBursts.forEach(element => {
        if (element && element.parentNode) {
          element.parentNode.removeChild(element);
        }
      });

      // Reset tracking arrays
      allStarElements = [];
      allConstellationElements = [];
      allEnergyBursts = [];
    }

    // Main function to generate the starfield
    function generateStarfield() {
      // Get current viewport dimensions
      const viewportWidth = window.innerWidth;
      const viewportHeight = window.innerHeight;

      // Create a document fragment for better performance
      const fragment = document.createDocumentFragment();

      // Reset all stars array
      allStars = [];

      // Calculate grid dimensions based on current viewport
      const gridRows = Math.ceil(viewportHeight / gridCellSize);
      const gridCols = Math.ceil(viewportWidth / gridCellSize);

      // Create grid representation
      const grid = new Array(gridRows);
      for (let y = 0; y < gridRows; y++) {
        grid[y] = new Array(gridCols).fill(null);
      }

      // Track all stars by ID for easier lookup
      const starsById = {};

      // First, ensure grid has enough stars placed for constellations, but with more randomness
      let gridStarsPlaced = 0;
      const desiredGridStars = Math.floor(gridRows * gridCols * gridDensityFactor);

      // Place stars directly on grid with some variation
      while (gridStarsPlaced < desiredGridStars) {
        // Choose a random grid cell
        const gridY = Math.floor(Math.random() * gridRows);
        const gridX = Math.floor(Math.random() * gridCols);

        // Skip if cell already has a star
        if (grid[gridY][gridX]) continue;

        // Add more randomness to grid positioning
        const randomOffset = 0.6; // Larger offset for more scattered look
        const xPercent = ((gridX + Math.random() * randomOffset - randomOffset/2) / gridCols) * 100;
        const yPercent = ((gridY + Math.random() * randomOffset - randomOffset/2) / gridRows) * 100;

        // Constrain to viewport
        const safeXPercent = Math.max(0.5, Math.min(99.5, xPercent));
        const safeYPercent = Math.max(0.5, Math.min(99.5, yPercent));

        // Always make these stars bigger (potential constellation candidates)
        const star = createStar(safeXPercent, safeYPercent, true);

        // Store grid coordinates
        star.gridX = gridX;
        star.gridY = gridY;

        // Add to lookup and grid
        starsById[star.id] = star;
        grid[gridY][gridX] = star;

        // Add to all stars array for random selection
        allStars.push(star);

        // Track the element for cleanup
        allStarElements.push(star.element);

        // Add to fragment
        fragment.appendChild(star.element);
        gridStarsPlaced++;
      }

      // Create clusters of stars in some areas for a more realistic look
      const numClusters = Math.floor(Math.random() * 10) + 5; // 5-15 clusters
      for (let c = 0; c < numClusters; c++) {
        const clusterX = Math.random() * 100;
        const clusterY = Math.random() * 100;
        const clusterSize = Math.floor(Math.random() * 30) + 15; // 15-45 stars per cluster
        const clusterRadius = Math.random() * 12 + 5; // 5-17% radius

        for (let i = 0; i < clusterSize; i++) {
          // Create stars in a Gaussian-like distribution around the cluster center
          const angle = Math.random() * Math.PI * 2;
          const distance = Math.random() * clusterRadius * (Math.random() + 0.5); // More stars toward center

          const starX = clusterX + Math.cos(angle) * distance;
          const starY = clusterY + Math.sin(angle) * distance;

          // Skip if outside viewport
          if (starX < 0 || starX > 100 || starY < 0 || starY > 100) continue;

          // These are smaller background stars (not for constellations)
          const star = createStar(starX, starY, false);

          // Map to nearest grid cell
          const gridX = Math.floor((starX / 100) * gridCols);
          const gridY = Math.floor((starY / 100) * gridRows);

          // Store grid coordinates
          if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
            star.gridX = gridX;
            star.gridY = gridY;
          }

          // Add to lookup
          starsById[star.id] = star;

          // Add to all stars array for random selection
          allStars.push(star);

          // Track the element for cleanup
          allStarElements.push(star.element);

          // Add to fragment
          fragment.appendChild(star.element);
        }
      }

      // Fill remaining space with randomly scattered stars
      const remainingStars = starCount - gridStarsPlaced - (numClusters * 30);
      for (let i = 0; i < remainingStars; i++) {
        // Regular stars with random positioning
        const xPercent = Math.random() * 100;
        const yPercent = Math.random() * 100;

        // These stars can be any size
        const isBig = Math.random() > 0.9; // Reduced probability of big stars
        const star = createStar(xPercent, yPercent, isBig);

        // Map to nearest grid cell
        const gridX = Math.floor((xPercent / 100) * gridCols);
        const gridY = Math.floor((yPercent / 100) * gridRows);

        // Store grid coordinates if in bounds
        if (gridX >= 0 && gridX < gridCols && gridY >= 0 && gridY < gridRows) {
          star.gridX = gridX;
          star.gridY = gridY;

          // Only add to grid if it's a big star and the cell is empty
          if (isBig && !grid[gridY][gridX]) {
            grid[gridY][gridX] = star;
          }
        }

        // Add to lookup
        starsById[star.id] = star;

        // Add to all stars array for random selection
        allStars.push(star);

        // Track the element for cleanup
        allStarElements.push(star.element);

        // Add to fragment
        fragment.appendChild(star.element);
      }

      // Keep track of ALL line segments across ALL constellations
      const allLineSegments = [];

      // Wave function collapse implementation for constellations
      for (let c = 0; c < constellationCount; c++) {
        // Find a valid starting point on the grid
        let startingCell = findValidStartingCell(grid);
        if (!startingCell) continue;

        // Create a group container for this constellation
        const constellationGroup = document.createElement('div');
        constellationGroup.className = 'constellation-group';

        // Create interactive area for this constellation
        const interactArea = document.createElement('div');
        interactArea.className = 'constellation-interact';

        // Track these elements for cleanup
        allConstellationElements.push(constellationGroup);
        allConstellationElements.push(interactArea);

        // Start with the first star
        const firstStar = startingCell.star;

        // Initialize the constellation path with the first star
        const constellationPath = [firstStar];
        constellationStars.add(firstStar.id);

        // Keep track of all connections in this constellation
        const connections = [];

        // Track all possible directions for each star in the constellation
        const possibleConnections = new Map();

        // Initialize the wave function for the first star
        // Each star can initially connect in any direction
        possibleConnections.set(firstStar.id, findNearbyStars(grid, firstStar.gridX, firstStar.gridY, maxConnectionDistance)
          .filter(star => !constellationStars.has(star.id))
          .map(star => ({
            star: star,
            entropy: 0  // Will calculate entropy later
          }))
        );

        // Continue until we reach the desired size or have no more valid options
        while (constellationPath.length < maxStarsPerConstellation && possibleConnections.size > 0) {
          // Find star with lowest entropy (fewest valid connections) to collapse next
          let lowestEntropyStar = null;
          let lowestEntropy = Infinity;
          let lowestEntropyConnections = [];

          // For each star in our constellation that has possible connections
          for (const [starId, connections] of possibleConnections.entries()) {
            if (connections.length === 0) {
              // No valid connections, remove from possibilities
              possibleConnections.delete(starId);
              continue;
            }

            // Calculate entropy based on number of valid connections
            // and distance to other stars in constellation
            for (const connection of connections) {
              connection.entropy = calculateEntropy(
                starsById[starId],
                connection.star,
                constellationPath,
                allLineSegments
              );
            }

            // Find connection with lowest entropy
            const minEntropyConn = connections.reduce(
              (min, conn) => conn.entropy < min.entropy ? conn : min,
              { entropy: Infinity }
            );

            // If this is the lowest entropy we've seen so far
            if (minEntropyConn.entropy < lowestEntropy) {
              lowestEntropy = minEntropyConn.entropy;
              lowestEntropyStar = starsById[starId];
              lowestEntropyConnections = connections;
            }
          }

          // If we found a valid next star to connect
          if (lowestEntropyStar && lowestEntropyConnections.length > 0) {
            // Sort connections by entropy and pick the lowest
            lowestEntropyConnections.sort((a, b) => a.entropy - b.entropy);

            // Choose the lowest entropy connection with a slight randomization
            const connectionIndex = Math.random() > 0.8
              ? Math.floor(Math.random() * Math.min(3, lowestEntropyConnections.length))
              : 0;

            const nextStar = lowestEntropyConnections[connectionIndex].star;

            // Check if adding this star would create any intersecting lines
            const potentialConnection = {
              from: lowestEntropyStar,
              to: nextStar
            };

            // Check for intersections with existing lines
            let wouldIntersect = false;

            // Check against this constellation's connections
            for (const existingConn of connections) {
              if (linesIntersect(
                existingConn.from.x, existingConn.from.y,
                existingConn.to.x, existingConn.to.y,
                potentialConnection.from.x, potentialConnection.from.y,
                potentialConnection.to.x, potentialConnection.to.y
              )) {
                wouldIntersect = true;
                break;
              }
            }

            // Check against ALL previously drawn connections from other constellations
            if (!wouldIntersect) {
              for (const existingSegment of allLineSegments) {
                if (linesIntersect(
                  existingSegment.x1, existingSegment.y1,
                  existingSegment.x2, existingSegment.y2,
                  potentialConnection.from.x, potentialConnection.from.y,
                  potentialConnection.to.x, potentialConnection.to.y
                )) {
                  wouldIntersect = true;
                  break;
                }
              }
            }

            // If no intersection, add the connection
            if (!wouldIntersect) {
              // Add the connection
              connections.push(potentialConnection);

              // Add the star to our constellation
              constellationPath.push(nextStar);
              constellationStars.add(nextStar.id);

              // Find new possible connections from this star
              const newConnections = findNearbyStars(
                grid,
                nextStar.gridX,
                nextStar.gridY,
                maxConnectionDistance
              )
              .filter(star => !constellationStars.has(star.id))
              .map(star => ({
                star: star,
                entropy: 0
              }));

              // Add new possibilities
              possibleConnections.set(nextStar.id, newConnections);

              // Remove the connected star from all other stars' possibilities
              for (const [id, starConnections] of possibleConnections.entries()) {
                if (id !== nextStar.id) {
                  possibleConnections.set(
                    id,
                    starConnections.filter(conn => conn.star.id !== nextStar.id)
                  );
                }
              }
            } else {
              // Remove this connection as it would cause an intersection
              possibleConnections.set(
                lowestEntropyStar.id,
                lowestEntropyConnections.filter(conn => conn.star.id !== nextStar.id)
              );
            }
          } else {
            // No valid connections left, exit the loop
            break;
          }
        }

        // Only create constellation if we have enough stars
        if (constellationPath.length >= minStarsPerConstellation) {
          // Render the connection lines
          for (const connection of connections) {
            const line = createConnectingLine(connection.from, connection.to, constellationGroup, viewportWidth, viewportHeight);

            // Track line element for cleanup
            if (line) {
              allConstellationElements.push(line);
            }

            // Add this connection to the global list to check against future constellations
            allLineSegments.push({
              x1: connection.from.x,
              y1: connection.from.y,
              x2: connection.to.x,
              y2: connection.to.y
            });
          }

          // Calculate bounding box for this constellation
          const bounds = getGroupBounds(constellationPath);

          // Size the interact area
          interactArea.style.left = `${bounds.minX - 5}%`;
          interactArea.style.top = `${bounds.minY - 5}%`;
          interactArea.style.width = `${bounds.maxX - bounds.minX + 10}%`;
          interactArea.style.height = `${bounds.maxY - bounds.minY + 10}%`;

          // Add to used areas to prevent overlap
          usedAreas.push(bounds);

          // Add to document
          fragment.appendChild(interactArea);
          fragment.appendChild(constellationGroup);
        }
      }

      // Add all elements to the DOM at once
      starField.appendChild(fragment);

      // Start single global energy burst animation
      startGlobalEnergyAnimation(viewportWidth, viewportHeight);
    }

    // Start a single global animation with one particle at a time
    function startGlobalEnergyAnimation(viewportWidth, viewportHeight) {
      // Clear any existing intervals
      energyIntervals.forEach(interval => clearInterval(interval));
      energyIntervals = [];

      // Schedule the next energy burst
      function scheduleNextBurst() {
        // Generate a random delay between 1 and 10 seconds
        const randomDelay = 1000 + Math.floor(Math.random() * 9000);

        // Set timeout with random delay
        const timeout = setTimeout(() => {
          // Only create a new burst if we have enough stars AND no other dot is traveling
          if (allStars.length >= 10 && !isEnergyDotTraveling) {
            // Define a safe margin from the edges (8% of viewport)
            const safeMargin = 8;

            // Filter for stars that are within the visible area with safe margins
            const visibleStars = allStars.filter(star =>
              star.x >= safeMargin &&
              star.x <= (100 - safeMargin) &&
              star.y >= safeMargin &&
              star.y <= (100 - safeMargin)
            );

            // Make sure we have enough visible stars
            if (visibleStars.length >= 2) {
              // Pick random start and end stars from visible stars
              const startIndex = Math.floor(Math.random() * visibleStars.length);
              let endIndex;

              // Make sure end star is different from start star
              do {
                endIndex = Math.floor(Math.random() * visibleStars.length);
              } while (endIndex === startIndex);

              const startStar = visibleStars[startIndex];
              const endStar = visibleStars[endIndex];

              // Create energy burst between these two random stars
              createEnergyBurst(startStar, endStar, viewportWidth, viewportHeight);
            }
          }

          // Schedule the next burst regardless of whether this one happened
          scheduleNextBurst();
        }, randomDelay);

        // Track for cleanup
        energyIntervals.push(timeout);
      }

      // Start the scheduling cycle
      scheduleNextBurst();
    }

    // Calculate entropy for a potential connection
    // Lower entropy = more constrained = higher priority to collapse
    function calculateEntropy(fromStar, toStar, existingPath, existingLines) {
      // Base entropy is distance - closer stars have lower entropy
      const dx = toStar.x - fromStar.x;
      const dy = toStar.y - fromStar.y;
      const distance = Math.sqrt(dx*dx + dy*dy);

      // Start with distance as base entropy
      let entropy = distance;

      // Adjust entropy based on proximity to other stars in constellation
      // Prefer stars that are close to multiple existing stars
      let proximityBonus = 0;
      for (const star of existingPath) {
        if (star.id === fromStar.id) continue;

        const dxOther = toStar.x - star.x;
        const dyOther = toStar.y - star.y;
        const distOther = Math.sqrt(dxOther*dxOther + dyOther*dyOther);

        // If close to another star, reduce entropy
        if (distOther < maxConnectionDistance * 1.5) {
          proximityBonus += (maxConnectionDistance * 1.5 - distOther) / 2;
        }
      }

      // Subtract proximity bonus from entropy
      entropy -= proximityBonus;

      // Add penalty for each near-miss with existing lines (prefer cleaner arrangements)
      for (const line of existingLines) {
        const nearMiss = linePointDistance(
          line.x1, line.y1, line.x2, line.y2,
          toStar.x, toStar.y
        );

        // If very close to an existing line, increase entropy
        if (nearMiss < 2) {
          entropy += (2 - nearMiss) * 3;
        }
      }

      // Add some randomness to avoid repetitive patterns
      entropy += Math.random() * 2;

      return entropy;
    }

    // Calculate the minimum distance from a point to a line segment
    function linePointDistance(x1, y1, x2, y2, px, py) {
      // Line segment length squared
      const lengthSq = (x2 - x1) * (x2 - x1) + (y2 - y1) * (y2 - y1);

      // If line is a point, just return distance to the point
      if (lengthSq === 0) return Math.sqrt((px - x1) * (px - x1) + (py - y1) * (py - y1));

      // Calculate projection of point onto line
      const t = Math.max(0, Math.min(1, ((px - x1) * (x2 - x1) + (py - y1) * (y2 - y1)) / lengthSq));

      // Calculate closest point on line
      const projX = x1 + t * (x2 - x1);
      const projY = y1 + t * (y2 - y1);

      // Return distance to closest point
      return Math.sqrt((px - projX) * (px - projX) + (py - projY) * (py - projY));
    }

    // Helper function to find nearby stars within the given distance
    function findNearbyStars(grid, centerX, centerY, maxDistance) {
      const results = [];
      const gridRows = grid.length;
      const gridCols = grid[0].length;

      // Search within a square area around the center
      for (let dy = -maxDistance; dy <= maxDistance; dy++) {
        for (let dx = -maxDistance; dx <= maxDistance; dx++) {
          const x = centerX + dx;
          const y = centerY + dy;

          // Skip if outside grid bounds
          if (x < 0 || x >= gridCols || y < 0 || y >= gridRows) continue;

          // Skip if no star at this position
          if (!grid[y][x]) continue;

          // Calculate actual distance (squared)
          const distSquared = dx*dx + dy*dy;

          // Skip if too far away
          if (distSquared > maxDistance*maxDistance) continue;

          // Add this star to results
          results.push(grid[y][x]);
        }
      }

      return results;
    }

    // Helper function to check if two line segments intersect
    function linesIntersect(x1, y1, x2, y2, x3, y3, x4, y4) {
      // Check if the lines share an endpoint
      if ((x1 === x3 && y1 === y3) ||
          (x1 === x4 && y1 === y4) ||
          (x2 === x3 && y2 === y3) ||
          (x2 === x4 && y2 === y4)) {
        return false;  // Don't count shared endpoints as intersections
      }

      // Calculate directions
      const d1x = x2 - x1;
      const d1y = y2 - y1;
      const d2x = x4 - x3;
      const d2y = y4 - y3;

      // Calculate the determinant
      const det = d1x * d2y - d1y * d2x;

      // If determinant is zero, lines are parallel
      if (Math.abs(det) < 0.001) return false;

      // Calculate relative positions
      const s = (d1x * (y3 - y1) - d1y * (x3 - x1)) / det;
      const t = (d2x * (y1 - y3) - d2y * (x1 - x3)) / -det;

      // Check if intersection point is within both line segments
      return s >= 0 && s <= 1 && t >= 0 && t <= 1;
    }

    // Helper function to find a valid starting cell for a constellation
    function findValidStartingCell(grid) {
      const gridRows = grid.length;
      const gridCols = grid[0].length;

      // Divide the grid into sections for more even distribution
      const sectionsX = 3; // 3 columns
      const sectionsY = 3; // 3 rows
      const sectionWidth = gridCols / sectionsX;
      const sectionHeight = gridRows / sectionsY;

      // Track which sections we've already used for better distribution
      if (!window.usedSections) {
        window.usedSections = new Set();
      }

      // Choose a random section that hasn't been used yet
      let sectionX, sectionY;
      let attempts = 0;

      do {
        // If all sections have been used or too many attempts, reset
        if (window.usedSections.size >= sectionsX * sectionsY || attempts > 20) {
          window.usedSections.clear();
        }

        sectionX = Math.floor(Math.random() * sectionsX);
        sectionY = Math.floor(Math.random() * sectionsY);
        attempts++;

      } while (window.usedSections.has(`${sectionX},${sectionY}`) && attempts < 20);

      // Mark this section as used
      window.usedSections.add(`${sectionX},${sectionY}`);

      // Calculate bounds for this section
      const minX = Math.floor(sectionX * sectionWidth);
      const maxX = Math.floor((sectionX + 1) * sectionWidth);
      const minY = Math.floor(sectionY * sectionHeight);
      const maxY = Math.floor((sectionY + 1) * sectionHeight);

      // Try random locations within this section
      for (let attempts = 0; attempts < 100; attempts++) {
        const y = minY + Math.floor(Math.random() * (maxY - minY));
        const x = minX + Math.floor(Math.random() * (maxX - minX));

        // Check if this cell has a star
        if (grid[y] && grid[y][x] && !constellationStars.has(grid[y][x].id)) {
          // More relaxed overlap check (reduced from 8px to 5px)
          let isValid = true;
          const cellX = (x / gridCols) * 100;
          const cellY = (y / gridRows) * 100;

          for (const area of usedAreas) {
            if (!(cellX + 5 < area.minX || cellX - 5 > area.maxX ||
                cellY + 5 < area.minY || cellY - 5 > area.maxY)) {
              isValid = false;
              break;
            }
          }

          if (isValid) {
            return { x, y, star: grid[y][x] };
          }
        }
      }

      // Fall back to random position anywhere if section approach fails
      for (let attempts = 0; attempts < 100; attempts++) {
        const y = Math.floor(Math.random() * gridRows);
        const x = Math.floor(Math.random() * gridCols);

        // Check if this cell has a star
        if (grid[y][x] && !constellationStars.has(grid[y][x].id)) {
          let isValid = true;
          const cellX = (x / gridCols) * 100;
          const cellY = (y / gridRows) * 100;

          for (const area of usedAreas) {
            if (!(cellX + 5 < area.minX || cellX - 5 > area.maxX ||
                cellY + 5 < area.minY || cellY - 5 > area.maxY)) {
              isValid = false;
              break;
            }
          }

          if (isValid) {
            return { x, y, star: grid[y][x] };
          }
        }
      }

      // Last resort: find any star that's not in a constellation
      if (usedAreas.length < 3) { // Only in the first few constellations to avoid too much overlap
        for (let y = 0; y < gridRows; y++) {
          for (let x = 0; x < gridCols; x++) {
            if (grid[y][x] && !constellationStars.has(grid[y][x].id)) {
              return { x, y, star: grid[y][x] };
            }
          }
        }
      }

      return null;
    }

    // Helper function to create a connection line between two stars
    function createConnectingLine(star1, star2, container, viewportWidth, viewportHeight) {
      // Create a line element
      const line = document.createElement('div');

      // Convert percentage positions to pixels for accurate angle calculation
      const star1XPx = (star1.x / 100) * viewportWidth;
      const star1YPx = (star1.y / 100) * viewportHeight;
      const star2XPx = (star2.x / 100) * viewportWidth;
      const star2YPx = (star2.y / 100) * viewportHeight;

      // Calculate the exact pixel distance and angle
      const dxPx = star2XPx - star1XPx;
      const dyPx = star2YPx - star1YPx;
      const distancePx = Math.sqrt(dxPx * dxPx + dyPx * dyPx);
      const angle = Math.atan2(dyPx, dxPx) * 180 / Math.PI;

      // Convert back to percentages for CSS
      const distancePercent = (distancePx / viewportWidth) * 100;

      // Apply all styles directly for precise positioning
      line.className = 'constellation-line';
      line.style.position = 'absolute';
      line.style.left = `${star1.x}%`;
      line.style.top = `${star1.y}%`;
      line.style.width = `${distancePercent}%`;
      line.style.height = '0.8px'; // Use consistent height of 0.8px (was 0.5px)
      line.style.backgroundColor = 'rgba(255, 255, 255, 0.25)'; // Brighter lines
      line.style.boxShadow = '0 0 3px rgba(255, 255, 255, 0.1)'; // Add subtle glow
      line.style.transformOrigin = '0 0'; // Very important for correct rotation
      line.style.transform = `rotate(${angle}deg)`;
      line.style.zIndex = '-1';

      container.appendChild(line);
      return line;
    }

    // Helper function to get bounding box of a group of stars
    function getGroupBounds(stars) {
      let minX = 100, minY = 100, maxX = 0, maxY = 0;

      stars.forEach(star => {
        minX = Math.min(minX, star.x);
        minY = Math.min(minY, star.y);
        maxX = Math.max(maxX, star.x);
        maxY = Math.max(maxY, star.y);
      });

      return { minX, minY, maxX, maxY };
    }

    // Helper function to create a star
    function createStar(x, y, isBig) {
      const star = document.createElement('div');
      const starId = `star-${Math.random().toString(36).substring(2, 9)}`;
      star.id = starId;

      // Generate a Stargate-style designation for this star
      const stargateName = generateStargateName();

      // Add a small random offset to position for more scattered effect
      const offsetX = (Math.random() * 0.8 - 0.4); // -0.4% to +0.4%
      const offsetY = (Math.random() * 0.8 - 0.4); // -0.4% to +0.4%

      // Position - stars will be centered due to CSS transform
      star.style.left = `${x + offsetX}%`;
      star.style.top = `${y + offsetY}%`;

      // Size - more variety in sizes
      const sizeRandom = Math.random();

      if (isBig && sizeRandom > 0.9) {
        star.className = 'star star-xlarge'; // New extra large stars (very rare)
      } else if (isBig && sizeRandom > 0.7) {
        star.className = 'star star-large';
      } else if (isBig || sizeRandom > 0.85) {
        star.className = 'star star-medium';
      } else if (sizeRandom > 0.6) {
        star.className = 'star star-small';
      } else if (sizeRandom > 0.3) {
        star.className = 'star'; // Default size
      } else {
        star.className = 'star star-tiny'; // New tiny stars
      }

      // Base brightness depends on star size
      let baseBrightness;
      if (star.className.includes('star-xlarge')) {
        baseBrightness = 0.9;
      } else if (star.className.includes('star-large')) {
        baseBrightness = 0.8;
      } else if (star.className.includes('star-medium')) {
        baseBrightness = 0.7;
      } else if (star.className.includes('star-small')) {
        baseBrightness = 0.6;
      } else if (star.className.includes('star-tiny')) {
        baseBrightness = 0.4;
      } else {
        baseBrightness = 0.5;
      }

      // Add more random variation to brightness
      const randomBrightness = Math.random() * 0.3;
      star.style.opacity = (baseBrightness + randomBrightness).toFixed(2);

      // Adjust color temperature slightly for some stars
      if (Math.random() > 0.7) {
        const hue = Math.floor(Math.random() * 60); // Subtle yellow/red tint for some stars
        star.style.backgroundColor = `hsl(${hue}, 100%, ${90 + Math.floor(Math.random() * 10)}%)`;
      }

      return {
        element: star,
        id: starId,
        x: x + offsetX,
        y: y + offsetY,
        name: stargateName
      };
    }

    // Generate Stargate-style planet designations
    function generateStargateName() {
      // Create standard Stargate address format (e.g., P3X-774, M4C-862)
      const prefix = Math.random() > 0.7 ? 'M' : 'P';
      const firstDigit = Math.floor(Math.random() * 9) + 1;
      const middleLetter = String.fromCharCode(65 + Math.floor(Math.random() * 26)); // A-Z
      const secondDigit = Math.floor(Math.random() * 9);
      const suffix = Math.floor(Math.random() * 900) + 100; // 100-999

      return `${prefix}${firstDigit}${middleLetter}${secondDigit}-${suffix}`;
    }

    // Helper function to create an energy burst between two stars
    function createEnergyBurst(star1, star2, viewportWidth, viewportHeight) {
      // Set the flag to indicate a dot is now traveling
      isEnergyDotTraveling = true;

      // Get start and end positions
      const startX = star1.x;
      const startY = star1.y;
      const endX = star2.x;
      const endY = star2.y;

      // For precise alignment, convert percentages to exact pixel values
      const star1XPx = (startX / 100) * viewportWidth;
      const star1YPx = (startY / 100) * viewportHeight;
      const star2XPx = (endX / 100) * viewportWidth;
      const star2YPx = (endY / 100) * viewportHeight;

      // Calculate the exact pixel distance and angle
      const dxPx = star2XPx - star1XPx;
      const dyPx = star2YPx - star1YPx;
      const distancePx = Math.sqrt(dxPx * dxPx + dyPx * dyPx);
      const angle = Math.atan2(dyPx, dxPx) * 180 / Math.PI;

      // Convert back to percentages for CSS
      const distancePercent = (distancePx / viewportWidth) * 100;

      // Create a thin line to show the travel path
      const pathLine = document.createElement('div');
      pathLine.className = 'path-line';

      // Use the exact same positioning as the constellation lines
      pathLine.style.position = 'absolute';
      pathLine.style.left = `${startX}%`;
      pathLine.style.top = `${startY}%`;
      pathLine.style.width = `${distancePercent}%`;
      pathLine.style.transformOrigin = '0 0';
      pathLine.style.transform = `rotate(${angle}deg)`;

      // Determine animation direction based on angle
      if (angle > 90 || angle < -90) {
        // Reverse the animation direction for paths going leftward
        pathLine.style.animationDirection = 'reverse';
      }

      document.getElementById('hyperspace').appendChild(pathLine);

      // Track for cleanup
      allEnergyBursts.push(pathLine);

      // Create energy dot element
      const energyDot = document.createElement('div');
      energyDot.className = 'energy-dot';
      document.getElementById('hyperspace').appendChild(energyDot);

      // Create source star label
      const sourceLabel = document.createElement('div');
      sourceLabel.style.position = 'absolute';
      sourceLabel.style.left = `${startX}%`;
      sourceLabel.style.top = `${startY}%`;
      sourceLabel.style.color = 'rgba(120, 210, 255, 0.85)';
      sourceLabel.style.fontSize = '11px';
      sourceLabel.style.fontFamily = 'monospace';
      sourceLabel.style.textShadow = '0 0 4px rgba(0, 100, 200, 0.9)';
      sourceLabel.style.transform = 'translate(-50%, -50%) translate(0, -15px)'; // Position above star
      sourceLabel.style.zIndex = '12';
      sourceLabel.style.pointerEvents = 'none';
      sourceLabel.textContent = star1.name;
      document.getElementById('hyperspace').appendChild(sourceLabel);

      // Create destination star label
      const destLabel = document.createElement('div');
      destLabel.style.position = 'absolute';
      destLabel.style.left = `${endX}%`;
      destLabel.style.top = `${endY}%`;
      destLabel.style.color = 'rgba(120, 210, 255, 0.85)';
      destLabel.style.fontSize = '11px';
      destLabel.style.fontFamily = 'monospace';
      destLabel.style.textShadow = '0 0 4px rgba(0, 100, 200, 0.9)';
      destLabel.style.transform = 'translate(-50%, -50%) translate(0, -15px)'; // Position above star
      destLabel.style.zIndex = '12';
      destLabel.style.pointerEvents = 'none';
      destLabel.textContent = star2.name;
      document.getElementById('hyperspace').appendChild(destLabel);

      // Track for cleanup
      allEnergyBursts.push(energyDot);
      allEnergyBursts.push(sourceLabel);
      allEnergyBursts.push(destLabel);

      // Position the dot at the starting point
      energyDot.style.left = `${startX}%`;
      energyDot.style.top = `${startY}%`;

      // Scale duration based on distance for consistent speed
      // Base speed: 15% of screen width per second
      const baseSpeed = 6; // percent per second (doubled from 3 to make dot move faster)
      const duration = Math.max(1000, (distancePercent / baseSpeed) * 1000);

      // Animate dot movement
      const startTime = performance.now();

      // Create animation frame
      function animate(currentTime) {
        const elapsed = currentTime - startTime;
        const progress = Math.min(elapsed / duration, 1);

        // Use easeOutQuad for deceleration as it approaches target
        // Starts fast, gradually slows down near the end
        const easeOutQuad = 1 - (1 - progress) * (1 - progress);

        // Apply easing function to movement
        const currentX = startX + (endX - startX) * easeOutQuad;
        const currentY = startY + (endY - startY) * easeOutQuad;

        // Update position of the dot
        energyDot.style.left = `${currentX}%`;
        energyDot.style.top = `${currentY}%`;

        // Continue animation if not complete
        if (progress < 1) {
          requestAnimationFrame(animate);
        } else {
          // Create a flash effect at the destination star
          const flash = document.createElement('div');
          flash.style.position = 'absolute';
          flash.style.left = `${endX}%`;
          flash.style.top = `${endY}%`;
          flash.style.width = '8px';
          flash.style.height = '8px';
          flash.style.backgroundColor = 'rgba(255, 255, 255, 0.9)';
          flash.style.borderRadius = '50%';
          flash.style.transform = 'translate(-50%, -50%)';
          flash.style.boxShadow = '0 0 10px 5px rgba(100, 200, 255, 0.8)';
          flash.style.opacity = '1';
          flash.style.transition = 'all 0.3s ease-out';
          flash.style.zIndex = '12';
          document.getElementById('hyperspace').appendChild(flash);

          // Track for cleanup
          allEnergyBursts.push(flash);

          // Animate the flash
          setTimeout(() => {
            flash.style.opacity = '0';
            flash.style.width = '12px';
            flash.style.height = '12px';
            flash.style.boxShadow = '0 0 15px 8px rgba(100, 200, 255, 0)';
          }, 50);

          // Start fading out elements
          pathLine.style.opacity = '0';
          sourceLabel.style.opacity = '0';
          destLabel.style.opacity = '0';

          // Remove all elements after animation completes
          setTimeout(() => {
            if (energyDot.parentNode) {
              energyDot.parentNode.removeChild(energyDot);
              const index = allEnergyBursts.indexOf(energyDot);
              if (index > -1) allEnergyBursts.splice(index, 1);
            }

            if (pathLine.parentNode) {
              pathLine.parentNode.removeChild(pathLine);
              const pathIndex = allEnergyBursts.indexOf(pathLine);
              if (pathIndex > -1) allEnergyBursts.splice(pathIndex, 1);
            }

            if (sourceLabel.parentNode) {
              sourceLabel.parentNode.removeChild(sourceLabel);
              const sourceLabelIndex = allEnergyBursts.indexOf(sourceLabel);
              if (sourceLabelIndex > -1) allEnergyBursts.splice(sourceLabelIndex, 1);
            }

            if (destLabel.parentNode) {
              destLabel.parentNode.removeChild(destLabel);
              const destLabelIndex = allEnergyBursts.indexOf(destLabel);
              if (destLabelIndex > -1) allEnergyBursts.splice(destLabelIndex, 1);
            }

            // Remove flash after it fades out
            if (flash.parentNode) {
              flash.parentNode.removeChild(flash);
              const flashIndex = allEnergyBursts.indexOf(flash);
              if (flashIndex > -1) allEnergyBursts.splice(flashIndex, 1);
            }

            // Reset the traveling flag so a new dot can be created
            isEnergyDotTraveling = false;
          }, 350);
        }
      }

      // Start animation
      requestAnimationFrame(animate);
    }
  })();
</script>
